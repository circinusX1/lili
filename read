rtspcam.cpp:    this->signal_to_stop();
rtspcam.cpp:    this->stop_thread();
rtspcam.cpp:        Frame* frame = _frames->to_stream();
rtspcam.cpp:            _frames->flip();
rtspcam.cpp:            leng = i._caml = frame->ptr(&i._camp);
rtspcam.cpp:                TRACE() << "piping "  << frame->length() << " bytes\n";
rtspcam.cpp:                _pipa->stream(frame->buffer(),frame->length());
rtspcam.cpp:    avrlibrtsp   p(this->_img_size);
rtspcam.cpp:        while(!this->is_stopped() && __alive && okay)
rtspcam.cpp:                if(false == p.spin(_frames->to_load()))
camevents.cpp:            int movedpix =  _mt->det_mov(imgl, _mohilo);
camevents.cpp:        w  = _mt->getw();
camevents.cpp:        h  = _mt->geth();
camevents.cpp:        return _mt->motionbuf();
camevents.cpp:    if(now - _tickmove > _inertiiaitl)
camevents.cpp:            _event.movepix = _mt->det_mov(imgl,_mohilo);
camevents.cpp:            --_movementintertia;
camevents.cpp:        if((now - _lapsetick) > (uint32_t)_time_lapse)
camevents.cpp:    if(_mt && _mt->darkav() < _dark_motion)
camevents.cpp:            if(time(0) - _mpgnewfile > 3600*24)  /*every day*/
camevents.cpp:            ::sprintf(fname, "%si%04d-%06d.jpg", savloc.c_str(),_event.movepix, _firstimage);
camevents.cpp:        _mt->set(pixnoise, pixdiv, imgscale);
camevents.cpp:        _mt->get(pixnoise, pixdiv, imgscale);
Binary file docs/limotion.png matches
Binary file docs/lili.png matches
Binary file docs/liimagremote.png matches
Binary file docs/limag1.png matches
Binary file docs/dia1.dia matches
docs/r-pi-rtsp-server.txt:User-Agent: Lavf58.29.100
docs/r-pi-rtsp-server.txt:User-Agent: Lavf58.29.100
docs/r-pi-rtsp-server.txt:	Content-Base: rtsp://192.168.1.116:8554/unicast/
docs/r-pi-rtsp-server.txt:	Content-Type: application/sdp
docs/r-pi-rtsp-server.txt:	Content-Length: 537
docs/r-pi-rtsp-server.txt:	o=- 1651758637343892 1 IN IP4 192.168.1.116
docs/r-pi-rtsp-server.txt:	a=range:npt=now-
docs/r-pi-rtsp-server.txt:	a=x-qt-text-nam:LIVE555 Streaming Media v2022.04.26
docs/r-pi-rtsp-server.txt:	a=x-qt-text-inf:LIVE555 Streaming Media v2022.04.26
docs/r-pi-rtsp-server.txt:	a=fmtp:96 profile-level-id=640028;sprop-parameter-sets=J2QAKKwrQCADDQDxImo=,KO4CXLA=
docs/r-pi-rtsp-server.txt:	a=x-dimensions:1024,768
docs/r-pi-rtsp-server.txt:Transport: RTP/AVP/UDP;unicast;client_port=15392-15393
docs/r-pi-rtsp-server.txt:User-Agent: Lavf58.29.100
docs/r-pi-rtsp-server.txt:	Transport: RTP/AVP;unicast;destination=192.168.1.191;source=192.168.1.116;client_port=15392-15393;server_port=6970-6971
docs/r-pi-rtsp-server.txt:Range: npt=0.000-
docs/r-pi-rtsp-server.txt:User-Agent: Lavf58.29.100
fxxtojpg.cpp:    First Release: September 16 - 29 2016
fxxtojpg.cpp:    if (cinfo->dest == NULL)
fxxtojpg.cpp:        cinfo->dest = (struct jpeg_destination_mgr *)
fxxtojpg.cpp:                (*cinfo->mem->alloc_small)((j_common_ptr)cinfo,
fxxtojpg.cpp:    dest = (mem_dest_ptr) cinfo->dest;
fxxtojpg.cpp:    dest->pub.init_destination    = _init_destination;
fxxtojpg.cpp:    dest->pub.empty_output_buffer = _empty_output_buffer;
fxxtojpg.cpp:    dest->pub.term_destination    = _term_destination;
fxxtojpg.cpp:    dest->buf      = _image = (uint8_t*)malloc(BLOCK_SZ);
fxxtojpg.cpp:    assert(dest->buf);
fxxtojpg.cpp:    dest->bufsize  = _memsz = BLOCK_SZ;
fxxtojpg.cpp:    dest->jpegsize = 0;
fxxtojpg.cpp:    mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
fxxtojpg.cpp:    dest->pub.next_output_byte  = dest->buf;
fxxtojpg.cpp:    dest->pub.free_in_buffer    = dest->bufsize;
fxxtojpg.cpp:    dest->jpegsize = 0;
fxxtojpg.cpp:    // TRACE() << "      JPEGER INIT TO "<<dest->buf <<","<<dest->bufsize << "bytes \r\n";
fxxtojpg.cpp:    mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
fxxtojpg.cpp:    size_t oldsize = _pthis->_memsz;
fxxtojpg.cpp:    ::memcpy(nb, _pthis->_image, oldsize);
fxxtojpg.cpp:    ::free(_pthis->_image);
fxxtojpg.cpp:    _pthis->_image = nb;
fxxtojpg.cpp:    _pthis->_memsz = oldsize+BLOCK_SZ;
fxxtojpg.cpp:    dest->pub.next_output_byte = _pthis->_image  + oldsize;
fxxtojpg.cpp:    dest->pub.free_in_buffer = BLOCK_SZ;
fxxtojpg.cpp:    dest->buf = _pthis->_image;
fxxtojpg.cpp:    dest->bufsize = _pthis->_memsz;
fxxtojpg.cpp:    TRACE() << "      JPEGER REALLOC TO "<<dest->buf <<","<<dest->bufsize << "bytes \r\n";
fxxtojpg.cpp:    mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
fxxtojpg.cpp:    size_t jpgsize = dest->bufsize -cinfo->dest->free_in_buffer;
fxxtojpg.cpp:    dest->jpegsize = jpgsize;
fxxtojpg.cpp:    mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
fxxtojpg.cpp:    // TRACE() << "      JPEG SZ "<<dest->jpegsize<<"\r\n" ;
fxxtojpg.cpp:    return dest->jpegsize;
mpeger.h:    //lavdevice - -lavformat -lavcodec -lavutil
pipefile.cpp:            rv =  ::write(_fd,buff+sent,maxsz-sent);
pipefile.cpp:                TRACE() << "mplayer " << _fn << " -cache 200 -cache-min 80  # has "<<maxsz<<" bytes \n";
avlibrtsp.cpp:    for (unsigned int i = 0; i < avf_ctx->nb_streams; i++)
avlibrtsp.cpp:        if (avf_ctx->streams[i]->codec->codec_type == AVMEDIA_TYPE_VIDEO)
avlibrtsp.cpp:        if(_pavcodec_find_encoder(avf_ctx->streams[i]->codec->codec_id)->type ==AVMEDIA_TYPE_VIDEO)
avlibrtsp.cpp:    if (video_stream_index == -1)
avlibrtsp.cpp:    avc_ctx = avf_ctx->streams[video_stream_index]->codec;
avlibrtsp.cpp:    avc = _pavcodec_find_decoder(avc_ctx->codec_id);
avlibrtsp.cpp:    pix_fmt = avc_ctx->pix_fmt;
avlibrtsp.cpp:    pFrame422->format = AV_PIX_FMT_YUV420P;
avlibrtsp.cpp:    pFrame422->width  = _dims.x; /* must match sizes as on sws_getContext() */
avlibrtsp.cpp:    pFrame422->height = _dims.y; /* must match sizes as on sws_getContext() */
avlibrtsp.cpp:                vframe->_wh.x = avc_ctx->width;
avlibrtsp.cpp:                vframe->_wh.y = avc_ctx->height;
avlibrtsp.cpp:        swsContext = _psws_getContext(avc_ctx->width, avc_ctx->height, avc_ctx->pix_fmt,
avlibrtsp.cpp:                                      pFrame->data,
avlibrtsp.cpp:                                      pFrame->linesize,
avlibrtsp.cpp:                                      pFrame->height,
avlibrtsp.cpp:                                      pFrame422->data,
avlibrtsp.cpp:                                      pFrame422->linesize);
avlibrtsp.cpp:                        vframe.copy(pFrame422->data[0],0,pFrame422->buf[0]->size);
liveimage.konf:# only if /usr/lib/x86_64-linux-gnu/lib_av.so  is provided.
liveimage.konf:        lib_av           {/usr/lib/x86_64-linux-gnu/libav}   # if the img format is !=0 TODO
liveimage.konf:        noise_div        {8}                # lower -> higher noise, (2...16)
park/mainn.cpp:    First Release: September 16 - 29 2016
park/mainn.cpp:sudo apt-get install libpng-dev libv4l-dev libjpeg-dev
park/mainn.cpp:                if(ps && ps->listen()==false)
park/mainn.cpp:                if(ps && ps->listen()==false)
park/mainn.cpp:                    ps->spin();
park/mainn.cpp:                if(ps && ps->has_clients())
park/mainn.cpp:                    int wants = ps->anyone_needs();
park/mainn.cpp:                    ps->stream_on(_enc_image.pimage, _enc_image.isize,"jpeg", wants);
park/mainn.cpp:    int ret = avcodec_encode_video2(plib->_ctx,
park/mainn.cpp:                                    &pkt, plib->pRawFrame, &got_output);
park/mainn.cpp:        uint64_t imgsz = _imagesz(GCFG->_glb.w, GCFG->_glb.h);
park/mainn.cpp:    int             iw = GCFG->_glb.w;
park/mainn.cpp:    int             ih = GCFG->_glb.h;
park/mainn.cpp:    if(!GCFG->_glb.webcast.empty())
park/mainn.cpp:            ps->spin();
park/mainn.cpp:        jpgsz = ffmt->convert420(pb422, iw, ih, GCFG->_glb.quality, &pjpg);
park/mainn.cpp:        if(ps && ps->has_clients())
park/mainn.cpp:            int wants = ps->anyone_needs();
park/mainn.cpp:                ps->stream_on(0, 0, "", WANTS_HTML);
park/mainn.cpp:                ps->stream_on(pjpg, jpgsz, GCFG->_glb.format=="jpg" ? "jpeg" : "png", WANTS_LIVE_IMAGE);
park/mainn.cpp:                size_t          jpgsz1 = ffmt->convertBW(mot, w, h, 80, &pjpg1);
park/mainn.cpp:                ps->stream_on(pjpg1, jpgsz1, GCFG->_glb.format=="jpg" ? "jpeg" : "png", WANTS_MOTION);
park/mainn.cpp:                ps->stream_on(pjpg, jpgsz, 0, WANTS_VIDEO_TODO);
park/mainn.cpp:        if(GCFG->_glb.imotion[0]>0)
park/mainn.cpp:            if(now - tickmove > GCFG->_glb.motionsnap)
park/mainn.cpp:                if( movepix >= GCFG->_glb.imotion[0] && movepix <= GCFG->_glb.imotion[1])
park/mainn.cpp:                    movementintertia = GCFG->_glb.motiontrail;
park/mainn.cpp:                    --movementintertia;
park/mainn.cpp:        if(GCFG->_glb.timelapse > 0)
park/mainn.cpp:            if((now - lapsetick) > (uint32_t)GCFG->_glb.timelapse)
park/mainn.cpp:        if(dev.darkaverage() < (uint32_t)GCFG->_glb.darklapse)
park/mainn.cpp:        if(dev.darkaverage() < (uint32_t)GCFG->_glb.darkmotion)
park/mainn.cpp:        if(!pathname.empty() && (savelapse || savemove || GCFG->_glb.oneshot || _sig_proc_capture) )
park/mainn.cpp:            ::sprintf(fname, "%si%04d-%06d.jpg", pathname.c_str(), movepix, firstimage);
park/mainn.cpp:                if(GCFG->_glb.userpid > 0)
park/mainn.cpp:                    ::kill(GCFG->_glb.userpid, SIGUSR2);
park/mainn.cpp:                    std::cout << "SIGUSR2: " << GCFG->_glb.userpid << "\n";
park/mainn.cpp:        if(GCFG->_glb.oneshot)
park/v4libavdev.h:    int videoStream = -1;
park/v4libavdev.cpp:    std::string fps = std::to_string(GCFG->_glb.fps);
park/v4libavdev.cpp:    ::sprintf(rez,"%dx%d",GCFG->_glb.w, GCFG->_glb.h);
park/v4libavdev.cpp:            if (-1 == opened)
park/v4libavdev.cpp:    for (int i = 0; i < pFormatCtx->nb_streams; i++)
park/v4libavdev.cpp:        if (pFormatCtx->streams[i]->codecpar->codec_type == AVMEDIA_TYPE_VIDEO) {
park/v4libavdev.cpp:    if (videoStream == -1)
park/v4libavdev.cpp:    pCodecParams1 = pFormatCtx->streams[videoStream]->codecpar;
park/v4libavdev.cpp:    pCodec = avcodec_find_decoder(pCodecParams1->codec_id);
park/v4libavdev.cpp:    if (avcodec_parameters_to_context(pCodecCtx, pFormatCtx->streams[videoStream]->codecpar) < 0)
park/v4libavdev.cpp:             _ctx->bit_rate = 14756;
park/v4libavdev.cpp:             _ctx->width = GCFG->_glb.w;
park/v4libavdev.cpp:             _ctx->height = GCFG->_glb.h;
park/v4libavdev.cpp:             _ctx->time_base.num = 1;
park/v4libavdev.cpp:             _ctx->time_base.den = 25;
park/v4libavdev.cpp:             _ctx->max_b_frames = 1;
park/v4libavdev.cpp:             _ctx->pix_fmt = AV_PIX_FMT_YUYV422;
park/v4libavdev.cpp:             _ctx->strict_std_compliance = FF_COMPLIANCE_UNOFFICIAL-1;
park/v4libavdev.cpp:        return -1;
park/v4libavdev.cpp:            return -1;
anytojpg-retired.cpp:    c->width = img._dims.x;
anytojpg-retired.cpp:    c->height = img._dims.y;
anytojpg-retired.cpp:    c->time_base.num = 1;
anytojpg-retired.cpp:    c->time_base.den = 1;
anytojpg-retired.cpp:    c->pix_fmt = _last_good; //img._camf;
anytojpg-retired.cpp:            c->pix_fmt = (AVPixelFormat)i;
anytojpg-retired.cpp:            c->width = img._dims.x;
anytojpg-retired.cpp:            c->height = img._dims.y;
anytojpg-retired.cpp:            c->time_base.num = 1;
anytojpg-retired.cpp:            c->time_base.den = 1;
anytojpg-retired.cpp:    picture->format = c->pix_fmt;
anytojpg-retired.cpp:    picture->width  = c->width;
anytojpg-retired.cpp:    picture->height = c->height;
anytojpg-retired.cpp:    ::memcpy(picture->data[0],img._camp,img._caml);
anytojpg-retired.cpp:        printf("encoded frame %3" PRId64" (size=%5d)\n", pkt->pts, pkt->size);
anytojpg-retired.cpp:            img._jpgp = pkt->data;
anytojpg-retired.cpp:            img._jpgl = pkt->size;
sockserver.h:    First Release: September 16 - 29 2016
sockserver.h:                "Cache-Control: no-cache\r\n"   \
sockserver.h:                "Content-Type: multipart/x-mixed-replace;boundary=MY_BOUNDARY_STRING_NOONE_HAS\r\n" \
sockserver.h:                "--MY_BOUNDARY_STRING_NOONE_HAS\r\n"
sockserver.h:                "Content-Length: %d\r\n" \
sockserver.h:                "Cache-Control: no-cache\r\n\r\n"
motion.cpp:    int diff = abs(Y - YP);
motion.cpp:    for (int y=1; y <_mh-dy; y++)             //height
motion.cpp:        for (int x = 1; x < _mw-dx; x++)       //width
motion.cpp:            _motion(0, base_py, pSeen, prowprev, prowcur, x-1, y-1, dx, dy, pixels);
motion.cpp:        for (int y= _inrect.y+1; y <_inrect.Y-1; y++)
motion.cpp:        for (int x = _inrect.x+1; x < _inrect.X-1; x++)
motion.cpp:        for (int y= _outrect.y+2; y <_outrect.Y-1; y++)
motion.cpp:        for (int x = _outrect.x+2; x < _outrect.X-2; x++)
motion.cpp:    // maxmoves -> _mh
motion.cpp:    // curmove  ->  x
motion.cpp:                *(pSeen + ((_mh-y) * _mw)) = (uint8_t)0;
motion.cpp:                *(pSeen + ((_mh-y) * _mw)+1) = (uint8_t)255;
motion.cpp:            --y;
motion.cpp:            for (int y = 1; y <_mh-dy; y++)             //height
motion.cpp:                for (int x = 1; x < neww-x; x++)       //width
motion.cpp:                            prowcur, x-1, y-1, dx, dy, pixels);
encrypter.h:            loco[i] = pc[i] - _key[i%_key.length()];
anytojpg-retired.h:    //lavdevice - -lavformat -lavcodec -lavutil
httpcam.cpp:    "User-Agent: liveimage 1.0\r\n"                 \
httpcam.cpp:    "Pragma: no-cache\r\n"                          \
httpcam.cpp:    "Cache-Control: no-cache\r\n\r\n"
httpcam.cpp:    this->signal_to_stop();
httpcam.cpp:    this->stop_thread();
httpcam.cpp:    while(!this->is_stopped() && __alive)
httpcam.cpp:                    hlen = hlen-(eoh-url+4);
httpcam.cpp:                    int icl = (int)_frame[_ifrm].capa()-hlen;
httpcam.cpp:                    char* pcl = strstr(url,"Content-Length: ");
httpcam.cpp:                        icl = ::atoi(pcl+16) - hlen;
httpcam.cpp:                            icl = (int)_frame[_ifrm].capa()-hlen;
httpcam.cpp:                int ir = sm.receive(req,sizeof(req)-1);
CMakeLists.txt:### sudo apt-get install libpng-dev
CMakeLists.txt:### sudo apt-get install libv4l-dev
CMakeLists.txt:### sudo apt-get install libjpeg-dev
CMakeLists.txt:add_definitions(-Dcimg_display=0 -Dcimg_use_jpeg  -Dcimg_display=0 -DWITH_AVLIB_RTSP)
CMakeLists.txt:SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0")
jpeger.cpp:    First Release: September 16 - 29 2016
jpeger.cpp:    if (cinfo->dest == NULL)
jpeger.cpp:        cinfo->dest = (struct jpeg_destination_mgr *)
jpeger.cpp:                (*cinfo->mem->alloc_small)((j_common_ptr)cinfo,
jpeger.cpp:    dest = (mem_dest_ptr) cinfo->dest;
jpeger.cpp:    dest->pub.init_destination    = _init_destination;
jpeger.cpp:    dest->pub.empty_output_buffer = _empty_output_buffer;
jpeger.cpp:    dest->pub.term_destination    = _term_destination;
jpeger.cpp:    dest->buf      = _image = (uint8_t*)malloc(BLOCK_SZ);
jpeger.cpp:    assert(dest->buf);
jpeger.cpp:    dest->bufsize  = _memsz = BLOCK_SZ;
jpeger.cpp:    dest->jpegsize = 0;
jpeger.cpp:    mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
jpeger.cpp:    dest->pub.next_output_byte  = dest->buf;
jpeger.cpp:    dest->pub.free_in_buffer    = dest->bufsize;
jpeger.cpp:    dest->jpegsize = 0;
jpeger.cpp:    // TRACE() << "      JPEGER INIT TO "<<dest->buf <<","<<dest->bufsize << "bytes \r\n";
jpeger.cpp:    mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
jpeger.cpp:    size_t oldsize = _pthis->_memsz;
jpeger.cpp:    ::memcpy(nb, _pthis->_image, oldsize);
jpeger.cpp:    ::free(_pthis->_image);
jpeger.cpp:    _pthis->_image = nb;
jpeger.cpp:    _pthis->_memsz = oldsize+BLOCK_SZ;
jpeger.cpp:    dest->pub.next_output_byte = _pthis->_image  + oldsize;
jpeger.cpp:    dest->pub.free_in_buffer = BLOCK_SZ;
jpeger.cpp:    dest->buf = _pthis->_image;
jpeger.cpp:    dest->bufsize = _pthis->_memsz;
jpeger.cpp:    TRACE() << "      JPEGER REALLOC TO "<<dest->buf <<","<<dest->bufsize << "bytes \r\n";
jpeger.cpp:    mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
jpeger.cpp:    size_t jpgsize = dest->bufsize -cinfo->dest->free_in_buffer;
jpeger.cpp:    dest->jpegsize = jpgsize;
jpeger.cpp:    mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
jpeger.cpp:    // TRACE() << "      JPEG SZ "<<dest->jpegsize<<"\r\n" ;
jpeger.cpp:    return dest->jpegsize;
_jpeger.cpp:    First Release: September 16 - 29 2016
_jpeger.cpp:    jpeg_set_quality(&cinfo, 80, TRUE /* limit to baseline-JPEG values */);
_jpeger.cpp:    if (cinfo->dest == NULL)
_jpeger.cpp:        cinfo->dest = (struct jpeg_destination_mgr *)
_jpeger.cpp:                      (*cinfo->mem->alloc_small)((j_common_ptr)cinfo, JPOOL_PERMANENT,
_jpeger.cpp:    dest = (mem_dest_ptr) cinfo->dest;
_jpeger.cpp:    dest->pub.init_destination    = _init_destination;
_jpeger.cpp:    dest->pub.empty_output_buffer = _empty_output_buffer;
_jpeger.cpp:    dest->pub.term_destination    = _term_destination;
_jpeger.cpp:    dest->buf      = buf;
_jpeger.cpp:    dest->bufsize  = bufsize;
_jpeger.cpp:    dest->jpegsize = 0;
_jpeger.cpp:    mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
_jpeger.cpp:    dest->pub.next_output_byte = dest->buf;
_jpeger.cpp:    dest->pub.free_in_buffer = dest->bufsize;
_jpeger.cpp:    dest->jpegsize = 0;
_jpeger.cpp:    mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
_jpeger.cpp:    dest->pub.next_output_byte = dest->buf;
_jpeger.cpp:    dest->pub.free_in_buffer = dest->bufsize;
_jpeger.cpp:    mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
_jpeger.cpp:    dest->jpegsize = dest->bufsize - dest->pub.free_in_buffer;
_jpeger.cpp:    mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
_jpeger.cpp:    return dest->jpegsize;
.gitignore:build-qt*/*
.gitignore:./build-*
v4ldevice.cpp-old.cpp:    First Release: September 16 - 29 2016
v4ldevice.cpp-old.cpp:            if (-1 == _device)
v4ldevice.cpp-old.cpp:    if (-1 == _device)
v4ldevice.cpp-old.cpp:    if (-1 == _ioctl(VIDIOC_QUERYCAP, &caps))
v4ldevice.cpp-old.cpp:    if (-1 == _ioctl(VIDIOC_S_FMT, &frmt))
v4ldevice.cpp-old.cpp:        if (-1 == _ioctl(VIDIOC_S_PARM, &fint))
v4ldevice.cpp-old.cpp:    uint32_t buffer_size = (frmt.fmt.pix.sizeimage + page_size - 1) & ~(page_size - 1);
v4ldevice.cpp-old.cpp:    if (-1 == _ioctl(VIDIOC_REQBUFS, &req))
v4ldevice.cpp-old.cpp:        if (-1 == _ioctl(VIDIOC_REQBUFS, &req))
v4ldevice.cpp-old.cpp:            if (-1 == _ioctl(VIDIOC_QBUF, &buf))
v4ldevice.cpp-old.cpp:        if (-1 == _ioctl(VIDIOC_STREAMON, &type))
v4ldevice.cpp-old.cpp:        if (-1 == _ioctl(VIDIOC_QUERYBUF, &buf))
v4ldevice.cpp-old.cpp:        if (-1 == _ioctl(VIDIOC_QBUF, &buf))
v4ldevice.cpp-old.cpp:    if (-1 == _ioctl(VIDIOC_STREAMON, &type))
v4ldevice.cpp-old.cpp:    while (-1 == r && EINTR == errno)
v4ldevice.cpp-old.cpp:    if(r==-1)
v4ldevice.cpp-old.cpp:    if(-1==_ioctl(VIDIOC_DQBUF, &buf))
v4ldevice.cpp-old.cpp:    if (-1 == _ioctl(VIDIOC_QBUF, &buf))
.git/info/exclude:# git ls-files --others --exclude-from=.git/info/exclude
.git/hooks/prepare-commit-msg.sample:# message file.  If the hook fails with a non-zero status,
.git/hooks/prepare-commit-msg.sample:# To enable this hook, rename this file to "prepare-commit-msg".
.git/hooks/prepare-commit-msg.sample:# The second includes the output of "git diff --name-status -r"
.git/hooks/prepare-commit-msg.sample:# commented because it doesn't cope with --amend or with squashed
.git/hooks/prepare-commit-msg.sample:# The third example adds a Signed-off-by line to the message, that can
.git/hooks/prepare-commit-msg.sample:/usr/bin/perl -i.bak -ne 'print unless(m/^. Please enter the commit message/..m/^#$/)' "$COMMIT_MSG_FILE"
.git/hooks/prepare-commit-msg.sample:#    /usr/bin/perl -i.bak -pe '
.git/hooks/prepare-commit-msg.sample:#       print "\n" . `git diff --cached --name-status -r`
.git/hooks/prepare-commit-msg.sample:# SOB=$(git var GIT_COMMITTER_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
.git/hooks/prepare-commit-msg.sample:# git interpret-trailers --in-place --trailer "$SOB" "$COMMIT_MSG_FILE"
.git/hooks/prepare-commit-msg.sample:# if test -z "$COMMIT_SOURCE"
.git/hooks/prepare-commit-msg.sample:#   /usr/bin/perl -i.bak -pe 'print "\n" if !$first_line++' "$COMMIT_MSG_FILE"
.git/hooks/commit-msg.sample:# that has the commit message.  The hook should exit with non-zero
.git/hooks/commit-msg.sample:# To enable this hook, rename this file to "commit-msg".
.git/hooks/commit-msg.sample:# Uncomment the below to add a Signed-off-by line to the message.
.git/hooks/commit-msg.sample:# Doing this in a hook is a bad idea in general, but the prepare-commit-msg
.git/hooks/commit-msg.sample:# SOB=$(git var GIT_AUTHOR_IDENT | sed -n 's/^\(.*>\).*$/Signed-off-by: \1/p')
.git/hooks/commit-msg.sample:# grep -qs "^$SOB" "$1" || echo "$SOB" >> "$1"
.git/hooks/commit-msg.sample:# This example catches duplicate Signed-off-by lines.
.git/hooks/commit-msg.sample:test "" = "$(grep '^Signed-off-by: ' "$1" |
.git/hooks/commit-msg.sample:	 sort | uniq -c | sed -e '/^[ 	]*1[ 	]/d')" || {
.git/hooks/commit-msg.sample:	echo >&2 Duplicate Signed-off-by lines.
.git/hooks/pre-applypatch.sample:# by applypatch from an e-mail message.
.git/hooks/pre-applypatch.sample:# The hook should exit with non-zero status after issuing an
.git/hooks/pre-applypatch.sample:# To enable this hook, rename this file to "pre-applypatch".
.git/hooks/pre-applypatch.sample:. git-sh-setup
.git/hooks/pre-applypatch.sample:precommit="$(git rev-parse --git-path hooks/pre-commit)"
.git/hooks/pre-applypatch.sample:test -x "$precommit" && exec "$precommit" ${1+"$@"}
.git/hooks/applypatch-msg.sample:# applypatch from an e-mail message.
.git/hooks/applypatch-msg.sample:# The hook should exit with non-zero status after issuing an
.git/hooks/applypatch-msg.sample:# To enable this hook, rename this file to "applypatch-msg".
.git/hooks/applypatch-msg.sample:. git-sh-setup
.git/hooks/applypatch-msg.sample:commitmsg="$(git rev-parse --git-path hooks/commit-msg)"
.git/hooks/applypatch-msg.sample:test -x "$commitmsg" && exec "$commitmsg" ${1+"$@"}
.git/hooks/pre-receive.sample:# To enable this hook, rename this file to "pre-receive".
.git/hooks/pre-receive.sample:if test -n "$GIT_PUSH_OPTION_COUNT"
.git/hooks/pre-receive.sample:	while test "$i" -lt "$GIT_PUSH_OPTION_COUNT"
.git/hooks/pre-receive.sample:			echo "echo from the pre-receive-hook: ${value#*=}" >&2
.git/hooks/update.sample:# Called by "git receive-pack" with arguments: refname sha1-old sha1-new
.git/hooks/update.sample:# ------
.git/hooks/update.sample:# --- Command line
.git/hooks/update.sample:# --- Safety check
.git/hooks/update.sample:if [ -z "$GIT_DIR" ]; then
.git/hooks/update.sample:if [ -z "$refname" -o -z "$oldrev" -o -z "$newrev" ]; then
.git/hooks/update.sample:# --- Config
.git/hooks/update.sample:allowunannotated=$(git config --bool hooks.allowunannotated)
.git/hooks/update.sample:allowdeletebranch=$(git config --bool hooks.allowdeletebranch)
.git/hooks/update.sample:denycreatebranch=$(git config --bool hooks.denycreatebranch)
.git/hooks/update.sample:allowdeletetag=$(git config --bool hooks.allowdeletetag)
.git/hooks/update.sample:allowmodifytag=$(git config --bool hooks.allowmodifytag)
.git/hooks/update.sample:projectdesc=$(sed -e '1q' "$GIT_DIR/description")
.git/hooks/update.sample:# --- Check types
.git/hooks/update.sample:	newrev_type=$(git cat-file -t $newrev)
.git/hooks/update.sample:		# un-annotated tag
.git/hooks/update.sample:			echo "*** The un-annotated tag, $short_refname, is not allowed in this repository" >&2
.git/hooks/update.sample:			echo "*** Use 'git tag [ -a | -s ]' for tags you want to propagate." >&2
.git/hooks/update.sample:		if [ "$allowmodifytag" != "true" ] && git rev-parse $refname > /dev/null 2>&1
.git/hooks/update.sample:		if [ "$oldrev" = "$zero" -a "$denycreatebranch" = "true" ]; then
.git/hooks/update.sample:# --- Finished
.git/hooks/pre-commit.sample:# exit with non-zero status after issuing an appropriate message if
.git/hooks/pre-commit.sample:# To enable this hook, rename this file to "pre-commit".
.git/hooks/pre-commit.sample:if git rev-parse --verify HEAD >/dev/null 2>&1
.git/hooks/pre-commit.sample:	against=$(git hash-object -t tree /dev/null)
.git/hooks/pre-commit.sample:# If you want to allow non-ASCII filenames set this variable to true.
.git/hooks/pre-commit.sample:allownonascii=$(git config --bool hooks.allownonascii)
.git/hooks/pre-commit.sample:# Cross platform projects tend to avoid non-ASCII filenames; prevent
.git/hooks/pre-commit.sample:	test $(git diff --cached --name-only --diff-filter=A -z $against |
.git/hooks/pre-commit.sample:	  LC_ALL=C tr -d '[ -~]\0' | wc -c) != 0
.git/hooks/pre-commit.sample:Error: Attempt to add a non-ASCII file name.
.git/hooks/pre-commit.sample:exec git diff-index --check --cached $against --
.git/hooks/pre-rebase.sample:# The "pre-rebase" hook is run just before "git rebase" starts doing
.git/hooks/pre-rebase.sample:# non-zero status.
.git/hooks/pre-rebase.sample:# $1 -- the upstream the series was forked from.
.git/hooks/pre-rebase.sample:# $2 -- the branch being rebased (or empty when rebasing the current branch).
.git/hooks/pre-rebase.sample:	topic=`git symbolic-ref HEAD` ||
.git/hooks/pre-rebase.sample:git show-ref -q "$topic" || {
.git/hooks/pre-rebase.sample:not_in_master=`git rev-list --pretty=oneline ^master "$topic"`
.git/hooks/pre-rebase.sample:if test -z "$not_in_master"
.git/hooks/pre-rebase.sample:only_next_1=`git rev-list ^master "^$topic" ${publish} | sort`
.git/hooks/pre-rebase.sample:only_next_2=`git rev-list ^master           ${publish} | sort`
.git/hooks/pre-rebase.sample:	not_in_topic=`git rev-list "^$topic" master`
.git/hooks/pre-rebase.sample:	if test -z "$not_in_topic"
.git/hooks/pre-rebase.sample:	not_in_next=`git rev-list --pretty=oneline ^${publish} "$topic"`
.git/hooks/pre-rebase.sample:	/usr/bin/perl -e '
.git/hooks/pre-rebase.sample:			/^([0-9a-f]+) /;
.git/hooks/pre-rebase.sample:				/^([0-9a-f]+) (.*)$/;
.git/hooks/pre-rebase.sample:			if (!exists $not_in_next{$elem->[0]}) {
.git/hooks/pre-rebase.sample:				print STDERR " $elem->[1]\n";
.git/hooks/pre-rebase.sample:    build on top of it -- other people may already want to
.git/hooks/pre-rebase.sample:		   o---o---o---o---o---o---o---o---o---o "next"
.git/hooks/pre-rebase.sample:		 /   a---a---b A     /           /
.git/hooks/pre-rebase.sample:	       /   /   c---c---c---c B         /
.git/hooks/pre-rebase.sample:	     /   /   /   b---b C     \       /
.git/hooks/pre-rebase.sample:    ---o---o---o---o---o---o---o---o---o---o---o "master"
.git/hooks/pre-rebase.sample:	git rev-list ^master ^topic next
.git/hooks/pre-rebase.sample:	git rev-list ^master        next
.git/hooks/pre-rebase.sample:	git rev-list master..topic
.git/hooks/pre-push.sample:# pushed.  If this script exits with a non-zero status nothing will be pushed.
.git/hooks/pre-push.sample:# $1 -- Name of the remote to which the push is being done
.git/hooks/pre-push.sample:# $2 -- URL to which the push is being done
.git/hooks/pre-push.sample:		commit=`git rev-list -n 1 --grep '^WIP' "$range"`
.git/hooks/pre-push.sample:		if [ -n "$commit" ]
.git/hooks/post-update.sample:# To enable this hook, rename this file to "post-update".
.git/hooks/post-update.sample:exec git update-server-info
.git/hooks/fsmonitor-watchman.sample:# To enable this hook, rename this file to "query-watchman" and set
.git/hooks/fsmonitor-watchman.sample:# 'git config core.fsmonitor .git/hooks/query-watchman'
.git/hooks/fsmonitor-watchman.sample:	die "Unsupported query-fsmonitor hook version '$version'.\n" .
.git/hooks/fsmonitor-watchman.sample:	my $pid = open2(\*CHLD_OUT, \*CHLD_IN, 'watchman -j --no-pretty')
.git/hooks/fsmonitor-watchman.sample:	my $o = $json_pkg->new->utf8->decode($response);
.git/hooks/fsmonitor-watchman.sample:	if ($retry > 0 and $o->{error} and $o->{error} =~ m/unable to resolve root .* directory (.*) is not watched/) {
.git/hooks/fsmonitor-watchman.sample:		$retry--;
.git/hooks/fsmonitor-watchman.sample:	die "Watchman: $o->{error}.\n" .
.git/hooks/fsmonitor-watchman.sample:	    "Falling back to scanning...\n" if $o->{error};
.git/hooks/fsmonitor-watchman.sample:	print @{$o->{files}};
Binary file .git/index matches
.git/packed-refs:# pack-refs with: peeled fully-peeled sorted 
.git/logs/HEAD:9c7c9deaa51cece507351583fde8ab2d5aa90076 d6efb55f0186a2d66476dd7db21320a314847978 circinusX1 <mcoctav@gmail.com> 1655214776 +0100	pull: Fast-forward
.git/logs/HEAD:d6efb55f0186a2d66476dd7db21320a314847978 9aba1d465d57003ede9b1a4cbdf5fc8c9b0d6117 circinusX1 <mcoctav@gmail.com> 1655245525 +0100	pull origin: Fast-forward
.git/logs/HEAD:9aba1d465d57003ede9b1a4cbdf5fc8c9b0d6117 55fb9972303fe52bc91c7ce1ab1f672744d730cc circinusX1 <mcoctav@gmail.com> 1655777872 +0100	pull: Fast-forward
.git/logs/HEAD:55fb9972303fe52bc91c7ce1ab1f672744d730cc fc52244d6c7bbf5a919cfc52628b7ee9e4ee0378 circinusX1 <mcoctav@gmail.com> 1658683305 +0100	pull origin: Fast-forward
.git/logs/HEAD:fc52244d6c7bbf5a919cfc52628b7ee9e4ee0378 cd0acfe7e617a33cd79597b8dad399fd81bb08b9 circinusX1 <mcoctav@gmail.com> 1689183475 +0100	pull: Fast-forward
.git/logs/HEAD:cd0acfe7e617a33cd79597b8dad399fd81bb08b9 363d0dbf5bfde7a736441a360ef6c7fe85544402 circinusX1 <mcoctav@gmail.com> 1689302544 +0100	pull: Fast-forward
.git/logs/HEAD:363d0dbf5bfde7a736441a360ef6c7fe85544402 c7285a0e2b0c11bd8351f13857b26635c19e55ca circinusX1 <mcoctav@gmail.com> 1690911741 +0100	commit: r-pi some fixes
.git/logs/HEAD:c7285a0e2b0c11bd8351f13857b26635c19e55ca 3830aaeae63c8c2271dfaec49fc4b4b5d9db1174 circinusX1 <mcoctav@gmail.com> 1690911889 +0100	commit (merge): r-pi some fixes
.git/logs/HEAD:3830aaeae63c8c2271dfaec49fc4b4b5d9db1174 ba370871057d19f07c947272ec14573d3de787c8 circinusX1 <mcoctav@gmail.com> 1690916301 +0100	pull: Fast-forward
.git/logs/HEAD:ba370871057d19f07c947272ec14573d3de787c8 5f372b9d281226e79f1936e9f46c7daaa47a7f6e circinusX1 <mcoctav@gmail.com> 1694812514 +0100	pull: Fast-forward
.git/logs/refs/heads/main:9c7c9deaa51cece507351583fde8ab2d5aa90076 d6efb55f0186a2d66476dd7db21320a314847978 circinusX1 <mcoctav@gmail.com> 1655214776 +0100	pull: Fast-forward
.git/logs/refs/heads/main:d6efb55f0186a2d66476dd7db21320a314847978 9aba1d465d57003ede9b1a4cbdf5fc8c9b0d6117 circinusX1 <mcoctav@gmail.com> 1655245525 +0100	pull origin: Fast-forward
.git/logs/refs/heads/main:9aba1d465d57003ede9b1a4cbdf5fc8c9b0d6117 55fb9972303fe52bc91c7ce1ab1f672744d730cc circinusX1 <mcoctav@gmail.com> 1655777872 +0100	pull: Fast-forward
.git/logs/refs/heads/main:55fb9972303fe52bc91c7ce1ab1f672744d730cc fc52244d6c7bbf5a919cfc52628b7ee9e4ee0378 circinusX1 <mcoctav@gmail.com> 1658683305 +0100	pull origin: Fast-forward
.git/logs/refs/heads/main:fc52244d6c7bbf5a919cfc52628b7ee9e4ee0378 cd0acfe7e617a33cd79597b8dad399fd81bb08b9 circinusX1 <mcoctav@gmail.com> 1689183475 +0100	pull: Fast-forward
.git/logs/refs/heads/main:cd0acfe7e617a33cd79597b8dad399fd81bb08b9 363d0dbf5bfde7a736441a360ef6c7fe85544402 circinusX1 <mcoctav@gmail.com> 1689302544 +0100	pull: Fast-forward
.git/logs/refs/heads/main:363d0dbf5bfde7a736441a360ef6c7fe85544402 c7285a0e2b0c11bd8351f13857b26635c19e55ca circinusX1 <mcoctav@gmail.com> 1690911741 +0100	commit: r-pi some fixes
.git/logs/refs/heads/main:c7285a0e2b0c11bd8351f13857b26635c19e55ca 3830aaeae63c8c2271dfaec49fc4b4b5d9db1174 circinusX1 <mcoctav@gmail.com> 1690911889 +0100	commit (merge): r-pi some fixes
.git/logs/refs/heads/main:3830aaeae63c8c2271dfaec49fc4b4b5d9db1174 ba370871057d19f07c947272ec14573d3de787c8 circinusX1 <mcoctav@gmail.com> 1690916301 +0100	pull: Fast-forward
.git/logs/refs/heads/main:ba370871057d19f07c947272ec14573d3de787c8 5f372b9d281226e79f1936e9f46c7daaa47a7f6e circinusX1 <mcoctav@gmail.com> 1694812514 +0100	pull: Fast-forward
.git/logs/refs/remotes/origin/main:64f10933a3a79636e1128e2ae6adfbcda0257c9b a9cf25ad7caf82b5e4153633fe16bfa042d633c2 circinusX1 <mcoctav@gmail.com> 1650921061 +0100	pull: fast-forward
.git/logs/refs/remotes/origin/main:9c7c9deaa51cece507351583fde8ab2d5aa90076 d6efb55f0186a2d66476dd7db21320a314847978 circinusX1 <mcoctav@gmail.com> 1655214775 +0100	pull: fast-forward
.git/logs/refs/remotes/origin/main:d6efb55f0186a2d66476dd7db21320a314847978 9aba1d465d57003ede9b1a4cbdf5fc8c9b0d6117 circinusX1 <mcoctav@gmail.com> 1655245525 +0100	pull origin: fast-forward
.git/logs/refs/remotes/origin/main:9aba1d465d57003ede9b1a4cbdf5fc8c9b0d6117 55fb9972303fe52bc91c7ce1ab1f672744d730cc circinusX1 <mcoctav@gmail.com> 1655777872 +0100	pull: fast-forward
.git/logs/refs/remotes/origin/main:55fb9972303fe52bc91c7ce1ab1f672744d730cc fc52244d6c7bbf5a919cfc52628b7ee9e4ee0378 circinusX1 <mcoctav@gmail.com> 1658683292 +0100	pull origin: fast-forward
.git/logs/refs/remotes/origin/main:fc52244d6c7bbf5a919cfc52628b7ee9e4ee0378 cd0acfe7e617a33cd79597b8dad399fd81bb08b9 circinusX1 <mcoctav@gmail.com> 1689183474 +0100	pull: fast-forward
.git/logs/refs/remotes/origin/main:cd0acfe7e617a33cd79597b8dad399fd81bb08b9 363d0dbf5bfde7a736441a360ef6c7fe85544402 circinusX1 <mcoctav@gmail.com> 1689302517 +0100	pull: fast-forward
.git/logs/refs/remotes/origin/main:363d0dbf5bfde7a736441a360ef6c7fe85544402 ea28283a777de46cab145185e91f2d8adec6dc0a circinusX1 <mcoctav@gmail.com> 1690911780 +0100	pull: fast-forward
.git/logs/refs/remotes/origin/main:3830aaeae63c8c2271dfaec49fc4b4b5d9db1174 ba370871057d19f07c947272ec14573d3de787c8 circinusX1 <mcoctav@gmail.com> 1690916301 +0100	pull: fast-forward
.git/logs/refs/remotes/origin/main:ba370871057d19f07c947272ec14573d3de787c8 5f372b9d281226e79f1936e9f46c7daaa47a7f6e circinusX1 <mcoctav@gmail.com> 1694812514 +0100	pull: fast-forward
.git/FETCH_HEAD:3d0d8a0a225e4834383bdff24b835cf77aca2dcd	not-for-merge	branch 'camwitmotion' of https://github.com/circinusX1/lili
Binary file .git/objects/f9/df398a271e5c08fe37d1b2f807e956361d50cf matches
Binary file .git/objects/ee/c115b5f0fbba0224960b023b0cd8606572b247 matches
Binary file .git/objects/ee/33ab4be7b7e8f07f5d4c2a5f1e9ba2a5f23b05 matches
Binary file .git/objects/ee/c203281af940ab88c8c48f751c954cae9edf11 matches
Binary file .git/objects/a4/ef89208c4a5e3f560eef27db9a452f72cce6d7 matches
Binary file .git/objects/6e/bde1f3c82c0c8a0c36f55753a58fc66558fd97 matches
Binary file .git/objects/a8/41a442a64da5b16b96ebd6952065950c21546d matches
Binary file .git/objects/a8/73db3cfe0deeda897e31a1011b8648d5b4572e matches
Binary file .git/objects/a8/478fea98f1fb1ebc9b6537c9a30db11954f354 matches
Binary file .git/objects/8e/87ab410c37875cdf5055a5949925a866e0d54f matches
Binary file .git/objects/8e/590b48399c63a30b748500159f47dbbefe86f3 matches
Binary file .git/objects/e5/fc4a02f2ea6414ee86002624a9a954b37804da matches
Binary file .git/objects/af/d1c19bf786295fb80f46899b9941554320a268 matches
Binary file .git/objects/58/d230d48c0595b3f31644ad1555ee808aa223ae matches
Binary file .git/objects/58/2c99c43bb1b07ef1985b70935b9cabbb75c7b2 matches
Binary file .git/objects/58/5c87d81ef41e96a380c2806efbad569b1f7f74 matches
Binary file .git/objects/40/d7ef1940ba91ea43114e38b98dd37f4ffacdeb matches
Binary file .git/objects/40/4807f1631cbca003f4794018b89f581e12259d matches
Binary file .git/objects/e9/d3fd254902f0becaf8181f7f4c842133dcd18b matches
Binary file .git/objects/8a/8efc8056451b92ac3d05fbbca2a3467edaf7b8 matches
Binary file .git/objects/ed/60572cfaea11213e0f7bc2f22052295d9b1650 matches
Binary file .git/objects/ed/b7cda0c262cc95bffcf855b0c55f8d5a64afe6 matches
Binary file .git/objects/47/8bb1a20dcc0f29d4bcb9d72abaad8ffdcb3213 matches
Binary file .git/objects/47/281a6ba467b22c47474b85b36fa4da8a68cb16 matches
Binary file .git/objects/47/e6f365e6b5e078934d7e9bcdfbf2d595bb446c matches
Binary file .git/objects/d9/4663f90b381a9e5219b3711d877d19dae0ce60 matches
Binary file .git/objects/41/a9dc8cd86d14990e8e5282cd9cd0c1c078f1c1 matches
Binary file .git/objects/41/74ba5e302f77f8a154b98c1a8ab98ade605fe1 matches
Binary file .git/objects/f1/dbccf2aafc873f4c3449564653367a476ed4b1 matches
Binary file .git/objects/e8/57d9570073bd2c27b3a60168fe9ae75f33ebc2 matches
Binary file .git/objects/3a/09d59327c365a3059c2ad33b424ad8899b3fad matches
Binary file .git/objects/3a/5e1a6ed6e9b7f062391e35ab8834ba3ce63c5a matches
Binary file .git/objects/b2/35abf805e678c017a5ef166952f6f50f45b2da matches
Binary file .git/objects/b2/e06d3cd911c31cce9e4a8a94790a6d41025843 matches
Binary file .git/objects/b2/c9380a410dfc9a43a4c64e03007c9b4e66d65e matches
Binary file .git/objects/a7/28945563c2da5cd8961863424e4a719062b622 matches
Binary file .git/objects/ef/4877f2d25ac527056977e9504ee38eb50053b7 matches
Binary file .git/objects/cc/85461ac11a0a6251e09e58bec659bd21421c82 matches
Binary file .git/objects/cc/d6ab1a9809e4e9194564234e3e535f9ceeccee matches
Binary file .git/objects/38/43c9264bd82bb1c94607dd5eac4034bd137e2a matches
Binary file .git/objects/94/8b62c1ee24bb85d9cb38966fc3e977ab22acab matches
Binary file .git/objects/53/9d1d747c6de5cc8b0425fb2cf00a55903851cf matches
Binary file .git/objects/c7/a82b7d066cf94a0debeb6c049ae7b1cdf7335f matches
Binary file .git/objects/c7/285a0e2b0c11bd8351f13857b26635c19e55ca matches
Binary file .git/objects/aa/dcc5c4f693ac70cef8348958624bf3c379b0fc matches
Binary file .git/objects/46/89cc98049373afaa43107ea499e780e06cf571 matches
Binary file .git/objects/28/fc622af07eafbaad4a47a63b78e463dbed5a59 matches
Binary file .git/objects/28/8c84599aa65681d1001423bd53633c38b0f80a matches
Binary file .git/objects/92/59b566c4cf2f0771f822fc8106ee8457aa6a59 matches
Binary file .git/objects/92/00eb85eff63756b14adc365148682d15da9df5 matches
Binary file .git/objects/8d/095c9b060281be298e5565b2b57e100f8f39ef matches
Binary file .git/objects/8d/a427e0f355ce96f683fce4c8c5be717d4c1dcc matches
Binary file .git/objects/6a/8b0d58f90a102929412ba3531d8f42d1e60330 matches
Binary file .git/objects/6a/de80a4f78219d4db44181c67ee8b86a6d22443 matches
Binary file .git/objects/b9/c28cc9a54ffacc70da1ad9693764350cc6e8b2 matches
Binary file .git/objects/c4/1251d549d38cb4ea3f799199b4220ce55496af matches
Binary file .git/objects/54/a3a49974b4f93c4a9b76525ff8dd72d18bb071 matches
Binary file .git/objects/b3/bf161c0a035a5f1768874b3ceddb059e53fa01 matches
Binary file .git/objects/b3/a1e4c811e5765b7ead1dd2011b6501723dd2b9 matches
Binary file .git/objects/60/1f5c87100a9aabe4719f74b8783352a6499451 matches
Binary file .git/objects/60/b49506cbcc40aa372ca282feaa2b09f9807852 matches
Binary file .git/objects/14/046f5f6cad35831f4dde8d66990df61f66d4d2 matches
Binary file .git/objects/c9/1ee01352693575b5a8dc0a509aa9a7d17e3923 matches
Binary file .git/objects/9d/d1816ed208b8f2f6a341743d0390332413612c matches
Binary file .git/objects/b7/e626c56801c3e5a24599282c9aea9ba0309394 matches
Binary file .git/objects/b7/f7239e2978ff4c1c7bb6ae39648017eb05080c matches
Binary file .git/objects/73/b919f71b88e6872fc234d3ef19d835f353c900 matches
Binary file .git/objects/73/ae9201d0306c58e0e93c16dd5ddc49ab4b4ad9 matches
Binary file .git/objects/30/dddb20af4dce930f3eb17846c496498c9d054e matches
Binary file .git/objects/03/e25c87807c63c1e7cc8fa6886fb5f9fd3318cb matches
Binary file .git/objects/3c/4af2d1942e9cd51111ef65b66e48bfdea9169e matches
Binary file .git/objects/43/f5782b518333aca5d7b97cd275a178b53c77a8 matches
Binary file .git/objects/76/ff9efcf73425ef6f10d5bb65520e7b4268b421 matches
Binary file .git/objects/70/171dd061f8462f240b42b11c8ce5cf26e935c0 matches
Binary file .git/objects/4d/4413422d80672fe261cee47b020e1d37e702bc matches
Binary file .git/objects/4d/aac5886f13c6e146cd3bac608f0a6cf3736277 matches
Binary file .git/objects/fc/f511c291e83def4193ed8a158bd5b8afe38ed5 matches
Binary file .git/objects/69/a537e7ebbe9340d7cadb264c18424f842331d7 matches
Binary file .git/objects/62/75526829cfa109ebf6e916f31211442612d0bf matches
Binary file .git/objects/90/e9d07f07d7e133a8435f813fd20ef2d3008406 matches
Binary file .git/objects/0f/c1fb6feb0aafee9222cf16a8d0fc75ead6f7fc matches
Binary file .git/objects/cf/8c7746cb0e55b3cb52c62602c56cd34800169b matches
Binary file .git/objects/cf/8d2f832e30d50dadb35122ab8c35cfc445e025 matches
Binary file .git/objects/96/6ffb641a3a4639f79b5dceb5f57ad41b77271c matches
Binary file .git/objects/6b/6ece8fe0e58934347c162f2c43fd05a9a3b413 matches
Binary file .git/objects/bb/44ea2693ffb6cb37eeda00b3d09703a5713d21 matches
Binary file .git/objects/ba/d7d266f4c87c1fd3309403372d239939606850 matches
Binary file .git/objects/ba/8e086a04965c1852338a4b74f2a7459c42601f matches
Binary file .git/objects/87/78f7a9be41a50d0033c72956716570ef2abc8b matches
Binary file .git/objects/79/712bcebff850973591af4bde82903b523251c7 matches
Binary file .git/objects/79/7ac95c3b64b7484256838497dff148c5cefe08 matches
Binary file .git/objects/79/418a8de0ad08274ad09cf2375b5872ac34abac matches
Binary file .git/objects/b6/ef0191424238b471d7c875e620c3777dd00a29 matches
Binary file .git/objects/13/2d894c9513c286f0bd2c89f375f9aed723e6d2 matches
Binary file .git/objects/b5/0b960c8837ccbd283223ca05f85a2b1d135367 matches
Binary file .git/objects/c6/7ab1ad9962b0c4a87ce3c316ef98566d3a19ef matches
Binary file .git/objects/c6/3c39684ee7037c8d33da6a8fd9b31e8c54e12f matches
Binary file .git/objects/c6/7fa94f9e1e297af74fdf29f80227a4f717c33b matches
Binary file .git/objects/d8/a250aa18a03e14dd2a367294818e206fb570c3 matches
Binary file .git/objects/d8/69a438ca5550040738a4d9b47ad6e17794a601 matches
Binary file .git/objects/67/7581f7bc11ca18ba05ac71b071d5ed768d3f10 matches
Binary file .git/objects/67/3e373fe3e65e10fef3b782014792f793d9f813 matches
Binary file .git/objects/e3/39a42a8786441c0e9bdf18640b05ba1b7f4c7c matches
Binary file .git/objects/7d/3da897a07dff7c02a7e08cbfa374816670a74b matches
Binary file .git/objects/7d/a613f1419501ea7ae4a6d475b6f2d8e293b78b matches
Binary file .git/objects/7d/e8f0bdabc88d5c8880f80d230faee11d52e30f matches
Binary file .git/objects/1c/5c2db18f0cb7553ccf180c77140f655a69e966 matches
Binary file .git/objects/1c/9ae83cad401e5e70970b86ee99c9c285f7a835 matches
Binary file .git/objects/25/adeb8b67785d52aa6296637c1fa5ac7a7fc991 matches
Binary file .git/objects/7b/ba12bbcb80e211680c962d059f53c808c0eb1a matches
Binary file .git/objects/65/1485c9d2fb781b1e208c7c3c615619c9d53b66 matches
Binary file .git/objects/65/a01133cf4042a84e529bcd762c1c1381843943 matches
Binary file .git/objects/bd/faec4f6c356dd8138b833ffdf839546644cbef matches
Binary file .git/objects/33/7f4a059c1796c9b5a299ac1fbb4a11b54a534c matches
Binary file .git/objects/fd/a0359f1ad99d2df9d80bf5b5710f566e8ce9d8 matches
Binary file .git/objects/fd/5e3ab1914ff474c6cd1dc3a3c15acf67f5f12a matches
Binary file .git/objects/fd/9ec7900cea585e0e8d14f4ff2ae9764d2315de matches
Binary file .git/objects/f4/79c2eee6f3c0ca6e347f215c2d4f7fcc1d2a9d matches
Binary file .git/objects/f4/dbdb5d621b82f916a69d8251f74757003a9029 matches
Binary file .git/objects/1e/bf78c4e78a58e8aeecb680e10844b6dcc1b3f6 matches
Binary file .git/objects/a9/cf25ad7caf82b5e4153633fe16bfa042d633c2 matches
Binary file .git/objects/91/3d789b7f1b4eb20674d0894e0b62d82ae5e634 matches
Binary file .git/objects/db/fa1f19b5f97b68f0d3551b99f09202748f7216 matches
Binary file .git/objects/db/36924820065f6d9ca11903a4859717bdaeef8b matches
Binary file .git/objects/ad/5dbaeb3b0061c4bed7cf3ca1f1247cece89a53 matches
Binary file .git/objects/ad/87dd075219f31ce0e41a82dff1b9f0c5642c2d matches
Binary file .git/objects/ad/4fed755ab2ba426f9bc840fee941a2f422d721 matches
Binary file .git/objects/pack/pack-ae390a8368bcc8a5483dea52d9ef90f0e9dd19af.idx matches
Binary file .git/objects/pack/pack-d3809d883a0ab5890b8533a10c4d231e52c521d1.idx matches
Binary file .git/objects/pack/pack-d3809d883a0ab5890b8533a10c4d231e52c521d1.pack matches
Binary file .git/objects/pack/pack-ae390a8368bcc8a5483dea52d9ef90f0e9dd19af.pack matches
Binary file .git/objects/cb/314d6748d0b99fe25a1d1135766d692b1ee375 matches
Binary file .git/objects/a6/2f65a156ab9117d05126b75c41b84873c2043f matches
Binary file .git/objects/f7/947afbc0eae5274dd43cdd87bae3ce7983eec8 matches
Binary file .git/objects/f7/50c35940b5b4d5e77cb0d3db10965c8ac403ed matches
Binary file .git/objects/34/41f1ac104869d2c7e5d1bdd41924a5446a8036 matches
Binary file .git/objects/95/4a74fa52dd1b87f8316bc6eb0e7007563faf53 matches
Binary file .git/objects/1a/3bba879b636c1e4973aa3b977e40e2d68d0f78 matches
Binary file .git/objects/1a/9acedf82df8edbbdb507a78122ba813ce0de7b matches
Binary file .git/objects/1a/35500ea409808ff9e5aa652120cb17cfbd8232 matches
Binary file .git/objects/1a/0b5ad4eefc735ad177606bb66f004a16b86786 matches
Binary file .git/objects/f3/1aad6563e90699f74014050156f94983c37b58 matches
Binary file .git/objects/74/8ffb69c9505f67c8bfe82ee19391a9ac0a268f matches
Binary file .git/objects/08/28c90e2e5a3d5b984c08512c3101a5d1ac9f0d matches
Binary file .git/objects/55/fb9972303fe52bc91c7ce1ab1f672744d730cc matches
Binary file .git/objects/55/76a0f3240a977d364fcd824a06ac7dfedd56e3 matches
Binary file .git/objects/b8/f01b2a3146bb27baa2dc112b3b25fdc129f55c matches
Binary file .git/objects/b8/733cc15c45157feca6f9ca77e1a6f306514356 matches
Binary file .git/objects/1b/57ae5afcb59d1c160a46d344f73035d9702b68 matches
Binary file .git/objects/11/eb18ff83e0c290693c69f885db126f38201959 matches
Binary file .git/objects/29/cdd76019c9ed537802a52ebc10a14e423cdbf7 matches
Binary file .git/objects/cd/670179392323bf7b113e93841d9853d5d916b5 matches
Binary file .git/objects/cd/f79f5beac424390aef631ac2f4900b28d7e8c7 matches
Binary file .git/objects/cd/6edddbeb853168d0a8e6190328f170b4abecc6 matches
Binary file .git/objects/cd/0acfe7e617a33cd79597b8dad399fd81bb08b9 matches
Binary file .git/objects/cd/e8835afd642e8dbc48084da9b279b8cedf0c4d matches
Binary file .git/objects/1f/39ce852bb7e37eb8d043d349a01847ea0a1952 matches
Binary file .git/objects/1f/6dc928f3288827bf1adf54d3c7a1e35801a7c2 matches
Binary file .git/objects/f5/ec0a5edbf2d1f610ef47cdc86b0ac09a7b711a matches
Binary file .git/objects/f5/388ba31848666f592e8f5ecabcc95972cd3a7d matches
Binary file .git/objects/f0/2775a3fb7fca1f86d3b3cae1fab91109361424 matches
Binary file .git/objects/ae/296e8530df2f3ed77a8a4cc7376b83b56bf1cf matches
Binary file .git/objects/5b/520ca5e909950b4e930c28caf08b4cb208646d matches
Binary file .git/objects/e4/cf83d1af83c8b26477ebfcf90049195734948b matches
Binary file .git/objects/35/5b0ec911e034db7679b7291e135d4a94ee90dd matches
Binary file .git/objects/35/44994b5ba68e31bc704746dc219bdd2a1ebb30 matches
Binary file .git/objects/9b/f6d27c0df32daf9144862b9289f1225a6cf3b3 matches
Binary file .git/objects/dd/a71752b6f8c77b9a4d660194a20d0f5b6209ca matches
Binary file .git/objects/31/03ef3f950829e58229c004dd8fb691bd2be7e8 matches
Binary file .git/objects/09/33e0d40ee9bd59f4eb1ce179492968f7de1da5 matches
Binary file .git/objects/09/800d6ae4e4afe88f45bdba5da9a10ab8bcdc1d matches
Binary file .git/objects/32/68934a5ba517444da280bd24d75e309695b4b9 matches
Binary file .git/objects/5c/e833aa0c2a80461a5994cc68f59573c175eb14 matches
Binary file .git/objects/36/3d0dbf5bfde7a736441a360ef6c7fe85544402 matches
Binary file .git/objects/ea/8f79c7b6e403438c3a0bde643743afc169637d matches
Binary file .git/objects/ea/bfce9a550e409f199be51e42493fb0d2cf9c73 matches
Binary file .git/objects/ea/28283a777de46cab145185e91f2d8adec6dc0a matches
Binary file .git/objects/c5/77a188ec32cb88c55f5123f5f4841b68c0e3d0 matches
Binary file .git/objects/c5/97df8c32163395a4a273600f006f4a99a5bcf9 matches
Binary file .git/objects/05/64380dfa4f6545bfeb13b64ed0ed046c701833 matches
Binary file .git/objects/be/5e0645179ee377095afbe7918646cb6033147f matches
Binary file .git/objects/ec/16caf770b4ec7a9cf64557b399790a0e27f81c matches
Binary file .git/objects/ec/9317f19173dc01a402853f53eca9ebd33f2558 matches
Binary file .git/objects/63/e6b3eb266d53b287798150252f85e4e8c9bd58 matches
Binary file .git/objects/63/b431998c3a4ea3cb013fee6f36bdb3fa468202 matches
Binary file .git/objects/c0/0708f027c20d0182b961490a0dd907c3d467e5 matches
Binary file .git/objects/07/8755ed89c225d865cef93bd1e23f28fa1baabb matches
Binary file .git/objects/83/2497dd4aeef89a2197347da0a8934a302d5f8d matches
Binary file .git/objects/49/eac6cea41d5cd052830f33608c2c251e527cf3 matches
Binary file .git/objects/c8/e882c3ae238bed94617de76ffe6c9a18f482eb matches
Binary file .git/objects/3e/ea92b90ec0b24c60816ba7a74126f32d9f928e matches
Binary file .git/objects/3e/c1a93b8b8a6af797958f0cd2c0f38e05d7bd6d matches
Binary file .git/objects/4f/5f67e74ca0443fbc1310d91b23704a336db664 matches
Binary file .git/objects/4f/cf6e8a182860c9847d03796d2786c72446c2af matches
Binary file .git/objects/4f/d634baf83acd7a1d46696e96132cd976b0aa0f matches
Binary file .git/objects/27/299bab948ba3118ec2143c62717d1e3adee9cb matches
Binary file .git/objects/0a/f15b7ebf4e0b222338a32e30ff8a689b820d77 matches
Binary file .git/objects/f2/b810ef80cdefcc0f25341c54fe61be03cb9612 matches
Binary file .git/objects/f2/743cb97af8463603098c46e090693c572aeb2e matches
Binary file .git/objects/24/27549fd7f664f226edc766c0c8d5781f5abd9f matches
Binary file .git/objects/24/f4936dd56c674f5e1528a340c727802e61fce7 matches
Binary file .git/objects/50/b824b1992eabace02bff4d57de6b3e00b79786 matches
Binary file .git/objects/ac/1fa25bc89c9b9fd31e1cc0a36453e71a9a2ee6 matches
Binary file .git/objects/ac/04e810394eb0b8c84d29367aa20bb8f019b21b matches
Binary file .git/objects/5d/8e4d5b7d385eade9fcb693de30af37aad9aba6 matches
Binary file .git/objects/9c/7c9deaa51cece507351583fde8ab2d5aa90076 matches
Binary file .git/objects/de/7e8464356652551d0bd6f6e00c4cad7336e691 matches
Binary file .git/objects/e0/146c4a359fb1c7f45fac7eaf6f7a88945a08d6 matches
Binary file .git/objects/e0/3b9d52b892f5085674febb62b02b5cbdf33acd matches
Binary file .git/objects/bc/54e6a9b22bf83256362382847bf7dd1afc870b matches
Binary file .git/objects/80/6c1e61ae2f1ff7e4efa69193ef64ae31c2ea3d matches
Binary file .git/objects/7f/3d562a2085558b1908473f0b1825087fc87998 matches
Binary file .git/objects/7f/755b8dd105c9ea4f3a3c1e4292883c2ccd87ba matches
Binary file .git/objects/d2/f74ed70fed53a0a02240a9f610dc0ff6205752 matches
Binary file .git/objects/4a/fac8e39b73f0d5c082e0072eeac337d1b1db9f matches
cbconf.h:            paka->_parent = this;
cbconf.h:            this->_values.push_back(paka);
cbconf.h:            this->_type = Node::eNODE;
cbconf.h:            this->_values.push_back(pn);
cbconf.h:                if(a->_name==key){
cbconf.h:                    if(a->_values.size()==1 && a->_values[0]->_name[0]=='@')
cbconf.h:                        const Node* pn = _get_ref(this, a->_values[0]->_name,  idx);
cbconf.h:                    assert(this->_name!=key);
cbconf.h:                        pn=pn->_parent;
cbconf.h:                            pn=pn->_root();
cbconf.h:                            pn=pn->_at(ev);
cbconf.h:            pn = pn->_at(ev);
cbconf.h:                    v = _values[index]->_name;
cbconf.h:                    v = _values[0]->_name;
cbconf.h:                    if(pn->_values.size()>dx)
cbconf.h:                        return pn->_values[dx]->_name;
cbconf.h:        bool exist()const {return this->_values.size()>0;}
cbconf.h:            while(pn->_parent)
cbconf.h:                pn=pn->_parent;
cbconf.h:                if(a->_name==s){
cbconf.h:        return _pnode->operator[](key);
cbconf.h:                Cbdler::_ilast_line = line-1;
cbconf.h:                            root->add(curent);
cbconf.h:                            curent->_parent = root;
cbconf.h:                        paka->_name=_string;
cbconf.h:                        paka->_parent = parent;
cbconf.h:                            parent->_values.push_back(paka);
cbconf.h:                            if(!paka->_name.empty())
cbconf.h:                                if(paka->_name=="%include")
cbconf.h:                                            Node* prent = paka->_parent ? paka->_parent : _pnode;
cbconf.h:                                            prent->_del_node(paka);
cbconf.h:                                            pn->_parent = prent;
cbconf.h:                                            prent->add(pn);
cbconf.h:                                        paka->store_it(_string);
cbconf.h:                                    paka->store_it(_string);
cbconf.h:                        paka = paka->_parent;
cbconf.h:                        --oc;
cbconf.h:                        paka->store_it(_string);
cbconf.h:            _pnode->_parent = _pnode;
cbconf.h:        TRACE()  << p->_name.c_str();
cbconf.h:        if(p->_values.size())
cbconf.h:            for(const auto& a : p->_values)
cbconf.h:        --depth;
avlibrtsp.h://-lavdevice -lavformat -lavcodec -lavutil ? no need, we link dynamically
webcast.cpp:        std::string sys = "mkdir -p ";
webcast.cpp:    this->signal_to_stop();
webcast.cpp:    this->stop_thread(); delete[] _send_buf;
webcast.cpp:            ph->index    = _frmidx++;
webcast.cpp:            ph->wh[0]    = imgsz.x;
webcast.cpp:            ph->wh[1]    = imgsz.y;
webcast.cpp:            ph->len      = len;
webcast.cpp:            ph->event    = event;
webcast.cpp:            ph->format   = eift;
webcast.cpp:            ph->magic    = _magic;
webcast.cpp:            ph->insync   = _insync;
webcast.cpp:            ::strncpy(ph->camname,name.c_str(),sizeof(LiFrmHdr::camname));
webcast.cpp:                if(now-_last_frame > _cacheintl &&
webcast.cpp:    if(ph->event.predicate & EVT_KEEP_ALIVE)
webcast.cpp:        TRACE()<< "caching frame [][][]"<< ph->index <<"\n";
webcast.cpp:        nfn += ".cac-";
webcast.cpp:    while(!this->osthread::is_stopped() && __alive)
webcast.cpp:        if(time(0)-_ctime > _pool_intl  || hasevents )
webcast.cpp:            TRACE()<< "Go streaming ----- \n";
webcast.cpp:            TRACE()<< "Done streaming ----- \n";
webcast.cpp:        _lastlen = sizeof(LiFrmHdr) * ph->len + 16384;
webcast.cpp:                if(ph->len)
webcast.cpp:                    by = _send_buf_do(ph, _frame.img(iframe), ph->len);
webcast.cpp:                ph->len = 0;
webcast.cpp:        if (entry->d_name[0]=='.') continue;
webcast.cpp:        if (!::strstr(entry->d_name,"cac-")) continue;
webcast.cpp:        std::string fp = _cachedir + entry->d_name;
webcast.cpp:            std::pair<time_t, std::string> p(dt, std::string(entry->d_name));
webcast.cpp:                std::string  ffn = _cachedir + it->second;
webcast.cpp:                            TRACE()<< "-->sending cached frame: "<< hdr.index << ", len:" <<
liveimage.sample_konf:    # only if /usr/lib/x86_64-linux-gnu/lib_av.so  is provided.
liveimage.sample_konf:            lib_av           {/usr/lib/x86_64-linux-gnu/libav}   # If you use a RTSP cam
liveimage.sample_konf:            digo-snap
liveimage.sample_konf:           digoo-rtsp
liveimage.sample_konf:           rpi-rtsp
liveimage.sample_konf:                #name            {rpirpi}                        # a R-PI rtsp camera for tsting. experimental.
liveimage.sample_konf:                on_event        {webcast,record,~force,~save}     #  force->save no mater of events
jpeger.h:    First Release: September 16 - 29 2016
camevents.h:    int _darkaverage()const{return _mt ?  _mt->darkav() : 0;}
sock.h:    # Copyright (C) 2007-2015 s(mariuschincisan@gmail.com) - coinscode.com - N/A
sock.h:    # http://www.apache.org/licenses/LICENSE-2.0
sock.h:    //---------------------------------------------------------------------------------------
sock.h:    //---------------------------------------------------------------------------------------
sock.h:    //---------------------------------------------------------------------------------------
sock.h:    //---------------------------------------------------------------------------------------
sock.h:    //---------------------------------------------------------------------------------------
sock.h:    //---------------------------------------------------------------------------------------
sock.h:           ::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));
sock.h:           ::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));
sock.h:            ::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));
sock.h:        void commit(){::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));}
sock.h:                int msk = pow(2,atoi(pm))-1;
sock.h:           ::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));
sock.h:                ::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));
sock.h:                int msk = pow(2,bits)-1;
sock.h:            ::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));
sock.h:    //---------------------------------------------------------------------------------------
sock.h:        int             detach(){int s = _thesock; _thesock=-1; return s;}
sock.h:    //---------------------------------------------------------------------------------------
sock.h:    //---------------------------------------------------------------------------------------
sock.h:    //---------------------------------------------------------------------------------------
sock.h:    //---------------------------------------------------------------------------------------
sock.h:    //---------------------------------------------------------------------------------------
sock.h:                                err_ == -1
CImg.h: #  Licenses        : This file is 'dual-licensed', you have to choose one
CImg.h: #                    CeCILL-C
CImg.h: #                    The CeCILL-C license is close to the GNU LGPL.
CImg.h: #                    ( http://cecill.info/licences/Licence_CeCILL-C_V1-en.html )
CImg.h: #                    ( http://cecill.info/licences/Licence_CeCILL_V2.1-en.html )
CImg.h: #  This software is governed either by the CeCILL or the CeCILL-C license
CImg.h: #  the CeCILL or CeCILL-C licenses as circulated by CEA, CNRS and INRIA
CImg.h: #  professionals having in-depth computer knowledge. Users are therefore
CImg.h: #  knowledge of the CeCILL and CeCILL-C licenses and that you accept its terms.
CImg.h:/*-----------------------------------------------------------
CImg.h: # Test and possibly auto-set CImg configuration variables
CImg.h: ------------------------------------------------------------*/
CImg.h:// This is the minimal set of required headers to make CImg-based codes compile.
CImg.h://                      '1' for a Unix-like OS (Linux, Solaris, BSD, MacOSX, Irix, ...).
CImg.h://                      (auto-detection is performed if 'cimg_OS' is not set by the user).
CImg.h:#error (correct values are '0 = unknown OS', '1 = Unix-like OS', '2 = Microsoft Windows').
CImg.h:// Include OS-specific headers.
CImg.h:// Define 'cimg_use_vt100' to allow output of color messages on VT100-compatible terminals.
CImg.h:// advantages of multi-core CPUs.
CImg.h://                           '1' to use the X-Window framework (X11).
CImg.h:#error (should be { 0=none | 1=X-Window (X11) | 2=Microsoft GDI32 }).
CImg.h:// Include display-specific headers.
CImg.h:// Board library may be used to draw 3D objects in vector-graphics canvas
CImg.h:#pragma GCC diagnostic ignored "-Wdeprecated"
CImg.h:#pragma GCC diagnostic ignored "-Wdeprecated-copy"
CImg.h:#pragma GCC diagnostic ignored "-Wshadow"
CImg.h:// TinyEXR is a small, single header-only library to load and save OpenEXR(.exr) images.
CImg.h:/*------------------------------------------------------------------------------
CImg.h:  # Define user-friendly macros.
CImg.h:  ------------------------------------------------------------------------------*/
CImg.h:  int _n1##x = x<(img).width() - 1?x + 1:(img).width() - 1, \
CImg.h:      _n1##y = y<(img).height() - 1?y + 1:(img).height() - 1
CImg.h:  int _p1##x = x>1?x - 1:0, \
CImg.h:      _p1##y = y>1?y - 1:0
CImg.h:  int _n2##x = x<(img).width() - 2?x + 2:(img).width() - 1, \
CImg.h:      _n2##y = y<(img).height() - 2?y + 2:(img).height() - 1
CImg.h:  int _p2##x = x>2?x - 2:0, \
CImg.h:      _p2##y = y>2?y - 2:0
CImg.h:  int _n3##x = x<(img).width() - 3?x + 3:(img).width() - 1, \
CImg.h:      _n3##y = y<(img).height() - 3?y + 3:(img).height() - 1
CImg.h:  int _p3##x = x>3?x - 3:0, \
CImg.h:      _p3##y = y>3?y - 3:0
CImg.h:  int _n4##x = x<(img).width() - 4?x + 4:(img).width() - 1, \
CImg.h:      _n4##y = y<(img).height() - 4?y + 4:(img).height() - 1
CImg.h:  int _p4##x = x>4?x - 4:0, \
CImg.h:      _p4##y = y>4?y - 4:0
CImg.h:  int _n1##z = z<(img).depth() - 1?z + 1:(img).depth() - 1
CImg.h:  int _p1##x = x>1?x - 1:0, \
CImg.h:      _p1##y = y>1?y - 1:0, \
CImg.h:      _p1##z = z>1?z - 1:0
CImg.h:#define cimg_rof(img,ptrs,T_ptrs) for (T_ptrs *ptrs = (img)._data + (img).size() - 1; ptrs>=(img)._data; --ptrs)
CImg.h:#define cimg_rofoff(img,off) for (cimg_long off = (cimg_long)((img).size() - 1); off>=0; --off)
CImg.h:#define cimg_rof1(bound,i) for (int i = (int)(bound) - 1; i>=0; --i)
CImg.h: for (int i = (int)(i0)<0?0:(int)(i0), _max##i = (int)(i1)<(int)(bound)?(int)(i1):(int)(bound) - 1; i<=_max##i; ++i)
CImg.h:#define cimg_for_insideX(img,x,n) cimg_for_inX(img,n,(img)._width - 1 - (n),x)
CImg.h:#define cimg_for_insideY(img,y,n) cimg_for_inY(img,n,(img)._height - 1 - (n),y)
CImg.h:#define cimg_for_insideZ(img,z,n) cimg_for_inZ(img,n,(img)._depth  - 1 - (n),z)
CImg.h:#define cimg_for_insideC(img,c,n) cimg_for_inC(img,n,(img)._spectrum - 1 - (n),c)
CImg.h:#define cimg_for_insideXY(img,x,y,n) cimg_for_inXY(img,n,n,(img)._width - 1 - (n),(img)._height - 1 - (n),x,y)
CImg.h:  cimg_for_inXYZ(img,n,n,n,(img)._width - 1 - (n),(img)._height - 1 - (n),(img)._depth - 1 - (n),x,y,z)
CImg.h:  cimg_for_inXYZ(img,n,n,n,(img)._width - 1 - (n),(img)._height - 1 - (n),(img)._depth - 1 - (n),x,y,z)
CImg.h:#define cimg_for_borderX(img,x,n) cimg_for_outX(img,n,(img)._width - 1 - (n),x)
CImg.h:#define cimg_for_borderY(img,y,n) cimg_for_outY(img,n,(img)._height - 1 - (n),y)
CImg.h:#define cimg_for_borderZ(img,z,n) cimg_for_outZ(img,n,(img)._depth - 1 - (n),z)
CImg.h:#define cimg_for_borderC(img,c,n) cimg_for_outC(img,n,(img)._spectrum - 1 - (n),c)
CImg.h:#define cimg_for_borderXY(img,x,y,n) cimg_for_outXY(img,n,n,(img)._width - 1 - (n),(img)._height - 1 - (n),x,y)
CImg.h:  cimg_for_outXYZ(img,n,n,n,(img)._width - 1 - (n),(img)._height - 1 - (n),(img)._depth - 1 - (n),x,y,z)
CImg.h: cimg_for_outXYZC(img,n,n,n,n,(img)._width - 1 - (n),(img)._height - 1 - (n), \
CImg.h:                  (img)._depth - 1 - (n),(img)._spectrum - 1 - (n),x,y,z,c)
CImg.h:      --_n1##y, _n1##x+=(_n1##x>>2) - ((!(_n1##x&3)?--y:((_n1##x&3)==1?(img)._width - 1 - ++x:\
CImg.h:      ((_n1##x&3)==2?(img)._height - 1 - ++y:--x))))?0:1)
CImg.h:      _dx=(x1)>(x0)?(int)(x1) - (int)(x0):(_sx=-1,(int)(x0) - (int)(x1)), \
CImg.h:      _dy=(y1)>(y0)?(int)(y1) - (int)(y0):(_sy=-1,(int)(y0) - (int)(y1)), \
CImg.h:      --_counter, x+=_steep? \
CImg.h:      (y+=_sy,(_err-=_dx)<0?_err+=_dy,_sx:0): \
CImg.h:      (y+=(_err-=_dy)<0?_err+=_dx,_sy:0,_sx))
CImg.h: for (int i = 0, _n1##i = 1>=(bound)?(int)(bound) - 1:1; \
CImg.h:      _n1##i<(int)(bound) || i==--_n1##i; \
CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1; \
CImg.h:      i<=(int)(i1) && (_n1##i<(int)(bound) || i==--_n1##i); \
CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1; \
CImg.h:      _n1##i<(int)(bound) || i==--_n1##i; \
CImg.h:      _p1##i = i - 1<0?0:i - 1, \
CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1; \
CImg.h:      i<=(int)(i1) && (_n1##i<(int)(bound) || i==--_n1##i); \
CImg.h: for (int i = 0, _p1##i = 0, _n1##i = 1>=(bound)?(int)(bound) - 1:1, \
CImg.h:      _n2##i = 2>=(bound)?(int)(bound) - 1:2; \
CImg.h:      _n2##i<(int)(bound) || _n1##i==--_n2##i || i==(_n2##i = --_n1##i); \
CImg.h:      _p1##i = i - 1<0?0:i - 1, \
CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1, \
CImg.h:      _n2##i = i + 2>=(int)(bound)?(int)(bound) - 1:i + 2; \
CImg.h:      i<=(int)(i1) && (_n2##i<(int)(bound) || _n1##i==--_n2##i || i==(_n2##i = --_n1##i)); \
CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1, \
CImg.h:      _n2##i = 2>=(bound)?(int)(bound) - 1:2; \
CImg.h:      _n2##i<(int)(bound) || _n1##i==--_n2##i || i==(_n2##i = --_n1##i); \
CImg.h:      _p2##i = i - 2<0?0:i - 2, \
CImg.h:      _p1##i = i - 1<0?0:i - 1, \
CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1, \
CImg.h:      _n2##i = i + 2>=(int)(bound)?(int)(bound) - 1:i + 2; \
CImg.h:      i<=(int)(i1) && (_n2##i<(int)(bound) || _n1##i==--_n2##i || i==(_n2##i = --_n1##i)); \
CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1, \
CImg.h:      _n2##i = 2>=(bound)?(int)(bound) - 1:2, \
CImg.h:      _n3##i = 3>=(bound)?(int)(bound) - 1:3; \
CImg.h:      _n3##i<(int)(bound) || _n2##i==--_n3##i || _n1##i==--_n2##i || i==(_n3##i = _n2##i = --_n1##i); \
CImg.h:      _p2##i = i - 2<0?0:i - 2, \
CImg.h:      _p1##i = i - 1<0?0:i - 1, \
CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1, \
CImg.h:      _n2##i = i + 2>=(int)(bound)?(int)(bound) - 1:i + 2, \
CImg.h:      _n3##i = i + 3>=(int)(bound)?(int)(bound) - 1:i + 3; \
CImg.h:      (_n3##i<(int)(bound) || _n2##i==--_n3##i || _n1##i==--_n2##i || i==(_n3##i = _n2##i = --_n1##i)); \
CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1, \
CImg.h:      _n2##i = 2>=(bound)?(int)(bound) - 1:2, \
CImg.h:      _n3##i = 3>=(bound)?(int)(bound) - 1:3; \
CImg.h:      _n3##i<(int)(bound) || _n2##i==--_n3##i || _n1##i==--_n2##i || i==(_n3##i = _n2##i = --_n1##i); \
CImg.h:      _p3##i = i - 3<0?0:i - 3, \
CImg.h:      _p2##i = i - 2<0?0:i - 2, \
CImg.h:      _p1##i = i - 1<0?0:i - 1, \
CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1, \
CImg.h:      _n2##i = i + 2>=(int)(bound)?(int)(bound) - 1:i + 2, \
CImg.h:      _n3##i = i + 3>=(int)(bound)?(int)(bound) - 1:i + 3; \
CImg.h:      (_n3##i<(int)(bound) || _n2##i==--_n3##i || _n1##i==--_n2##i || i==(_n3##i = _n2##i = --_n1##i)); \
CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1, \
CImg.h:      _n2##i = 2>=(bound)?(int)(bound) - 1:2, \
CImg.h:      _n3##i = 3>=(bound)?(int)(bound) - 1:3, \
CImg.h:      _n4##i = 4>=(bound)?(int)(bound) - 1:4; \
CImg.h:      _n4##i<(int)(bound) || _n3##i==--_n4##i || _n2##i==--_n3##i || _n1##i==--_n2##i || \
CImg.h:      i==(_n4##i = _n3##i = _n2##i = --_n1##i); \
CImg.h:      _p3##i = i - 3<0?0:i - 3, \
CImg.h:      _p2##i = i - 2<0?0:i - 2, \
CImg.h:      _p1##i = i - 1<0?0:i - 1, \
CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1, \
CImg.h:      _n2##i = i + 2>=(int)(bound)?(int)(bound) - 1:i + 2, \
CImg.h:      _n3##i = i + 3>=(int)(bound)?(int)(bound) - 1:i + 3, \
CImg.h:      _n4##i = i + 4>=(int)(bound)?(int)(bound) - 1:i + 4; \
CImg.h:      i<=(int)(i1) && (_n4##i<(int)(bound) || _n3##i==--_n4##i || _n2##i==--_n3##i || _n1##i==--_n2##i || \
CImg.h:      i==(_n4##i = _n3##i = _n2##i = --_n1##i)); \
CImg.h:       _n1##i = 1>=(int)(bound)?(int)(bound) - 1:1, \
CImg.h:       _n2##i = 2>=(int)(bound)?(int)(bound) - 1:2, \
CImg.h:       _n3##i = 3>=(int)(bound)?(int)(bound) - 1:3, \
CImg.h:       _n4##i = 4>=(int)(bound)?(int)(bound) - 1:4; \
CImg.h:       _n4##i<(int)(bound) || _n3##i==--_n4##i || _n2##i==--_n3##i || _n1##i==--_n2##i || \
CImg.h:       i==(_n4##i = _n3##i = _n2##i = --_n1##i); \
CImg.h:       _p4##i = i - 4<0?0:i - 4, \
CImg.h:       _p3##i = i - 3<0?0:i - 3, \
CImg.h:       _p2##i = i - 2<0?0:i - 2, \
CImg.h:       _p1##i = i - 1<0?0:i - 1, \
CImg.h:       _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1, \
CImg.h:       _n2##i = i + 2>=(int)(bound)?(int)(bound) - 1:i + 2, \
CImg.h:       _n3##i = i + 3>=(int)(bound)?(int)(bound) - 1:i + 3, \
CImg.h:       _n4##i = i + 4>=(int)(bound)?(int)(bound) - 1:i + 4; \
CImg.h:       i<=(int)(i1) && (_n4##i<(int)(bound) || _n3##i==--_n4##i || _n2##i==--_n3##i || _n1##i==--_n2##i || \
CImg.h:       i==(_n4##i = _n3##i = _n2##i = --_n1##i)); \
CImg.h:   1>=(img)._width?(img).width() - 1:1);  \
CImg.h:   x==--_n1##x; \
CImg.h:   x + 1>=(int)(img)._width?(img).width() - 1:x + 1); \
CImg.h:   x==--_n1##x); \
CImg.h:   1>=(img)._width?(img).width() - 1:1); \
CImg.h:   x==--_n1##x; \
CImg.h:   _p1##x = x - 1<0?0:x - 1, \
CImg.h:   x + 1>=(int)(img)._width?(img).width() - 1:x + 1); \
CImg.h:   x==--_n1##x);            \
CImg.h:   _n1##x = 1>=(img)._width?(img).width() - 1:1, \
CImg.h:   2>=(img)._width?(img).width() - 1:2); \
CImg.h:   _n1##x==--_n2##x || x==(_n2##x = --_n1##x); \
CImg.h:   _p1##x = x - 1<0?0:x - 1, \
CImg.h:   _n1##x = x + 1>=(int)(img)._width?(img).width() - 1:x + 1, \
CImg.h:   x + 2>=(int)(img)._width?(img).width() - 1:x + 2); \
CImg.h:   _n1##x==--_n2##x || x==(_n2##x = --_n1##x)); \
CImg.h:   _n1##x = 1>=(img)._width?(img).width() - 1:1, \
CImg.h:   2>=(img)._width?(img).width() - 1:2); \
CImg.h:   _n1##x==--_n2##x || x==(_n2##x = --_n1##x); \
CImg.h:   _p2##x = x - 2<0?0:x - 2, \
CImg.h:   _p1##x = x - 1<0?0:x - 1, \
CImg.h:   _n1##x = x + 1>=(int)(img)._width?(img).width() - 1:x + 1, \
CImg.h:   x + 2>=(int)(img)._width?(img).width() - 1:x + 2); \
CImg.h:   _n1##x==--_n2##x || x==(_n2##x = --_n1##x)); \
CImg.h:   _n1##x = 1>=(img)._width?(img).width() - 1:1, \
CImg.h:   _n2##x = 2>=(img)._width?(img).width() - 1:2, \
CImg.h:   3>=(img)._width?(img).width() - 1:3); \
CImg.h:   _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n3## x = _n2##x = --_n1##x); \
CImg.h:   _p2##x = x - 2<0?0:x - 2, \
CImg.h:   _p1##x = x - 1<0?0:x - 1, \
CImg.h:   _n1##x = x + 1>=(int)(img)._width?(img).width() - 1:x + 1, \
CImg.h:   _n2##x = x + 2>=(int)(img)._width?(img).width() - 1:x + 2, \
CImg.h:   x + 3>=(int)(img)._width?(img).width() - 1:x + 3); \
CImg.h:   _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n3## x = _n2##x = --_n1##x)); \
CImg.h:   _n1##x = 1>=(img)._width?(img).width() - 1:1, \
CImg.h:   _n2##x = 2>=(img)._width?(img).width() - 1:2, \
CImg.h:   3>=(img)._width?(img).width() - 1:3); \
CImg.h:   _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n3##x = _n2##x = --_n1##x); \
CImg.h:   _p3##x = x - 3<0?0:x - 3, \
CImg.h:   _p2##x = x - 2<0?0:x - 2, \
CImg.h:   _p1##x = x - 1<0?0:x - 1, \
CImg.h:   _n1##x = x + 1>=(int)(img)._width?(img).width() - 1:x + 1, \
CImg.h:   _n2##x = x + 2>=(int)(img)._width?(img).width() - 1:x + 2, \
CImg.h:   x + 3>=(int)(img)._width?(img).width() - 1:x + 3); \
CImg.h:   _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n3##x = _n2##x = --_n1##x)); \
CImg.h:   _n1##x = 1>=((img)._width)?(img).width() - 1:1, \
CImg.h:   _n2##x = 2>=((img)._width)?(img).width() - 1:2, \
CImg.h:   _n3##x = 3>=((img)._width)?(img).width() - 1:3, \
CImg.h:   4>=((img)._width)?(img).width() - 1:4); \
CImg.h:   _n3##x==--_n4##x || _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n4##x = _n3##x = _n2##x = --_n1##x); \
CImg.h:   _p3##x = x - 3<0?0:x - 3, \
CImg.h:   _p2##x = x - 2<0?0:x - 2, \
CImg.h:   _p1##x = x - 1<0?0:x - 1, \
CImg.h:   _n1##x = x + 1>=(img).width()?(img).width() - 1:x + 1, \
CImg.h:   _n2##x = x + 2>=(img).width()?(img).width() - 1:x + 2, \
CImg.h:   _n3##x = x + 3>=(img).width()?(img).width() - 1:x + 3, \
CImg.h:   x + 4>=(img).width()?(img).width() - 1:x + 4); \
CImg.h:   _n3##x==--_n4##x || _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n4##x = _n3##x = _n2##x = --_n1##x)); \
CImg.h:   _n1##x = 1>=((img)._width)?(img).width() - 1:1, \
CImg.h:   _n2##x = 2>=((img)._width)?(img).width() - 1:2, \
CImg.h:   _n3##x = 3>=((img)._width)?(img).width() - 1:3, \
CImg.h:   4>=((img)._width)?(img).width() - 1:4); \
CImg.h:   _n3##x==--_n4##x || _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n4##x = _n3##x = _n2##x = --_n1##x); \
CImg.h:   _p4##x = x - 4<0?0:x - 4, \
CImg.h:   _p3##x = x - 3<0?0:x - 3, \
CImg.h:   _p2##x = x - 2<0?0:x - 2, \
CImg.h:   _p1##x = x - 1<0?0:x - 1, \
CImg.h:   _n1##x = x + 1>=(img).width()?(img).width() - 1:x + 1, \
CImg.h:   _n2##x = x + 2>=(img).width()?(img).width() - 1:x + 2, \
CImg.h:   _n3##x = x + 3>=(img).width()?(img).width() - 1:x + 3, \
CImg.h:   x + 4>=(img).width()?(img).width() - 1:x + 4); \
CImg.h:   _n3##x==--_n4##x || _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n4##x = _n3##x = _n2##x = --_n1##x)); \
CImg.h:   1>=(img)._width?(img).width() - 1:1); \
CImg.h:   x==--_n1##x; \
CImg.h:   x + 1>=(int)(img)._width?(img).width() - 1:x + 1); \
CImg.h:   x==--_n1##x); \
CImg.h:   1>=(img)._width?(img).width() - 1:1); \
CImg.h:   x==--_n1##x; \
CImg.h:   _p1##x = x - 1<0?0:x - 1, \
CImg.h:   x + 1>=(int)(img)._width?(img).width() - 1:x + 1); \
CImg.h:   x==--_n1##x); \
CImg.h:#define cimglist_rof(list,l) for (int l = (int)(list)._width - 1; l>=0; --l)
CImg.h:  for (int l = (int)(l0)<0?0:(int)(l0), _max##l = (unsigned int)l1<(list)._width?(int)(l1):(int)(list)._width - 1; \
CImg.h:#define cimg_instance _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type()
CImg.h:/*------------------------------------------------
CImg.h: -------------------------------------------------*/
CImg.h:   \CImg-based programs with
CImg.h:      int result = -1;
CImg.h:      if (result==-1) result = _vscprintf(format,ap);
CImg.h:    // Mutex-protected version of sscanf, sprintf and snprintf.
CImg.h:    // Used only MacOSX, as it seems those functions are not re-entrant on MacOSX.
CImg.h:       - \c 0: Hide library messages (quiet mode).
CImg.h:       - \c 1: Print library messages on the console.
CImg.h:       - \c 2: Display library messages on a dialog window.
CImg.h:       - \c 3: Do as \c 1 + add extra debug warnings (slow down the code!).
CImg.h:       - \c 4: Do as \c 2 + add extra debug warnings (slow down the code!).
CImg.h:       The way openmp-based methods are handled by \CImg can be changed dynamically, using this function.
CImg.h:       - \c 0: Never parallelize.
CImg.h:       - \c 1: Always parallelize.
CImg.h:       - \c 2: Adaptive parallelization mode (default behavior).
CImg.h:  /*---------------------------------------
CImg.h:    --------------------------------------*/
CImg.h:      - \b CImgAbortException: Thrown when a computationally-intensive function is aborted by an external signal.
CImg.h:        This is the only \c non-derived exception class.
CImg.h:      - \b CImgArgumentException: Thrown when one argument of a called \CImg function is invalid.
CImg.h:      CImg<float> img(100,100,1,3); // Define a 100x100 color image with float-valued pixels
CImg.h:      img.mirror('e');              // Try to mirror image along the (non-existing) 'e'-axis
CImg.h:      - \b CImgDisplayException: Thrown when something went wrong during the display of images in CImgDisplay instances.
CImg.h:      - \b CImgInstanceException: Thrown when an instance associated to a called \CImg method does not fit
CImg.h:      - \b CImgIOException: Thrown when an error occurred when trying to load or save image files.
CImg.h:      - \b CImgWarningException: Thrown only if configuration macro \c cimg_strict_warnings is set, and
CImg.h:    //! Return a C-string containing the error message associated to the thrown exception.
CImg.h:  // a computationally-intensive function has been aborted by an external signal.
CImg.h:    //! Return a C-string containing the error message associated to the thrown exception.
CImg.h:  /*-------------------------------------
CImg.h:    -----------------------------------*/
CImg.h:  //! Contains \a low-level functions and variables of the \CImg Library.
CImg.h:     Most of the functions and variables within this namespace are used by the \CImg library for low-level operations.
CImg.h:      static T max() { return (T)1<<(8*sizeof(T) - 1); }
CImg.h:      static unsigned char max() { return (unsigned char)-1; }
CImg.h:      static char max() { return (char)-1; }
CImg.h:      static char max() { return (char)((unsigned char)-1>>1); }
CImg.h:      static signed char max() { return (signed char)((unsigned char)-1>>1); }
CImg.h:      static unsigned short max() { return (unsigned short)-1; }
CImg.h:      static short max() { return (short)((unsigned short)-1>>1); }
CImg.h:      static unsigned int max() { return (unsigned int)-1; }
CImg.h:      static cimg_uint64 max() { return (cimg_uint64)-1; }
CImg.h:      static cimg_int64 max() { return (cimg_int64)((cimg_uint64)-1>>1); }
CImg.h:      static bool is_nan(const double val) { // Custom version that works with '-ffast-math'
CImg.h:      static double min() { return -DBL_MAX; }
CImg.h:        const double val_nan = -std::sqrt(-1.); return val_nan;
CImg.h:      static bool is_nan(const float val) { // Custom version that works with '-ffast-math'
CImg.h:      static float min() { return -FLT_MAX; }
CImg.h:      static long double min() { return -LDBL_MAX; }
CImg.h:      static long double nan() { const long double val_nan = -std::sqrt(-1.L); return val_nan; }
CImg.h:      static bool is_nan(const half val) { // Custom version that works with '-ffast-math'
CImg.h:      static half min() { return (half)-65504; }
CImg.h:      static half nan() { const half val_nan = (half)-std::sqrt(-1.); return val_nan; }
CImg.h:    // Define keycodes for X11-based graphical systems.
CImg.h:    const unsigned int keyESC        = 1U;   //!< Keycode for the \c ESC key (architecture-dependent)
CImg.h:    const unsigned int keyF1         = 2U;   //!< Keycode for the \c F1 key (architecture-dependent)
CImg.h:    const unsigned int keyF2         = 3U;   //!< Keycode for the \c F2 key (architecture-dependent)
CImg.h:    const unsigned int keyF3         = 4U;   //!< Keycode for the \c F3 key (architecture-dependent)
CImg.h:    const unsigned int keyF4         = 5U;   //!< Keycode for the \c F4 key (architecture-dependent)
CImg.h:    const unsigned int keyF5         = 6U;   //!< Keycode for the \c F5 key (architecture-dependent)
CImg.h:    const unsigned int keyF6         = 7U;   //!< Keycode for the \c F6 key (architecture-dependent)
CImg.h:    const unsigned int keyF7         = 8U;   //!< Keycode for the \c F7 key (architecture-dependent)
CImg.h:    const unsigned int keyF8         = 9U;   //!< Keycode for the \c F8 key (architecture-dependent)
CImg.h:    const unsigned int keyF9         = 10U;  //!< Keycode for the \c F9 key (architecture-dependent)
CImg.h:    const unsigned int keyF10        = 11U;  //!< Keycode for the \c F10 key (architecture-dependent)
CImg.h:    const unsigned int keyF11        = 12U;  //!< Keycode for the \c F11 key (architecture-dependent)
CImg.h:    const unsigned int keyF12        = 13U;  //!< Keycode for the \c F12 key (architecture-dependent)
CImg.h:    const unsigned int keyPAUSE      = 14U;  //!< Keycode for the \c PAUSE key (architecture-dependent)
CImg.h:    const unsigned int key1          = 15U;  //!< Keycode for the \c 1 key (architecture-dependent)
CImg.h:    const unsigned int key2          = 16U;  //!< Keycode for the \c 2 key (architecture-dependent)
CImg.h:    const unsigned int key3          = 17U;  //!< Keycode for the \c 3 key (architecture-dependent)
CImg.h:    const unsigned int key4          = 18U;  //!< Keycode for the \c 4 key (architecture-dependent)
CImg.h:    const unsigned int key5          = 19U;  //!< Keycode for the \c 5 key (architecture-dependent)
CImg.h:    const unsigned int key6          = 20U;  //!< Keycode for the \c 6 key (architecture-dependent)
CImg.h:    const unsigned int key7          = 21U;  //!< Keycode for the \c 7 key (architecture-dependent)
CImg.h:    const unsigned int key8          = 22U;  //!< Keycode for the \c 8 key (architecture-dependent)
CImg.h:    const unsigned int key9          = 23U;  //!< Keycode for the \c 9 key (architecture-dependent)
CImg.h:    const unsigned int key0          = 24U;  //!< Keycode for the \c 0 key (architecture-dependent)
CImg.h:    const unsigned int keyBACKSPACE  = 25U;  //!< Keycode for the \c BACKSPACE key (architecture-dependent)
CImg.h:    const unsigned int keyINSERT     = 26U;  //!< Keycode for the \c INSERT key (architecture-dependent)
CImg.h:    const unsigned int keyHOME       = 27U;  //!< Keycode for the \c HOME key (architecture-dependent)
CImg.h:    const unsigned int keyPAGEUP     = 28U;  //!< Keycode for the \c PAGEUP key (architecture-dependent)
CImg.h:    const unsigned int keyTAB        = 29U;  //!< Keycode for the \c TAB key (architecture-dependent)
CImg.h:    const unsigned int keyQ          = 30U;  //!< Keycode for the \c Q key (architecture-dependent)
CImg.h:    const unsigned int keyW          = 31U;  //!< Keycode for the \c W key (architecture-dependent)
CImg.h:    const unsigned int keyE          = 32U;  //!< Keycode for the \c E key (architecture-dependent)
CImg.h:    const unsigned int keyR          = 33U;  //!< Keycode for the \c R key (architecture-dependent)
CImg.h:    const unsigned int keyT          = 34U;  //!< Keycode for the \c T key (architecture-dependent)
CImg.h:    const unsigned int keyY          = 35U;  //!< Keycode for the \c Y key (architecture-dependent)
CImg.h:    const unsigned int keyU          = 36U;  //!< Keycode for the \c U key (architecture-dependent)
CImg.h:    const unsigned int keyI          = 37U;  //!< Keycode for the \c I key (architecture-dependent)
CImg.h:    const unsigned int keyO          = 38U;  //!< Keycode for the \c O key (architecture-dependent)
CImg.h:    const unsigned int keyP          = 39U;  //!< Keycode for the \c P key (architecture-dependent)
CImg.h:    const unsigned int keyDELETE     = 40U;  //!< Keycode for the \c DELETE key (architecture-dependent)
CImg.h:    const unsigned int keyEND        = 41U;  //!< Keycode for the \c END key (architecture-dependent)
CImg.h:    const unsigned int keyPAGEDOWN   = 42U;  //!< Keycode for the \c PAGEDOWN key (architecture-dependent)
CImg.h:    const unsigned int keyCAPSLOCK   = 43U;  //!< Keycode for the \c CAPSLOCK key (architecture-dependent)
CImg.h:    const unsigned int keyA          = 44U;  //!< Keycode for the \c A key (architecture-dependent)
CImg.h:    const unsigned int keyS          = 45U;  //!< Keycode for the \c S key (architecture-dependent)
CImg.h:    const unsigned int keyD          = 46U;  //!< Keycode for the \c D key (architecture-dependent)
CImg.h:    const unsigned int keyF          = 47U;  //!< Keycode for the \c F key (architecture-dependent)
CImg.h:    const unsigned int keyG          = 48U;  //!< Keycode for the \c G key (architecture-dependent)
CImg.h:    const unsigned int keyH          = 49U;  //!< Keycode for the \c H key (architecture-dependent)
CImg.h:    const unsigned int keyJ          = 50U;  //!< Keycode for the \c J key (architecture-dependent)
CImg.h:    const unsigned int keyK          = 51U;  //!< Keycode for the \c K key (architecture-dependent)
CImg.h:    const unsigned int keyL          = 52U;  //!< Keycode for the \c L key (architecture-dependent)
CImg.h:    const unsigned int keyENTER      = 53U;  //!< Keycode for the \c ENTER key (architecture-dependent)
CImg.h:    const unsigned int keySHIFTLEFT  = 54U;  //!< Keycode for the \c SHIFTLEFT key (architecture-dependent)
CImg.h:    const unsigned int keyZ          = 55U;  //!< Keycode for the \c Z key (architecture-dependent)
CImg.h:    const unsigned int keyX          = 56U;  //!< Keycode for the \c X key (architecture-dependent)
CImg.h:    const unsigned int keyC          = 57U;  //!< Keycode for the \c C key (architecture-dependent)
CImg.h:    const unsigned int keyV          = 58U;  //!< Keycode for the \c V key (architecture-dependent)
CImg.h:    const unsigned int keyB          = 59U;  //!< Keycode for the \c B key (architecture-dependent)
CImg.h:    const unsigned int keyN          = 60U;  //!< Keycode for the \c N key (architecture-dependent)
CImg.h:    const unsigned int keyM          = 61U;  //!< Keycode for the \c M key (architecture-dependent)
CImg.h:    const unsigned int keySHIFTRIGHT = 62U;  //!< Keycode for the \c SHIFTRIGHT key (architecture-dependent)
CImg.h:    const unsigned int keyARROWUP    = 63U;  //!< Keycode for the \c ARROWUP key (architecture-dependent)
CImg.h:    const unsigned int keyCTRLLEFT   = 64U;  //!< Keycode for the \c CTRLLEFT key (architecture-dependent)
CImg.h:    const unsigned int keyAPPLEFT    = 65U;  //!< Keycode for the \c APPLEFT key (architecture-dependent)
CImg.h:    const unsigned int keyALT        = 66U;  //!< Keycode for the \c ALT key (architecture-dependent)
CImg.h:    const unsigned int keySPACE      = 67U;  //!< Keycode for the \c SPACE key (architecture-dependent)
CImg.h:    const unsigned int keyALTGR      = 68U;  //!< Keycode for the \c ALTGR key (architecture-dependent)
CImg.h:    const unsigned int keyAPPRIGHT   = 69U;  //!< Keycode for the \c APPRIGHT key (architecture-dependent)
CImg.h:    const unsigned int keyMENU       = 70U;  //!< Keycode for the \c MENU key (architecture-dependent)
CImg.h:    const unsigned int keyCTRLRIGHT  = 71U;  //!< Keycode for the \c CTRLRIGHT key (architecture-dependent)
CImg.h:    const unsigned int keyARROWLEFT  = 72U;  //!< Keycode for the \c ARROWLEFT key (architecture-dependent)
CImg.h:    const unsigned int keyARROWDOWN  = 73U;  //!< Keycode for the \c ARROWDOWN key (architecture-dependent)
CImg.h:    const unsigned int keyARROWRIGHT = 74U;  //!< Keycode for the \c ARROWRIGHT key (architecture-dependent)
CImg.h:    const unsigned int keyPAD0       = 75U;  //!< Keycode for the \c PAD0 key (architecture-dependent)
CImg.h:    const unsigned int keyPAD1       = 76U;  //!< Keycode for the \c PAD1 key (architecture-dependent)
CImg.h:    const unsigned int keyPAD2       = 77U;  //!< Keycode for the \c PAD2 key (architecture-dependent)
CImg.h:    const unsigned int keyPAD3       = 78U;  //!< Keycode for the \c PAD3 key (architecture-dependent)
CImg.h:    const unsigned int keyPAD4       = 79U;  //!< Keycode for the \c PAD4 key (architecture-dependent)
CImg.h:    const unsigned int keyPAD5       = 80U;  //!< Keycode for the \c PAD5 key (architecture-dependent)
CImg.h:    const unsigned int keyPAD6       = 81U;  //!< Keycode for the \c PAD6 key (architecture-dependent)
CImg.h:    const unsigned int keyPAD7       = 82U;  //!< Keycode for the \c PAD7 key (architecture-dependent)
CImg.h:    const unsigned int keyPAD8       = 83U;  //!< Keycode for the \c PAD8 key (architecture-dependent)
CImg.h:    const unsigned int keyPAD9       = 84U;  //!< Keycode for the \c PAD9 key (architecture-dependent)
CImg.h:    const unsigned int keyPADADD     = 85U;  //!< Keycode for the \c PADADD key (architecture-dependent)
CImg.h:    const unsigned int keyPADSUB     = 86U;  //!< Keycode for the \c PADSUB key (architecture-dependent)
CImg.h:    const unsigned int keyPADMUL     = 87U;  //!< Keycode for the \c PADMUL key (architecture-dependent)
CImg.h:    const unsigned int keyPADDIV     = 88U;  //!< Keycode for the \c PADDDIV key (architecture-dependent)
CImg.h:      "}|^{|}|g{|}| s{}~}_{|y~|gy~} Z{}~}_{|y~|gy~}    )y}|                       -{|y~                    Jy}|yy}|   "
CImg.h:      "}y~}  6{}~}_{}~}f{|y~|  -y~}6{|y~ A{}y~Z{}~}  j{|y~I{}y~d{}~}d{}~} \\{|y~a{|}y|*{}~}j{|y~|O{}~}F{|y~K{|}y~y|j{}"
CImg.h:      "|y~|O{}~}F{|y~J{|y~h{}y~     Ry~}b{~| r{}~}    i{}~}-x}y~ '{}x~w|y~|  e{}~|         qy~      i{|x~g{}y~b{|x~  f"
CImg.h:      "|y~|O{}~}F{|y~J{|y~h{}y~     Rx| W{}~}    i{}~}-{}y~}| &{}s~|  i{|~y}y~         t{|~y}y~      kv~|g{}y~dv~|  ex"
CImg.h:      "}                   s{|y~}|     '{|n~}  m{|y}w~}|6{|y~} ?{}y~Z{}~}  nx~}|-{}~} B{|y~ g{}~}j{|y~|O{}~}F{|y~J{|y~"
CImg.h:      "h{}y~           q{}~}  -{|}x~}|  f{}y~}|         t{|x~}|      kx~}|f{}y~dx~}|                                  "
CImg.h:      " -{|                                                                                                           "
CImg.h:      "}c~|_{}d~}^{|}p~}|R{|v~Y{}^~|iv~}r{|v~qv~}a{|}p~}| x{}x~} s{}w~ s{}w~|  f{|}r~}|-{}w~|i{|v~({|q~}|W{|v~vv~|Ty|u"
CImg.h:      "~}St~V{}c~|_{}d~}`{|}k~|T{|v~Y{}^~|iv~}r{|v~qv~}c{|k~}| {}v~} t{}w~ t{}u~|  i{|l~-v~i{}w~|Xw}|R{|l~X{|v~vv~|W{|"
CImg.h:      "~}a{}g~|V{|v~Y{}^~|iv~}r{|v~qv~}e{|g~}\"{}t~} u{}w~ u{}s~| >y~}P{|k~-{|w~}k{|w~}Ww~|S{|k~X{|v~vv~|Y{|}k~}|Z{|y~"
CImg.h:      "|w~|R{|x~}x{|x~}Uv~|w{}w~}Q{|w~|Ww~}Hv~}w{}w~}    Pw~}y{|x~}cY~  i{}y~|#{|w~}Qm~|`m~}w{|m~|\\{}v~|  ;{}`~}    -"
CImg.h:      "~|Rw~ {{}o~}w{|x~} H{}x~|T{|w~r{}x~}-{}x~|hw~|d{}x~|hw~|_{}x~|mw~|%{|r~|R{|r~|R{|r~|R{|r~|R{|r~|R{}r~|Y{|v~|y{|"
CImg.h:      "}|uy|s~a{|t~}|uy|s~a{|t~}|uy|s~a{|t~}|uy|s~-{|t~}|u{|}q~}f{|v~h{}w~}f{|v~h{}w~}f{|v~h{}w~}f{|v~h{}w~}dv~}l{}v~`"
CImg.h:      "~h{}v~}f{|r~y}v~}r~}d{}w~}hv~|iv~}r{|v~qv~}j{|v~}i{|u~-{}v~}{}w~{|v~} {}w~ {}v~}{}w~{|u~ Cy~}Rv~|S{}~}g{|y~|_v~"
CImg.h:      "-{}y~}r{}y~}R{}w~I{|w~Pt~}| L{}m~}w{|x~} H{}x~|U{|x~}p{|w~.{}x~|kw~|a{}x~|kw~|ct~}lw~|${|v~xv~U{|v~xv~U{|v~xv~U"
CImg.h:      "v~S{|v~}x{|}v~}|y{|v~}^{|w~}u{|w~}Rw~|S{|u~}${}y~|v{}v~}|wy|}y~u{|y~}c{|x~}r{|x~}Q{|q{| W{}y~|uw~vy|v~u{|y~}-w~"
CImg.h:      "~}g{|y~}dw~q{}x~}S{}~}s{}y~ X{}y~|tw~s{}x~}u{|y~}-{}p~}P{}w~M{|w~|F{|x~}({|w~|m{}w~|a{}m~}w{|x~} H{}x~|Tw~p{}x~"
CImg.h:      "v~|mv~|`v~}n{}w~|av~|n{|v~|av~|n{|v~|av~|n{|v~|av~|n{|v~|av~|n{|v~|-v~|r{|x~}v~`{|w~|m{}w~|a{|w~|m{}w~|a{|w~|m{"
CImg.h:      "{y|u~}T{|w~}Lw}|P{|}p~}-{|y~}u{}l~u{}y~|.{|v~|v{}w~}Dw~}6{|y~}uw~rw~}w{}y~| O{}w~  p{|w~|m{}w~|Ux~}w{|x~}  C{}w"
CImg.h:      "S{}v~}?{|v~c{|_~|Ov~|`v~|m{}w~}Y{|v~W{|v~k{}w~}O{|v~ J{|}p~}|d{|Z~}d{|}p~}|-w~s{|w~ov~|v{}x~|lv~|j{|v~c{}w~}k{}"
CImg.h:      "{|w~|D{}w~| q{|y~}K{|y~}L{}v~|N{}v~Ww~}kw~}^{|j~}\\v~|o{}w~}X{}s~W{|^~}    -s~}v|}v~}$v~}#{|w~t{|x~}X{}e~|^w~|o"
CImg.h:      "}\\{}h~}T{}x~}Ms~ K{|y~}C{|w~ p{}x~K{}x~Kw~|L{}x~|Ww~}kw~}]{|l~}\\{|v~n{|w~}X{|s~U{}`~}    -{|h~|$v~}#{}x~}t{}x"
CImg.h:      "  -{|k~}|    U{|r~}                  l{}r~}            Z{}r~|Rw~}L{}r~|    O{}t~                               "
CImg.h:      "       k{}t~}           -{|`}|    `{|}m~}| Jt~}   _w~}9{|w~|    `{}s~| :w~|   cv~  S{|w~}W{|w~|#{|w~| j{}w~ s{}"
CImg.h:      "                         )X  AX '\\ )XAV 7YDY -]      BY  BY '[ +YEY 2X  AY (\\ -YDY   'XAU 3Y  AY (\\ )XAV 8YD"
CImg.h:      "X  CY '] -ZEZ 2X  CY (^ .ZEZ   )[CU 2Y  CY (] *[CU 7ZEZ      LY  CY (] -ZEZ %Y                                 "
CImg.h:      "                                  =X  KX 'XJX 3WKd 5ZEY 3XGX      CX  JX 'WIW 1ZEZ .X  JX (XJX 2ZEZ   -WKd -X  "
CImg.h:      "W 3VHa 4ZEY 3WDW      CX  LX 'WGW 2ZEZ -X  LX 'WHW 2ZEZ   -VHa +X  KX (XHW 3VHa 5ZEZ      GX  KX (WGW 2ZEZ )X  "
CImg.h:      "X 'WFW 3ZEZ   -VF^ )X  MX 'WFW 4VF^ 4ZEZ      FX  MX 'WFW 3ZEZ *X                 ?d                           "
CImg.h:      "             ?W  X 'WDW 5UC[ 2ZEY 4VAV      AW  X &WDW 4ZEZ +W  NW 'WDW 4ZEZ   -UC[ 'W  MW 'WDW 5UC[ 3ZEZ      "
CImg.h:      "           NVAV                                          <P              -X +Y  =Y +] )[CU 7YDY 4V@V      KY  ="
CImg.h:      "CW                                          <R              4a .Y  >X *^ +]DU 7ZEZ 5U>U      JY  ?Y *^ -YEZ 4Y "
CImg.h:      "                                 7Y          -T 7W#W <Y    9X -W  DU             KY    HZ \"\\      4Z    M[ \""
CImg.h:      "    +g                 A[                      LY        8Z -ZEZ   \"Y          1o )V    FX  NZ  FY            "
CImg.h:      " FV             a   \"d -g      >d   (d +b            %b        4f        Bg                 Ie   \"e   \"h    "
CImg.h:      "      -n   $g        I`                   .j        >a        ;e    HU        .U        +b        Ac 2ZEZ   'b "
CImg.h:      "         5o -]    Na (c  KY          .Y #_   8Y!W'Y\"X.c$X              3XGX    Mf                       -e +d "
CImg.h:      "        +g    L\\ 8t (m Ks 2~R E} <o HZ(Z :Z \"Z 4Z,] LZ 2_'_(^-Z Ck :q 0k ?q *n J~d'Z(Z*Z LZ=Z.\\.Z7Z(Z([$Z'~^"
CImg.h:      " ,\\ ,h        7\\ -o .`   $f -h  NY    No     %_ %c   @_\"X-_\"W0h&W   .\\ $\\ \"\\ #\\ #\\ )g 5~a Lm D~S I~S "
CImg.h:      "         GX 5i 0d 2p ;u !^ ?y 2o F~S @n 4j            /l    N\\ 8x .r Nx 7~R E} >t KZ(Z :Z \"Z 4Z-] KZ 2_'_(^-Z"
CImg.h:      "                        Le /X 0e          1r   +r        c                   3o -\\ 5~S E~R Dn *Z :~]+[;Z;Z Ko "
CImg.h:      "   Y    EX    EY        2m   @Y)Y   6l 7ZEZ 0e 2k        >e 1o 0c   'j /i  X   !r     (b 'g   Eb\"W0c#X0i(W   -"
CImg.h:      "LY   )h   :Y  <Y  NX 0X  >Y                 >X               8f /X 0f          3t   -s        c                "
CImg.h:      "X   #u     (b (i   Fb#X0c#W/k+X   .^ %] $^ %] $^ (d 5~b\"v H~S I~S H~R H~R 6Z !Z !Z \"Z :{ A_-Y Gt :t ;t ;s ;t "
CImg.h:      "6p 7m        Eo 6o 2h   *l 1l %X   #v     (b )k   Gb$X/c$X/l,W   -^ &_ %^ &_ %^ 'b 4~b$z J~S I~S H~R H~R 6Z !Z "
CImg.h:      "!Z \"Z :~ D_-Y Hw =v >w >w >w   4wIX)Z(Z#Z(Z$Z(Z$Y'Y$[)[ KZ  Mt 1X  HX )WHW 2VHb 6ZEZ 4WDW      DX  GX )WHW 1YE"
CImg.h:      "X    H_      7U 'p   ?Y,Y 6X *o 7ZEZ 8t 9YH]        Ht 9o 3i   *XG[ 1VE[ &Y   %x     (b *[I[   Hb$W.c%X.VE[-X  "
CImg.h:      "J_ 2X  IX )WGW 2VG` 5ZEZ 4XFX      CX  IX )WFW 2YEZ .X  IX )WFW 3ZEZ /j 8VG` -X  HX *WFW 4VG` 4ZEZ      IX  IX "
CImg.h:      ")WGW 2ZEZ 'X 6Y  FYEZ                 ?XKX M~f        7T   )W 'i DiAi ;X          1~V                  (w   -Z "
CImg.h:      " A~R E} E~T$Z(Z :Z \"Z 4Z2] FZ 2a+a(`/Z K| C{ C} H| =|!~d'Z(Z(Z!Z9Z1^1Z2[0[!Z+[$~^ @X $X  ;Y -e    MX   'Y     "
CImg.h:      "        8Z@[ 2` 7~S E~R J{ 1Z :~]+[;Z;Z#}   +`    HX    Ia      8U (q   >Y-Y 6X +p 7ZEZ 9bMb ;U@Y        JbMb :"
CImg.h:      "n 3ZIZ   +T@Y 2R>Y 'X   %y     (XLV +ZEZ   IXMW%X.YMW%W-R>Y.W   -` '_ &` '_ &` '` 4~c'~R N~S I~S H~R H~R 6Z !Z "
CImg.h:      "W 2YEZ -X  KX (WFW 3ZEZ .f 5UE_ ,X  JX )WFW 4VF_ 4ZEZ      HX  KX )WEW 3ZEZ (X 5Y  FYEZ                 @YJW M~"
CImg.h:      "e        7U   *X (j EkCk =Y          3~X                  )x   -Z +XCX ,W?X 3T BYEY3X Ft (X  KX %X  JV         "
CImg.h:      "~P   -b    IX    Jc      9U )r   >Y.Y 5X ,]DX 7ZEZ ;\\>\\ <R;X        M]>\\   0XDX   ,R=Y  MX (X   %hEW     (SG"
CImg.h:      "V ,YAY   JSHW%W-SGW&X GX/W   ,` (a '` (a '` (a 5~d(~S N~S I~S H~R H~R 6Z !Z !Z \"Z :~T Ia/Y L~P F~P F~P F~P F~P"
CImg.h:      "   <~X&Z(Z#Z(Z$Z(Z$Y'Y\"[-[ IZ  \\>Z 1X  LX )VCW 4UD] 4ZEZ 2f      ?X  LX )WDW 3YEZ ,W  KX )WDW 4ZEZ -b 2UD] *W"
CImg.h:      "   6~Z                  *`C\\   -Z +XCX ,W?W 2T CYCY5X E]CZ (X  LX $X  JV           IX 9]E^ @m 7aGb B^Ec ,b ?y "
CImg.h:      "9aF[ F~R E_C_ B_E^            ;]E_ ={ 7b ;~R @cBb'~V D~R E} HeBc$Z(Z :Z \"Z 4Z4] DZ 2b-b(a0Z NbCb E} GbCb J~ Aa"
CImg.h:      "/d    JX    Ke      :U )]BW   =Y/Y 5X ,[?U   3Z8[ &W        NZ7Z   2XBW    EX  LW )X   %iEW      KV -Y?Y   @W&X"
CImg.h:      "!W&W EW0X   -b )a (b )a 'a )a 5~d)dCb N~S I~S H~R H~R 6Z !Z !Z \"Z :~V Kb0Y MbCb HbCb HbCb HbCb HbCb   >bCh%Z(Z"
CImg.h:      "   -Z +XCX -X@X 2U DXAX5W E\\=V (X  LX #X .R@V?Q          ,X :\\A\\ @m 7\\>_ CY<_ -c ?y :^=V F~Q E]>^ D]@]     "
CImg.h:      "       <Z@^ @~P 9b ;Z=d Aa;^'Z>j E~R E| Ha8^$Z(Z :Z \"Z 4Z5] CZ 2b-b(b1Z `<_ FZ@d I`=` K[@d C_:Z ~b&Z(Z'Z#Z8Z2`"
CImg.h:      "     ;U *\\=T   =Y0Y 4X ,Z;R   5Z3Y &W       !Y3Y   3W@W    EW  LX *W   %jEW      KV -X=X   @W'X W'X EX1W   ,b "
CImg.h:      " NW 2Y         N\\ #[ \"\\ #\\ #[  MXHW L~b        7U   +\\ ,n IoGp C_          ;~]                  ,]:X   -Z "
CImg.h:      "+XCX -X@X 8c LX@X7X E[:T (X  MX \"X /TAVAT          .X :\\?\\ Am 7Y9] CT4] .c ?Y  J]8S  Z E\\;\\ E]=[          "
CImg.h:      "  <W;\\ B~T ;b ;Z7_ C_5['Z7e GZ  MZ '`3[$Z(Z :Z \"Z 4Z6] BZ 2b-b(b1Z!_8^ GZ;` K_9_ LZ:` D]5W 3Y 9Z(Z&Z$Z7Z3`3Z."
CImg.h:      "U *[:R   <Y2Z 4X -Z8P   6Y/X 'W       #Y/Y   6W>V    EW  KW +W   %kEW      KV .X;W   @W'W NW(X CW2X   -c *c )b "
CImg.h:      "e +d +d ,e #XHW LZ#Z        7U   +] -o KqHp C_          <c                   2]7V   -Z +XCX -W?X <l#X?X7W E[7R "
CImg.h:      "E^1Y'Z3b HZ  MZ (_/Y$Z(Z :Z \"Z 4Z7] AZ 2c/c(c2Z!]4] HZ9^ L^5^ MZ8^ E\\0T 3Y 9Z(Z&Z%Z6Z3`3Z-Z6[ J[2Z  \\ >X #X "
CImg.h:      "        #Z                   =Y8Z 7d 7[  Z )_7_ Bp EZ(Z+[;Z;Z(^5^   5j    MX    Nk      =U +[7P   <Z3Y 3X -Y   "
CImg.h:      "       7U   +_ /p KrJr Ea          >`                   .\\5U   -Z +XCX -W?W =r'X>W8X EZ  ;X  NY !X 1XDVDX 2X  "
CImg.h:      "      &X ;[;[ BWDZ 7T2\\ \"\\ 1XMZ ?Y  L\\  2Z E[7[ G\\9[            >S5[ F`7` ?YNY <Z3\\ F]-W'Z0` IZ  MZ )^+W$"
CImg.h:      "Z(Z :Z \"Z 4Z8] @Z 2YNX/XNY(c2Z\"]2] IZ7] N]2] MZ6] G\\-R 3Y 9Z(Z&[&Z6Z4XNW3Z-[8[ HZ3[ !\\ =X #X  <Y 3\\H]    N"
CImg.h:      "                >Y6Y 7YNY 6[ !Z *^3] Dt GZ(Z+[;Z;Z)]2]   6l    NX    m      >U +Z   !Y4Z 3X -Y    NW(W (W      "
CImg.h:      " 7U   ,a 0q LrJr Fc          A_                   ,\\2S   -Z +XCX .X@X ?u(W=X:X DY  :X  NX  Y 2ZFVFZ 2X        "
CImg.h:      "LY   -Y   'Y      8X  >Y                 >Y               ;Y  X  Y          :Y6Y 7j :Y        \"Y              "
CImg.h:      "     >Y6Z 9YMY 5[ \"Z *]1] Hy IZ(Z+[;Z;Z)\\/\\   8n    X   !o      ?U ,[    Y5Y 2X -Y    W&W )W       'W%W   9V"
CImg.h:      "<V +X  DW  LW     )mEW      KV /X9X   BW)X MW)W BW3X   ,YMY ,YMY ,ZNZ -YMY +YNZ -YMY 9ZGZ 5]*U NZ !Z  Z !Z  >Z "
CImg.h:      "C^                   *[0R   -Z +XCX .X@X @v)X=X:W CY  :X  Y  NX 1[HVH[ 1X        'X ;Z7Z 0Z 7P,[ ![ 3XLZ ?Y  M["
CImg.h:      "  1Z EZ4[ I[5Z            ?P1Z I^-] BYLY =Z1[ H\\(T'Z-^ JZ  MZ *\\$S$Z(Z :Z \"Z 4Z:] >Z 2YMX1XMY(YNZ4Z$].\\ JZ5"
CImg.h:      "\\!\\-\\ Z4[ GZ  ;Y 9Z(Z%Z'Z4Z5XNX5Z*Z:[ F[6Z  [ ;X \"X  =Y 5\\C[       #Y     LY   -Y   'Y      8X  >Y        "
CImg.h:      "(Z+[;Z;Z*\\-\\   :p   !X   \"q      @U ,Z    NY6Y 1X -X    W#V *W       (W#W   :U;V +X  DW  LW     )mEW      KV"
CImg.h:      " /X9X   BW*X LW*X BW3W   +YLY -YMY ,YLY -YMY ,YLY -YMZ ;ZFZ 5\\'S NZ !Z  Z !Z  >Z !Z !Z \"Z :Z-^\"e3Y#\\.]#].\\"
CImg.h:      "#\\-\\#\\-\\#\\-\\   H\\.]$Z(Z#Z(Z$Z(Z$Y'Y L[6Z DZ \"Y5Y                                    /[G[               "
CImg.h:      "  -Z +XCX .W?X Bx)X=X;X DZ  :X  X  MY 0ZIVIZ /X        'X ;Z7[ 1Z  AZ ![ 4XKZ ?Y  MZ  0Z EZ3Z I[5Z             "
CImg.h:      "(Z4Z5WLW5Z*[<[ DZ7[ !\\ ;X \"X  =Y 6\\A[       $Y     LY   -Y   'Y      8X  >Y                 >Y              "
CImg.h:      "   #s      AU ,Z    MY7Y 1X -Y   \"W!V :f       (V!W   ;U;V +X  EX  MW     (mEW      KV /W7W   BW*W KW+X BW3X  "
CImg.h:      " +YLY .YKY -YLY .YKY -YLY .ZLY ;ZFZ 6\\%R NZ !Z  Z !Z  >Z !Z !Z \"Z :Z,^#YNZ3Y$\\,\\#\\,\\$\\,\\%\\+\\%\\,\\ MP"
CImg.h:      " NP N\\-]$Z(Z#Z(Z$Z(Z$Y'Y KZ7[ Dq :Z4X                                    /XC[                              EY "
CImg.h:      "       -x @x >x ?x @x -X :Z'Z      ?U  MU   -e 2q MtLt Ig          E[                   'Z,P   -Z +XCX .W?W By)"
CImg.h:      "X<W;W CZ  :X  X  MY .ZKVKZ -X        (Y <Z5Z 1Z  A[ !Z 4XKZ ?Y  N[  1Z DZ3Z IZ3Y             NY K\\%[ EYKZ >Z0Z"
CImg.h:      " !\\ :X !X  >Y 7[>[       %Y     LY   -Y   'Y      8X  >Y                 >Y               ;Y  X  Y          ;Y"
CImg.h:      "  BU ,Z  *P DY8Y 0X -Y   #W NV @k       )V NV   <V;V +X  EW  NY     )nEW      KV /W7W   BW+X KW+W CY4X   +YKZ /"
CImg.h:      "YKY .ZLZ /YKY .ZKY /YKY <ZEZ 7\\#Q NZ !Z  Z !Z  >Z !Z !Z \"Z :Z+]#YMZ4Y%\\*\\%\\*\\&\\*[%[)[%[*\\ R!R [-_%Z(Z#Z"
CImg.h:      "B{ Az B{ /X :Z'Y      >V  U   -g 4r NvNu Ji *\\ 5X.X 6\\ 7Z1Z M[                   '[    8Z +XCX /X@X C`MTL_)W;"
CImg.h:      "\\ 9X !X  >Y 8[<[       &Y     LY   -Y   'Y      8X  >Y                 >Y               ;Y  X  Y          ;Y5Y "
CImg.h:      "7RB] =\\        $Z                   BY2Y ;YJY 3[ &Z -[(\\!~U Z(Z+[;Z;Z,\\)\\   ?\\MXL[   $X   %\\LXM\\      CU"
CImg.h:      " ,Y *Q\"R DY9Y 0X -Y   #V=_?V Cm       *V LV   <U;V +X  FX \"[     (nEW      KV /W7W   BW+W JW,X F[3W   *YJY 0Z"
CImg.h:      "KZ /YJY /YKZ /YJY /YJY =ZEZ 7[!P NZ !Z  Z !Z  >Z !Z !Z \"Z :Z*]$YMZ4Y%[([%[(['\\)\\'\\)\\'\\)[!T#T\"\\-`&Z(Z#Z("
CImg.h:      "[ ![ 8X !X  >Y 9[:[       'Y     LY   -Y   'Y      8X  >Y                 >Y               ;Y  X  Y          ;Y"
CImg.h:      " DU -Z +S$T EY:Y /X -Z   %V?fBU Eo       +VEg=V   =V<V +X  GX *b     &nEW      KV /W7W   BW,X JW,W Nb2X   +ZJY "
CImg.h:      "0YIY /YJY 0YIY /YJZ 1YIY =ZEZ 8\\  NZ !Z  Z !Z  >Z !Z !Z \"Z :Z)\\$YLZ5Y&\\'['['\\(['['['['['[#V%V#[-a&Z(Z#Z(Z$"
CImg.h:      "K[ &Z(\\ MZ  MZ -[  Z(Z :Z \"Z 4Z?\\ 8Z 2YKX5XKY(YLZ6Z&[&[ MZ3[%[&\\#Z2[ JZ  :Y 9Z(Z#Z+Z1Z7WJW7Z&Z@Z >Z<Z ![ 7X"
CImg.h:      "X  Y        6Y /Y5Y $[ =`  G^ !Z    IZ             M\\     #Y2Z =YIZ 3\\ (Z .[%[%aIZI`\"Z(Z+[;Z;Z-[%[   B\\KXJ["
CImg.h:      "BW-X IW-X N`0W   *YIZ 1YIY 0YHY 1YIY 0ZIY 1YIZ ?ZDZ 8[  MZ !Z  Z !Z  >Z !Z !Z \"Z :Z(\\%YLZ5Y&[&['[&[)\\&[)[%[)"
CImg.h:      "[&[$X'X%[-b&Z(Z#Z(Z$Z(Z$Y'Y I[=[ Az CY;` 5\\ $] $\\ \"\\ #\\ $] 8\\/[ 3\\ '\\ #\\ \"[ \"[          \"[ &Z &[ !["
CImg.h:      "XHZ ?Y !Z  /Z CY1Y JZ1Z      2Y   Y  $Z Z HY JYHY ?Z/Y L[ %Z'\\ NZ  MZ -[  Z(Z :Z \"Z 4Z@\\ 7Z 2YKX5XKY(YKZ7Z'["
CImg.h:      "0X1Z 8Y FXD`9` YD` -c 9XD` /aEX :XD] 6g 7t BX0Y LY)Y+X6Z6X)Z/Z NX)Y I} 2Y  X  Y        9_>W KY5Y #[ =c  h >XD` "
CImg.h:      "AT#X 5Y 6X0X LY'Y ?RCW ?~Y!X?X?X ;d 'r!~W KZ1Y =YHY 2\\ )Z /[$[%_GZG_#Z(Z+[;Z;Z-[%[   C\\JXI[   'X   (\\IXJ\\  "
CImg.h:      " (Y  d 5Z -W(X FY<Y .X ,[   (UAmDV Iq       ,VDl@U   >V=W +X  HX )^   ,Y1Y HnEW      KV 0X7W   BW-W HW.X M^/X )"
CImg.h:      "Z(Z$Z(Z$Y'Y H[>Z @{ DY=b ;f -f -f ,e -f -f Ae7c ;e /b )c *c *c 'Y  NX  NX  X  E[ >XD` -c )c *b *c )c '\\ &bDX L"
CImg.h:      "2Z&[#Z#Z2[ JZ  :Y 9Z(Z\"Z,Z1Z8XJX8Z%[D[ <Z?[ \"\\ 6X  X  ?Y <[4[     -l :YGd ,k 9eGY :h 5r 8eGY GYGe +Y  NX 0X3"
CImg.h:      "Z $k 9Z .Y*Z FY=Y .X ,\\   *UAnCU J^CW       -VCmAV   ?W>V *X  IX (a   /Y1Y HnEW      KV 0X7W   BW.X HW.W La3X "
CImg.h:      "#[$Z2[ JZ  :Y 9Z(Z\"Z-Z/Z9XJX9Z#ZDZ :Z@Z \"\\ 5X  NX  @Y =[1Z     1q <YIh 0o =hHY <l 7r 9hIY GYHg ,Y  NX 0X4\\ "
CImg.h:      "7Y FYIg@g#YHh 6l =YIh 7hHX ;YHa ;q <t BY1Y KY+Y*Y8\\8Y([3[ MY+Y I~ 2Y  X  Y        =gCX KY6Z !Z <i -q CYHh F[*Y"
CImg.h:      " ;Z /[,[ FZ?Y -X +\\   +UBoBU LZ>W       -UBnAU   >W@W *X  JX 'c   1Y1Y HnEW      KV /W7W   BW.W GW/X Lc5W 'Y ,"
CImg.h:      "YFY 4ZGY 2YFY 3YGZ 3YFY 3YGZ AZCZ 9Z  KZ !Z  Z !Z  >Z !Z !Z \"Z :Z&[&YJZ7Y'[#[*Z\"Z+[#[+[#[+[#[&[-\\'[/YM[(Z(Z#"
CImg.h:      "BY2Z KZ0[      <b   a  -[\"Y BX MYFY @Z0Z M[ $Z%[ Z  MZ .Z  MZ(Z :Z \"Z 4ZD] 4Z 2YJX7XJY(YJZ8Z([\"[ Z2Z&Z\"[$Z2"
CImg.h:      "JiBi$YJk 8o ?YJj 9kJX ;YJc <r <t BY1Y KZ-Z)X8\\8Y'Z4[ LZ,Y I~ 2Y  X  Y        ?jDX KY6Y  Z ;k 1r CYIj G]-Z 5Z 7"
CImg.h:      " (q ;Z .[BVB[ DY@Z -X *]   .UC^EXBU LX<W       .VBWC[AU   ?WAW )X  KX %c   2Y1Y HnEW      KV /W7W   BW/X GW/W J"
CImg.h:      " -\\ ,nLW JY0X HY0X GX0X GX0Y KY,Y JYJj CY,Y     :ZBXBZ!Z+Z Z,Z Z,Z!Z+Z 6X 7Z-Z      BZ  U   0q 7o M~n s ;u BX."
CImg.h:      "Z2Z'[!Z$Z2[ JZ  :Y 9Z(Z!Z/[/Z:XHW9Z\"[H[ 8ZC[ \"[ 3X  NX  @Y ?[-Z     5v ?YKm 6r ?mKY ?q 9r <mKY GYKm /Y  NX 0X"
CImg.h:      "6[ 4Y FYKkEl%YKm ;r @YKl ;mKX ;YKd >t <t BY1Y JY-Y(Y9]9Y&Z5Z JY-Y H~ 2Y  X  Y        @lFX JY6Y  NY 9k 4s CYJl H"
CImg.h:      "EXFU   %Z )r ;Z -[G^G[ CZAY ,X )]   /UC[>TAU NX;W )P9P     =UAWAYAU   >XDX )X  LX  HY   3Y1Y HnEW      KV /W7W "
CImg.h:      "AP9P 9W0X FW0X ?Y8W &Y -YEZ 5YEY 4ZFZ 5YEY 4ZEY 5YEY BZBZ :[  KZ !Z  Z !Z  >Z !Z !Z \"Z :Z%['YIZ8Y([!Z+Z![,Z![-"
CImg.h:      "[![-[!Z$[1\\&[/XJZ(Z(Z#Z(Z$Z(Z$Y'Y EZCZ =Z;` HYA[ 8u <u =v <v =u <u!uGr Js =r 9r 9r 9r .Y  Y  NX  Y (o AXJl :q "
CImg.h:      "7q 9r 9q 7q .\\ -y IY0X HY0X GX0X GX0Y KZ-Y JYKl DY-Z     ;ZAXAZ\"Y)Y!Z*Z\"Z*Z\"Y)Y 6X 7Z-Y      BZ  NT   0s 8o"
CImg.h:      "GYLo 0Y  NX 0X7[ 3Y FYLmGn&YLo =t AYLo >oLX ;YLe ?u <t BY1Y JY-Y(Y9]9X%[7Z IZ.Y H~ 2Y  X  Y        AnGX JY7Z  N"
CImg.h:      "Z 9k 6t CYKn I^/Z 5\\ 8Y1Y Z$Z L\\Jg H~Y!Y@X@Y Br =~S\"~W LZ/Y @YDY /[ -Z 0Z NZ+\\@Z@\\'Z(Z*Z;Z;Z/[![ U  GSEXDS"
CImg.h:      "W      KV /W7W AQ:Q :W0W EW1X <X:X &Y -YDY 6ZEZ 5YDY 6ZEZ 5YDY 5YEZ CZBZ :Z  JZ !Z  Z !Z  >Z !Z !Z \"Z :Z%['YHZ"
CImg.h:      "9Y(Z Z+Z Z-[![-[![-Z [$[3\\%[0XI[)Z(Z#Z(Z$Z(Z$Y'Y E[E[ =Z9^ HYBZ 6v =v >w =w >v =v\"vIt Lt >t ;t ;t ;t /Y  Y  N"
CImg.h:      "Z(Z :Z \"Z 4ZG] 1Z 2YIX:YIY(YHZ:Z)[ [!Z2Z'Z [%Z2[ J[  ;Y 9Z(Z Z0Z-Z;XHX;Z NZJ[ 6[FZ \"\\ 2X  MX  AY AZ(Z     7x"
CImg.h:      "!Z !Z \"Z :Z$Z'YHZ9Y)[ [-[ [.[ Z-Z NZ-Z [#[5\\$Z0XH[)Z(Z#Z(Z$Z(Z$Y'Y D[FZ <Z7] IYBY 5w >w ?x >x ?w >w#wKv Nu ?v"
CImg.h:      "X :[  >X $Y  FY +f &X        +X ;Z/Z 4Z  AZ !Z ;YDZ ?YFP -Z?Q  BZ ?Z5Z JZ/Z 5Z \"[  Gj   Ii  ;[\"X1Q,W\"YCZ BZ1"
CImg.h:      "j J~Y!Y@X@Y D_I` A~U\"~W LY.Y AYCZ .[ /Z 1Z MZ,\\?Z?\\(Z(Z*Z;Z<[/Z NZ\"Y  ;X  ;Y 3X 3Y2Y 3X    EZ -hM[ ;Z *~Q >"
CImg.h:      "CY 6YBY 7YCY 6ZCY 7YCZ EZAZ ;[  JZ !Z  Z !Z  >Z !Z !Z \"Z :Z$Z'YGZ:Y)[ NZ-[ [.Z N[.Z NZ.[ NZ\"[7\\$[1XFZ)Z(Z#Z("
CImg.h:      "-j (X        +X ;Z/Z 4Z  AZ \"Z :XCZ ?YM_ 5ZE^  IZ >Y6Z IZ0[ 5Z \"[  Jj   Ci  ?\\\"X6\\2X#YBY BZ1Z MZ \"Z$[!Z  "
CImg.h:      " K~Y!Y@X@Y E]C^ CaHl\"~W LY.Z BYBY .\\ 0Z 1Z M[-[>Z>[(Z(Z*Z;Z<[0[ N[$[  <X  <[ 4X 4[4[ 4X    EZ ._KUHV ;Z )~ <Y"
CImg.h:      "Z 7YBY 8ZCZ 7YBY 8ZBY FZ@Z ;Z  IZ !Z  Z !Z  >Z !Z !Z \"Z :Z$[(YGZ:Y)[ NZ-Z MZ.Z N[/[ N[/[ NZ![9\\#[2YFZ)Z(Z#Z(Z"
CImg.h:      "$Z(Z$Y'Y C[I[ ;Z5\\ JYCY 4X=^ @X=] @Y=] ?Y>^ @X=^ @X=^%X=l@\\\"_?W A]@\\ @]@\\ @^A\\ @^A\\ 1Y  Y  NX  Y -w DXNY"
CImg.h:      "BZ 9YAY 8ZBZ 9YAY 8ZBZ 9YAY FZ@Z ;Z  IZ !Z  Z !Z  >Z !Z !Z \"Z :Z$[(YFZ;Y)Z MZ-Z MZ/[ MZ/[ N[/Z M[![;\\\"[3YE[*"
CImg.h:      "[ \"Z#Z!Z  MZ 0Z  KZ(Z :Z \"Z 4ZK] -Z 2YGX=XGY(YFZ<Z*[ MZ!Z3[(Z M[&Z3[ H^  ?Y 9Z(Z NZ3Z*Z=XFX=Z Kf 0[L[ #\\ /X "
CImg.h:      "X@Y FZ;[ E]>\\ 0Z 6Y.Z CYAZ -\\ 2Z 1Z LZ.[=Z=[)Z(Z*Z;Z<Z/Z LZ&\\  ;X  ;\\ 6X 6\\2\\ 6X    EZ /\\GUCQ ;Z 'z 9YGY"
CImg.h:      " )X -ZN_   ;TDX\"U\"W;Y 0W@W     ?T>W>X@T   ;a #X #X  =W   6Y1Y GmEW      KV .X;X @W@W @W3W BW4X 6W?X #Y /Y@Y :"
CImg.h:      " >Y  EY 2ZKVKZ -X        ,X :Z/Z 4Z  BZ &] :XAZ ?s =YJk #[ ;[=[ FZ1\\ 6Z \"[ #j L~d Ki  J\\!X:hKVAW%Y@Y CZ5\\ L"
CImg.h:      "  LX  BY        JQ1[ D_:[ B\\ ([9_ F[7Z 6Y 1[:_ G^9Z 3Y  NX 0X>\\ -Y F^;b;Z)_:Z D[:\\ F_:[ G[9^ ;_ /Y  EY .Y1Y "
CImg.h:      "Z9[ G\\;[ 0Y 5Y.Z DZ@Y ,\\ 3Z 1Z LZ.Z<Z=[)Z(Z*Z;Z<Z/Z LZ'\\  :X  :\\ 7X 7\\0\\ 7X    EZ 0\\FU -Z &x 8YHY (X -YK"
CImg.h:      " MZ 0Z  KZ(Z :Z \"Z 4ZM] +Z 2YGY?XFY(YEZ=Z*Z L[\"Z4['Z LZ&Z4[ Fc  EY 9Z(Z MZ5Z)Z>XDW=Z Ic .[NZ #\\ -X  KX  CY  "
CImg.h:      ".Z DZ@Z ,\\ 4Z 2[ LZ.Z<Z<Z)Z(Z*[<Z<Z/Z LZ(\\  9X  9\\ 8X 8\\.\\ 8X    EZ 1\\EU -Z %^E] EhIg 6X .YI_   ?UEX T!W="
CImg.h:      "Z 2YBY     @U>W>W?U   7W <~d BX  ;W   6Y1Y GmEW      KV -X=X ?YBY BW4W AW5X 5W@W !Y 0Y?Z ;Y?Y :Z@Z ;Y?Y :Z?Y ;Y"
CImg.h:      "Y GX.X ;YMZ 7Z;Z!X                   *~R   !Z    X@X BZDT BXCYDX 6`    ?Y  DY 7[HVH[ 1X        -X 9Z.Y 4Z  D[ 7"
CImg.h:      "G]7Z 4Y  NX 0X@[ *Y F]8^8Z*]7Z FZ6[ G]6Z I[7] ;] -X  DY .Y1Y GY3Y#Y=WNX=X L[CZ ?Y4Y &[ .X  NX  Y     $iGh Z:XNX"
CImg.h:      "ZIuIZ)\\  8X  8\\ 9X 9\\,\\ 9X    EZ 1[DU -Z $Z@[ EhJh 6X /YF_   ATDX U\"X?[ 3ZCZ     @U>W>W?U     K~d CX  ;X  "
CImg.h:      " 6Y1Y FlEW      KV -Y?Y ?ZCZ CW5X AW5W 5XAX !Y 0Y>Y <Z?Z ;Y>Y <Z?Z ;Y>Y ;Y?Z JZ>~Q3[  I~Q G~Q F~Q G~Q 5Z !Z !Z "
CImg.h:      "R   !Z    X@X BZDT BZGZCW 6b    @Y  DY 8ZFVFZ 2X        -X 9Z.Y 4Z  DZ 7l 8X?Z ?w BZMr ([ 7s C[3] 6Z \"[ +i C~d"
CImg.h:      "Z5\\ ;] -X  DY .Y1Y GZ5Z#Y>XMW>Y K[E[ ?Y5Y &[ .Y  NX  Y     $XIZHZIY!Z:XNX GYHf  GY DY6[ CY $\\5Y CX6Y 5c ;Y1Y#"
CImg.h:      "CU -Z %Z>Z EiKh 6X /XC^   BTDX U\"YA\\ 4ZCZ N~d  &U>W?X>T     K~d EY  :W   5Y1Y EkEW      KV ,YAY =ZCZ DW6X @W6"
CImg.h:      "   BZ  DY 8XDVDX 2X        -X 9Z.Y 4Z  E[ 7j 7Y?Z ?x CZNt )Z 5p @Z3] 6Z \"[ .i @~d @i *\\ MW<^Ib@W(Y=Z E| GZ !Z"
CImg.h:      "[5[ 3Y 6~W EY=Z *[ 6Z 2Z KZ/Z;Z<[*Z(Z)Z<Z=Z/[IuI[,\\  6X  6\\ ;X ;\\(\\ ;X      LZBU -Z %Y<Z FjMi 6X 0X@]   CTD"
CImg.h:      "4[   >Z9` IY0X HY0X GX0X GX0Y FY6Z F\\4Z GY6Y     ;W9X9W-X JX,WD[I\\DW,W1[DW-X JX =X 1Y6Z     <~d'RKY:U   5~U J"
CImg.h:      "8Z.Y 4Z  F[ 6h 5X>Z ?y DgF` *Z 2k >Z4^ 6Z \"[ 1j >~d =i -[ LW=\\C_?W)Y<Y Ez EZ !Z\"Z\"~Q Dy![  K~] :Z \"Z 4e &Z"
CImg.h:      " 3Y2[ G[4Y 4Y  NX 0XD\\ 'Y F[5[5Y*[4Y HZ2Z H[3Z KZ3[ ;[ ,Y  DY .Y1Y FY5Y!Y?WLX?Y J[GZ <Y7Z '[ -Y  NX  Z     'WC"
CImg.h:      "Z)[=Z=Z/[IuI[-\\  5X  5\\ <X <\\&\\ <X      LZBU -Z &Y:Y FjNj 6X 0X?]   EUEX NU!s 6ZCZ L~d  &T=WAY=T     K~d GX"
CImg.h:      "3Z GY6Y     ;W9X9W-W HW,WC[K\\CW,W2[CW-W HW =X 1Z7Z     <~d NX:U   5~V M~X%~e&~Y LX0Y HX.X =ZJY 6Y=Z W         "
CImg.h:      " =X      MZAU -Z &X8Y G~W 6X 0W<\\   FUEX MT iNW 8[D[ K~d  &T=WE\\<T     K~d HX  NQ<Y   4Y1Y CiEW 3Z    CV )k 7"
CImg.h:      "6Y  Y  NX  Y 3Z3Z HZ3Y IZ1Z IZ2Z IZ2Z JZ1Z IZ2Z   ?Z:b IY0X HY0X GX0X GX0Y EY8Z E[2Y GZ8Z     ;W9X9X.W HW-XB[M"
CImg.h:      "T >eBX<U\"[M\\4Y   ;Y  CZ 7Q?V?Q 0X        .X 8Y-Z 5Z  H\\ 5j 9Y=Z ?T9_ Ec>] ,Z 1j <[7_     7i 8~d 7i 5[ KW=Z="
CImg.h:      " IY@X@Y JY1Y LZ1Z 4Y 6~W FY;Z *[ 7Z 2Z KZ/Z;Z;Z*Z(Z(Z=Z>[/[IuI[/\\  3X  3\\ >X >\\\"\\ >X      MZAU -Z 'X6X 5c "
CImg.h:      "X<[+Z(Z#Z(Z$Z(Z$Y'Y <_ 4Z2Z KYD[  @X  NX  Y  NY  X  NX 3Z/Y-Z $Z/Y KZ/Y KZ/Y KZ/Y 6Y  Y  NX  Y 4Z2Z HZ3Y IZ1Z I"
CImg.h:      "Z1Z JY1Z JZ1Z IZ1Z   @Z;XNZ JY0X HY0X GX0X GX0Y EY8Y D[2Z GY8Y     ;X9X8W.W HW-W@hAW-X4[@W.W:[:W =X 0Z9Z      I"
CImg.h:      "X        /X 7Y-Z 5Z  H[ 4l ;X<Z ?Q4^ Fb<] .[ 3o ?[7_     :i    5j 9[ JW=Y;[?W+Z:Y F~ IZ !Z\"Z\"~Q Dy![2l'~] :Z "
CImg.h:      " 3Y.Y-Z $Y.Y KY.Y KY.Y KY.Y 6Y  Y  NX  Y 4Z1Y HY2Y IZ1Z IY0Z KZ0Z KZ1Z IY0Z   @Y;XMZ JY0X HY0X GX0X GX0Y DY9Y D"
CImg.h:      "Z0Y GY9Z     ;W8X8W.W HW-W?f?W.W4[?W.W:[:W =X 0Z9Y      HZ 5X<U   6~Z$~`'~a&~\\ NY/X HX.X =YHY 7Z?Z ~m         "
CImg.h:      "         4Z    3Y    W?W <i >_@XAa*[I\\6Y   ;Y  CZ %V  MX        /X 7Y-Z 5Z  I[ 3n >X;Z  ] G`9\\ .Z 4s @[9`    "
CImg.h:      "[ Ff GZ:X:[+Z(Z#Z(Z$Z(Z$Y'Y :\\ 3Z2Z KYC\\  BY  X  NX  NY  Y  X 3Y-X-Y #Y-X KY-X KY-X KY-X 6Y  Y  NX  Y 5Z0Y HY"
CImg.h:      "2Y IY/Y JZ0Z KZ0Z KY/Z KZ/Y   AZ;WKY JY0X HY0X GX0X GX0Y DY:Z DZ0Y FY:Y     :WK~KW.WK}KW-W>d>W.W5[>W.W:[:W =X /"
CImg.h:      "  CZ %V ;~c        LX 7Y-Z 5Z  J\\ 2n @Y;Z  N\\ G`8\\ /Z 5u A\\<b     ?i    *i ?Z IW=X8Z>V+Y8Y G~R LZ !Z\"Z\"~Q"
CImg.h:      "-[ 5Z 2[ LZ/Z;Z;Z*Z(Z'[?Z?[.[IuI[2~n BX B~n AX A~m AX      NZ@U 8y <X4X 4_ #X 1X7Z   IUEX MT J^HW <ZCZ F~d  &T="
CImg.h:      "g5T     -X ,o 5k   1Y1Y >dEW 3Z    Nl ._ ,ZCZ'lEX6\\>mEWDVCZBkAX6]   LY8Y BZ9Z AY8Y BZ9Z AY8Y BZ9Z!Z;~Q3Z  H~Q "
CImg.h:      "  NY  Y  Y 4Y-Y.Y #Y-X KY-X KY-Y LY-Y 7Y  Y  NX  Y 5Z0Z IY2Y JZ/Z KZ/Y KY/Z KY/Z KZ/Y#~d$Z<WJY JY0X HY0X GX0X G"
CImg.h:      "N~m                  4Z    3Y   !X@X :n 'WBg.ZE\\8X   :Y  CZ %V <~e        NX 6Y-Y 4Z  K\\ #a AX:Z  M\\ H_6[ 0Z"
CImg.h:      "3Y+Y1Y JY.Y IY/Z NY/Y ;Z *\\  HY .Y1Y DZ;Z LXBXIWBY Ce 6Y;Y )[ -\\  LX  L\\ >q:X  !U:[9U&Y5] DY?d =jLX FY/Z C[ "
CImg.h:      ")Y1Y AX=Z 6ZIY >Y1Y%Z IZ*YAYAY HY9Y IY@X@Y KY/Y NZ/Z 5Y 5Y-Y HZ8Y .[ 4Z 1Z LZ/Z;Z;Z*Z(Z'[?Z@[-[ L[3~o BX B~o BX"
CImg.h:      " B~o BX      NZ@U 8y <X4X 4^ \"X 1X6Y   IUEX MT GW *ZCZ E~d  &T=g5T     -X ,o 5i   /Y1Y <bEW 3Z    Nl *W 'ZCZ(l",
CImg.h:      "1[ L[1Z KZ Dc E[=Y9[+Z(Z#Z(Z$Z(Z$Y'Y 9Z 2Z2Z KYB^ &i 0i 1i /i 0i 0i Ej-Y/Z $Z-Y MZ-Y MZ-Y LY-Y 7Y  Y  NX  Y 5Y/"
CImg.h:      "/Z 5Y 5Y-Y HZ8Z 0\\ 4Z 1Z LZ/Z;Z;Z*Z(Z&[@Z@[-[ L[4~p BX B~o BX B~p CX      NY?U 8y <W2W 3] \"X 1Y7Y   IUEX MT  "
CImg.h:      " JZCZ  8X  &T=WIZ6T     -X ,o 3e   -Y1Y :`EW 3Z    Nl   (ZCZ)lFW5UNV>mFWCQ;XAe>X6UNW CY 4Y7Z DZ7Y BZ8Z CY7Z CZ7"
CImg.h:      "KYA^ /q 9r 9q 7q 8q 9r Mq,Y/Z $Y,Y MY,Y MY,Y MZ-Y 7Y  Y  NX  Y 5Y.Y IY1X JZ/Z KY.Z LY.Y LZ/Z KY.Z$~d$Y=XIZ KY0X"
CImg.h:      " ?ZFY 6YAZ N~m                  4Z    3Y   !W?W 6p -WCk1ZB\\;Y   :Y  CZ %V <~e        NX 6Z.Y 4Z  M\\  J] EY9Z "
CImg.h:      " L[ H^4[ 2[ 8\\<\\ BbKi     ?`     Ha @Z HV=X5X>W-Y6Y HZ2\\ Z !Z\"Z\"Z  MZ 1[2l'Z(Z :Z \"Z 4ZL] ,Z 2YBXGXBY(Y?Z"
CImg.h:      "XNX GZ.Y Ai 9Y1Y AY>Y 5YHZ ?Y1Y&[ IZ+ZAYAY HY9Y IY@X@Y KY/Y NZ.Y 5Y 5Y-Y IZ6Y 0[ 3Z 1Z LZ/Z;Z;Z*Z(Z&\\AZA[,[ L["
CImg.h:      "4~p BX B~o BX C~q CX      NY?U 8y <W2W 3\\   )Y6Y   JUEX NU   KZCZ  7X  &T=WGY7T     -X    J^   *Y1Y 7]EW 3Z   "
CImg.h:      "     8ZCZ 4X6UMV GX-X=^;W6UMW CY 4Y6Y DZ7Z CY6Y DZ7Z CY6Y DZ7Z#Z:Z <Z  HZ !Z  Z !Z  >Z !Z !Z \"Z :Z#[)Y>ZCY*Z K"
CImg.h:      " NX  Y 6Z.Y IX0X JY-Y KY.Z MZ.Y LZ.Y KY.Z$~d$Y>XHZ KY0X HY0X GX0X GX0Y BY=Y BY.Y FY=Z     9WK~KW/WJ}JW.W:\\:W.W"
CImg.h:      "Z IZ1[ Z !Z#[\"Z  MZ 1[2l'Z(Z :Z \"Z 4ZK] -Z 2YBXHYBY(Y>ZDZ*Z KZ\"v L[ LZ&z !c 4Y 9Z(Z HZ>Z\"ZDX>XDY Ge 'Z '[ "
CImg.h:      " KYDXGWDY @a 3Z>Y +[ 5d  IX  Ic L~d  !U8X7T'Z4[ CY5\\ AZCa GY-Y @h 9Y1Y @X?Z 6ZGY ?Y1Y&[9X9Z+ZAYAZ IY9Y IY@X@Y "
CImg.h:      "KY/Z Y-Y 5Y 5Y.Z IZ6Z 2[ 2Z 1Z M[/Z;Z<[*Z(Z%[AZB\\,[ LZ3~p BX B~o BX C~q CX      NY?U 8y <W2W 2[   (Y7Y   ITDW "
CImg.h:      "NU   M[CZ  6X  &T=WFY8T     -X        EY1Y 1WEW 3Z        7ZC[ 6W6ULV HX+W JX7ULW CY 5Z6Z EY5Y DZ6Z EY5Y DZ6Z E"
CImg.h:      "_ 8w ?x ?w =w >w >w$~u/Y #~W M~W M~W M~W 7Y  Y  NX  Y 6Z.Y IX0X JY-Y KY.Z MZ.Z MY-Y KY-Y$~d$Y?XFY KY0X HY0X GX0"
CImg.h:      "X GX0Y BY>Z BY.Y EY>Y     8WK~KW/WJ}JW.W;]:W.W:[9W/W9[9W >X -Y>Z      KZ .YAU   6~^*~g%~W L~T JX.Y IX.X ?YEZ 7Z"
CImg.h:      "2Z 2Z 8[7[ BqMZ     ?^     C^ @Y GV=W4X>V-Y5Z IZ0[!Z !Z#[\"Z  MZ 1[2l'Z(Z :Z \"Z 4ZJ] .Z 2YAXIXAY(Y=YDZ*Z L[\"s"
CImg.h:      " FY3Y2Y+Y1Y KZ.Z JY.Y Y.Y ;Y &h (Y .Y1Y BY=Y IXDXGWDY ?_ 1Y?Z ,[ 4b  GX  Ga L~c   T6V6T'Z4[ CY4\\ CZ@_ GY-Y >f "
CImg.h:      "9Y1Y @Y@Y 5YFZ @Y1Y&Z8X9[,ZAYAZ IY9Y IY@X@Y KX.Z Y-Y 5Y 5Y.Z IY5Z 3[ 1Z 1Z M[/[<Z<[*Z(Z%\\BZC\\+[ LZ3~p BX B~o "
CImg.h:      "BX C~q CX    DX 4Z?U -Z (W2W 2Z   'Z7X   ITDX U   MZCZ  5X  &U>WEY9T     -X        EY1Y 1WEW 3Z        6ZCZ 7X7"
CImg.h:      "-Y KY-Y MZ.Z MY-Y KY-Y$~d$Y?WEY KY0X HY0X GX0X GX0Y BZ?Y AY.Y EY>Y     8WK~KW/WJ}JW.W<_;W.W;[8W/W9[9W >X -Z?Z  "
CImg.h:      "    LZ -YBU   5~^*~h%~U J~R IX.Y IX.X @ZDY 6YCZ LW                   'y    JY   \"W?X ,j 3WCYCY4Y=\\>X   9Y  CZ"
CImg.h:      "Gz FY.Y KZ %Y-Y J~W :Y 5Y.Y GY1Y 5Y  NX 0c  IY FY3Y2Y+Y1Y KZ.Z JY.Y Y.Y ;Y %j +Y .Y1Y BY=Y IYEXGXEY >] 0Y?Y ,[ "
CImg.h:      "3`  EX  E_ L\\Cx   NT6V6T'Z4Z BY2Z CY>^ GY-Y ;c 9Y1Y @YAZ 6ZEY @Y1Y&Z8X9[,ZAYAZ IY9Y IY@X@Y KX.Z Y-Y 5Y 5Y.Z JZ"
CImg.h:      "4Y 4\\ 1Z 1[ NZ.[<Z<Z)Z(Z$\\CZD]*Z LZ3~p BX B~o BX C~q CX    DX 4Z?U -Z (W2W 2Z   'Z7X   ITDX U   MYBY  4X  &U>"
CImg.h:      "WDX:U     -X        EY1Y 1WEW 3Z        5YBY 7W6UKV IX*W KW6UKW CY 6Z4Y FZ5Z FZ4Z GZ4Y EY4Z GZ4Y%Y8Z <[  IZ !Z "
CImg.h:      "B{'~x/Y #~W M~W M~W M~W 7Y  Y  NX  Y 6Z.Y IX0X JY-Y LZ-Y MZ.Z MY-Y KY-Y$~d$Y@WDY KY0X HY0X GX0X GX0Y AY@Z AY.Y "
CImg.h:      "^ 6Y 9Z(Z GZAZ NZEW<WEZ IZL[ )Z *\\  X  FX  HY        H{ FY.Y KZ %Y-Y K~X :Y 5Y.Y GY1Y 5Y  NX 0c  IY FY3Y2Y+Y1Y"
CImg.h:      " KZ-Y JY.Y Y-X ;Y $l .Y .Y1Y AY?Y HYEWFXEX =\\ .Y@Y -[ 2b  GX  Ga LY=s   LT6W7T'Z4Z BY2Z DY=^ GY-Z =d 9Y1Y ?XAY"
CImg.h:      " 5YDZ AY1Y&Z8X9[,ZAYAZ IY9Y IY@X@Y KX.Z Y-Y 5Y 5Y.Z JZ4Z 5[ 0Z 0Z NZ-Z<Z<Z)Z(Z#\\DZD\\)Z LZ3~p BX B~o BX B~p CX"
CImg.h:      "    DX 4Z?U -Z (W2W 2Z   &[9X   IUEX T s AXAY  4X  &U>WCX;U     -X        EY1Y 1WEW 3Z      Is 0YAX 8W6UJV IW)W"
CImg.h:      "Ca CZBY4Z*Z(Z#Z(Z$Z(Z$Y'Y 9Z 2Z5\\ JY<` A| C| C{ A{ C| C|(~y/Y #~W M~W M~W M~W 7Y  Y  NX  Y 6Y-Z JX0X JY-Y LZ-Y"
CImg.h:      " MZ.Z MY-Y KY-Y$~d$YAWCY KY0X HY0X GX0X GX0Y AY@Y @Y.Y DY@Y     7WK~KW/XK}KX.W>c=W.W=[6W/X:[:X >X ,Y@Z      M[ "
CImg.h:      "Y KZ %Y-Y K~X :Y 5Y.Y GY1Y 5Y  NX 0d  JY FY3Y2Y+Y1Y KZ-Y JY.Y Y-X ;Y #m 0Y .Y1Y AY?Y HYFXEWFY =\\ .YAY ,[ 2d  I"
CImg.h:      "X  Ic LW8n   JU7W7T'Y2Y BY1Z EY<\\ FY-Z @g 9Y1Y ?YBY 6ZDZ AY1Y&Z8X8Z,Y@YAZ IY9Y IY@X@Y LY-Y Y-Y 5Y 5Y.Z JY3Z 6["
CImg.h:      " /Z 0Z [-[=Z=[)Z(Z#]EZE\\(Z LZ2~o BX B~n AX A~n BX    DX 4Z?U -Z (X4X H~W   <\\:W   HUDX!T s AZCZ  5X  %T>WBX<U"
CImg.h:      "     -X        EY1Y 1WEW       \"s 1ZCZ 9X7UIV JX)W LW7UIW CY 6Y2Y HZ3Z GY2Y HZ3Z GY2Y HZ3Z'Z8Z <[  IZ !Z  Z !Z"
CImg.h:      "/Y #~W M~W M~W M~W 7Y  Y  NX  Y 6Y-Z JX0X JY-Y LZ-Y MY-Z MY-Y LZ-Y$~d%ZBXCY KY0X HY0X GX0X GX0Y @YAY @Y.Y DYAZ "
CImg.h:      "    7W8X8W.W HW-W?e>W.W>[5W.W:[:W =W +ZAY      LZ *YDU   5~`,~i#~Q F} GX.Y IX.X AZBY 7ZEZ KX                   "
CImg.h:      "BZ MYFX<XGZ J[IZ *Z +[  MX  FX  HY        Jb>Y FY.Y KZ %Y-Y K~X :Y 5Y.Y GY1Y 5Y  NX 0e  KY FY3Y2Y+Y1Y KZ-Y JY.Y"
CImg.h:      " Y-X ;Y !m 2Y .Y1Y AZAZ GYGXEXGY >] .ZBY -[ 1e  JX  Ke LU4k   IU8Y8T'Y2X AY0Y EX:[ FY-Z Ah 9Y1Y >XCZ 6YBY AY1Y&"
CImg.h:      "Z8X8Z,Y@YAZ IY9Y IY@X@Y LY-Y Y-Y 5Y 5Z/Y JZ2Z 8[ .Z 0[!Z,[=Z=[)Z(Z\"]FZG]'Z M[1]  1X  1\\ @X @\\ L\\ AX    DX 4"
CImg.h:      "Z?U -Z (X4X H~W   ;\\;W   GTDX\"U s A[D[  6X  %T>WBX<T     ,X        EY1Y 1WEW       \"s 2[D[ 9W7UHV KX(W MX7UI"
CImg.h:      "X3[*Z(Z#Z(Z$Z(Z$Y(Z 9Z 2Z8^ IY9` Fb=Y Eb=Y Eb=X Cb>Y Eb=Y Eb=Y*b=~V/Y #~W M~W M~W M~W 7Y  Y  NX  Y 6Y-Z JX0X JY"
CImg.h:      "-Y LZ-Y MY-Z MY-Y LZ-Y   CZCXBY KY0X HY0X GX0X GX0Y @YBZ @Y.Y CYBY     6W8X8W.W HW-W@g@X.W?[4W.W:[:W =W *YBZ   "
CImg.h:      "  KX    Nl   !X 4Z/Z 4Z %\\  =Z LX4Z  IZ I[0Z 5Z 9Z0Z <bFY     ;i    1i =Z HW>X3W?W/~S KZ-Z\"Z \"Z#Z!Z  MZ 0[!Z"
CImg.h:      "]8Y FY.Y KZ %Y-Y K~X :Y 5Y.Y GY1Y 5Y  NX 0f  LY FY3Y2Y+Y1Y KZ-Y JY.Y Y-X ;Y  Mk 3Y .Y1Y @YAY FYGWDXGY >^ .YCZ ."
CImg.h:      "[ )_  KX  L_ ES/e   FU8Z9T'Z3X AY0Y FY:[ FY-Z Cj 9Y1Y >XCY 6ZBZ BY1Y&Z8X9[,Y@YAZ IY9Y IY@X@Y LY-Y Y-Y 5Y 5Z/Y J"
CImg.h:      "Z2Z 9\\ .Z /Z!Z,\\>Z>[(Z(Z!]GZH^'[ N[0\\  1X  2\\ ?X ?[ M\\ @X    DX 4Z?U -Z 'W4W G~W   :]>X   GTDY#U s @[D[  7"
CImg.h:      " !Z  >Z !Z !Z \"Z :Z$[(Y;ZFY)Z MZ-Z MZ/[ N[/[ N[/Z MZ Eg F[EX2[*Z(Z#Z(Z$Z(Z$Y(Z 9Z 2Z9^ HY7_ G]8Y F^8Y F^8X D]8"
CImg.h:      "Y E]8Y F^8Y+^8~V/Y #~W M~W M~W M~W 7Y  Y  NX  Y 6Y-Z JX0X JY-Y LZ-Y MY-Z MY-Y LZ-Y   BYDXAY KY0X HY0X GX0X GX0Y"
CImg.h:      " @ZCY ?Y.Y CYBY     5W9X8W.W HW-WAiAW,WA[3W.W9Y9W >X *ZCZ     6~d IYET   4~`,~i!| By EX.Y IX.X AYAZ 7ZFY IX    "
CImg.h:      "Y 8ZCZ     8i 6~d 5i ;Z HW>X3W?W0~T KZ-Z\"Z \"Z$[!Z  MZ 0[!Z'Z(Z :Z \"Z 4ZD] 4Z 2Y?XMX?Y(Y:ZHZ)Z N[!Z /[ NZ%Z6["
CImg.h:      "  J[ 7Y 9Z(Y DZDZ LZGW:WGZ K[GZ +Z -\\  LX  EX  IY        L\\6Y FY.Y KZ %Y-Y K~W 9Y 5Y.Y GY1Y 5Y  NX 0XM\\  MY "
CImg.h:      "FY3Y2Y+Y1Y KZ.Z JY.Y Y-X ;Y  Ji 4Y .Y1Y @YAY FYGWDXGX >` /YCY .[ $\\  LX  M\\ AR+`   CT9[:U'Z3X AY0Y FY9Z FY-Z "
CImg.h:      "D` .Y1Y >YEZ 6YAZ BY1Y&Z8X9[,ZAYAZ IY9Y IY@X@Y LY.Z Y-Y 5Y 5Z/Y KZ1Z 9[ -Z /Z\"[+[>Z>[(Z(Z ^IZJ_&[ NZ.\\  2X  3"
CImg.h:      "\\ >X >[ \\ ?X    DX 4Z?U -Z 'X6X G~W   9^@X   GUDY$T Ns ?[CZ  8X  %U?WAY?U     ,X        EY1Y 1WEW       \"s 4"
CImg.h:      "ZCZ 7W7UGV LX)X MW7UGW CY 8~T J~T I~S J~T I~T K~T*~ ;Z  IZ !Z  Z !Z  >Z !Z !Z \"Z :Z$[(Y:ZGY)[ NZ-Z N[.Z N[/[ N"
CImg.h:      "  Y 6Y-Z JX0X JY-Y LZ-Y MZ.Z MY-Y KY-Y   BYDW@Y KY0X HY0X GX0X GX0Y ?YDZ ?Y.Y BYDY     4W9X9X.W HW-XC\\L[BW,WB["
CImg.h:      "Z6\\GY   7Y  CY    JX    Nl   \"X 2Y/Z 4Z '\\  :Z M~Z %Z I[0Z 6Z 8Z/Z \"Z     5i 9~d 8i 8Z HW>X3W?W0~U LZ-Z\"[ "
CImg.h:      "HXCWHY ?b /YDY /[ ![  MX  M[ @Q%W   ?T9\\;U'Z3X AY0Z GX8Z FY-Z E\\ )Y1Y =XEY 6Z@Y BY1Y&Z9Y9[,ZAYAZ IY9Y IY@X@Y "
CImg.h:      "LY.Z Y-Y 5Y 4Y/Y KZ0Z ;[ ,Z /[#Z*\\?Z?\\(Z(Z N`LZL`$Z NZ-\\  3X  4\\ JPCXCP J[\"\\ >X    DX 4Z?U -Z 'X6X G~W   "
CImg.h:      "T J~U K~T*~ ;[  JZ !Z  Z !Z  >Z !Z !Z \"Z :Z$Z'Y9YGY)[ [-[ [.Z N[.Z NZ.[ NZ G\\L[ GZGX0Z)Z(Z#Z(Z$Z(Y#Z)Z 9Z 2~ "
CImg.h:      "GY4] J[4Y G[4Y G[4X EZ4Y FZ4Y G[4Y,[4X 1Y #Y  Y  Y  Y  9Y  Y  NX  Y 6Y-Z JX0X JY-Y LZ-Y MZ.Z MY-Y KY-Y   BYEW?Y"
CImg.h:      " KY0X HY0X GX0X GX0Y ?YDY >Y.Y BYDY     4W9X9W-X JX,WD\\J[CW,WC[2W-X JX >X )YDZ     5~d HXFU   4~_+~i z @w DX.Y"
CImg.h:      " M~Z %Z I[0Z 6Z 8Z/Z \"Z     2i <~d ;i 5Z HW>X3W@W/~U LZ-[#[ #Z$Z Z  MZ /Z!Z'Z(Z :Z \"Z 4ZB] 6Z 2Y>a>Y(Y9ZIZ)[ "
CImg.h:      "Z Z .Z [%Z4Z  JZ 7Y 9Z)Z DZEZ JYHX:XIZ KZD[ -Z /\\  JX  EX  IY        MZ3Y FY.Y JY %Z/Z JY  <Y 5Y.Y GY1Y 5Y  NX"
CImg.h:      " EY-Y E[ 'Y1Y =YFY 6Z@Z CY1Y&Z9Y9Z+ZAYAZ IY9Y IY@X@Y LZ/Z Y-Y 5Y 4Y0Z KZ0Z <[ +Z .Z$[)\\@Z@\\'Z(Z M~Q#Z [,\\  4"
CImg.h:      "X  5\\ JRDXDR J[$\\ KQCXDQ   #Y 4Z?U -Z &X8X F~W   7_EY   EUDY&U Ns <ZCZ  :X  $U@W?XAU     +X        EY1Y 1WEW "
CImg.h:      "      \"s 6ZCZ 7X8UEV MX)X MW7UFW DZ 8~U L~V K~U L~V K~U K~U+~ :Z  JZ !Z  Z !Z  >Z !Z !Z \"Z :Z%['Y9ZHY(Z [-[ Z"
CImg.h:      "-[ Z-Z [-Z [ H\\J[ HZHY1[)Z(Z#Z(Z$Z(Y#Z)Z 9Z 2} FY2\\ KZ3Y GZ3Y GY3Y FZ3Y GZ3Y GZ3Y,Z3X 1Y #Y  Y  Y  Y  9Y  Y  "
CImg.h:      "NX  Y 6Y-Z JX0X JY-Y KY.Z MZ.Z MY-Y KY-Y   BYFX?Y KY0X HY0X GX0X GX0Y >YEY >Y.Y BYEZ     4X:X9W,W JW+WE\\H[EX,X"
CImg.h:      "X8Z4\\JY   6Z  DY    JX        4X 1Z0Y 3Z )\\  8Z M~Z %Z I[0Z 7Z 7Z/Z \"Y     /i >~d >i 2Z GV>X3W@W0~V LZ-[\"Z "
CImg.h:      "#Z%[ Z  MZ /[\"Z'Z(Z :Z \"Z 4ZA] 7Z 2Y>a>Y(Y9ZIZ(Z Z Z .[![%Z4[  KZ 7Y 9Z)Z CZFZ JZIX:XIZ L[CZ -Z /[  IX  DX  J"
CImg.h:      "Y-Y 5Y 4Y0Z LZ.Y =[ *Z .[%Z(]AZA]'Z(Z L~\"[![+\\  5X  6\\ JTEXET J[&\\ KSDXES   $Y 3Y?U -Z &Y:Y F~W   5_GX   DU"
CImg.h:      ",~P :Z  JZ !Z  Z !Z  >Z !Z !Z \"Z :Z%['Y8ZIY(Z Z+Z Z-[![-[![-[![ I\\H[ I[JY0[(Y(Z#Z(Z$Z)Z#Z)Z 9Z 2| EY1\\ LY2Y "
CImg.h:      "HZ2Y HZ3Y FY2Y GY2Y GY2Y-Z2X 1Y #Y  Y  Y  Y  9Y  Y  NX  Y 6Z.Y IX0X JY-Y KY.Z MZ.Z MY-Y KY.Z   BYGX?Z KY1Y HY0X"
CImg.h:      "Z HZ0Z 7Z 7Y.Z #Z     ,i A~d Aj 0Z GV=W4X@W0~W MZ-[\"[ $Z%[ Z  MZ /[\"Z'Z(Z :Z \"Z 4Z@] 8Z 2Y>`=Y(Y8ZJZ([\"[ Z "
CImg.h:      " EZ.Y FZ %Y1Y <XGY 6Z>Y CY1Y&[:Z:Z+ZAYAY HY9Y IY@X@Y LZ/Y NZ.Y 5Y 4Y0Y KZ.Z ?\\ *Z -['['\\AZB]&Z(Z K|![!Z)\\  6"
CImg.h:      "X  7\\ JVFXFV J[(\\ KUEXFU   %Y 3Y?U -Z %Y<Y /Z    M`KY   BUC[=SAU   CZCZ  <X  #UAW>XCU     *X        EY1Y 1WEW"
CImg.h:      "          F[CZ 6X8UDV NW)X MX8UDW DY 8~W N~W L~W M~V L~W M~W-~P :[  KZ !Z  Z !Z  >Z !Z !Z \"Z :Z%['Y8ZIY([\"[+["
CImg.h:      "\"[,Z![-[!Z,[!Z I\\F[ J[KY/Z'Z)Z#Z)Z#Z)Z#Z)Z 9Z 2{ DY0[ MY1Y HY1Y HY2Y FY2Y HZ2Y HY1Y-Y2Y 1Z $Y  Y  Y  Z  :Y  Y"
CImg.h:      "BZ >W?W;W8Z2\\MY   4Y  DY    JX        4X 1Z1Z 3Z +\\  6Z M~Z %Z HZ0Z 8[ 7Y.Z #Z     )i D~d Ci -Z GV=W4XAW/~W M"
CImg.h:      "Z-[\"[ $Z&[ NZ  MZ .Z\"Z'Z(Z :Z \"Z 4Z?] 9Z 2Y=_=Y(Y8ZJZ([\"[ Z -Z\"[$Z3[  L[ 8Y 9Z)Z BZHZ IZJX8XJY LZ@[ /Z 1\\"
CImg.h:      "Y IY@X@Y LZ/Y NZ/Z 5Y 3Y1Y KY-Z ?[ )Z -[([%]CZC]%Z(Z Jy M[#[(\\  7X  8\\ JXGXGX J[*\\ KWFXGW   &Y 3Y?U -Z %Z>Z "
CImg.h:      " 9Z 2z CY/Z MY1Y HY2Z HY2Y GY1Y HY1Y HY1Y-Y2Z 2Z $Z !Z !Z !Z  :Y  Y  NX  Y 6Z.Y IX0X JZ/Z KY.Z LY.Y LZ/Z KY.Z  "
CImg.h:      "Y1Z 3Z ,\\  5Z M~Z %Z HZ0Z 8Z 6Y.Z #Z     &i G~d Fi )X FV=X5XAW0~Y NZ-[!Z $Z&[ NZ  MZ .[#Z'Z(Z :Z \"Z 4Z>] :Z 2"
CImg.h:      "Y=_=Y(Y7ZKZ'Z#[ NZ -[#[$Z2[  M[ 8Y 9Z)Z BZHZ HYJX8XKZ M[?Z /Z 2\\  GX  CX  KY        NY1Y FZ0Z JZ %Y/Z JZ  =Y 4"
CImg.h:      "%Z(Z Iw L[#['\\  8X  9\\ JZHXHZ J[,\\ KYGXHY   'Y 3Z@U -Z $[B[ .Z  NW $j   @UCpBU   @[D[  ?X  \"UBW=XEU     )X "
CImg.h:      "Y7ZJY'[#Z)Z#[+[#[+[#[+[#[ K\\B[ K[MX.['Z*Z!Z*Z#Z)Z#Z)Z 9Z 2x AY.Z NY2Z HY2Z IY1Y GY1Y HY1Y HY2Z-X1Z 2Z $Z !Z !Z"
CImg.h:      "    1W?X &TAY ?W>W;W8Z0e   3Y  EZ    JX        5X /Z2Y 2Z -\\  4Z M~Z %Z HZ0Z 8Z 6Z/Z $Z     #j J~d Ii   CW>X6Y"
CImg.h:      "BX0~Y NZ-[![ %Z'\\ NZ  MZ -Z#Z'Z(Z :Z \"Z 4Z=] ;Z 2Y<]<Y(Y7ZKZ'[$[ NZ -[$[#Z1Z  M[ 8Y 8Z*Z BZIZ GZKX8XKZ N[>[ 0"
CImg.h:      "HY9Y IY@X@Y LZ/Y MY/Z 4Y 4Y2Y KZ,Z B[ 'Z +[+[#_FZF_$Z(Z Gt JZ$[%\\  9X  :\\ J\\IXI[ I\\/\\ K[HXI[   (Y 3Z@U -Z "
CImg.h:      "  3Z M~Z &Z FY1Z 8[ 6Z/Z $Z      i L~d Li   @W>Y7YBW0Z*Y NZ-[![ %Z'[ MZ  MZ -[$Z'Z(Z :Z \"Z 4Z<] <Z 2Y<]<Y(Y6ZL"
CImg.h:      "[%[$\\  :X  ;\\ H\\JXJ\\ H\\1\\ J\\IXJ\\   (Y 3Z@U -Z &x 0Z  X  c   <UAmDV   =[CZ  AX  !VDW<YHU     (X        E"
CImg.h:      "Y6ZKY&[%[)\\&[)[%[)[%[)[%[ L\\>[ Ld.[&Z*Z!Z*Z\"Z+[\"Z+Z 8Z 2s <Y-Y NX1Z IY1Z IY2Z GY2Z HY2Z HX1Z.Y1Z 1Z $Y  Y  "
CImg.h:      "W/Z*Z Z-Z N[ &Z(\\ MZ  MZ -\\%Z'Z(Z :Z \"Z 4Z;] =Z 2Y<]<Y(Y6ZLZ&[&[ MZ ,\\'[\"Z0Z  NZ 7Y 8Z+Z @ZJY FZLX6XLY N[;"
CImg.h:      "Y GY9Y IY@XAZ L[1Y LZ1Z 3Y 3Y3Y LZ*Z D[ &Z *[-[ aJZJa\"Z(Z Cl F\\'[\"\\  ;X  <\\ F\\KXK\\ F\\3\\ H\\JXK\\   'Y "
CImg.h:      "2ZAU -Z 'z 1Z  X  Na   ;V@jDV   :ZCZ  BX   UDW;XIU     'X        EY2Z 1WEW          KZCZ 3X9U@V\"W*X LX9VAW H[ "
CImg.h:      "[,[\"Z+Z!Z+Z 8Z 2n 7Y-Y NX1Z IY2[ IY2Z GY2Z HY2Z IY2[.Y2\\ 2Z $Z !Z !Z !Z  ;Y  Y  NX  Y 5Z0Y HX0X IZ1Z IY0Z KZ0"
CImg.h:      "   -dIQId%kKRKk El 2j >X.Y HY2Y CY;Z 7ZMZ BZ                   #Z        3X@X %TAX @W<W;W7Z/a   0Y  FY    IX   "
CImg.h:      "     6X -Z4Z 2Z 0\\  2[ )Z  JZ FZ2Z 8Z 5Z/Z %Z      Hi   @j   :V=Y9ZDX/Z*Z Z-Z N\\ 'Z)\\ LZ  MZ ,[%Z'Z(Z :Z \"Z"
CImg.h:      "/[ MdNZNd!Z(Z Ag B['[!\\  <X  =\\ D\\LXL\\ D[4\\ F\\KXL\\   &Z 3ZAU -Z (| 2Z  X  L^   9V?fBU   8ZCZ  CX   V JV "
CImg.h:      " !Z \"Z :Z)\\$Y5ZLY%[(\\'\\(['\\(['['['[(\\ M\\:[ Ma-[$Z,Z NZ,Z![,Z!Z,[ 8Z 2Z #Y-Y NX2[ IY2[ IY2Z GY3[ HX2[ IY2"
CImg.h:      "         $[,P       )W?X %TBY AX<W;W7[/_   /Y  FY    IX        6X -Z5Z 1Z 1\\  1Z (Z  K[ EY2Z 9Z 4Z0[ &[      F"
CImg.h:      "j   Ei   7W=Y;[EX/Z(Z!Z.[ M[!P'Z*] LZ  MZ ,\\&Z'Z(Z :Z \"Z 4Z9] ?Z 2Y;[;Y(Y4YMZ%[)\\ LZ +\\)[!Z/Z  Z 7Y 7Z-[ ?Z"
CImg.h:      "XM\\   %Z 3ZAU -Z )~ 3Z  X  J]   9V>a@V   7YBY  CX   NV LV              BZ3Z 1WEW          LYBY 2W8U?V#W+X KX9U"
CImg.h:      "[ N`-[#Z,Z NZ,Z Z-[![-[ 8Z 2Z #Y-Y NX2[ IY2[ IY3[ GY3[ HY3[ HX2[.Y3^ 2Z $Z !Z !Z !Z  <Y  Y  NX  Y 4Z2Z HX0X HZ2"
CImg.h:      "$Z  HYNU   +aHSH`!hJRIg Bi /g <X.Y GY4Y CZ:Y 6YMY @[                   $Z-Q       )W?W $TBY AW;W<X6Z.]   .Y  GY"
CImg.h:      "    HX        6X -Z5Z 1Z 2\\  0Z (Z  L[ DZ4Z 8Z 4[1Z %Z      Bj   Ki   4W=Z=\\GY.Z(Z!Z.[ M\\#Q'Z+] KZ  MZ +\\'Z"
CImg.h:      "'Z(Z :Z \"Z 4Z8] @Z 2Y:Y:Y(Y4ZNZ%\\*[ KZ *\\+\\!Z/[ \"[ 7Y 7Z-Z >ZMZ DZMW4WMZ![7Z 3Z 7\\  BX  AX  MY        NY3"
CImg.h:      "[ F\\4Z FZ &Z3\\ HZ  ?Y 3Z4\\ GY1Y 5Y  NX 0X@[ *Y FY3Y2Y+Y1Y HZ3Z H\\4Z KZ3[ ;Y  5Y 9Y -Y4[ ;YKY >YNX=WNY D[D[ "
CImg.h:      "Y6Z LZ(Z H\\ $Z (\\3[ I~R MZ(Z :Z ;\\+\\ MY  ;X  ;X @\\NXN\\ @X1X B\\MXN\\   $Z 2ZBU -Z *~Q 4Z  X  I]   :W9U;V "
CImg.h:      "Z  Z !Z  >Z !Z !Z \"Z :Z+]#Y4ZMY$[*\\%\\*[%\\+\\%\\+\\%\\+\\ N\\6[ N^-\\#[.[ N[.[ [.Z NZ-Z 7Z 2Z #Y-Y NY4\\ IY3"
CImg.h:      " GZ5[ GZ5\\ :YMY :\\4Z ;XMZ     +Y@X@Y#Z)Z\"Y(Y\"Y(Y#Z)Z 9X %ZMZ     %Z  F_   )^GSG^ NfIRHe @g -e ;X.Y GZ6Z CY9"
CImg.h:      "Z 9[ 3Z2[ &Z      >i   i   2W<Z?]HZ.Y'Z!Z/\\ L\\&S'Z,] JZ  MZ *\\(Z'Z(Z :Z \"Z 4Z7] AZ 2Y JY(Y3e$\\,\\ KZ )\\-"
CImg.h:      "Y FY3Y2Y+Y1Y HZ4Z G\\4Z JZ5\\ ;Y  6Y 8Y -Y5\\ ;YKY =XNX=WNY E[B[ 3YNY 4[  BY  X  Y      N_=_ LZ:_ CZ2Y FX;Y >Z4"
CImg.h:      "Z EY #Y1Y 9XNZ 7Y6Z GZ4[$Z=]=['ZDYDZ FY9Y HZBXBZ K]5Z J[5[ 2Y 2Z7Y L[(Z H[ #Z '\\5[ F~ LZ(Z :Z :\\-\\ KW  :X  :"
CImg.h:      "V >r >V/V @s   #Z 2[CU -Z +[MeL[ 5Z  X  G\\   :W!V   3W@W     7V!W              AZ4[ 1WEW          LW@W 1W7s,X-"
CImg.h:      "Y JX8t$\\ 7Z'Z%Z'Z$Z'Y%Z'Z$Z'Y%Z'Z4Z1Z 6\\&S NZ !Z  Z !Z  >Z !Z !Z \"Z :Z,]\"Y3ZNY$\\,\\#\\,\\$\\,\\$\\-\\$\\,"
CImg.h:      "\\ N\\4[ ]-\\![/Z LZ/[ N[/[ N[/[ 7Z 2Z #Y-Y NY4\\ HY5] IY4\\ GY4\\ HY4\\ HY4\\.Z5` 2Z $Z !Z !Z !Z  =Y  Y  NX  Y "
CImg.h:      "X $YMY     %[  F^   '\\FSF\\ LcGRGc >f ,c :X.Y FZ7Y BY8Y 7e >[                   %[1S   -Y   'X@X ;Q:TCZ CX:X=X"
CImg.h:      "  AX  MY        NY5] F]6Z DZ &Z5] G[  AY 2[8^ GY1Y 5Y  NX 0X>[ ,Y FY3Y2Y+Y1Y H[6[ G]6Z IZ5\\ ;Y  6Y 8Y -Z6\\ ;Z"
CImg.h:      "IZ5Z 1Y 1Y8Z LZ&Z J[ \"Z &\\8] E| KZ(Z :Z :]/] JU  9X  9T <p <T-T >q   \"Z 1ZCU -Z ,[JaI[ 6Z  X  F\\   :W#V   1"
CImg.h:      "V?V     7W#W              @[5[ 1WEW          LV?V 1X7s,W-Y JX7t%\\ 6Z&Z&Z'Z%Z&Z&Z'Z%Z&Z&Z&Y4Y0Z 5\\(T NZ !Z  Z "
CImg.h:      "!Z  >Z !Z !Z \"Z :Z.^!Y3e#\\.\\!\\.\\#].\\#]/]#\\.\\ N\\2[ ]/]![0[ L[0[ M[0[ N\\1[ 6Z 2Z #Y-Y NY5] HY5] IZ6] GY"
CImg.h:      "5] HY5] HY5]-Y5a 3[ %[ \"[ \"[ \"[  >Y  Y  NX  Y 3Z5[ GX0X GZ5Z F[6[ G[6[ GZ5Z F[5Z 5\\ 4^9Z FY6\\ FY6\\ FY6\\ "
CImg.h:      "FY6] 9c 9]6Z :d     )[CXBZ Z-Z NZ-[ [-Z Z-Z 7X $YNZ     %Z  D]   $VCSDW G`FSG` ;d +c :X.Y F[9Z CZ8Y 6d =\\     "
CImg.h:      "              '\\3T   -Z   (W?X ;S<TDZ BW8W=W4\\1`   0Y  HY    HX  NZ    GZ 'X *Z9Z /Z 5\\  0\\ 'Z  N\\ B[8[ 8Z"
CImg.h:      " 2\\5[ '[ /Z \"[  >d   c  @Z EW<_Ks-Z&Z\"Z1] J^,V'Z/_ IZ  MZ )]*Z'Z(Z :Z \"Z 4Z5] CZ 2Y JY(Y2d#]0\\ IZ (]1] NZ-"
CImg.h:      "Z NS*\\ 6Y 6[1[ <e Bc4c\"[3Z 5Z 9\\  @X  AX  MY        NZ6] F^8[ D[ &Z7^ G[  AY 1[:_ GY1Y 5Y  NX 0X=[ -Y FY3Y2Y"
CImg.h:      "1[DU -Z -[F\\F[ 7Z  X  E\\   :W&W   /U>U     6W%W              ?[6\\ 1WEW          LU>U 0W6s-X.X HW6t&\\ 5Z&Z'Z"
CImg.h:      "2[ L[1[ 6Z 2Z #Y.Y MZ7^ HY6^ HY6] GZ6] HZ7^ HZ7^-Y6c 3[ %[ \"[ \"[ \"[  ?Y  Y  NX  Y 3[7[ FX0X G[7[ E[7[ FZ7[ F"
CImg.h:      "\\ 9b )a 9X.Y E[<[ BY7Z 7c ;\\                   '\\5U   -Z   (W?W :U>TE[ CX8X?X3\\3b   1Y  IY    GX  NZ    GZ ("
CImg.h:      "X )[;[ /Z 5[ %Q-\\ &Z BQ/] AZ9\\ 9Z 0[6\\ (\\ /Z \"[  ;a   `  =Z EX<nNd,Z$Y\"Z2] H^.W'Z2a HZ  MZ (^,Z'Z(Z :Z \""
CImg.h:      "Z 4Z4] DZ 2Y JY(Y2d\"]3^ IZ ']3] MZ-[ U-] 6Y 5\\4\\ ;d Bb2b#[2[ 6Z :\\  ?X  @X  NY        MZ8^ F^8Z B[ '[9_ F[,"
CImg.h:      "P 7Y 1\\<` GY1Y 5Y  NX 0X<[ .Y FY3Y2Y+Y1Y G[8[ F^9[ G[9^ ;Y *Q/Z 7Y -Z9^ :YMY <a;` F[>[ 4b 6[  ?Y  X  Y        "
CImg.h:      "(Z :Z 8]3] FQ  7X  7P 8l 8P)P :m    Z 0[EU -Z .[?P?[ 8Z  X  D[   9W(W   -T<S     5X)X              >\\8] 1WEW  "
CImg.h:      "        LS<T 0W5s-W.X HX6t'\\ 5Z$Y'Z%Z'[%Z(Z%Z&Z%Z(Z%Z6Z0Z 4^.W NZ !Z  Z !Z  >Z !Z !Z \"Z :Z2a Y2d\"^3] N]3^ ]3"
CImg.h:      "] N]3] N]3] \\.[!^3] M\\4\\ J\\4\\ K\\4\\ L\\4\\ 5Z 2Z #Y.Y MZ8_ HZ8_ HZ8^ FZ8^ HZ8_ HZ8_-Z8e-Q)\\ &\\-Q G\\-Q "
CImg.h:      "G\\-Q G\\-Q 5Y  Y  NX  Y 2[9\\ FX0X F[9[ D\\9[ E[8[ E[9[ D\\9[ 4\\ 3[9[ EZ9^ FZ9^ FZ9^ F[9^ 9b 8^9[ 8b     &[2["
CImg.h:      "-Z   )X@X :W@TF[ BW7X?X3]6e   1X  IY    GX  NZ    GZ (X ([=[ .Z 6[ $S1^ &Z BS3^ @\\<\\ 8Z 0]9] FR6] .Z \"[  8^ "
CImg.h:      "Y/Z LZ:` H[:` H[:_ FZ:` GZ:` GZ:`-[:YN\\0S(\\4Q C\\0S F\\0S F\\0S F\\0S 5Y  Y  NX  Y 1[:[ EX0X F\\;\\ C\\;[ C[:"
CImg.h:      "@[    @T  JT  _ %] 7X.Y D^D^ BZ6Y 6b 9_                   *];X   -Z   )X@X :ZCTH] CX7YAX1^:h   2Y  JY    GX  NZ"
CImg.h:      "    GZ (X (\\?\\ .Z 7\\ $W7_ %Z BV8` ?\\>] 9[ /];] ET9] -Z \"[  5[   [  8Z DX;jLb*Z$Z#Z7a E`7\\'Z9f FZ  MZ &`4^"
CImg.h:      "        -_?Z   -Z   )W?X :^GTK_ CX5XAX0_>k   3Y  JX    FX  NZ    GZ )Y ']C] ?} I~S IZ=b %Z BZ>a =]B^ 8Z ._?^ DX"
CImg.h:      "   ?U  KT  M\\ #[ 6X.Y Bu AY5Z 7a 6f                   2aE]   -Z   )W?W 9~ BW4YCY/bFp   3X  KY    FX  NZ    GZ "
CImg.h:      ")X %^G^ >} I~S I~ $Z B| ;^F_ 7Z -aEa Dv +Z \"[  0V   U  2Z CX9dI^'Z\"Z$~S AfGd'~U C~S FZ $gGg&Z(Z :Z \"Z 4Z0] H"
CImg.h:      "Z 5dGd   )X    Jd   \"e    KZ -`MUKY H~U IU&U 6Z  X  AY   5Z7Z          LZ7Z     ;~d       3cFk 8WEW           "
CImg.h:      "      dLd CdMd BdLd CdLd DeMd 2X !`     %X  =Y    ?U  LV  MZ !Y 5X.Y As AZ4Y 6` 5~]                  )x   -Z   "
CImg.h:      "*X@X 9} BX3YFZ-{L]   4Y  LY    FX  NZ    GZ )X $t >} I~S I} #Z B{ :v 7[ ,{ Cu *Z \"[  -S   S  0Z BW8aG[%[\"Z$~R"
CImg.h:      "Y FYNr ;u AqMY B{ 7Y -oLY GY1Y 5Y  NX 0X7\\ 4Y FY3Y2Y+Y1Y Cv BYNr ArMX ;Y *y 2j >qMY 8a 8^9^ I[6Z 5^ 6~P 2Y  X "
CImg.h:      " (v   ,Z   *X@X 9| AW1[K[+yJ]   5Y  LX    EX  NZ    GZ )X #r =} I~S I| \"Z Bz 8t 6Z *y Bt )Z \"[  *P   P  -Z BX"
CImg.h:      "DX KV*W0o-W KW%[ 1Z Z,Z!Z+Z Z,Z!Z+Z Z,Z!Z;Z-~T'~P M~T J~T I~S I~S 7Z !Z !Z \"Z :~R GY.` K| B| C{ B{ B{ FS\"S$YM"
CImg.h:      "{ Bz @z B{ B{ 1Z 2Z #YIq GqLY EqLY EqLX CqMY ErMY EqLY*sF{$u ?{ B{ B{ B{ 5Y  Y  NX  Y -t AX0X Bu ;u <t <u ;u   "
CImg.h:      "    5Z AX  HZ Z%~ 9|$~P >~S FZ  ~P\"Z(Z :Z \"Z 4Z-] K~Q)Y JY(Y.` Jy AZ  x EZ)Z#~P 0Y /x 3_ =_0_%Z([ ;Z =~a AX  "
CImg.h:      "JV+X0o.X KW%Z 0Z Z-Z NZ,Z Z-[ Z,Z Z-[ Z<Z-~T&| K~T J~T I~S I~S 7Z !Z !Z \"Z :~P EY.` Iy @y @y @y @y DQ Q$YKy @x"
CImg.h:      " !Y        InKY FYKl 5r ?lJY >w 7Y )hIY GY1Y 5Y  NX 0X4\\ 7Y FY3Y2Y+Y1Y @p ?YKl ;lJX ;Y *v -h ;kJY 7_ 7]7\\ J[2"
CImg.h:      "JV+W/o/X JW&Z 0[ Z-Z NZ-[ [.Z NZ,Z NZ.Z NZ=Z,~T$x I~T J~T I~S I~S 7Z !Z !Z \"Z :| BY-_ Hv <v =v =u =v   BXHu =v"
CImg.h:      " 9lJX AlJX AlJX AlJY 5[ 5YKl /\\      Hp 8q 7p 7p 8q -X  N]      NP  9V    ?Y  X  KS  IS 2X.Y <h <Z2Y 6^ -~V   "
CImg.h:      "               $n   (Z   +X@X 1o =W-f$pB]   6X  NX    DX  Z    FZ *X  Nk 9} I~S Iw  LZ Bv 0m 4Z %q >p %Z \"Z   "
CImg.h:      "     4Z @X  JZ MZ&{ 3u z 9~S FZ  Lx MZ(Z :Z \"Z 4Z+] M~Q)Y JY(Y-_ Fr >Z  Lr BZ(Z!y -Y -s /] <^.]&[&[ <Z =~a AX "
CImg.h:      "   EW IV,X/o/W IW&Z 0Z MZ/[ NZ-Z MZ.Z N[.Z MZ.Z MZ>Z,~T\"t G~T J~T I~S I~S 7Z !Z !Z \"Z :y ?Y-_ Fr 8r 9r :s :r "
CImg.h:      "  AXEr :r 8r :s :s -Z 2Z #YIn AkIY BkIY BkIX @jIY BkIY BkIY'l=t Mq :t ;t ;t ;t 3Y  Y  NX  Y *m =X0X >m 3m 5n 5m"
CImg.h:      " 3m   6XLm 7iHX @iHX @jIX @jIY 5[ 5YJj -Z      El 3k 2l 3l 4l *X  N\\        5U    ?Y  Y  KR  HQ 1X.Y 9b 9Y1Z 7"
CImg.h:      "] )~S                  \"j   &Z   +X@X -h ;X+c!l?\\   6X  Y    DX  Z    FZ +X  Kh 8} I~S Fr  JZ As ,i 3[ $n ;m "
CImg.h:      "#Z \"Y        3Z ?X  KZ MZ&x -p Mu 4~S FZ  Js JZ(Z :Z \"Z 4Z*] N~Q)Y JY(Y-_ Dn <Z  Jn @Z([ Nt +Y +o ,\\ ;].]&Z$"
CImg.h:      "<i 0j 1j 1j 1j   5XIi 3fGX >fGX >fGX >fGY 4Y 4YHf +Z      Bg /g .g -g /g (X  M[        5T    ?Z !Z  JP   'X.Y 5"
CImg.h:      " $k  ` 7cFY 6] 5[5Z KZ-[ 8Y 3~P 2Y  X  Y        ;b=X NYJe 0` $e +l BY1Y 4Y 7Y*Y LYIaE[ b@a >k 9Y6_ Ah ;YFc 0e  "
CImg.h:      "FZ 2a D~i$~T FZ 3oDo @Z :Z(Z :Z )i    LX    CV    CW    DZ #h D~U   *Z  X -R9Z   #[          *[     *~d       3"
CImg.h:      "YIaE\\ 8WEW            GX HV-W-o0W HW'Z 0Z L[0Z LZ/[ LZ0Z LZ/[ LZ0Z LZ?Z+~T Lj B~T J~T I~S I~S 7Z !Z !Z \"Z :o "
CImg.h:      "5Y,^ Ai /h 0i 0i 0i   >W?i 1j 0j 1j 1i (Z 2Z #YGh 9cEY ?dEY ?dEX =dFY >dFY >cEY#d5j Ch 1j 1j 1j 1j -Y  Y  NX  Y"
CImg.h:      " &e 9X0X :e ,f -f -e ,f   4XFe 0cEX <bEX <bEX <bEY 4Y 4YFb )Z      ?` (a '` '` (a %X          'T               "
CImg.h:      "X J\\;] 9e  A^ =` 7YC] *_    G[                 >a             NU    CZ  N`        9X -T<[                     "
CImg.h:      "    9Y #X      :Y      EX  ?Q      8R    ?R  @Q    @R  MQ    =Y          DY       @R        -Q      <Z         "
CImg.h:      "  @Q        *Z    DY  X  Y          ;Y  <P  AQ  CQ  ;Y 4Y   *YAQ8P @Q0Q -Y  8X 7Y 3Y=Q  LQ                     "
CImg.h:      " JQ                 4Z  IU        3X -W@[                              KYAQ8P 1WEW   $U        IV  MW  LW  FZ  "
CImg.h:      "X 3Y                                          CZ  IU        3X -\\I_                              KY  8WEW   $V"
CImg.h:      "         CZ  IU        3X -q                              JY  8WEW   #V              &Z                  NV    "
CImg.h:      ":Y         8Y 4Y   *Y    1Y    EX 3Y                                          CZ  IU        3X -p              "
CImg.h:      "                                     CZ  IU        3X -o                              HY  8WEW   \"V           "
CImg.h:      "U        3X -n                              GY  8WEW   \"V              '[3Q                 <V                "
CImg.h:      "                      V          5b?c                     A[               -\\                     ?e   !f     "
CImg.h:      "   HZ /Y  AZ                 DWIX                                                                LT        &X -"
CImg.h:      "                     CZ  IU        3X                                5Y      -PDX              %v              "
CImg.h:      "                                          -_Me     %b            .Y  'X                /e    9c /X 0c          "
CImg.h:      "               5Y      -d              $u                 Je                                                   "
CImg.h:      "                   ?d                                               $d -Y  Ne                 Ad               "
CImg.h:      " 5s                     Cd                                                               ,v     %b            -"
CImg.h:      "            CZ  IU        3X                                5Y      -d              #t                 Jd      "
CImg.h:      "  %e -Y  Nd                 @c                                                                                 "
CImg.h:      "                     +u     $b            -Y  'X                0d    2^ /X 0_          1Y         8Y 4Y   *Y  "
CImg.h:      "-c              !q                 Hd                                                                      >c  "
CImg.h:      "X                                5Y      -c               Nm                 Fc                                "
CImg.h:      "                               CZ          &W                                5Y      -b               Lj       "
CImg.h:      "     3Y      -`               He                 A`                                                            "
CImg.h:    // Lock/unlock mutex for CImg multi-thread programming.
CImg.h:       \param format C-string containing the format of the message, as with <tt>std::printf()</tt>.
CImg.h:       \param command C-string containing the command line to execute.
CImg.h:       \return Status value of the executed command, whose meaning is OS-dependent.
CImg.h:       on Windows-based systems.
CImg.h:      return -1;
CImg.h:      } else return -1;
CImg.h:        return -1;
CImg.h:            const unsigned short val = *(--ptr);
CImg.h:            const unsigned int val = *(--ptr);
CImg.h:            const cimg_uint64 val = *(--ptr);
CImg.h:            unsigned char *pb = (unsigned char*)(--ptr), *pe = pb + sizeof(T);
CImg.h:            for (int i = 0; i<(int)sizeof(T)/2; ++i) swap(*(pb++),*(--pe));
CImg.h:      // use memcpy instead of assignment to avoid undesired optimizations by C++-compiler.
CImg.h:      const unsigned int v = u|(3U<<(8*sizeof(unsigned int)-2)); // set sign & exponent bit to 1
CImg.h:      // use memcpy instead of simple assignment to avoid undesired optimizations by C++-compiler.
CImg.h:      const unsigned int time_diff = (unsigned int)(*p_timer + milliseconds - current_time);
CImg.h:    // Custom random number generator (allow re-entrance).
CImg.h:      return val_min + (val_max - val_min)*val;
CImg.h:        const double x2 = cimg::rand(-1,1,p_rng);
CImg.h:        x1 = cimg::rand(-1,1,p_rng);
CImg.h:      return x1*std::sqrt((-2*std::log(w))/w);
CImg.h:      if (z<=1.e-10) return 0;
CImg.h:      const double y = std::exp(-z);
CImg.h:      return k - 1;
CImg.h:    //! Bitwise-rotate value on the left.
CImg.h:      return n?(T)((a<<n)|(a>>((sizeof(T)<<3) - n))):a;
CImg.h:    //! Bitwise-rotate value on the right.
CImg.h:      return n?(T)((a>>n)|(a<<((sizeof(T)<<3) - n))):a;
CImg.h:      return a>=0?a:-a;
CImg.h:      return std::log(x + std::sqrt(x*x - 1));
CImg.h:      return 0.5*std::log((1. + x)/(1. - x));
CImg.h:    //! Return base-2 logarithm of a value.
CImg.h:        sgn = val<0?-1:1,
CImg.h:        x = (1 - val)*(1 + val),
CImg.h:      return sgn*std::sqrt(-tt1 + std::sqrt(tt1*tt1 - tt2));
CImg.h:      return x>=0?std::pow((double)x,1./3):-std::pow(-(double)x,1./3);
CImg.h:      return (T)(cimg::type<T>::is_nan(x)?0:x<0?-1:x>0);
CImg.h:       \note This modulo function accepts negative and floating-points modulo numbers, as well as variables of any type.
CImg.h:      if (cimg::type<double>::is_finite(dx)) return (T)(dx - dm * std::floor(dx / dm));
CImg.h:    //! Return the min-mod of two values.
CImg.h:       - <i>minmod(\p a,\p b) = min(\p a,\p b)</i>, if \p a and \p b have the same sign.
CImg.h:       - <i>minmod(\p a,\p b) = 0</i>, if \p a and \p b have different signs.
CImg.h:       \param rounding_type Type of rounding operation (\c 0 = nearest, \c -1 = backward, \c 1 = forward).
CImg.h:      const double sx = (double)x/y, floor = std::floor(sx), delta =  sx - floor;
CImg.h:      for (int i = n; i>=n - k + 1; --i) res*=i;
CImg.h:      return (char)((x<'A'||x>'Z')?x:x - 'A' + 'a');
CImg.h:      return (double)((x<'A'||x>'Z')?x:x - 'A' + 'a');
CImg.h:    //! Convert C-string to lower case.
CImg.h:      return (char)((x<'a'||x>'z')?x:x - 'a' + 'A');
CImg.h:      return (double)((x<'a'||x>'z')?x:x - 'a' + 'A');
CImg.h:    //! Convert C-string to upper case.
CImg.h:    //! Return \c true if input character is blank (space, tab, or non-printable character).
CImg.h:    //! Read value in a C-string.
CImg.h:       \param str C-string containing the float value to read.
CImg.h:       \note Same as <tt>std::atof()</tt> extended to manage the retrieval of fractions from C-strings,
CImg.h:    //! Compare the first \p l characters of two C-strings, ignoring the case.
CImg.h:       \param str1 C-string.
CImg.h:       \param str2 C-string.
CImg.h:       \note This function has to be defined since it is not provided by all C++-compilers (not ANSI).
CImg.h:      if (!str1) return str2?-1:0;
CImg.h:      int k, diff = 0; for (k = 0; k<l && !(diff = lowercase(*nstr1) - lowercase(*nstr2)); ++k) { ++nstr1; ++nstr2; }
CImg.h:    //! Compare two C-strings, ignoring the case.
CImg.h:       \param str1 C-string.
CImg.h:       \param str2 C-string.
CImg.h:       \note This function has to be defined since it is not provided by all C++-compilers (not ANSI).
CImg.h:      if (!str1) return str2?-1:0;
CImg.h:       \param str C-string.
CImg.h:      if (is_ending) std::strcpy(str + nl - 5,"(...)");
CImg.h:        const unsigned int ll = (nl - 5)/2 + 1 - (nl%2), lr = nl - ll - 5;
CImg.h:        std::memmove(str + ll + 5,str + ls - lr,lr);
CImg.h:       \param str C-string.
CImg.h:       \param res output C-string.
CImg.h:        std::strncpy(res,str,nl - 5);
CImg.h:        std::strcpy(res + nl -5,"(...)");
CImg.h:        const unsigned int ll = (nl - 5)/2 + 1 - (nl%2), lr = nl - ll - 5;
CImg.h:        std::strncpy(res + ll + 5,str + ls - lr,lr);
CImg.h:    //! Remove delimiters on the start and/or end of a C-string.
CImg.h:       \param[in,out] str C-string to work with (modified at output).
CImg.h:      if (is_symmetric) for (p = 0, q = l - 1; p<q && str[p]==delimiter && str[q]==delimiter; ) {
CImg.h:          --q; ++p; if (!is_iterative) break;
CImg.h:        for (q = l - 1; q>p && str[q]==delimiter; ) { --q; if (!is_iterative) break; }
CImg.h:      const int n = q - p + 1;
CImg.h:    //! Remove white spaces on the start and/or end of a C-string.
CImg.h:      if (is_symmetric) for (p = 0, q = l - 1; p<q && is_blank(str[p]) && is_blank(str[q]); ) {
CImg.h:          --q; ++p; if (!is_iterative) break;
CImg.h:        for (q = l - 1; q>p && is_blank(str[q]); ) { --q; if (!is_iterative) break; }
CImg.h:      const int n = q - p + 1;
CImg.h:       \param[in,out] str C-string to work with (modified at output).
CImg.h:    //! Replace escape sequences in C-strings by character values.
CImg.h:       \param[in,out] str C-string to work with (modified at output).
CImg.h:            val = (unsigned char)(*(ns++) - '0');
CImg.h:            if (*ns>='0' && *ns<='7') (val<<=3)|=*(ns++) - '0';
CImg.h:            if (*ns>='0' && *ns<='7') (val<<=3)|=*(ns++) - '0';
CImg.h:              val = (unsigned char)(c<='9'?c - '0':c - 'a' + 10);
CImg.h:                (val<<=4)|=(c<='9'?c - '0':c - 'a' + 10);
CImg.h:          case 'u' : { // UTF-8 BMP
CImg.h:              c1 = (c1<='9'?c1 - '0':c1 - 'a' + 10);
CImg.h:              c2 = (c2<='9'?c2 - '0':c2 - 'a' + 10);
CImg.h:              c3 = (c3<='9'?c3 - '0':c3 - 'a' + 10);
CImg.h:              c4 = (c4<='9'?c4 - '0':c4 - 'a' + 10);
CImg.h:          case 'U' : { // UTF-8 astral planes
CImg.h:              c1 = (c1<='9'?c1 - '0':c1 - 'a' + 10);
CImg.h:              c2 = (c2<='9'?c2 - '0':c2 - 'a' + 10);
CImg.h:              c3 = (c3<='9'?c3 - '0':c3 - 'a' + 10);
CImg.h:              c4 = (c4<='9'?c4 - '0':c4 - 'a' + 10);
CImg.h:              c5 = (c5<='9'?c5 - '0':c5 - 'a' + 10);
CImg.h:              c6 = (c6<='9'?c6 - '0':c6 - 'a' + 10);
CImg.h:              c7 = (c7<='9'?c7 - '0':c7 - 'a' + 10);
CImg.h:              c8 = (c8<='9'?c8 - '0':c8 - 'a' + 10);
CImg.h:    // Convert filename as a Windows-style filename (short path name).
CImg.h:       \param mode C-string describing the opening mode.
CImg.h:      if (*path=='-' && (!path[1] || path[1]=='.')) {
CImg.h:          if (setmode(_fileno(res),0x8000)==-1) res = 0;
CImg.h:          if (_setmode(_fileno(res),0x8000)==-1) res = 0;
CImg.h:    // Get the file or directory attributes with support for UTF-8 paths (Windows only).
CImg.h:       \return File size or '-1' if file does not exist.
CImg.h:      if (!file) return (cimg_int64)-1;
CImg.h:    //! Get last write time of a given file or directory (multiple-attributes version).
CImg.h:                      Replaced by read attributes after return (or -1 if an error occurred).
CImg.h:#define _cimg_fdate_err() for (unsigned int i = 0; i<nb_attr; ++i) attr[i] = (T)-1
CImg.h:      int res = -1;
CImg.h:      if (!path || !*path) { _cimg_fdate_err(); return -1; }
CImg.h:                        attr[i]==6?ft.wSecond:-1);
CImg.h:                      attr[i]==6?ft.tm_sec:-1);
CImg.h:    //! Get last write time of a given file or directory (single-attribute version).
CImg.h:       \return Specified attribute or -1 if an error occurred.
CImg.h:    //! Get current local time (multiple-attributes version).
CImg.h:                           Replaced by read attributes after return (or -1 if an error occurred).
CImg.h:      int res = -1;
CImg.h:                    attr[i]==7?st.wMilliseconds:-1);
CImg.h:        res = (int)(attr[i]==0?st->tm_year + 1900:
CImg.h:                    attr[i]==1?st->tm_mon + 1:
CImg.h:                    attr[i]==2?st->tm_mday:
CImg.h:                    attr[i]==3?st->tm_wday:
CImg.h:                    attr[i]==4?st->tm_hour:
CImg.h:                    attr[i]==5?st->tm_min:
CImg.h:                    attr[i]==6?st->tm_sec:
CImg.h:                    attr[i]==7?_st.tv_usec/1000:-1);
CImg.h:    //! Get current local time (single-attribute version).
CImg.h:       \return Specified attribute or -1 if an error occurred.
CImg.h:    //! Split filename into two C-strings \c body and \c extension.
CImg.h:      const unsigned int l = (unsigned int)(p - filename);
CImg.h:        to_read-=l_al_read;
CImg.h:        to_write-=l_al_write;
CImg.h:       \param filename Filename, as a C-string (can be \c 0 if \c file is set).
CImg.h:        visu = cimg::option("-h",argc,argv,(char*)0,(char*)0,false)!=0;
CImg.h:        visu |= cimg::option("-help",argc,argv,(char*)0,(char*)0,false)!=0;
CImg.h:        visu |= cimg::option("--help",argc,argv,(char*)0,(char*)0,false)!=0;
CImg.h:          res = (k++==argc?_default:(k==argc?argv[--k]:argv[k]));
CImg.h:        if (visu && usage) std::fprintf(cimg::output(),"    %s%-16s%s %-24s %s%s%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Operating System:         %s%-13s%s %s('cimg_OS'=%d)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Verbosity mode:           %s%-13s%s %s('cimg_verbosity'=%d)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Stricts warnings:         %s%-13s%s %s('cimg_strict_warnings' %s)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Support for C++11:        %s%-13s%s %s('cimg_use_cpp11'=%d)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Using VT100 messages:     %s%-13s%s %s('cimg_use_vt100' %s)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Display type:             %s%-13s%s %s('cimg_display'=%d)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Using XShm for X11:       %s%-13s%s %s('cimg_use_xshm' %s)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Using XRand for X11:      %s%-13s%s %s('cimg_use_xrandr' %s)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Using OpenMP:             %s%-13s%s %s('cimg_use_openmp' %s)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Using PNG library:        %s%-13s%s %s('cimg_use_png' %s)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Using JPEG library:       %s%-13s%s %s('cimg_use_jpeg' %s)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Using TIFF library:       %s%-13s%s %s('cimg_use_tiff' %s)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Using Magick++ library:   %s%-13s%s %s('cimg_use_magick' %s)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Using FFTW3 library:      %s%-13s%s %s('cimg_use_fftw3' %s)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Using LAPACK library:     %s%-13s%s %s('cimg_use_lapack' %s)%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Path of 'curl':           %s%-13s%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Path of 'dcraw':          %s%-13s%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Path of 'ffmpeg':         %s%-13s%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Path of 'graphicsmagick': %s%-13s%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Path of 'gunzip':         %s%-13s%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Path of 'gzip':           %s%-13s%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Path of 'imagemagick':    %s%-13s%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Path of 'medcon':         %s%-13s%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Temporary path:           %s%-13s%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Path of 'wget':           %s%-13s%s\n",
CImg.h:      std::fprintf(cimg::output(),"  > Path of 'powershell_path':           %s%-13s%s\n",
CImg.h:  /*------------------------------------------------
CImg.h:   -------------------------------------------------*/
CImg.h:  inline CImg<typename cimg::superset<T,typ>::type> operator-(const typ val, const CImg<T>& img) { \
CImg.h:    return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; \
CImg.h:  inline CImg<_cimg_Tfloat> operator-(const char *const expression, const CImg<T>& img) {
CImg.h:    return CImg<_cimg_Tfloat>(img,false).fill(expression,true)-=img;
CImg.h:  /*-----------------------------------
CImg.h:   ----------------------------------*/
CImg.h:     CImgDisplay methods rely on a low-level graphic library to perform: it can be either \b X-Window
CImg.h:     (X11, for Unix-based systems) or \b GDI32 (for Windows-based systems).
CImg.h:     - 0: Disable display capabilities.
CImg.h:     - 1: Use \b X-Window (X11) library.
CImg.h:     - 2: Use \b GDI32 library.
CImg.h:    //---------------------------
CImg.h:    //---------------------------
CImg.h:    //--------------------------------------------------------
CImg.h:    //--------------------------------------------------------
CImg.h:      _mouse_x(-1),_mouse_y(-1),_wheel(0),
CImg.h:        (<tt>0</tt>=none, <tt>1</tt>=always, <tt>2</tt>=once, <tt>3</tt>=pixel type-dependent, see normalization()).
CImg.h:      _mouse_x(-1),_mouse_y(-1),_wheel(0),
CImg.h:        (<tt>0</tt>=none, <tt>1</tt>=always, <tt>2</tt>=once, <tt>3</tt>=pixel type-dependent, see normalization()).
CImg.h:      _mouse_x(-1),_mouse_y(-1),_wheel(0),
CImg.h:        (<tt>0</tt>=none, <tt>1</tt>=always, <tt>2</tt>=once, <tt>3</tt>=pixel type-dependent, see normalization()).
CImg.h:        \note All images of the list, appended along the X-axis, are initially displayed on the associated window.
CImg.h:      _mouse_x(-1),_mouse_y(-1),_wheel(0),
CImg.h:      _mouse_x(-1),_mouse_y(-1),_wheel(0),
CImg.h:    //! Destructor - Empty constructor \inplace.
CImg.h:#define cimg_fitscreen(dx,dy,dz) CImgDisplay::_fitscreen(dx,dy,dz,-25,-85,false), \
CImg.h:                                 CImgDisplay::_fitscreen(dx,dy,dz,-25,-85,true)
CImg.h:        mw = dmin<0?cimg::round(u*-dmin/100.f):(float)dmin,
CImg.h:        mh = dmin<0?cimg::round(v*-dmin/100.f):(float)dmin,
CImg.h:        Mw = dmax<0?cimg::round(u*-dmax/100.f):(float)dmax,
CImg.h:        Mh = dmax<0?cimg::round(v*-dmax/100.f):(float)dmax;
CImg.h:    //------------------------------------------
CImg.h:    //------------------------------------------
CImg.h:    //------------------------------------------
CImg.h:    //------------------------------------------
CImg.h:       - When a user physically closes the associated window, the display is set to closed.
CImg.h:       - A closed display is not destroyed. Its associated window can be show again on the screen using show().
CImg.h:       \note Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
CImg.h:       \param keycode C-string containing the keycode label of the key to test.
CImg.h:       \note Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
CImg.h:          *const ps_end = keycodes_sequence + length - 1,
CImg.h:          *const pk_end = (unsigned int*)_keys + 1 + 128 - length,
CImg.h:            for (unsigned int i = 1; i<length; ++i) res = (*(--ps)==*(pk2++));
CImg.h:              if (remove_sequence) std::memset((void*)(pk - 1),0,sizeof(unsigned int)*length);
CImg.h:    //------------------------------------------
CImg.h:    //------------------------------------------
CImg.h:    //! Return width of the screen (current resolution along the X-axis).
CImg.h:    //! Return height of the screen (current resolution along the Y-axis).
CImg.h:       - \c 0: Value normalization is disabled. It is then assumed that all input data to be displayed by the
CImg.h:       - \c 1: Value normalization is always performed (this is the default behavior).
CImg.h:       (e.g. float-valued images).
CImg.h:       - \c 2: Value normalization is performed once (on the first image display), then the same normalization
CImg.h:       - \c 3: Value normalization depends on the pixel type of the data to display. For integer pixel types,
CImg.h:       For float-valued pixel types, the normalization is done regarding the minimum/maximum value of the image
CImg.h:    //! Return title of the associated window as a C-string.
CImg.h:    //! Return X-coordinate of the associated window.
CImg.h:       \note The returned coordinate corresponds to the location of the upper-left corner of the associated window.
CImg.h:    //! Return Y-coordinate of the associated window.
CImg.h:       \note The returned coordinate corresponds to the location of the upper-left corner of the associated window.
CImg.h:    //! Return X-coordinate of the mouse pointer.
CImg.h:       - If the mouse pointer is outside window area, \c -1 is returned.
CImg.h:       - Otherwise, the returned value is in the range [0,width()-1].
CImg.h:    //! Return Y-coordinate of the mouse pointer.
CImg.h:       - If the mouse pointer is outside window area, \c -1 is returned.
CImg.h:       - Otherwise, the returned value is in the range [0,height()-1].
CImg.h:       - bit \c 0 (value \c 0x1): State of the left mouse button.
CImg.h:       - bit \c 1 (value \c 0x2): State of the right mouse button.
CImg.h:       - bit \c 2 (value \c 0x4): State of the middle mouse button.
CImg.h:       - The returned value can be positive or negative depending on whether the mouse wheel has been scrolled
CImg.h:       - Scrolling the wheel forward add \c 1 to the wheel value.
CImg.h:       - Scrolling the wheel backward subtract \c 1 to the wheel value.
CImg.h:       - The returned value cumulates the number of forward of backward scrolls since the creation of the display,
CImg.h:       - Each CImgDisplay stores a history of the pressed keys in a buffer of size \c 128. When a new key is pressed,
CImg.h:       - Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
CImg.h:       - Each CImgDisplay stores a history of the released keys in a buffer of size \c 128. When a new key is released,
CImg.h:       - Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
CImg.h:       \note Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
CImg.h:      const float delta = (float)((cimg::time() - _fps_timer)/1000.f);
CImg.h:        x1 = x0 + window_width() - 1,
CImg.h:        y1 = y0 + window_height() - 1,
CImg.h:        move(std::max(0,std::min(x0,sw - x1 + x0)),
CImg.h:             std::max(0,std::min(y0,sh - y1 + y0)));
CImg.h:    //---------------------------------------
CImg.h:    //---------------------------------------
CImg.h:       (\c 0 for upper-left, \c 0.5 for centering and \c 1 for lower-right).
CImg.h:        img._get_select(*this,_normalization,(img._width - 1)/2,(img._height - 1)/2,
CImg.h:                        (img._depth - 1)/2).move_to(visu[l]);
CImg.h:      cimglist_for(list,l) if (visu[l]._spectrum<dims) visu[l].resize(-100,-100,-100,dims,1);
CImg.h:       - Force the associated window of a display to be visible on the screen, even if it has been closed before.
CImg.h:       - Using show() on a visible display does nothing.
CImg.h:       - A closed display only means the associated window is not visible anymore. This does not mean the display has
CImg.h:       - Using close() on a closed display does nothing.
CImg.h:       \param pos_x X-coordinate of the new window location.
CImg.h:       \param pos_y Y-coordinate of the new window location.
CImg.h:       - Calling this method ensures that width() and window_width() become equal, as well as height() and
CImg.h:       - The associated window is also resized to specified dimensions.
CImg.h:       - Calling this method ensures that width() and <tt>img.width()</tt> become equal, as well as height() and
CImg.h:       - The associated window is also resized to specified dimensions.
CImg.h:       - Calling this method ensures that width() and <tt>disp.width()</tt> become equal, as well as height() and
CImg.h:       - The associated window is also resized to specified dimensions.
CImg.h:          *(poff_x++) = curr - old;
CImg.h:          *(poff_y++) = ws*(curr - old);
CImg.h:        for ( ; !dy && y<hd; std::memcpy(ptrd,ptrd - wd,sizeof(t)*wd), ++y, ptrd+=wd, dy = *(poff_y++)) {}
CImg.h:       \param format C-string containing the format of the title, as with <tt>std::printf()</tt>.
CImg.h:       - When the fullscreen mode is enabled, the associated window fills the entire screen but the size of the
CImg.h:       - The screen resolution may be switched to fit the associated window size and ensure it appears the largest
CImg.h:       For X-Window (X11) users, the configuration flag \c cimg_use_xrandr has to be set to allow the screen
CImg.h:       \note Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
CImg.h:       - Convert image data representation into the internal display buffer (architecture-dependent structure).
CImg.h:       - The content of the associated window is not modified, until paint() is called.
CImg.h:       - Should not be used for common CImgDisplay uses, since display() is more useful.
CImg.h:       - Update the content of the associated window with the internal display buffer, e.g. after a render() call.
CImg.h:       - Should not be used for common CImgDisplay uses, since display() is more useful.
CImg.h:       \param x0 X-coordinate of the upper left corner.
CImg.h:       \param y0 Y-coordinate of the upper left corner.
CImg.h:       \param x1 X-coordinate of the lower right corner.
CImg.h:       \param y1 Y-coordinate of the lower right corner.
CImg.h:    // X11-based implementation
CImg.h:    //--------------------------
CImg.h:          _window_width = nw; _window_height = nh; _mouse_x = _mouse_y = -1;
CImg.h:          if (_mouse_x<0 || _mouse_y<0 || _mouse_x>=width() || _mouse_y>=height()) _mouse_x = _mouse_y = -1;
CImg.h:          if (_mouse_x<0 || _mouse_y<0 || _mouse_x>=width() || _mouse_y>=height()) _mouse_x = _mouse_y = -1;
CImg.h:          case 5 : set_wheel(-1); break;
CImg.h:        if (_mouse_x<0 || _mouse_y<0 || _mouse_x>=width() || _mouse_y>=height()) _mouse_x = _mouse_y = -1;
CImg.h:        _mouse_x = _mouse_y = -1; _is_event = true;
CImg.h:        if (_mouse_x<0 || _mouse_y<0 || _mouse_x>=width() || _mouse_y>=height()) _mouse_x = _mouse_y = -1;
CImg.h:            if (!cimg::X11_attr().wins[i]->_is_closed && event.xany.window==cimg::X11_attr().wins[i]->_window)
CImg.h:              cimg::X11_attr().wins[i]->_handle_events(&event);
CImg.h:          nshminfo->shmid = shmget(IPC_PRIVATE,ndimx*ndimy*sizeof(T),IPC_CREAT | 0777);
CImg.h:          if (nshminfo->shmid==-1) { XDestroyImage(nimage); delete nshminfo; return; }
CImg.h:            nshminfo->shmaddr = nimage->data = (char*)shmat(nshminfo->shmid,0,0);
CImg.h:            if (nshminfo->shmaddr==(char*)-1) {
CImg.h:              shmctl(nshminfo->shmid,IPC_RMID,0); XDestroyImage(nimage); delete nshminfo; return;
CImg.h:              nshminfo->readOnly = 0;
CImg.h:                shmdt(nshminfo->shmaddr);
CImg.h:                shmctl(nshminfo->shmid,IPC_RMID,0);
CImg.h:                T *const ndata = (T*)nimage->data;
CImg.h:                shmdt(_shminfo->shmaddr);
CImg.h:                shmctl(_shminfo->shmid,IPC_RMID,0);
CImg.h:        if (vinfo && vinfo->red_mask<vinfo->blue_mask) cimg::X11_attr().is_blue_first = true;
CImg.h:        _window = XCreateWindow(dpy,DefaultRootWindow(dpy),(sx - _width)/2,(sy - _height)/2,_width,_height,0,0,
CImg.h:      window_class->res_name = (char*)_window_class;
CImg.h:      window_class->res_class = (char*)_window_class;
CImg.h:          _shminfo->shmid = shmget(IPC_PRIVATE,_image->bytes_per_line*_image->height,IPC_CREAT|0777);
CImg.h:          if (_shminfo->shmid==-1) { XDestroyImage(_image); delete _shminfo; _shminfo = 0; }
CImg.h:            _shminfo->shmaddr = _image->data = (char*)(_data = shmat(_shminfo->shmid,0,0));
CImg.h:            if (_shminfo->shmaddr==(char*)-1) {
CImg.h:              shmctl(_shminfo->shmid,IPC_RMID,0); XDestroyImage(_image); delete _shminfo; _shminfo = 0;
CImg.h:              _shminfo->readOnly = 0;
CImg.h:                shmdt(_shminfo->shmaddr); shmctl(_shminfo->shmid,IPC_RMID,0); XDestroyImage(_image);
CImg.h:      for ( ; i<cimg::X11_attr().nb_wins - 1; ++i) cimg::X11_attr().wins[i] = cimg::X11_attr().wins[i + 1];
CImg.h:      --cimg::X11_attr().nb_wins;
CImg.h:        shmdt(_shminfo->shmaddr);
CImg.h:        shmctl(_shminfo->shmid,IPC_RMID,0);
CImg.h:      const CImg<T>& nimg = (img._depth==1)?img:(tmp=img.get_projections2d((img._width - 1)/2,
CImg.h:                                                                           (img._height - 1)/2,
CImg.h:                                                                           (img._depth - 1)/2));
CImg.h:      const CImg<T> img = list>'x', &nimg = (img._depth==1)?img:(tmp=img.get_projections2d((img._width - 1)/2,
CImg.h:                                                                                           (img._height - 1)/2,
CImg.h:                                                                                           (img._depth - 1)/2));
CImg.h:        tmpdimx = (nwidth>0)?nwidth:(-nwidth*width()/100),
CImg.h:        tmpdimy = (nheight>0)?nheight:(-nheight*height()/100),
CImg.h:      if (_is_fullscreen) move((screen_width() - _width)/2,(screen_height() - _height)/2);
CImg.h:      if (img._depth!=1) return render(img.get_projections2d((img._width - 1)/2,(img._height - 1)/2,
CImg.h:                                                             (img._depth - 1)/2));
CImg.h:        return render(img.get_resize(_width,_height,1,-100,1));
CImg.h:            for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
CImg.h:          case 2 : for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:          default : for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:              } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:              } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:              } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:        const float delta = _max - _min, mm = 255/(delta?delta:1.f);
CImg.h:          case 1 : for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:              const unsigned char R = (unsigned char)((*(data1++) - _min)*mm);
CImg.h:          case 2 : for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                R = (unsigned char)((*(data1++) - _min)*mm),
CImg.h:                G = (unsigned char)((*(data2++) - _min)*mm);
CImg.h:            for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                R = (unsigned char)((*(data1++) - _min)*mm),
CImg.h:                G = (unsigned char)((*(data2++) - _min)*mm),
CImg.h:                B = (unsigned char)((*(data3++) - _min)*mm);
CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                const unsigned char val = (unsigned char)((*(data1++) - _min)*mm), G = val>>2;
CImg.h:              } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                const unsigned char val = (unsigned char)((*(data1++) - _min)*mm), G = val>>2;
CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                const unsigned char G = (unsigned char)((*(data2++) - _min)*mm)>>2;
CImg.h:                ptrd[0] = ((unsigned char)((*(data1++) - _min)*mm)&M) | (G>>3);
CImg.h:              } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                const unsigned char G = (unsigned char)((*(data2++) - _min)*mm)>>2;
CImg.h:                ptrd[1] = ((unsigned char)((*(data1++) - _min)*mm)&M) | (G>>3);
CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                const unsigned char G = (unsigned char)((*(data2++) - _min)*mm)>>2;
CImg.h:                ptrd[0] = ((unsigned char)((*(data1++) - _min)*mm)&M) | (G>>3);
CImg.h:                ptrd[1] = (G<<5) | ((unsigned char)((*(data3++) - _min)*mm)>>3);
CImg.h:              } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                const unsigned char G = (unsigned char)((*(data2++) - _min)*mm)>>2;
CImg.h:                ptrd[0] = (G<<5) | ((unsigned char)((*(data3++) - _min)*mm)>>3);
CImg.h:                ptrd[1] = ((unsigned char)((*(data1++) - _min)*mm)&M) | (G>>3);
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                  const unsigned char val = (unsigned char)((*(data1++) - _min)*mm);
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                  const unsigned char val = (unsigned char)((*(data1++) - _min)*mm);
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
CImg.h:                    ((unsigned char)((*(data1++) - _min)*mm)<<16) |
CImg.h:                    ((unsigned char)((*(data2++) - _min)*mm)<<8);
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
CImg.h:                    ((unsigned char)((*(data2++) - _min)*mm)<<16) |
CImg.h:                    ((unsigned char)((*(data1++) - _min)*mm)<<8);
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
CImg.h:                    ((unsigned char)((*(data1++) - _min)*mm)<<16) |
CImg.h:                    ((unsigned char)((*(data2++) - _min)*mm)<<8) |
CImg.h:                    (unsigned char)((*(data3++) - _min)*mm);
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
CImg.h:                    ((unsigned char)((*(data3++) - _min)*mm)<<24) |
CImg.h:                    ((unsigned char)((*(data2++) - _min)*mm)<<16) |
CImg.h:                    ((unsigned char)((*(data1++) - _min)*mm)<<8);
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                  const unsigned char val = (unsigned char)((*(data1++) - _min)*mm);
CImg.h:                } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                  const unsigned char val = (unsigned char)((*(data1++) - _min)*mm);
CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                ptrd[1] = (unsigned char)((*(data2++) - _min)*mm);
CImg.h:                ptrd[2] = (unsigned char)((*(data1++) - _min)*mm);
CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                  ptrd[1] = (unsigned char)((*(data1++) - _min)*mm);
CImg.h:                  ptrd[2] = (unsigned char)((*(data2++) - _min)*mm);
CImg.h:                  ptrd[3] = (unsigned char)((*(data3++) - _min)*mm);
CImg.h:                } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:                  ptrd[0] = (unsigned char)((*(data3++) - _min)*mm);
CImg.h:                  ptrd[1] = (unsigned char)((*(data2++) - _min)*mm);
CImg.h:                  ptrd[2] = (unsigned char)((*(data1++) - _min)*mm);
CImg.h:        _x1 = std::min(_x1,width - 1);
CImg.h:        _y1 = std::min(_y1,height - 1);
CImg.h:        image = XGetImage(dpy,root,_x0,_y0,_x1 - _x0 + 1,_y1 - _y0 + 1,AllPlanes,ZPixmap);
CImg.h:            red_mask = image->red_mask,
CImg.h:            green_mask = image->green_mask,
CImg.h:            blue_mask = image->blue_mask;
CImg.h:          img.assign(image->width,image->height,1,3);
CImg.h:                                   "with coordinates (%d,%d)-(%d,%d).",
CImg.h:        for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:        if (cimg::X11_attr().byte_order) for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:          } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:        if (cimg::X11_attr().byte_order) for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:          } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:    // Windows-based implementation.
CImg.h:    //-------------------------------
CImg.h:        disp->_mouse_x = disp->_mouse_y = -1;
CImg.h:        disp->_window_x = disp->_window_y = cimg::type<int>::min();
CImg.h:        disp->set_button().set_key(0).set_key(0,false)._is_closed = true;
CImg.h:        ReleaseMutex(disp->_mutex);
CImg.h:        ShowWindow(disp->_window,SW_HIDE);
CImg.h:        disp->_is_event = true;
CImg.h:        WaitForSingleObject(disp->_mutex,INFINITE);
CImg.h:        if (nw && nh && (nw!=disp->_width || nh!=disp->_height)) {
CImg.h:          disp->_window_width = nw;
CImg.h:          disp->_window_height = nh;
CImg.h:          disp->_mouse_x = disp->_mouse_y = -1;
CImg.h:          disp->_is_resized = disp->_is_event = true;
CImg.h:        ReleaseMutex(disp->_mutex);
CImg.h:        WaitForSingleObject(disp->_mutex,INFINITE);
CImg.h:        if (nx!=disp->_window_x || ny!=disp->_window_y) {
CImg.h:          disp->_window_x = nx;
CImg.h:          disp->_window_y = ny;
CImg.h:          disp->_is_moved = disp->_is_event = true;
CImg.h:        ReleaseMutex(disp->_mutex);
CImg.h:        disp->paint();
CImg.h:        if (disp->_is_cursor_visible) while (ShowCursor(TRUE)<0); else while (ShowCursor(FALSE_WIN)>=0);
CImg.h:        disp->set_key((unsigned int)wParam);
CImg.h:        disp->set_key((unsigned int)wParam,false);
CImg.h:        disp->_mouse_x = LOWORD(lParam);
CImg.h:        disp->_mouse_y = HIWORD(lParam);
CImg.h:        if (!disp->_is_mouse_tracked) {
CImg.h:          tme.hwndTrack = disp->_window;
CImg.h:          if (TrackMouseEvent(&tme)) disp->_is_mouse_tracked = true;
CImg.h:        if (disp->_mouse_x<0 || disp->_mouse_y<0 || disp->_mouse_x>=disp->width() || disp->_mouse_y>=disp->height())
CImg.h:          disp->_mouse_x = disp->_mouse_y = -1;
CImg.h:        disp->_is_event = true;
CImg.h:        if (disp->_is_cursor_visible) while (ShowCursor(TRUE)<0); else while (ShowCursor(FALSE_WIN)>=0);
CImg.h:        disp->_mouse_x = disp->_mouse_y = -1;
CImg.h:        disp->_is_mouse_tracked = false;
CImg.h:        disp->set_button(1);
CImg.h:        disp->set_button(2);
CImg.h:        disp->set_button(3);
CImg.h:        disp->set_button(1,false);
CImg.h:        disp->set_button(2,false);
CImg.h:        disp->set_button(3,false);
CImg.h:        disp->set_wheel((int)((short)HIWORD(wParam))/120);
CImg.h:      disp->_bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
CImg.h:      disp->_bmi.bmiHeader.biWidth = disp->width();
CImg.h:      disp->_bmi.bmiHeader.biHeight = -disp->height();
CImg.h:      disp->_bmi.bmiHeader.biPlanes = 1;
CImg.h:      disp->_bmi.bmiHeader.biBitCount = 32;
CImg.h:      disp->_bmi.bmiHeader.biCompression = BI_RGB;
CImg.h:      disp->_bmi.bmiHeader.biSizeImage = 0;
CImg.h:      disp->_bmi.bmiHeader.biXPelsPerMeter = 1;
CImg.h:      disp->_bmi.bmiHeader.biYPelsPerMeter = 1;
CImg.h:      disp->_bmi.bmiHeader.biClrUsed = 0;
CImg.h:      disp->_bmi.bmiHeader.biClrImportant = 0;
CImg.h:      disp->_data = new unsigned int[(size_t)disp->_width*disp->_height];
CImg.h:      if (!disp->_is_fullscreen) { // Normal window
CImg.h:        rect.left = rect.top = 0; rect.right = (LONG)disp->_width - 1; rect.bottom = (LONG)disp->_height - 1;
CImg.h:          border1 = (int)((rect.right - rect.left + 1 - disp->_width)/2),
CImg.h:          border2 = (int)(rect.bottom - rect.top + 1 - disp->_height - border1),
CImg.h:          ww = disp->width() + 2*border1,
CImg.h:          wh = disp->height() + border1 + border2,
CImg.h:          wx = (int)cimg::round(cimg::rand(0,sw - ww -1)),
CImg.h:          wy = (int)cimg::round(cimg::rand(64,sh - wh - 65));
CImg.h:        if (wx + ww>=sw) wx = sw - ww;
CImg.h:        if (wy + wh>=sh) wy = sh - wh;
CImg.h:        disp->_window = CreateWindowA("MDICLIENT",title?title:" ",
CImg.h:                                      (DWORD)(WS_OVERLAPPEDWINDOW | (disp->_is_closed?0:WS_VISIBLE)),
CImg.h:                                      wx,wy,ww,wh,0,0,0,&(disp->_ccs));
CImg.h:        if (!disp->_is_closed) {
CImg.h:          GetWindowRect(disp->_window,&rect);
CImg.h:          disp->_window_x = rect.left;
CImg.h:          disp->_window_y = rect.top;
CImg.h:        } else disp->_window_x = disp->_window_y = cimg::type<int>::min();
CImg.h:        disp->_window = CreateWindowA("MDICLIENT",title?title:" ",
CImg.h:                                      (DWORD)(WS_POPUP | (disp->_is_closed?0:WS_VISIBLE)),
CImg.h:                                      (int)(sx - disp->_width)/2,
CImg.h:                                      (int)(sy - disp->_height)/2,
CImg.h:                                      disp->width(),disp->height(),0,0,0,&(disp->_ccs));
CImg.h:        disp->_window_x = disp->_window_y = 0;
CImg.h:      SetForegroundWindow(disp->_window);
CImg.h:      disp->_hdc = GetDC(disp->_window);
CImg.h:      disp->_window_width = disp->_width;
CImg.h:      disp->_window_height = disp->_height;
CImg.h:      disp->flush();
CImg.h:      SetWindowLongPtr(disp->_window,GWLP_USERDATA,(LONG_PTR)disp);
CImg.h:      SetWindowLongPtr(disp->_window,GWLP_WNDPROC,(LONG_PTR)_handle_events);
CImg.h:      SetWindowLong(disp->_window,GWL_USERDATA,(LONG)disp);
CImg.h:      SetWindowLong(disp->_window,GWL_WNDPROC,(LONG)_handle_events);
CImg.h:      SetEvent(disp->_is_created);
CImg.h:        rect.left = rect.top = 0; rect.right = (LONG)_width - 1; rect.bottom = (LONG)_height - 1;
CImg.h:      const CImg<T>& nimg = (img._depth==1)?img:(tmp=img.get_projections2d((img._width - 1)/2,
CImg.h:                                                                           (img._height - 1)/2,
CImg.h:                                                                           (img._depth - 1)/2));
CImg.h:      const CImg<T> img = list>'x', &nimg = (img._depth==1)?img:(tmp=img.get_projections2d((img._width - 1)/2,
CImg.h:                                                                                           (img._height - 1)/2,
CImg.h:                                                                                           (img._depth - 1)/2));
CImg.h:        tmpdimx = (nwidth>0)?nwidth:(-nwidth*_width/100),
CImg.h:        tmpdimy = (nheight>0)?nheight:(-nheight*_height/100),
CImg.h:          RECT rect; rect.left = rect.top = 0; rect.right = (LONG)dimx - 1; rect.bottom = (LONG)dimy - 1;
CImg.h:          const int cwidth = rect.right - rect.left + 1, cheight = rect.bottom - rect.top + 1;
CImg.h:          _bmi.bmiHeader.biHeight = -(int)dimy;
CImg.h:      if (_is_fullscreen) move((screen_width() - width())/2,(screen_height() - height())/2);
CImg.h:      if (img._depth!=1) return render(img.get_projections2d((img._width - 1)/2,(img._height - 1)/2,
CImg.h:                                                             (img._depth - 1)/2));
CImg.h:          for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:          for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:          for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:        const float delta = _max - _min, mm = 255/(delta?delta:1.f);
CImg.h:          for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:            const unsigned char val = (unsigned char)((*(data1++) - _min)*mm);
CImg.h:          for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:              R = (unsigned char)((*(data1++) - _min)*mm),
CImg.h:              G = (unsigned char)((*(data2++) - _min)*mm);
CImg.h:          for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:              R = (unsigned char)((*(data1++) - _min)*mm),
CImg.h:              G = (unsigned char)((*(data2++) - _min)*mm),
CImg.h:              B = (unsigned char)((*(data3++) - _min)*mm);
CImg.h:          _x1 = std::min(_x1,width - 1);
CImg.h:          _y1 = std::min(_y1,height - 1);
CImg.h:          const int bw = _x1 - _x0 + 1, bh = _y1 - _y0 + 1;
CImg.h:                bmi.biHeight = -bh;
CImg.h:                                   "with coordinates (%d,%d)-(%d,%d).",
CImg.h:      for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
CImg.h:   #--------------------------------------
CImg.h:   #--------------------------------------
CImg.h:     while the number of channels is rather used as a vector-valued dimension
CImg.h:     Thus, the \c CImg<T> class is able to represent volumetric images of vector-valued pixels,
CImg.h:     images that have floating-point pixel values. The default value for the template T is \c float.
CImg.h:     - \c _width defines the number of \a columns of the image (size along the X-axis).
CImg.h:     - \c _height defines the number of \a rows of the image (size along the Y-axis).
CImg.h:     - \c _depth defines the number of \a slices of the image (size along the Z-axis).
CImg.h:     - \c _spectrum defines the number of \a channels of the image (size along the C-axis).
CImg.h:     - \c _data defines a \a pointer to the \a pixel \a data (of type \c T).
CImg.h:     - \c _is_shared is a boolean that tells if the memory buffer \c data is shared with
CImg.h:     - Construct images from arbitrary dimensions:
CImg.h:         - <tt>CImg<char> img;</tt> declares an empty image.
CImg.h:         - <tt>CImg<unsigned char> img(128,128);</tt> declares a 128x128 greyscale image with
CImg.h:         - <tt>CImg<double> img(3,3);</tt> declares a 3x3 matrix with \c double coefficients.
CImg.h:         - <tt>CImg<unsigned char> img(256,256,1,3);</tt> declares a 256x256x1x3 (color) image
CImg.h:         - <tt>CImg<double> img(128,128,128);</tt> declares a 128x128x128 volumetric and greyscale image
CImg.h:         - <tt>CImg<> img(128,128,128,3);</tt> declares a 128x128x128 volumetric color image
CImg.h:         - \b Note: images pixels are <b>not automatically initialized to 0</b>. You may use the function \c fill() to
CImg.h:     - Construct images from filenames:
CImg.h:         - <tt>CImg<unsigned char> img("image.jpg");</tt> reads a JPEG color image from the file "image.jpg".
CImg.h:         - <tt>CImg<float> img("analyze.hdr");</tt> reads a volumetric image (ANALYZE7.5 format) from the
CImg.h:         - \b Note: You need to install <a href="http://www.imagemagick.org">ImageMagick</a>
CImg.h:     - Construct images from C-style arrays:
CImg.h:         - <tt>CImg<int> img(data_buffer,256,256);</tt> constructs a 256x256 greyscale image from a \c int* buffer
CImg.h:         - <tt>CImg<unsigned char> img(data_buffer,256,256,1,3);</tt> constructs a 256x256 color image
CImg.h:     - operator()(): Read or write pixel values.
CImg.h:     - display(): displays the image in a new window.
CImg.h:       - The \c CImg<T>::iterator type is defined to be a <tt>T*</tt>.
CImg.h:       - You will seldom have to use iterators in %CImg, most classical operations
CImg.h:       img.fill(0);                                                              // Do the same with a built-in method
CImg.h:       - The \c CImg<T>::const_iterator type is defined to be a \c const \c T*.
CImg.h:       - You will seldom have to use iterators in %CImg, most classical operations
CImg.h:       const float sum2 = img.sum();                                              // Do the same with a built-in method
CImg.h:       - The \c CImg<T>::value_type type of a \c CImg<T> is defined to be a \c T.
CImg.h:       - \c CImg<T>::value_type is actually not used in %CImg methods. It has been mainly defined for
CImg.h:    //---------------------------
CImg.h:    //---------------------------
CImg.h:    //---------------------------------------------------------
CImg.h:    //---------------------------------------------------------
CImg.h:       - The pixel buffer data() is deallocated if necessary, e.g. for non-empty and non-shared image instances.
CImg.h:       - Destroying an empty or shared image does nothing actually.
CImg.h:       - When destroying a non-shared image, make sure that you will \e not operate on a remaining shared image
CImg.h:       - An empty image has no pixel data and all of its dimensions width(), height(), depth(), spectrum()
CImg.h:       - An empty image may be re-assigned afterwards, e.g. with the family of
CImg.h:       - An empty image is never shared.
CImg.h:       img1.assign(256,256,1,3);    // Re-assign 'img1' to be a 256x256x1x3 (color) image
CImg.h:       img2 = img1.get_rand(0,255); // Re-assign 'img2' to be a random-valued version of 'img1'
CImg.h:       img2.assign();               // Re-assign 'img2' to be an empty image again
CImg.h:       - It is able to create only \e non-shared images, and allocates thus a pixel buffer data()
CImg.h:       - Setting one dimension \c size_x,\c size_y,\c size_z or \c size_c to \c 0 leads to the construction of
CImg.h:       - A \c CImgInstanceException is thrown when the pixel buffer cannot be allocated
CImg.h:       - The allocated pixel buffer is \e not filled with a default value, and is likely to contain garbage values.
CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int),
CImg.h:       - It cannot be used to construct a vector-valued image and initialize it with \e vector-valued pixels
CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it also fills
CImg.h:       - You must specify \e exactly \c size_x*\c size_y*\c size_z*\c size_c integers in the initialization sequence.
CImg.h:        if (_siz--) { \
CImg.h:          if (_siz--) { \
CImg.h:            for ( ; _siz; --_siz) *(ptrd++) = (T)va_arg(ap,t); \
CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it also fills
CImg.h:  if (repeat_values) for (T *ptrd = _data; siz--; ) { \
CImg.h:  else { siz = std::min(siz,values.size()); for (T *ptrd = _data; siz--; ) *(ptrd++) = (T)(*(it++)); }
CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int) with height=1, depth=1, and spectrum=1,
CImg.h:      for (T *ptrd = _data; siz--; ) *(ptrd++) = (T)(*(it++));
CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int,int,int,...), but
CImg.h:       - You must specify \e exactly \c dx*\c dy*\c dz*\c dc doubles in the initialization sequence.
CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it also fills
CImg.h:       - Value string \c values may describe two different filling processes:
CImg.h:         - Either \c values is a sequences of values assigned to the image pixels, as in <tt>"1,2,3,7,8,2"</tt>.
CImg.h:         - Either, \c values is a formula, as in <tt>"cos(x/10)*sin(y/20)"</tt>.
CImg.h:       - For both cases, specifying \c repeat_values is mandatory.
CImg.h:       - A \c CImgArgumentException is thrown when an invalid value string \c values is specified.
CImg.h:       - If \c is_shared is \c false, the image instance allocates its own pixel buffer,
CImg.h:       - Otherwise, the image instance does \e not allocate a new buffer, and uses the input memory buffer as its
CImg.h:       - A \c CImgInstanceException is thrown when the pixel buffer cannot be allocated
CImg.h:       - You must take care when operating on a shared image, since it may have an invalid pixel buffer pointer data()
CImg.h:       CImg<unsigned char> img1(tab,256,256,1,1,false), // Construct new non-shared image from buffer 'tab'
CImg.h:                           img2(tab,256,256,1,1,true);  // Construct new shared-image from buffer 'tab'
CImg.h:       \param filename Filename, as a C-string.
CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it reads the image
CImg.h:       - The recognition of the image file format by %CImg higlhy depends on the tools installed on your system
CImg.h:       - Considered pixel type \c T should better fit the file format specification, or data loss may occur during
CImg.h:         file load (e.g. constructing a \c CImg<unsigned char> from a float-valued image file).
CImg.h:       - A \c CImgIOException is thrown when the specified \c filename cannot be read, or if the file format is not
CImg.h:       - Constructed copy has the same size width() x height() x depth() x spectrum() and pixel values as the
CImg.h:       - If input image \c img is \e shared and if types \c T and \c t are the same, the constructed copy is also
CImg.h:       - Otherwise, the constructed copy allocates its own pixel buffer, and copies pixel values from the input
CImg.h:       - Constructing a copy from an image \c img when types \c t and \c T are the same is significantly faster than
CImg.h:       - A \c CImgInstanceException is thrown when the pixel buffer cannot be allocated
CImg.h:       - Similar to CImg(const CImg<t>&), except that it allows to decide the shared state of
CImg.h:         - If \c is_shared is \c true, the constructed copy will share its pixel buffer with the input image \c img.
CImg.h:         - If \c is_shared is \c false, the constructed copy will allocate its own pixel buffer, whether the input
CImg.h:       - A \c CImgArgumentException is thrown when a shared copy is requested with different pixel types \c T and \c t.
CImg.h:       \param dimensions C-string describing the image size along the X,Y,Z and C-dimensions.
CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it takes the image dimensions
CImg.h:       - The allocated pixel buffer is \e not filled with a default value, and is likely to contain garbage values.
CImg.h:       \param dimensions String describing the image size along the X,Y,Z and V-dimensions.
CImg.h:       - Similar to CImg(const CImg<t>&,const char*), but it also fills the pixel buffer with the specified \c value.
CImg.h:       - The width() and height() of the constructed image instance are the same as the specified \c CImgDisplay.
CImg.h:       - The depth() and spectrum() of the constructed image instance are respectively set to \c 1 and \c 3
CImg.h:       - The image pixels are read as 8-bits RGB values.
CImg.h:       In-place version of the default constructor CImg(). It simply resets the instance to an empty image.
CImg.h:       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int).
CImg.h:       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int,T).
CImg.h:       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int,int,int,...).
CImg.h:       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int,double,double,...).
CImg.h:       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int,const char*,bool).
CImg.h:       In-place version of the constructor CImg(const t*,unsigned int,unsigned int,unsigned int,unsigned int).
CImg.h:       In-place version of the constructor CImg(const char*).
CImg.h:       In-place version of the constructor CImg(const CImg<t>&).
CImg.h:    //! In-place version of the advanced copy constructor.
CImg.h:       In-place version of the constructor CImg(const CImg<t>&,bool).
CImg.h:       In-place version of the constructor CImg(const CImg<t>&,const char*).
CImg.h:        if (cimg_sscanf(s,"%255[^0-9%xyzvwhdcXYZVWHDC]",item._data)>0) s+=std::strlen(item);
CImg.h:       In-place version of the constructor CImg(const CImg<t>&,const char*,T).
CImg.h:       In-place version of the constructor CImg(const CImgDisplay&).
CImg.h:       - It has been defined for compatibility with STL naming conventions.
CImg.h:       - Pixel types \c T and \c t of source and destination images can be different, though the process is
CImg.h:       - When optional parameter \c pos is omitted, the image instance is transferred as a new
CImg.h:       - It is convenient to sequentially insert new images into image lists, with no
CImg.h:      - It can be used to interchange the content of two images in a very fast way. Can be convenient when dealing
CImg.h:    //------------------------------------------
CImg.h:    //------------------------------------------
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       - Range of pixel coordinates start from <tt>(0,0,0,0)</tt> to
CImg.h:         <tt>(width() - 1,height() - 1,depth() - 1,spectrum() - 1)</tt>.
CImg.h:       - Due to the particular arrangement of the pixel buffers defined in %CImg, you can omit one coordinate if the
CImg.h:       - There is \e no boundary checking done in this operator, to make it as fast as possible.
CImg.h:         You \e must take care of out-of-bounds access by yourself, if necessary.
CImg.h:         when accessing out-of-bounds pixels.
CImg.h:          valB = img(10,10,2),   // Read blue value at coordinates (10,10) (Z-coordinate can be omitted)
CImg.h:      return const_cast<CImg<T>*>(this)->operator()(x,y,z,c);
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       - Similar to (but faster than) operator()().
CImg.h:       - It simply returns the pointer data() to the pixel buffer.
CImg.h:       - This implicit conversion is convenient to test the empty state of images (data() being \c 0 in this case), e.g.
CImg.h:       - It also allows to use brackets to access pixel values, without need for a \c CImg<T>::operator[](), e.g.
CImg.h:       - The image size is never modified.
CImg.h:       - The \c value may be casted to pixel type \c T if necessary.
CImg.h:       - String parameter \c expression may describe different things:
CImg.h:         - If \c expression is a list of values (as in \c "1,2,3,8,3,2"), or a formula (as in \c "(x*y)%255"),
CImg.h:         - If \c expression is a filename (as in \c "reference.jpg"), the corresponding image file is loaded and
CImg.h:       Similar to the in-place copy constructor assign(const CImg<t>&).
CImg.h:    //! In-place addition operator.
CImg.h:       - Resulting pixel values are casted to fit the pixel type \c T.
CImg.h:       - Overflow values are treated as with standard C++ numeric types. For instance,
CImg.h:       img+=1;                                   // Add '1' to each pixels -> Overflow
CImg.h:       - To prevent value overflow, you may want to consider pixel type \c T as \c float or \c double,
CImg.h:       CImg<unsigned char> img1("reference.jpg"); // Load a 8-bits RGB image (values in [0,255])
CImg.h:       CImg<float> img2(img1); // Construct a float-valued copy of 'img1'
CImg.h:       img2+=100; // Add '100' to pixel values -> goes out of [0,255] but no problems with floats
CImg.h:    //! In-place addition operator.
CImg.h:       - Similar to operator=(const char*), except that it adds values to the pixels of the current image instance,
CImg.h:    //! In-place addition operator.
CImg.h:       - The size of the image instance is never modified.
CImg.h:       - It is not mandatory that input image \c img has the same size as the image instance.
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:    //! In-place increment operator (prefix).
CImg.h:       - Writing \c ++img is equivalent to \c img+=1.
CImg.h:    //! In-place increment operator (postfix).
CImg.h:       Add \c 1 to all image pixels, and return a new copy of the initial (pre-incremented) image instance.
CImg.h:       - Use the prefixed version operator++() if you don't need a copy of the initial
CImg.h:         (pre-incremented) image instance, since a useless image copy may be expensive in terms of memory usage.
CImg.h:    //! Return a non-shared copy of the image instance.
CImg.h:       - Use this operator to ensure you get a non-shared copy of an image instance with same pixel type \c T.
CImg.h:       - Writing \c (+img) is equivalent to \c CImg<T>(img,false).
CImg.h:       Similar to operator+=(const t), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator+=(const char*), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator+=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
CImg.h:    //! In-place subtraction operator.
CImg.h:    CImg<T>& operator-=(const t value) {
CImg.h:      cimg_openmp_for(*this,*ptr - value,524288);
CImg.h:    //! In-place subtraction operator.
CImg.h:    CImg<T>& operator-=(const char *const expression) {
CImg.h:      return *this-=(+*this)._fill(expression,true,1,0,0,"operator-=",this);
CImg.h:    //! In-place subtraction operator.
CImg.h:    CImg<T>& operator-=(const CImg<t>& img) {
CImg.h:        if (is_overlapped(img)) return *this-=+img;
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:            *ptrd = (T)(*ptrd - *(ptrs++));
CImg.h:        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)(*ptrd - *(ptrs++));
CImg.h:    //! In-place decrement operator (prefix).
CImg.h:    CImg<T>& operator--() {
CImg.h:      cimg_openmp_for(*this,*ptr - 1,524288);
CImg.h:    //! In-place decrement operator (postfix).
CImg.h:    CImg<T> operator--(int) {
CImg.h:      --*this;
CImg.h:       - If the computed opposite values are out-of-range, they are treated as with standard C++ numeric types.
CImg.h:         img2 = -img1;            // Compute its opposite (in 'unsigned char')
CImg.h:    CImg<T> operator-() const {
CImg.h:      return CImg<T>(_width,_height,_depth,_spectrum,(T)0)-=*this;
CImg.h:       Similar to operator-=(const t), except that it returns a new image instance instead of operating in-place.
CImg.h:    CImg<_cimg_Tt> operator-(const t value) const {
CImg.h:      return CImg<_cimg_Tt>(*this,false)-=value;
CImg.h:       Similar to operator-=(const char*), except that it returns a new image instance instead of operating in-place.
CImg.h:    CImg<Tfloat> operator-(const char *const expression) const {
CImg.h:      return CImg<Tfloat>(*this,false)-=expression;
CImg.h:       Similar to operator-=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
CImg.h:    CImg<_cimg_Tt> operator-(const CImg<t>& img) const {
CImg.h:      return CImg<_cimg_Tt>(*this,false)-=img;
CImg.h:    //! In-place multiplication operator.
CImg.h:    //! In-place multiplication operator.
CImg.h:    //! In-place multiplication operator.
CImg.h:       - It does \e not compute a pointwise multiplication between two images. For this purpose, use
CImg.h:       - The size of the image instance can be modified by this operator.
CImg.h:       Similar to operator*=(const t), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator*=(const char*), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator*=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
CImg.h:    //! In-place division operator.
CImg.h:    //! In-place division operator.
CImg.h:    //! In-place division operator.
CImg.h:       - It does \e not compute a pointwise division between two images. For this purpose, use
CImg.h:       - It returns the matrix operation \c A*inverse(img).
CImg.h:       - The size of the image instance can be modified by this operator.
CImg.h:       Similar to operator/=(const t), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator/=(const char*), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator/=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
CImg.h:    //! In-place modulo operator.
CImg.h:    //! In-place modulo operator.
CImg.h:    //! In-place modulo operator.
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:       Similar to operator%=(const t), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator%=(const char*), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator%=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
CImg.h:    //! In-place bitwise AND operator.
CImg.h:    //! In-place bitwise AND operator.
CImg.h:    //! In-place bitwise AND operator.
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:       Similar to operator&=(const t), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator&=(const char*), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator&=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
CImg.h:    //! In-place bitwise OR operator.
CImg.h:    //! In-place bitwise OR operator.
CImg.h:    //! In-place bitwise OR operator.
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:       Similar to operator|=(const t), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator|=(const char*), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator|=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
CImg.h:    //! In-place bitwise XOR operator.
CImg.h:       - It does \e not compute the \e power of pixel values. For this purpose, use pow(const t) instead.
CImg.h:    //! In-place bitwise XOR operator.
CImg.h:       - It does \e not compute the \e power of pixel values. For this purpose, use pow(const char*) instead.
CImg.h:    //! In-place bitwise XOR operator.
CImg.h:       - It does \e not compute the \e power of pixel values. For this purpose, use pow(const CImg<t>&) instead.
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:       Similar to operator^=(const t), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator^=(const char*), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator^=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
CImg.h:    //! In-place bitwise left shift operator.
CImg.h:    //! In-place bitwise left shift operator.
CImg.h:    //! In-place bitwise left shift operator.
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:       Similar to operator<<=(const t), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator<<=(const char*), except that it returns a new image instance instead of operating in-place.
CImg.h:       operating in-place.
CImg.h:    //! In-place bitwise right shift operator.
CImg.h:    //! In-place bitwise right shift operator.
CImg.h:    //! In-place bitwise right shift operator.
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:       Similar to operator>>=(const t), except that it returns a new image instance instead of operating in-place.
CImg.h:       Similar to operator>>=(const char*), except that it returns a new image instance instead of operating in-place.
CImg.h:       operating in-place.
CImg.h:       Similar to operator-(), except that it compute the bitwise inverse instead of the opposite value.
CImg.h:      for (T *ptrd = _data + size(); is_equal && ptrd>_data; is_equal = ((Tt)*(--ptrd)==(Tt)value)) {}
CImg.h:       - The pixel buffer pointers data() of the two compared images do not have to be the same for operator==()
CImg.h:      for (T *ptrd = _data + siz; is_equal && ptrd>_data; is_equal = ((Tt)*(--ptrd)==(Tt)*(--ptrs))) {}
CImg.h:       - Writing \c img1!=img2 is equivalent to \c !(img1==img2).
CImg.h:         - A copy of the image instance, at position [\c 0].
CImg.h:         - A copy of the specified image \c img, at position [\c 1].
CImg.h:       - The family of operator,() is convenient to easily create list of images, but it is also \e quite \e slow
CImg.h:       - Constructed lists contain no shared images. If image instance or input image \c img are shared, they are
CImg.h:         inserted as new non-shared copies in the resulting list.
CImg.h:       - The pixel type of the returned list may be a superset of the initial pixel type \c T, if necessary.
CImg.h:       - Pipelining operator,() \c N times will perform \c N copies of the entire content of a (growing) image list.
CImg.h:         - A copy of the image instance, at position [\c 0].
CImg.h:         - A copy of the specified image list \c list, from positions [\c 1] to [\c list.size()].
CImg.h:       - Similar to operator,(const CImg<t>&) const, except that it takes an image list as an argument.
CImg.h:       - Similar to get_split(char,int) const, with default second argument.
CImg.h:    //-------------------------------------
CImg.h:    //-------------------------------------
CImg.h:       - The returned string does not contain any spaces.
CImg.h:       - If the pixel type \c T does not correspond to a registered type, the string <tt>"unknown"</tt> is returned.
CImg.h:       Return the image width, i.e. the image dimension along the X-axis.
CImg.h:       - The width() of an empty image is equal to \c 0.
CImg.h:       - width() is typically equal to \c 1 when considering images as \e vectors for matrix calculations.
CImg.h:       - width() returns an \c int, although the image width is internally stored as an \c unsigned \c int.
CImg.h:       Return the image height, i.e. the image dimension along the Y-axis.
CImg.h:       - The height() of an empty image is equal to \c 0.
CImg.h:       - height() returns an \c int, although the image height is internally stored as an \c unsigned \c int.
CImg.h:       Return the image depth, i.e. the image dimension along the Z-axis.
CImg.h:       - The depth() of an empty image is equal to \c 0.
CImg.h:       - depth() is typically equal to \c 1 when considering usual 2D images. When depth()\c > \c 1, the image
CImg.h:       - depth() returns an \c int, although the image depth is internally stored as an \c unsigned \c int.
CImg.h:       Return the number of image channels, i.e. the image dimension along the C-axis.
CImg.h:       - The spectrum() of an empty image is equal to \c 0.
CImg.h:       - spectrum() is typically equal to \c 1 when considering scalar-valued images, to \c 3
CImg.h:         for RGB-coded color images, and to \c 4 for RGBA-coded color images (with alpha-channel).
CImg.h:         up to the number of channels (e.g. a 4-channel image may indifferently stands for a RGBA or CMYK color image).
CImg.h:       - spectrum() returns an \c int, although the image spectrum is internally stored as an \c unsigned \c int.
CImg.h:       - The size() of an empty image is equal to \c 0.
CImg.h:       - The allocated memory size for a pixel buffer of a non-shared \c CImg<T> instance is equal to
CImg.h:       - The data() of an empty image is equal to \c 0 (null pointer).
CImg.h:       - The allocated pixel buffer for the image instance starts from \c data()
CImg.h:         and goes to <tt>data()+\ref size() - 1</tt> (included).
CImg.h:       - To get the pointer to one particular location of the pixel buffer, use
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       - Writing \c img.data(x,y,z,c) is equivalent to <tt>&(img(x,y,z,c))</tt>. Thus, this method has the same
CImg.h:      return const_cast<CImg<T>*>(this)->data(x,y,z,c);
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       - Writing \c img.data(x,y,z,c) is equivalent to <tt>&(img(x,y,z,c)) - img.data()</tt>.
CImg.h:       const CImg<float> img(100,100,1,3);      // Define a 100x100 RGB-color image
CImg.h:       - Equivalent to data().
CImg.h:       - It has been mainly defined for compatibility with STL naming conventions.
CImg.h:       - Writing \c img.end() is equivalent to <tt>img.data() + img.size()</tt>.
CImg.h:       - It has been mainly defined for compatibility with STL naming conventions.
CImg.h:       - The returned iterator actually points to a value located \e outside the acceptable bounds of the pixel buffer.
CImg.h:       - Writing \c img.front() is equivalent to <tt>img[0]</tt>, or <tt>img(0,0,0,0)</tt>.
CImg.h:       - It has been mainly defined for compatibility with STL naming conventions.
CImg.h:       - Writing \c img.back() is equivalent to <tt>img[img.size() - 1]</tt>, or
CImg.h:         <tt>img(img.width() - 1,img.height() - 1,img.depth() - 1,img.spectrum() - 1)</tt>.
CImg.h:       - It has been mainly defined for compatibility with STL naming conventions.
CImg.h:      return *(_data + size() - 1);
CImg.h:      return *(_data + size() - 1);
CImg.h:       or to a specified default value in case of out-of-bounds access.
CImg.h:       - Writing \c img.at(offset,out_value) is similar to <tt>img[offset]</tt>, except that if \c offset
CImg.h:       - Due to the additional boundary checking operation, this method is slower than operator()(). Use it when
CImg.h:       or to the nearest pixel location in the image instance in case of out-of-bounds access.
CImg.h:       - Similar to at(int,const T), except that an out-of-bounds access returns the value of the
CImg.h:         - If \c offset<0, then \c img[0] is returned.
CImg.h:         - If \c offset>=img.size(), then \c img[img.size() - 1] is returned.
CImg.h:       - Due to the additional boundary checking operation, this method is slower than operator()(). Use it when
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method \c _at(int).
CImg.h:      return (*this)[offset<0?0:(unsigned int)offset>=siz?siz - 1:offset];
CImg.h:      return (*this)[offset<0?0:(unsigned int)offset>=siz?siz - 1:offset];
CImg.h:    //! Access to a pixel value, using Dirichlet boundary conditions for the X-coordinate.
CImg.h:       or to a specified default value in case of out-of-bounds access along the X-axis.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       - Similar to operator()(), except that an out-of-bounds access along the X-axis returns the specified value
CImg.h:       - Due to the additional boundary checking operation, this method is slower than operator()(). Use it when
CImg.h:       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
CImg.h:    //! Access to a pixel value, using Dirichlet boundary conditions for the X-coordinate \const.
CImg.h:    //! Access to a pixel value, using Neumann boundary conditions for the X-coordinate.
CImg.h:       or to the nearest pixel location in the image instance in case of out-of-bounds access along the X-axis.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       - Similar to at(int,int,int,int,const T), except that an out-of-bounds access returns the value of the
CImg.h:         nearest pixel in the image instance, regarding the specified X-coordinate.
CImg.h:       - Due to the additional boundary checking operation, this method is slower than operator()(). Use it when
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
CImg.h:       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
CImg.h:      return (*this)(x<0?0:(x>=width()?width() - 1:x),y,z,c);
CImg.h:    //! Access to a pixel value, using Neumann boundary conditions for the X-coordinate \const.
CImg.h:      return (*this)(x<0?0:(x>=width()?width() - 1:x),y,z,c);
CImg.h:    //! Access to a pixel value, using Dirichlet boundary conditions for the X and Y-coordinates.
CImg.h:       Similar to atX(int,int,int,int,const T), except that boundary checking is performed both on X and Y-coordinates.
CImg.h:    //! Access to a pixel value, using Neumann boundary conditions for the X and Y-coordinates.
CImg.h:       Similar to atX(int,int,int,int), except that boundary checking is performed both on X and Y-coordinates.
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
CImg.h:      return (*this)(cimg::cut(x,0,width() - 1),
CImg.h:                     cimg::cut(y,0,height() - 1),z,c);
CImg.h:    //! Access to a pixel value, using Neumann boundary conditions for the X and Y-coordinates \const.
CImg.h:      return (*this)(cimg::cut(x,0,width() - 1),
CImg.h:                     cimg::cut(y,0,height() - 1),z,c);
CImg.h:    //! Access to a pixel value, using Dirichlet boundary conditions for the X,Y and Z-coordinates.
CImg.h:       X,Y and Z-coordinates.
CImg.h:    //! Access to a pixel value, using Dirichlet boundary conditions for the X,Y and Z-coordinates \const.
CImg.h:    //! Access to a pixel value, using Neumann boundary conditions for the X,Y and Z-coordinates.
CImg.h:       Similar to atX(int,int,int,int), except that boundary checking is performed both on X,Y and Z-coordinates.
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
CImg.h:      return (*this)(cimg::cut(x,0,width() - 1),
CImg.h:                     cimg::cut(y,0,height() - 1),
CImg.h:                     cimg::cut(z,0,depth() - 1),c);
CImg.h:    //! Access to a pixel value, using Neumann boundary conditions for the X,Y and Z-coordinates \const.
CImg.h:      return (*this)(cimg::cut(x,0,width() - 1),
CImg.h:                     cimg::cut(y,0,height() - 1),
CImg.h:                     cimg::cut(z,0,depth() - 1),c);
CImg.h:       X,Y,Z and C-coordinates.
CImg.h:       Similar to atX(int,int,int,int), except that boundary checking is performed on all X,Y,Z and C-coordinates.
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
CImg.h:      return (*this)(cimg::cut(x,0,width() - 1),
CImg.h:                     cimg::cut(y,0,height() - 1),
CImg.h:                     cimg::cut(z,0,depth() - 1),
CImg.h:                     cimg::cut(c,0,spectrum() - 1));
CImg.h:      return (*this)(cimg::cut(x,0,width() - 1),
CImg.h:                     cimg::cut(y,0,height() - 1),
CImg.h:                     cimg::cut(z,0,depth() - 1),
CImg.h:                     cimg::cut(c,0,spectrum() - 1));
CImg.h:    //! Return pixel value, using linear interpolation and Dirichlet boundary conditions for the X-coordinate.
CImg.h:       Return a linearly-interpolated pixel value of the image instance located at (\c fx,\c y,\c z,\c c),
CImg.h:       or a specified default value in case of out-of-bounds access along the X-axis.
CImg.h:       \param fx X-coordinate of the pixel value (float-valued).
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       - Similar to atX(int,int,int,int,const T), except that the returned pixel value is approximated by
CImg.h:         a linear interpolation along the X-axis, if corresponding coordinates are not integers.
CImg.h:       - The type of the returned pixel value is extended to \c float, if the pixel type \c T is not float-valued.
CImg.h:       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1;
CImg.h:        dx = fx - x;
CImg.h:      return Ic + dx*(In - Ic);
CImg.h:    //! Return pixel value, using linear interpolation and Neumann boundary conditions for the X-coordinate.
CImg.h:       Return a linearly-interpolated pixel value of the image instance located at (\c fx,\c y,\c z,\c c),
CImg.h:       or the value of the nearest pixel location in the image instance in case of out-of-bounds access along
CImg.h:       the X-axis.
CImg.h:       \param fx X-coordinate of the pixel value (float-valued).
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       - Similar to linear_atX(float,int,int,int,const T) const, except that an out-of-bounds access returns
CImg.h:         the value of the nearest pixel in the image instance, regarding the specified X-coordinate.
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
CImg.h:       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
CImg.h:        nfx = cimg::cut(fx,0,width() - 1);
CImg.h:        dx = nfx - x;
CImg.h:      return Ic + dx*(In - Ic);
CImg.h:    //! Return pixel value, using linear interpolation and periodic boundary conditions for the X-coordinate.
CImg.h:        nfx = cimg::mod(fx,_width - 0.5f);
CImg.h:        dx = nfx - x;
CImg.h:      return Ic + dx*(In - Ic);
CImg.h:    //! Return pixel value, using linear interpolation and Dirichlet boundary conditions for the X and Y-coordinates.
CImg.h:       boundary checking are achieved both for X and Y-coordinates.
CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1,
CImg.h:        y = (int)fy - (fy>=0?0:1), ny = y + 1;
CImg.h:        dx = fx - x,
CImg.h:        dy = fy - y;
CImg.h:      return Icc + (Inc - Icc + (Icc + Inn - Icn - Inc)*dy)*dx + (Icn - Icc)*dy;
CImg.h:    //! Return pixel value, using linear interpolation and Neumann boundary conditions for the X and Y-coordinates.
CImg.h:       are achieved both for X and Y-coordinates.
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
CImg.h:        nfx = cimg::cut(fx,0,width() - 1),
CImg.h:        nfy = cimg::cut(fy,0,height() - 1);
CImg.h:        dx = nfx - x,
CImg.h:        dy = nfy - y;
CImg.h:      return Icc + (Inc - Icc + (Icc + Inn - Icn - Inc)*dy)*dx + (Icn - Icc)*dy;
CImg.h:    //! Return pixel value, using linear interpolation and periodic boundary conditions for the X and Y-coordinates.
CImg.h:        nfx = cimg::mod(fx,_width - 0.5f),
CImg.h:        nfy = cimg::mod(fy,_height - 0.5f);
CImg.h:        dx = nfx - x,
CImg.h:        dy = nfy - y;
CImg.h:      return Icc + (Inc - Icc + (Icc + Inn - Icn - Inc)*dy)*dx + (Icn - Icc)*dy;
CImg.h:    //! Return pixel value, using linear interpolation and Dirichlet boundary conditions for the X,Y and Z-coordinates.
CImg.h:       boundary checking are achieved both for X,Y and Z-coordinates.
CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1,
CImg.h:        y = (int)fy - (fy>=0?0:1), ny = y + 1,
CImg.h:        z = (int)fz - (fz>=0?0:1), nz = z + 1;
CImg.h:        dx = fx - x,
CImg.h:        dy = fy - y,
CImg.h:        dz = fz - z;
CImg.h:        (Incc - Iccc +
CImg.h:         (Iccc + Innc - Icnc - Incc +
CImg.h:          (Iccn + Innn + Icnc + Incc - Icnn - Incn - Iccc - Innc)*dz)*dy +
CImg.h:         (Iccc + Incn - Iccn - Incc)*dz)*dx +
CImg.h:        (Icnc - Iccc +
CImg.h:         (Iccc + Icnn - Iccn - Icnc)*dz)*dy +
CImg.h:        (Iccn - Iccc)*dz;
CImg.h:    //! Return pixel value, using linear interpolation and Neumann boundary conditions for the X,Y and Z-coordinates.
CImg.h:       are achieved both for X,Y and Z-coordinates.
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
CImg.h:        nfx = cimg::cut(fx,0,width() - 1),
CImg.h:        nfy = cimg::cut(fy,0,height() - 1),
CImg.h:        nfz = cimg::cut(fz,0,depth() - 1);
CImg.h:        dx = nfx - x,
CImg.h:        dy = nfy - y,
CImg.h:        dz = nfz - z;
CImg.h:        (Incc - Iccc +
CImg.h:         (Iccc + Innc - Icnc - Incc +
CImg.h:          (Iccn + Innn + Icnc + Incc - Icnn - Incn - Iccc - Innc)*dz)*dy +
CImg.h:         (Iccc + Incn - Iccn - Incc)*dz)*dx +
CImg.h:        (Icnc - Iccc +
CImg.h:         (Iccc + Icnn - Iccn - Icnc)*dz)*dy +
CImg.h:        (Iccn - Iccc)*dz;
CImg.h:    //! Return pixel value, using linear interpolation and periodic boundary conditions for the X,Y and Z-coordinates.
CImg.h:        nfx = cimg::mod(fx,_width - 0.5f),
CImg.h:        nfy = cimg::mod(fy,_height - 0.5f),
CImg.h:        nfz = cimg::mod(fz,_depth - 0.5f);
CImg.h:        dx = nfx - x,
CImg.h:        dy = nfy - y,
CImg.h:        dz = nfz - z;
CImg.h:        (Incc - Iccc +
CImg.h:         (Iccc + Innc - Icnc - Incc +
CImg.h:          (Iccn + Innn + Icnc + Incc - Icnn - Incn - Iccc - Innc)*dz)*dy +
CImg.h:         (Iccc + Incn - Iccn - Incc)*dz)*dx +
CImg.h:        (Icnc - Iccc +
CImg.h:         (Iccc + Icnn - Iccn - Icnc)*dz)*dy +
CImg.h:        (Iccn - Iccc)*dz;
CImg.h:    //! Return pixel value, using linear interpolation and Dirichlet boundary conditions for all X,Y,Z,C-coordinates.
CImg.h:       boundary checking are achieved for all X,Y,Z and C-coordinates.
CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1,
CImg.h:        y = (int)fy - (fy>=0?0:1), ny = y + 1,
CImg.h:        z = (int)fz - (fz>=0?0:1), nz = z + 1,
CImg.h:        c = (int)fc - (fc>=0?0:1), nc = c + 1;
CImg.h:        dx = fx - x,
CImg.h:        dy = fy - y,
CImg.h:        dz = fz - z,
CImg.h:        dc = fc - c;
CImg.h:        dx*(Inccc - Icccc +
CImg.h:            dy*(Icccc + Inncc - Icncc - Inccc +
CImg.h:                dz*(Iccnc + Innnc + Icncc + Inccc - Icnnc - Incnc - Icccc - Inncc +
CImg.h:                    dc*(Iccnn + Innnn + Icncn + Inccn + Icnnc + Incnc + Icccc + Inncc -
CImg.h:                        Icnnn - Incnn - Icccn - Inncn - Iccnc - Innnc - Icncc - Inccc)) +
CImg.h:                dc*(Icccn + Inncn + Icncc + Inccc - Icncn - Inccn - Icccc - Inncc)) +
CImg.h:            dz*(Icccc + Incnc - Iccnc - Inccc +
CImg.h:                dc*(Icccn + Incnn + Iccnc + Inccc - Iccnn - Inccn - Icccc - Incnc)) +
CImg.h:            dc*(Icccc + Inccn - Inccc - Icccn)) +
CImg.h:        dy*(Icncc - Icccc +
CImg.h:            dz*(Icccc + Icnnc - Iccnc - Icncc +
CImg.h:                dc*(Icccn + Icnnn + Iccnc + Icncc - Iccnn - Icncn - Icccc - Icnnc)) +
CImg.h:            dc*(Icccc + Icncn - Icncc - Icccn)) +
CImg.h:        dz*(Iccnc - Icccc +
CImg.h:            dc*(Icccc + Iccnn - Iccnc - Icccn)) +
CImg.h:        dc*(Icccn  -Icccc);
CImg.h:    //! Return pixel value, using linear interpolation and Neumann boundary conditions for all X,Y,Z and C-coordinates.
CImg.h:       are achieved for all X,Y,Z and C-coordinates.
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
CImg.h:        nfx = cimg::cut(fx,0,width() - 1),
CImg.h:        nfy = cimg::cut(fy,0,height() - 1),
CImg.h:        nfz = cimg::cut(fz,0,depth() - 1),
CImg.h:        nfc = cimg::cut(fc,0,spectrum() - 1);
CImg.h:        dx = nfx - x,
CImg.h:        dy = nfy - y,
CImg.h:        dz = nfz - z,
CImg.h:        dc = nfc - c;
CImg.h:        dx*(Inccc - Icccc +
CImg.h:            dy*(Icccc + Inncc - Icncc - Inccc +
CImg.h:                dz*(Iccnc + Innnc + Icncc + Inccc - Icnnc - Incnc - Icccc - Inncc +
CImg.h:                    dc*(Iccnn + Innnn + Icncn + Inccn + Icnnc + Incnc + Icccc + Inncc -
CImg.h:                        Icnnn - Incnn - Icccn - Inncn - Iccnc - Innnc - Icncc - Inccc)) +
CImg.h:                dc*(Icccn + Inncn + Icncc + Inccc - Icncn - Inccn - Icccc - Inncc)) +
CImg.h:            dz*(Icccc + Incnc - Iccnc - Inccc +
CImg.h:                dc*(Icccn + Incnn + Iccnc + Inccc - Iccnn - Inccn - Icccc - Incnc)) +
CImg.h:            dc*(Icccc + Inccn - Inccc - Icccn)) +
CImg.h:        dy*(Icncc - Icccc +
CImg.h:            dz*(Icccc + Icnnc - Iccnc - Icncc +
CImg.h:                dc*(Icccn + Icnnn + Iccnc + Icncc - Iccnn - Icncn - Icccc - Icnnc)) +
CImg.h:            dc*(Icccc + Icncn - Icncc - Icccn)) +
CImg.h:        dz*(Iccnc - Icccc +
CImg.h:            dc*(Icccc + Iccnn - Iccnc - Icccn)) +
CImg.h:        dc*(Icccn - Icccc);
CImg.h:    //! Return pixel value, using linear interpolation and periodic boundary conditions for all X,Y,Z and C-coordinates.
CImg.h:        nfx = cimg::mod(fx,_width - 0.5f),
CImg.h:        nfy = cimg::mod(fy,_height - 0.5f),
CImg.h:        nfz = cimg::mod(fz,_depth - 0.5f),
CImg.h:        nfc = cimg::mod(fc,_spectrum - 0.5f);
CImg.h:        dx = nfx - x,
CImg.h:        dy = nfy - y,
CImg.h:        dz = nfz - z,
CImg.h:        dc = nfc - c;
CImg.h:        dx*(Inccc - Icccc +
CImg.h:            dy*(Icccc + Inncc - Icncc - Inccc +
CImg.h:                dz*(Iccnc + Innnc + Icncc + Inccc - Icnnc - Incnc - Icccc - Inncc +
CImg.h:                    dc*(Iccnn + Innnn + Icncn + Inccn + Icnnc + Incnc + Icccc + Inncc -
CImg.h:                        Icnnn - Incnn - Icccn - Inncn - Iccnc - Innnc - Icncc - Inccc)) +
CImg.h:                dc*(Icccn + Inncn + Icncc + Inccc - Icncn - Inccn - Icccc - Inncc)) +
CImg.h:            dz*(Icccc + Incnc - Iccnc - Inccc +
CImg.h:                dc*(Icccn + Incnn + Iccnc + Inccc - Iccnn - Inccn - Icccc - Incnc)) +
CImg.h:            dc*(Icccc + Inccn - Inccc - Icccn)) +
CImg.h:        dy*(Icncc - Icccc +
CImg.h:            dz*(Icccc + Icnnc - Iccnc - Icncc +
CImg.h:                dc*(Icccn + Icnnn + Iccnc + Icncc - Iccnn - Icncn - Icccc - Icnnc)) +
CImg.h:            dc*(Icccc + Icncn - Icncc - Icccn)) +
CImg.h:        dz*(Iccnc - Icccc +
CImg.h:            dc*(Icccc + Iccnn - Iccnc - Icccn)) +
CImg.h:        dc*(Icccn - Icccc);
CImg.h:    //! Return pixel value, using cubic interpolation and Dirichlet boundary conditions for the X-coordinate.
CImg.h:       Return a cubicly-interpolated pixel value of the image instance located at (\c fx,\c y,\c z,\c c),
CImg.h:       or a specified default value in case of out-of-bounds access along the X-axis.
CImg.h:       \param fx d X-coordinate of the pixel value (float-valued).
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       - Similar to linear_atX(float,int,int,int,const T) const, except that the returned pixel value is
CImg.h:         approximated by a \e cubic interpolation along the X-axis.
CImg.h:       - The type of the returned pixel value is extended to \c float, if the pixel type \c T is not float-valued.
CImg.h:       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
CImg.h:        x = (int)fx - (fx>=0?0:1), px = x - 1, nx = x + 1, ax = x + 2;
CImg.h:        dx = fx - x;
CImg.h:      return Ic + 0.5f*(dx*(-Ip + In) + dx*dx*(2*Ip - 5*Ic + 4*In - Ia) + dx*dx*dx*(-Ip + 3*Ic - 3*In + Ia));
CImg.h:    //! Return clamped pixel value, using cubic interpolation and Dirichlet boundary conditions for the X-coordinate.
CImg.h:    //! Return pixel value, using cubic interpolation and Neumann boundary conditions for the X-coordinate.
CImg.h:       Return a cubicly-interpolated pixel value of the image instance located at (\c fx,\c y,\c z,\c c),
CImg.h:       or the value of the nearest pixel location in the image instance in case of out-of-bounds access
CImg.h:       along the X-axis. The cubic interpolation uses Hermite splines.
CImg.h:       \param fx X-coordinate of the pixel value (float-valued).
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       - Similar to cubic_atX(float,int,int,int,const T) const, except that the returned pixel value is
CImg.h:         approximated by a cubic interpolation along the X-axis.
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
CImg.h:       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
CImg.h:        nfx = cimg::type<float>::is_nan(fx)?0:cimg::cut(fx,0,width() - 1);
CImg.h:        dx = nfx - x;
CImg.h:        px = x - 1<0?0:x - 1, nx = dx>0?x + 1:x, ax = x + 2>=width()?width() - 1:x + 2;
CImg.h:      return Ic + 0.5f*(dx*(-Ip + In) + dx*dx*(2*Ip - 5*Ic + 4*In - Ia) + dx*dx*dx*(-Ip + 3*Ic - 3*In + Ia));
CImg.h:    //! Return clamped pixel value, using cubic interpolation and Neumann boundary conditions for the X-coordinate.
CImg.h:    //! Return pixel value, using cubic interpolation and periodic boundary conditions for the X-coordinate.
CImg.h:        nfx = cimg::type<float>::is_nan(fx)?0:cimg::mod(fx,_width - 0.5f);
CImg.h:        dx = nfx - x;
CImg.h:        px = cimg::mod(x - 1,width()), nx = cimg::mod(x + 1,width()), ax = cimg::mod(x + 2,width());
CImg.h:      return Ic + 0.5f*(dx*(-Ip + In) + dx*dx*(2*Ip - 5*Ic + 4*In - Ia) + dx*dx*dx*(-Ip + 3*Ic - 3*In + Ia));
CImg.h:    //! Return pixel value, using cubic interpolation and Dirichlet boundary conditions for the X and Y-coordinates.
CImg.h:       are achieved both for X and Y-coordinates.
CImg.h:        x = (int)fx - (fx>=0?0:1), px = x - 1, nx = x + 1, ax = x + 2,
CImg.h:        y = (int)fy - (fy>=0?0:1), py = y - 1, ny = y + 1, ay = y + 2;
CImg.h:      const float dx = fx - x, dy = fy - y;
CImg.h:        Ip = Icp + 0.5f*(dx*(-Ipp + Inp) + dx*dx*(2*Ipp - 5*Icp + 4*Inp - Iap) + dx*dx*dx*(-Ipp + 3*Icp - 3*Inp + Iap)),
CImg.h:        Ic = Icc + 0.5f*(dx*(-Ipc + Inc) + dx*dx*(2*Ipc - 5*Icc + 4*Inc - Iac) + dx*dx*dx*(-Ipc + 3*Icc - 3*Inc + Iac)),
CImg.h:        In = Icn + 0.5f*(dx*(-Ipn + Inn) + dx*dx*(2*Ipn - 5*Icn + 4*Inn - Ian) + dx*dx*dx*(-Ipn + 3*Icn - 3*Inn + Ian)),
CImg.h:        Ia = Ica + 0.5f*(dx*(-Ipa + Ina) + dx*dx*(2*Ipa - 5*Ica + 4*Ina - Iaa) + dx*dx*dx*(-Ipa + 3*Ica - 3*Ina + Iaa));
CImg.h:      return Ic + 0.5f*(dy*(-Ip + In) + dy*dy*(2*Ip - 5*Ic + 4*In - Ia) + dy*dy*dy*(-Ip + 3*Ic - 3*In + Ia));
CImg.h:    //! Return clamped pixel value, using cubic interpolation and Dirichlet boundary conditions for the X,Y-coordinates.
CImg.h:    //! Return pixel value, using cubic interpolation and Neumann boundary conditions for the X and Y-coordinates.
CImg.h:       are achieved for both X and Y-coordinates.
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
CImg.h:        nfx = cimg::type<float>::is_nan(fx)?0:cimg::cut(fx,0,width() - 1),
CImg.h:        nfy = cimg::type<float>::is_nan(fy)?0:cimg::cut(fy,0,height() - 1);
CImg.h:      const float dx = nfx - x, dy = nfy - y;
CImg.h:        px = x - 1<0?0:x - 1, nx = dx<=0?x:x + 1, ax = x + 2>=width()?width() - 1:x + 2,
CImg.h:        py = y - 1<0?0:y - 1, ny = dy<=0?y:y + 1, ay = y + 2>=height()?height() - 1:y + 2;
CImg.h:        Ip = Icp + 0.5f*(dx*(-Ipp + Inp) + dx*dx*(2*Ipp - 5*Icp + 4*Inp - Iap) + dx*dx*dx*(-Ipp + 3*Icp - 3*Inp + Iap)),
CImg.h:        Ic = Icc + 0.5f*(dx*(-Ipc + Inc) + dx*dx*(2*Ipc - 5*Icc + 4*Inc - Iac) + dx*dx*dx*(-Ipc + 3*Icc - 3*Inc + Iac)),
CImg.h:        In = Icn + 0.5f*(dx*(-Ipn + Inn) + dx*dx*(2*Ipn - 5*Icn + 4*Inn - Ian) + dx*dx*dx*(-Ipn + 3*Icn - 3*Inn + Ian)),
CImg.h:        Ia = Ica + 0.5f*(dx*(-Ipa + Ina) + dx*dx*(2*Ipa - 5*Ica + 4*Ina - Iaa) + dx*dx*dx*(-Ipa + 3*Ica - 3*Ina + Iaa));
CImg.h:      return Ic + 0.5f*(dy*(-Ip + In) + dy*dy*(2*Ip - 5*Ic + 4*In - Ia) + dy*dy*dy*(-Ip + 3*Ic - 3*In + Ia));
CImg.h:    //! Return clamped pixel value, using cubic interpolation and Neumann boundary conditions for the X,Y-coordinates.
CImg.h:    //! Return pixel value, using cubic interpolation and periodic boundary conditions for the X and Y-coordinates.
CImg.h:        nfx = cimg::type<float>::is_nan(fx)?0:cimg::mod(fx,_width - 0.5f),
CImg.h:        nfy = cimg::type<float>::is_nan(fy)?0:cimg::mod(fy,_height - 0.5f);
CImg.h:      const float dx = nfx - x, dy = nfy - y;
CImg.h:        px = cimg::mod(x - 1,width()), nx = cimg::mod(x + 1,width()), ax = cimg::mod(x + 2,width()),
CImg.h:        py = cimg::mod(y - 1,height()), ny = cimg::mod(y + 1,height()), ay = cimg::mod(y + 2,height());
CImg.h:        Ip = Icp + 0.5f*(dx*(-Ipp + Inp) + dx*dx*(2*Ipp - 5*Icp + 4*Inp - Iap) + dx*dx*dx*(-Ipp + 3*Icp - 3*Inp + Iap)),
CImg.h:        Ic = Icc + 0.5f*(dx*(-Ipc + Inc) + dx*dx*(2*Ipc - 5*Icc + 4*Inc - Iac) + dx*dx*dx*(-Ipc + 3*Icc - 3*Inc + Iac)),
CImg.h:        In = Icn + 0.5f*(dx*(-Ipn + Inn) + dx*dx*(2*Ipn - 5*Icn + 4*Inn - Ian) + dx*dx*dx*(-Ipn + 3*Icn - 3*Inn + Ian)),
CImg.h:        Ia = Ica + 0.5f*(dx*(-Ipa + Ina) + dx*dx*(2*Ipa - 5*Ica + 4*Ina - Iaa) + dx*dx*dx*(-Ipa + 3*Ica - 3*Ina + Iaa));
CImg.h:      return Ic + 0.5f*(dy*(-Ip + In) + dy*dy*(2*Ip - 5*Ic + 4*In - Ia) + dy*dy*dy*(-Ip + 3*Ic - 3*In + Ia));
CImg.h:    //! Return pixel value, using cubic interpolation and Dirichlet boundary conditions for the X,Y and Z-coordinates.
CImg.h:       are achieved both for X,Y and Z-coordinates.
CImg.h:        x = (int)fx - (fx>=0?0:1), px = x - 1, nx = x + 1, ax = x + 2,
CImg.h:        y = (int)fy - (fy>=0?0:1), py = y - 1, ny = y + 1, ay = y + 2,
CImg.h:        z = (int)fz - (fz>=0?0:1), pz = z - 1, nz = z + 1, az = z + 2;
CImg.h:      const float dx = fx - x, dy = fy - y, dz = fz - z;
CImg.h:        Ipp = Icpp + 0.5f*(dx*(-Ippp + Inpp) + dx*dx*(2*Ippp - 5*Icpp + 4*Inpp - Iapp) +
CImg.h:                           dx*dx*dx*(-Ippp + 3*Icpp - 3*Inpp + Iapp)),
CImg.h:        Icp = Iccp + 0.5f*(dx*(-Ipcp + Incp) + dx*dx*(2*Ipcp - 5*Iccp + 4*Incp - Iacp) +
CImg.h:                           dx*dx*dx*(-Ipcp + 3*Iccp - 3*Incp + Iacp)),
CImg.h:        Inp = Icnp + 0.5f*(dx*(-Ipnp + Innp) + dx*dx*(2*Ipnp - 5*Icnp + 4*Innp - Ianp) +
CImg.h:                           dx*dx*dx*(-Ipnp + 3*Icnp - 3*Innp + Ianp)),
CImg.h:        Iap = Icap + 0.5f*(dx*(-Ipap + Inap) + dx*dx*(2*Ipap - 5*Icap + 4*Inap - Iaap) +
CImg.h:                           dx*dx*dx*(-Ipap + 3*Icap - 3*Inap + Iaap)),
CImg.h:        Ip = Icp + 0.5f*(dy*(-Ipp + Inp) + dy*dy*(2*Ipp - 5*Icp + 4*Inp - Iap) +
CImg.h:                         dy*dy*dy*(-Ipp + 3*Icp - 3*Inp + Iap)),
CImg.h:        Ipc = Icpc + 0.5f*(dx*(-Ippc + Inpc) + dx*dx*(2*Ippc - 5*Icpc + 4*Inpc - Iapc) +
CImg.h:                           dx*dx*dx*(-Ippc + 3*Icpc - 3*Inpc + Iapc)),
CImg.h:        Icc = Iccc + 0.5f*(dx*(-Ipcc + Incc) + dx*dx*(2*Ipcc - 5*Iccc + 4*Incc - Iacc) +
CImg.h:                           dx*dx*dx*(-Ipcc + 3*Iccc - 3*Incc + Iacc)),
CImg.h:        Inc = Icnc + 0.5f*(dx*(-Ipnc + Innc) + dx*dx*(2*Ipnc - 5*Icnc + 4*Innc - Ianc) +
CImg.h:                           dx*dx*dx*(-Ipnc + 3*Icnc - 3*Innc + Ianc)),
CImg.h:        Iac = Icac + 0.5f*(dx*(-Ipac + Inac) + dx*dx*(2*Ipac - 5*Icac + 4*Inac - Iaac) +
CImg.h:                           dx*dx*dx*(-Ipac + 3*Icac - 3*Inac + Iaac)),
CImg.h:        Ic = Icc + 0.5f*(dy*(-Ipc + Inc) + dy*dy*(2*Ipc - 5*Icc + 4*Inc - Iac) +
CImg.h:                         dy*dy*dy*(-Ipc + 3*Icc - 3*Inc + Iac)),
CImg.h:        Ipn = Icpn + 0.5f*(dx*(-Ippn + Inpn) + dx*dx*(2*Ippn - 5*Icpn + 4*Inpn - Iapn) +
CImg.h:                           dx*dx*dx*(-Ippn + 3*Icpn - 3*Inpn + Iapn)),
CImg.h:        Icn = Iccn + 0.5f*(dx*(-Ipcn + Incn) + dx*dx*(2*Ipcn - 5*Iccn + 4*Incn - Iacn) +
CImg.h:                           dx*dx*dx*(-Ipcn + 3*Iccn - 3*Incn + Iacn)),
CImg.h:        Inn = Icnn + 0.5f*(dx*(-Ipnn + Innn) + dx*dx*(2*Ipnn - 5*Icnn + 4*Innn - Iann) +
CImg.h:                           dx*dx*dx*(-Ipnn + 3*Icnn - 3*Innn + Iann)),
CImg.h:        Ian = Ican + 0.5f*(dx*(-Ipan + Inan) + dx*dx*(2*Ipan - 5*Ican + 4*Inan - Iaan) +
CImg.h:                           dx*dx*dx*(-Ipan + 3*Ican - 3*Inan + Iaan)),
CImg.h:        In = Icn + 0.5f*(dy*(-Ipn + Inn) + dy*dy*(2*Ipn - 5*Icn + 4*Inn - Ian) +
CImg.h:                         dy*dy*dy*(-Ipn + 3*Icn - 3*Inn + Ian)),
CImg.h:        Ipa = Icpa + 0.5f*(dx*(-Ippa + Inpa) + dx*dx*(2*Ippa - 5*Icpa + 4*Inpa - Iapa) +
CImg.h:                           dx*dx*dx*(-Ippa + 3*Icpa - 3*Inpa + Iapa)),
CImg.h:        Ica = Icca + 0.5f*(dx*(-Ipca + Inca) + dx*dx*(2*Ipca - 5*Icca + 4*Inca - Iaca) +
CImg.h:                           dx*dx*dx*(-Ipca + 3*Icca - 3*Inca + Iaca)),
CImg.h:        Ina = Icna + 0.5f*(dx*(-Ipna + Inna) + dx*dx*(2*Ipna - 5*Icna + 4*Inna - Iana) +
CImg.h:                           dx*dx*dx*(-Ipna + 3*Icna - 3*Inna + Iana)),
CImg.h:        Iaa = Icaa + 0.5f*(dx*(-Ipaa + Inaa) + dx*dx*(2*Ipaa - 5*Icaa + 4*Inaa - Iaaa) +
CImg.h:                           dx*dx*dx*(-Ipaa + 3*Icaa - 3*Inaa + Iaaa)),
CImg.h:        Ia = Ica + 0.5f*(dy*(-Ipa + Ina) + dy*dy*(2*Ipa - 5*Ica + 4*Ina - Iaa) +
CImg.h:                         dy*dy*dy*(-Ipa + 3*Ica - 3*Ina + Iaa));
CImg.h:      return Ic + 0.5f*(dz*(-Ip + In) + dz*dz*(2*Ip - 5*Ic + 4*In - Ia) + dz*dz*dz*(-Ip + 3*Ic - 3*In + Ia));
CImg.h:    //! Return clamped pixel value, using cubic interpolation and Dirichlet boundary conditions for the XYZ-coordinates.
CImg.h:    //! Return pixel value, using cubic interpolation and Neumann boundary conditions for the X,Y and Z-coordinates.
CImg.h:       are achieved both for X,Y and Z-coordinates.
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
CImg.h:        nfx = cimg::type<float>::is_nan(fx)?0:cimg::cut(fx,0,width() - 1),
CImg.h:        nfy = cimg::type<float>::is_nan(fy)?0:cimg::cut(fy,0,height() - 1),
CImg.h:        nfz = cimg::type<float>::is_nan(fz)?0:cimg::cut(fz,0,depth() - 1);
CImg.h:      const float dx = nfx - x, dy = nfy - y, dz = nfz - z;
CImg.h:        px = x - 1<0?0:x - 1, nx = dx>0?x + 1:x, ax = x + 2>=width()?width() - 1:x + 2,
CImg.h:        py = y - 1<0?0:y - 1, ny = dy>0?y + 1:y, ay = y + 2>=height()?height() - 1:y + 2,
CImg.h:        pz = z - 1<0?0:z - 1, nz = dz>0?z + 1:z, az = z + 2>=depth()?depth() - 1:z + 2;
CImg.h:        Ipp = Icpp + 0.5f*(dx*(-Ippp + Inpp) + dx*dx*(2*Ippp - 5*Icpp + 4*Inpp - Iapp) +
CImg.h:                           dx*dx*dx*(-Ippp + 3*Icpp - 3*Inpp + Iapp)),
CImg.h:        Icp = Iccp + 0.5f*(dx*(-Ipcp + Incp) + dx*dx*(2*Ipcp - 5*Iccp + 4*Incp - Iacp) +
CImg.h:                           dx*dx*dx*(-Ipcp + 3*Iccp - 3*Incp + Iacp)),
CImg.h:        Inp = Icnp + 0.5f*(dx*(-Ipnp + Innp) + dx*dx*(2*Ipnp - 5*Icnp + 4*Innp - Ianp) +
CImg.h:                           dx*dx*dx*(-Ipnp + 3*Icnp - 3*Innp + Ianp)),
CImg.h:        Iap = Icap + 0.5f*(dx*(-Ipap + Inap) + dx*dx*(2*Ipap - 5*Icap + 4*Inap - Iaap) +
CImg.h:                           dx*dx*dx*(-Ipap + 3*Icap - 3*Inap + Iaap)),
CImg.h:        Ip = Icp + 0.5f*(dy*(-Ipp + Inp) + dy*dy*(2*Ipp - 5*Icp + 4*Inp - Iap) +
CImg.h:                         dy*dy*dy*(-Ipp + 3*Icp - 3*Inp + Iap)),
CImg.h:        Ipc = Icpc + 0.5f*(dx*(-Ippc + Inpc) + dx*dx*(2*Ippc - 5*Icpc + 4*Inpc - Iapc) +
CImg.h:                           dx*dx*dx*(-Ippc + 3*Icpc - 3*Inpc + Iapc)),
CImg.h:        Icc = Iccc + 0.5f*(dx*(-Ipcc + Incc) + dx*dx*(2*Ipcc - 5*Iccc + 4*Incc - Iacc) +
CImg.h:                           dx*dx*dx*(-Ipcc + 3*Iccc - 3*Incc + Iacc)),
CImg.h:        Inc = Icnc + 0.5f*(dx*(-Ipnc + Innc) + dx*dx*(2*Ipnc - 5*Icnc + 4*Innc - Ianc) +
CImg.h:                           dx*dx*dx*(-Ipnc + 3*Icnc - 3*Innc + Ianc)),
CImg.h:        Iac = Icac + 0.5f*(dx*(-Ipac + Inac) + dx*dx*(2*Ipac - 5*Icac + 4*Inac - Iaac) +
CImg.h:                           dx*dx*dx*(-Ipac + 3*Icac - 3*Inac + Iaac)),
CImg.h:        Ic = Icc + 0.5f*(dy*(-Ipc + Inc) + dy*dy*(2*Ipc - 5*Icc + 4*Inc - Iac) +
CImg.h:                         dy*dy*dy*(-Ipc + 3*Icc - 3*Inc + Iac)),
CImg.h:        Ipn = Icpn + 0.5f*(dx*(-Ippn + Inpn) + dx*dx*(2*Ippn - 5*Icpn + 4*Inpn - Iapn) +
CImg.h:                           dx*dx*dx*(-Ippn + 3*Icpn - 3*Inpn + Iapn)),
CImg.h:        Icn = Iccn + 0.5f*(dx*(-Ipcn + Incn) + dx*dx*(2*Ipcn - 5*Iccn + 4*Incn - Iacn) +
CImg.h:                           dx*dx*dx*(-Ipcn + 3*Iccn - 3*Incn + Iacn)),
CImg.h:        Inn = Icnn + 0.5f*(dx*(-Ipnn + Innn) + dx*dx*(2*Ipnn - 5*Icnn + 4*Innn - Iann) +
CImg.h:                           dx*dx*dx*(-Ipnn + 3*Icnn - 3*Innn + Iann)),
CImg.h:        Ian = Ican + 0.5f*(dx*(-Ipan + Inan) + dx*dx*(2*Ipan - 5*Ican + 4*Inan - Iaan) +
CImg.h:                           dx*dx*dx*(-Ipan + 3*Ican - 3*Inan + Iaan)),
CImg.h:        In = Icn + 0.5f*(dy*(-Ipn + Inn) + dy*dy*(2*Ipn - 5*Icn + 4*Inn - Ian) +
CImg.h:                         dy*dy*dy*(-Ipn + 3*Icn - 3*Inn + Ian)),
CImg.h:        Ipa = Icpa + 0.5f*(dx*(-Ippa + Inpa) + dx*dx*(2*Ippa - 5*Icpa + 4*Inpa - Iapa) +
CImg.h:                           dx*dx*dx*(-Ippa + 3*Icpa - 3*Inpa + Iapa)),
CImg.h:        Ica = Icca + 0.5f*(dx*(-Ipca + Inca) + dx*dx*(2*Ipca - 5*Icca + 4*Inca - Iaca) +
CImg.h:                           dx*dx*dx*(-Ipca + 3*Icca - 3*Inca + Iaca)),
CImg.h:        Ina = Icna + 0.5f*(dx*(-Ipna + Inna) + dx*dx*(2*Ipna - 5*Icna + 4*Inna - Iana) +
CImg.h:                           dx*dx*dx*(-Ipna + 3*Icna - 3*Inna + Iana)),
CImg.h:        Iaa = Icaa + 0.5f*(dx*(-Ipaa + Inaa) + dx*dx*(2*Ipaa - 5*Icaa + 4*Inaa - Iaaa) +
CImg.h:                           dx*dx*dx*(-Ipaa + 3*Icaa - 3*Inaa + Iaaa)),
CImg.h:        Ia = Ica + 0.5f*(dy*(-Ipa + Ina) + dy*dy*(2*Ipa - 5*Ica + 4*Ina - Iaa) +
CImg.h:                         dy*dy*dy*(-Ipa + 3*Ica - 3*Ina + Iaa));
CImg.h:      return Ic + 0.5f*(dz*(-Ip + In) + dz*dz*(2*Ip - 5*Ic + 4*In - Ia) + dz*dz*dz*(-Ip + 3*Ic - 3*In + Ia));
CImg.h:    //! Return clamped pixel value, using cubic interpolation and Neumann boundary conditions for the XYZ-coordinates.
CImg.h:    //! Return pixel value, using cubic interpolation and Neumann boundary conditions for the X,Y and Z-coordinates.
CImg.h:       are achieved both for X,Y and Z-coordinates.
CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
CImg.h:        nfx = cimg::type<float>::is_nan(fx)?0:cimg::mod(fx,_width - 0.5f),
CImg.h:        nfy = cimg::type<float>::is_nan(fy)?0:cimg::mod(fy,_height - 0.5f),
CImg.h:        nfz = cimg::type<float>::is_nan(fz)?0:cimg::mod(fz,_depth - 0.5f);
CImg.h:      const float dx = nfx - x, dy = nfy - y, dz = nfz - z;
CImg.h:        px = cimg::mod(x - 1,width()), nx = cimg::mod(x + 1,width()), ax = cimg::mod(x + 2,width()),
CImg.h:        py = cimg::mod(y - 1,height()), ny = cimg::mod(y + 1,height()), ay = cimg::mod(y + 2,height()),
CImg.h:        pz = cimg::mod(z - 1,depth()), nz = cimg::mod(z + 1,depth()), az = cimg::mod(z + 2,depth());
CImg.h:        Ipp = Icpp + 0.5f*(dx*(-Ippp + Inpp) + dx*dx*(2*Ippp - 5*Icpp + 4*Inpp - Iapp) +
CImg.h:                           dx*dx*dx*(-Ippp + 3*Icpp - 3*Inpp + Iapp)),
CImg.h:        Icp = Iccp + 0.5f*(dx*(-Ipcp + Incp) + dx*dx*(2*Ipcp - 5*Iccp + 4*Incp - Iacp) +
CImg.h:                           dx*dx*dx*(-Ipcp + 3*Iccp - 3*Incp + Iacp)),
CImg.h:        Inp = Icnp + 0.5f*(dx*(-Ipnp + Innp) + dx*dx*(2*Ipnp - 5*Icnp + 4*Innp - Ianp) +
CImg.h:                           dx*dx*dx*(-Ipnp + 3*Icnp - 3*Innp + Ianp)),
CImg.h:        Iap = Icap + 0.5f*(dx*(-Ipap + Inap) + dx*dx*(2*Ipap - 5*Icap + 4*Inap - Iaap) +
CImg.h:                           dx*dx*dx*(-Ipap + 3*Icap - 3*Inap + Iaap)),
CImg.h:        Ip = Icp + 0.5f*(dy*(-Ipp + Inp) + dy*dy*(2*Ipp - 5*Icp + 4*Inp - Iap) +
CImg.h:                         dy*dy*dy*(-Ipp + 3*Icp - 3*Inp + Iap)),
CImg.h:        Ipc = Icpc + 0.5f*(dx*(-Ippc + Inpc) + dx*dx*(2*Ippc - 5*Icpc + 4*Inpc - Iapc) +
CImg.h:                           dx*dx*dx*(-Ippc + 3*Icpc - 3*Inpc + Iapc)),
CImg.h:        Icc = Iccc + 0.5f*(dx*(-Ipcc + Incc) + dx*dx*(2*Ipcc - 5*Iccc + 4*Incc - Iacc) +
CImg.h:                           dx*dx*dx*(-Ipcc + 3*Iccc - 3*Incc + Iacc)),
CImg.h:        Inc = Icnc + 0.5f*(dx*(-Ipnc + Innc) + dx*dx*(2*Ipnc - 5*Icnc + 4*Innc - Ianc) +
CImg.h:                           dx*dx*dx*(-Ipnc + 3*Icnc - 3*Innc + Ianc)),
CImg.h:        Iac = Icac + 0.5f*(dx*(-Ipac + Inac) + dx*dx*(2*Ipac - 5*Icac + 4*Inac - Iaac) +
CImg.h:                           dx*dx*dx*(-Ipac + 3*Icac - 3*Inac + Iaac)),
CImg.h:        Ic = Icc + 0.5f*(dy*(-Ipc + Inc) + dy*dy*(2*Ipc - 5*Icc + 4*Inc - Iac) +
CImg.h:                         dy*dy*dy*(-Ipc + 3*Icc - 3*Inc + Iac)),
CImg.h:        Ipn = Icpn + 0.5f*(dx*(-Ippn + Inpn) + dx*dx*(2*Ippn - 5*Icpn + 4*Inpn - Iapn) +
CImg.h:                           dx*dx*dx*(-Ippn + 3*Icpn - 3*Inpn + Iapn)),
CImg.h:        Icn = Iccn + 0.5f*(dx*(-Ipcn + Incn) + dx*dx*(2*Ipcn - 5*Iccn + 4*Incn - Iacn) +
CImg.h:                           dx*dx*dx*(-Ipcn + 3*Iccn - 3*Incn + Iacn)),
CImg.h:        Inn = Icnn + 0.5f*(dx*(-Ipnn + Innn) + dx*dx*(2*Ipnn - 5*Icnn + 4*Innn - Iann) +
CImg.h:                           dx*dx*dx*(-Ipnn + 3*Icnn - 3*Innn + Iann)),
CImg.h:        Ian = Ican + 0.5f*(dx*(-Ipan + Inan) + dx*dx*(2*Ipan - 5*Ican + 4*Inan - Iaan) +
CImg.h:                           dx*dx*dx*(-Ipan + 3*Ican - 3*Inan + Iaan)),
CImg.h:        In = Icn + 0.5f*(dy*(-Ipn + Inn) + dy*dy*(2*Ipn - 5*Icn + 4*Inn - Ian) +
CImg.h:                         dy*dy*dy*(-Ipn + 3*Icn - 3*Inn + Ian)),
CImg.h:        Ipa = Icpa + 0.5f*(dx*(-Ippa + Inpa) + dx*dx*(2*Ippa - 5*Icpa + 4*Inpa - Iapa) +
CImg.h:                           dx*dx*dx*(-Ippa + 3*Icpa - 3*Inpa + Iapa)),
CImg.h:        Ica = Icca + 0.5f*(dx*(-Ipca + Inca) + dx*dx*(2*Ipca - 5*Icca + 4*Inca - Iaca) +
CImg.h:                           dx*dx*dx*(-Ipca + 3*Icca - 3*Inca + Iaca)),
CImg.h:        Ina = Icna + 0.5f*(dx*(-Ipna + Inna) + dx*dx*(2*Ipna - 5*Icna + 4*Inna - Iana) +
CImg.h:                           dx*dx*dx*(-Ipna + 3*Icna - 3*Inna + Iana)),
CImg.h:        Iaa = Icaa + 0.5f*(dx*(-Ipaa + Inaa) + dx*dx*(2*Ipaa - 5*Icaa + 4*Inaa - Iaaa) +
CImg.h:                           dx*dx*dx*(-Ipaa + 3*Icaa - 3*Inaa + Iaaa)),
CImg.h:        Ia = Ica + 0.5f*(dy*(-Ipa + Ina) + dy*dy*(2*Ipa - 5*Ica + 4*Ina - Iaa) +
CImg.h:                         dy*dy*dy*(-Ipa + 3*Ica - 3*Ina + Iaa));
CImg.h:      return Ic + 0.5f*(dz*(-Ip + In) + dz*dz*(2*Ip - 5*Ic + 4*In - Ia) + dz*dz*dz*(-Ip + 3*Ic - 3*In + Ia));
CImg.h:    //! Set pixel value, using linear interpolation for the X-coordinates.
CImg.h:       the value is spread amongst several neighbors if the pixel coordinates are float-valued.
CImg.h:       \param fx X-coordinate of the pixel value (float-valued).
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       - Calling this method with out-of-bounds coordinates does nothing.
CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1;
CImg.h:        dx = fx - x;
CImg.h:          const float w1 = 1 - dx, w2 = is_added?1:(1 - w1);
CImg.h:          const float w1 = dx, w2 = is_added?1:(1 - w1);
CImg.h:    //! Set pixel value, using linear interpolation for the X and Y-coordinates.
CImg.h:       is achieved both for X and Y-coordinates.
CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1,
CImg.h:        y = (int)fy - (fy>=0?0:1), ny = y + 1;
CImg.h:        dx = fx - x,
CImg.h:        dy = fy - y;
CImg.h:            const float w1 = (1 - dx)*(1 - dy), w2 = is_added?1:(1 - w1);
CImg.h:            const float w1 = dx*(1 - dy), w2 = is_added?1:(1 - w1);
CImg.h:            const float w1 = (1 - dx)*dy, w2 = is_added?1:(1 - w1);
CImg.h:            const float w1 = dx*dy, w2 = is_added?1:(1 - w1);
CImg.h:    //! Set pixel value, using linear interpolation for the X,Y and Z-coordinates.
CImg.h:       is achieved both for X,Y and Z-coordinates.
CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1,
CImg.h:        y = (int)fy - (fy>=0?0:1), ny = y + 1,
CImg.h:        z = (int)fz - (fz>=0?0:1), nz = z + 1;
CImg.h:        dx = fx - x,
CImg.h:        dy = fy - y,
CImg.h:        dz = fz - z;
CImg.h:              const float w1 = (1 - dx)*(1 - dy)*(1 - dz), w2 = is_added?1:(1 - w1);
CImg.h:              const float w1 = dx*(1 - dy)*(1 - dz), w2 = is_added?1:(1 - w1);
CImg.h:              const float w1 = (1 - dx)*dy*(1 - dz), w2 = is_added?1:(1 - w1);
CImg.h:              const float w1 = dx*dy*(1 - dz), w2 = is_added?1:(1 - w1);
CImg.h:              const float w1 = (1 - dx)*(1 - dy)*dz, w2 = is_added?1:(1 - w1);
CImg.h:              const float w1 = dx*(1 - dy)*dz, w2 = is_added?1:(1 - w1);
CImg.h:              const float w1 = (1 - dx)*dy*dz, w2 = is_added?1:(1 - w1);
CImg.h:              const float w1 = dx*dy*dz, w2 = is_added?1:(1 - w1);
CImg.h:    //! Return a C-string containing a list of all values of the image instance.
CImg.h:       \param separator A \c char character which specifies the separator between values in the returned C-string.
CImg.h:       \param format For float/double-values, tell the printf format used to generate the text representation
CImg.h:       - The returned image is never empty.
CImg.h:       - For an empty image instance, the returned string is <tt>""</tt>.
CImg.h:       - If \c max_size is equal to \c 0, there are no limits on the size of the returned string.
CImg.h:       - Otherwise, if the maximum number of string characters is exceeded, the value string is cut off
CImg.h:        item[printed_size - 1] = separator;
CImg.h:      if (max_size && res._width>=max_size) res.crop(0,max_size - 1);
CImg.h:    //-------------------------------------
CImg.h:    //-------------------------------------
CImg.h:       - A shared image do not own his pixel buffer data() and will not deallocate it on destruction.
CImg.h:       - Most of the time, a \c CImg<T> image instance will \e not be shared.
CImg.h:       - A shared image can only be obtained by a limited set of constructors and methods (see list below).
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       - Return \c true only if all these conditions are verified:
CImg.h:         - The image instance is \e not empty.
CImg.h:         - <tt>0<=x<=\ref width() - 1</tt>.
CImg.h:         - <tt>0<=y<=\ref height() - 1</tt>.
CImg.h:         - <tt>0<=z<=\ref depth() - 1</tt>.
CImg.h:         - <tt>0<=c<=\ref spectrum() - 1</tt>.
CImg.h:    //! Test if pixel value is inside image bounds and get its X,Y,Z and C-coordinates.
CImg.h:       \param[out] x X-coordinate of the pixel value, if test succeeds.
CImg.h:       \param[out] y Y-coordinate of the pixel value, if test succeeds.
CImg.h:       \param[out] z Z-coordinate of the pixel value, if test succeeds.
CImg.h:       \param[out] c C-coordinate of the pixel value, if test succeeds.
CImg.h:       - Useful to convert an offset to a buffer value into pixel value coordinates:
CImg.h:      ulongT off = (ulongT)(ppixel - _data);
CImg.h:    //! Test if pixel value is inside image bounds and get its X,Y and Z-coordinates.
CImg.h:       Similar to contains(const T&,t&,t&,t&,t&) const, except that only the X,Y and Z-coordinates are set.
CImg.h:      ulongT off = ((ulongT)(ppixel - _data))%whd;
CImg.h:    //! Test if pixel value is inside image bounds and get its X and Y-coordinates.
CImg.h:       Similar to contains(const T&,t&,t&,t&,t&) const, except that only the X and Y-coordinates are set.
CImg.h:      ulongT off = ((unsigned int)(ppixel - _data))%wh;
CImg.h:    //! Test if pixel value is inside image bounds and get its X-coordinate.
CImg.h:       Similar to contains(const T&,t&,t&,t&,t&) const, except that only the X-coordinate is set.
CImg.h:      x = (t)(((ulongT)(ppixel - _data))%_width);
CImg.h:       - Buffer overlapping may happen when manipulating \e shared images.
CImg.h:       - If two image buffers overlap, operating on one of the image will probably modify the other one.
CImg.h:       - Most of the time, \c CImg<T> instances are \e non-shared and do not overlap between each others.
CImg.h:         img1("reference.jpg"),             // Load RGB-color image
CImg.h:       \param[out] error_message C-string to contain the error message, if the test does not succeed.
CImg.h:       - Set \c full_checking to \c false to speed-up the 3D object checking. In this case, only the size of
CImg.h:       - Size of the string \c error_message should be at least 128-bytes long, to be able to contain the error message.
CImg.h:       \param[out] error_message C-string to contain the error message, if the test does not succeed.
CImg.h:       - Set \c full_check to \c false to speed-up the 3D object checking. In this case, only the size of
CImg.h:       - Size of the string \c error_message should be at least 128-bytes long, to be able to contain the error message.
CImg.h:                                          nb_points,nb_primitives,(unsigned int)(ptre - ptrs),(ptre - ptrs)>1?"s":"");
CImg.h:                                        nb_points,nb_primitives,(unsigned int)(ptre - ptrs)/3);
CImg.h:                                          nb_points,nb_primitives,p,(unsigned int)(ptrs - ptre));
CImg.h:        if (*(ptrs++)!=(T)-128) ptrs+=2;
CImg.h:            w = (unsigned int)*(ptrs - 3),
CImg.h:            h = (unsigned int)*(ptrs - 2),
CImg.h:            s = (unsigned int)*(ptrs - 1);
CImg.h:                                          nb_points,nb_primitives,c,(unsigned int)(ptrs - ptre));
CImg.h:        if (*(ptrs++)==(T)-128 && (ptrs+=3)<ptre) {
CImg.h:            w = (unsigned int)*(ptrs - 3),
CImg.h:            h = (unsigned int)*(ptrs - 2),
CImg.h:            s = (unsigned int)*(ptrs - 1);
CImg.h:                                        nb_points,nb_primitives,(unsigned int)(ptre - ptrs),(ptre - ptrs)>1?"s":"");
CImg.h:    //-------------------------------------
CImg.h:    //-------------------------------------
CImg.h:#define _cimg_mp_is_reserved(arg) (memtype[arg]==-1) // Is scalar and reserved (e.g. variable)?
CImg.h:#define _cimg_mp_size(arg) (_cimg_mp_is_scalar(arg)?0U:(unsigned int)memtype[arg] - 1) // Size (0=scalar, N>0=vectorN)
CImg.h:  for (s0 = ss; s0>expr._data && *s0!=';'; --s0) {} \
CImg.h:        p_break((CImg<ulongT>*)(cimg_ulong)-2),imgin(img_input),
CImg.h:        char *ps = &expr.back() - 1;
CImg.h:        while (ps>expr._data && (cimg::is_blank(*ps) || *ps==';')) --ps;
CImg.h:        *(++ps) = 0; expr._width = (unsigned int)(ps - expr._data + 1);
CImg.h:        // Ease the retrieval of previous non-space characters afterwards.
CImg.h:        for (unsigned int i = 0; i<=10; ++i) mem[i] = (double)i; // mem[0-10] = 0...10
CImg.h:        for (unsigned int i = 1; i<=5; ++i) mem[i + 10] = -(double)i; // mem[11-15] = -1...-5
CImg.h:        // { -1 = reserved (e.g. variable) | 0 = computation value |
CImg.h:        //    1 = compile-time constant | N>1 = constant ptr to vector[N-1] }.
CImg.h:          memtype[_cimg_mp_slot_z] = memtype[_cimg_mp_slot_c] = -1;
CImg.h:        // reserved_label[0-31] are used to store the memory index of these variables:
CImg.h:        const unsigned int ind_result = compile(expr._data,expr._data + expr._width - 1,0,0,0);
CImg.h:        if (mem._width>=256 && mem._width - mempos>=mem._width/2) mem.resize(mempos,1,1,1,-1);
CImg.h:            opcode._data = p_code->_data;
CImg.h:        p_code_end(0),p_break((CImg<ulongT>*)(cimg_ulong)-2),
CImg.h:        need_input_copy(mp.need_input_copy),result(mem._data + (mp.result - mp.mem._data)),
CImg.h:                                      (ss - 4)>expr._data?ss - 4:expr._data);
CImg.h:            while (se>ss && (cimg::is_blank(c1 = *(se - 1)) || c1==';')) --se; // Remove trailing blanks and ';'
CImg.h:          while (*ss=='(' && *(se - 1)==')' && std::strchr(ss,')')==se - 1) { // Remove useless start/end parentheses
CImg.h:            ++ss; --se; c2 = 1;
CImg.h:            const unsigned int clevel = level[ss - expr._data];
CImg.h:            while (ss<se && (*ss!=')' || level[ss - expr._data]!=clevel)) ++ss;
CImg.h:          *const se1 = se - 1, *const se2 = se - 2, *const se3 = se - 3,
CImg.h:        const unsigned int clevel = level[ss - expr._data], clevel1 = clevel + 1;
CImg.h:        // Look for a single value or a pre-defined variable.
CImg.h:        s = ss + (*ss=='+' || *ss=='-'?1:0);
CImg.h:        if (*s=='i' || *s=='I' || *s=='n' || *s=='N') { // Particular cases : +/-NaN and +/-Inf
CImg.h:          is_sth = *ss=='-';
CImg.h:          if (nb==1 && is_sth) val = -val;
CImg.h:          is_sth = *ss=='-';
CImg.h:            if (is_sth) val = -val;
CImg.h:        if (ss1==se) switch (*ss) { // One-char reserved variable
CImg.h:        else if (ss2==se) { // Two-chars reserved variable
CImg.h:              pos = 20 + *ss1 - '0';
CImg.h:              _cimg_mp_scalar6(mp_ixyzc,_cimg_mp_slot_x,_cimg_mp_slot_y,_cimg_mp_slot_z,pos - 20,0,0);
CImg.h:        } else if (ss3==se) { // Three-chars reserved variable
CImg.h:        } else if (ss4==se) { // Four-chars reserved variable
CImg.h:          if (*s==';' && level[s - expr._data]==clevel) { // Separator ';'
CImg.h:              *ps!='+' && *ps!='-' && *ps!='*' && *ps!='/' && *ps!='%' &&
CImg.h:              level[s - expr._data]==clevel) {
CImg.h:            variable_name.assign(ss,(unsigned int)(s + 1 - ss)).back() = 0;
CImg.h:            char *const ve1 = ss + l_variable_name - 1;
CImg.h:                  s0 = ss3; while (s0<ve1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                  else if (_cimg_mp_is_comp(arg2)) memtype[arg2] = -1;
CImg.h:                  if (_cimg_mp_is_comp(arg1)) memtype[arg1] = -1;
CImg.h:                  s0 = ss3; while (s0<ve1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                  s1 = s0; while (s1<ve1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                    s2 = ++s1; while (s2<ve1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                      s3 = ++s2; while (s3<ve1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
CImg.h:                  else if (_cimg_mp_is_comp(arg5)) memtype[arg5] = -1;
CImg.h:                  if (p1!=~0U && _cimg_mp_is_comp(p1)) memtype[p1] = -1;
CImg.h:                  if (_cimg_mp_is_comp(arg1)) memtype[arg1] = -1;
CImg.h:                  if (_cimg_mp_is_comp(arg2)) memtype[arg2] = -1;
CImg.h:                  if (_cimg_mp_is_comp(arg3)) memtype[arg3] = -1;
CImg.h:                  if (_cimg_mp_is_comp(arg4)) memtype[arg4] = -1;
CImg.h:              s0 = ve1; while (s0>ss && (*s0!='[' || level[s0 - expr._data]!=clevel)) --s0;
CImg.h:              if (s0>ss && is_varname(ss,s0 - ss)) {
CImg.h:                variable_name[s0 - ss] = 0; // Remove brackets in variable name
CImg.h:                  compile(ss,s0,depth1,0,bloc_flags); // Variable does not exist or is not a vector -> error
CImg.h:                if (_cimg_mp_is_const_scalar(arg2)) { // Constant index -> return corresponding variable slot directly
CImg.h:                  compile(ss,s,depth1,0,bloc_flags); // Out-of-bounds reference -> error
CImg.h:                // Case of non-constant index -> return assigned value + linked reference
CImg.h:                  if (_cimg_mp_is_comp(arg3)) memtype[arg3] = -1; // Prevent from being used in further optimization
CImg.h:                  if (_cimg_mp_is_comp(arg2)) memtype[arg2] = -1;
CImg.h:            // Assign user-defined macro.
CImg.h:              s0 = ve1; while (s0>ss && *s0!='(') --s0;
CImg.h:              if (is_varname(ss,s0 - ss) && std::strncmp(variable_name,"debug(",6) &&
CImg.h:                s0 = variable_name._data + (s0 - ss);
CImg.h:                s1 = variable_name._data + l_variable_name - 1; // Pointer to closing parenthesis
CImg.h:                CImg<charT>(variable_name._data,(unsigned int)(s0 - variable_name._data + 1)).move_to(macro_def,0);
CImg.h:                CImg<charT>(s,(unsigned int)(se - s + 1)).move_to(macro_body,0);
CImg.h:                    p2 = (unsigned int)(s3 - s2); // Argument length
CImg.h:                      if (!((ps>macro_body[0]._data && is_varchar(*(ps - 1))) ||
CImg.h:                        if (ps>macro_body[0]._data && *(ps - 1)=='#') { // Remove pre-number sign
CImg.h:                          *(ps - 1) = (char)p1;
CImg.h:                            std::memmove(ps,ps + p2 + 1,macro_body[0].end() - ps - p2 - 1);
CImg.h:                            macro_body[0]._width-=p2 + 1;
CImg.h:                            std::memmove(ps,ps + p2,macro_body[0].end() - ps - p2);
CImg.h:                            macro_body[0]._width-=p2;
CImg.h:                        } else if (ps + p2<macro_body[0].end() && *(ps + p2)=='#') { // Remove post-number sign
CImg.h:                          std::memmove(ps,ps + p2,macro_body[0].end() - ps - p2);
CImg.h:                          macro_body[0]._width-=p2;
CImg.h:                          std::memmove(ps,ps + p2 - 1,macro_body[0].end() - ps - p2 + 1);
CImg.h:                          macro_body[0]._width-=p2 - 1;
CImg.h:                            ps-=(ulongT)macro_body[0]._data;
CImg.h:                            macro_body[0].resize(macro_body[0]._width - p2 + 3,1,1,1,0);
CImg.h:                          } else macro_body[0]._width-=p2 - 3;
CImg.h:                          std::memmove(ps + 3,ps + p2,macro_body[0].end() - ps - 3);
CImg.h:                macro_def[0].resize(macro_def[0]._width + 1,1,1,1,0).back() = is_variadic?(char)-1:(char)(p1 - 1);
CImg.h:              variable_name.resize(variable_name.end() - s0,1,1,1,0,0,1);
CImg.h:                    memtype[arg1] = -1;
CImg.h:                    if (variable_def._width>=variable_pos._width) variable_pos.resize(-200,1,1,1,0);
CImg.h:              } else { // Variable already exists -> assign a new value
CImg.h:                                              _cimg_mp_is_const_scalar(arg1)?"":"non-",
CImg.h:            // No assignment expressions match -> error
CImg.h:        for (s = se2, ps = se3, ns = ps - 1; s>ss1; --s, --ps, --ns) // Here, ns = ps - 1
CImg.h:              level[s - expr._data]==clevel) { // Self-operators for complex numbers only (**=,//=,^^=)
CImg.h:        for (s = se2, ps = se3, ns = ps - 1; s>ss1; --s, --ps, --ns) // Here, ns = ps - 1
CImg.h:          if (*s=='=' && (*ps=='+' || *ps=='-' || *ps=='*' || *ps=='/' || (*ps=='%' && s[1]!='=') ||
CImg.h:              level[s - expr._data]==clevel) { // Self-operators (+=,-=,*=,/=,%=,>>=,<<=,&=,^=,|=)
CImg.h:            case '-' : op = mp_self_sub; _cimg_mp_op("Operator '-='"); break;
CImg.h:            variable_name.assign(ss,(unsigned int)(s - ss)).back() = 0;
CImg.h:          if (*s=='?' && level[s - expr._data]==clevel) { // Ternary operator 'cond?expr1:expr2'
CImg.h:            s1 = s + 1; while (s1<se1 && (*s1!=':' || level[s1 - expr._data]!=clevel)) ++s1;
CImg.h:                                p3 - p2,code._width - p3,arg4).move_to(code,p2);
CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
CImg.h:          if (*s=='|' && *ns=='|' && level[s - expr._data]==clevel) { // Logical or ('||')
CImg.h:            CImg<ulongT>::vector((ulongT)mp_logical_or,pos,arg1,arg2,code._width - p2).
CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
CImg.h:          if (*s=='&' && *ns=='&' && level[s - expr._data]==clevel) { // Logical and ('&&')
CImg.h:            CImg<ulongT>::vector((ulongT)mp_logical_and,pos,arg1,arg2,code._width - p2).
CImg.h:        for (s = se2; s>ss; --s)
CImg.h:          if (*s=='|' && level[s - expr._data]==clevel) { // Bitwise or ('|')
CImg.h:        for (s = se2; s>ss; --s)
CImg.h:          if (*s=='&' && level[s - expr._data]==clevel) { // Bitwise and ('&')
CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
CImg.h:          if (*s=='!' && *ns=='=' && level[s - expr._data]==clevel) { // Not equal to ('!=')
CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
CImg.h:          if (*s=='=' && *ns=='=' && level[s - expr._data]==clevel) { // Equal to ('==')
CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
CImg.h:          if (*s=='<' && *ns=='=' && level[s - expr._data]==clevel) { // Less or equal than ('<=')
CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
CImg.h:          if (*s=='>' && *ns=='=' && level[s - expr._data]==clevel) { // Greater or equal than ('>=')
CImg.h:        for (s = se2, ns = se1, ps = se3; s>ss; --s, --ns, --ps)
CImg.h:          if (*s=='<' && *ns!='<' && *ps!='<' && level[s - expr._data]==clevel) { // Less than ('<')
CImg.h:        for (s = se2, ns = se1, ps = se3; s>ss; --s, --ns, --ps)
CImg.h:          if (*s=='>' && *ns!='>' && *ps!='>' && level[s - expr._data]==clevel) { // Greater than ('>')
CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
CImg.h:          if (*s=='<' && *ns=='<' && level[s - expr._data]==clevel) { // Left bit shift ('<<')
CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
CImg.h:          if (*s=='>' && *ns=='>' && level[s - expr._data]==clevel) { // Right bit shift ('>>')
CImg.h:        for (ns = se1, s = se2, ps = pexpr._data + (se3 - expr._data); s>ss; --ns, --s, --ps)
CImg.h:          if (*s=='+' && (*ns!='+' || ns!=se1) && *ps!='-' && *ps!='+' && *ps!='*' && *ps!='/' && *ps!='%' &&
CImg.h:              (*ps!='e' || !(ps - pexpr._data>ss - expr._data && (*(ps - 1)=='.' || (*(ps - 1)>='0' &&
CImg.h:                                                                                     *(ps - 1)<='9')))) &&
CImg.h:              level[s - expr._data]==clevel) { // Addition ('+')
CImg.h:        for (ns = se1, s = se2, ps = pexpr._data + (se3 - expr._data); s>ss; --ns, --s, --ps)
CImg.h:          if (*s=='-' && (*ns!='-' || ns!=se1) && *ps!='-' && *ps!='+' && *ps!='*' && *ps!='/' && *ps!='%' &&
CImg.h:              (*ps!='e' || !(ps - pexpr._data>ss - expr._data && (*(ps - 1)=='.' || (*(ps - 1)>='0' &&
CImg.h:                                                                                     *(ps - 1)<='9')))) &&
CImg.h:              level[s - expr._data]==clevel) { // Subtraction ('-')
CImg.h:            _cimg_mp_op("Operator '-'");
CImg.h:              _cimg_mp_const_scalar(mem[arg1] - mem[arg2]);
CImg.h:            if (code) { // Try to spot linear cases 'a*b - c' and 'c - a*b'
CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
CImg.h:          if (*s=='*' && *ns=='*' && level[s - expr._data]==clevel) { // Complex multiplication ('**')
CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
CImg.h:          if (*s=='/' && *ns=='/' && level[s - expr._data]==clevel) { // Complex division ('//')
CImg.h:        for (s = se2; s>ss; --s) if (*s=='*' && level[s - expr._data]==clevel) { // Multiplication ('*')
CImg.h:        for (s = se2; s>ss; --s) if (*s=='/' && level[s - expr._data]==clevel) { // Division ('/')
CImg.h:        for (s = se2, ns = se1; s>ss; --s, --ns)
CImg.h:          if (*s=='%' && *ns!='^' && level[s - expr._data]==clevel) { // Modulo ('%')
CImg.h:          if (*ss=='-' && (*ss1!='-' || (ss2<se && *ss2>='0' && *ss2<='9'))) { // Unary minus ('-')
CImg.h:            _cimg_mp_op("Operator '-'");
CImg.h:            if (_cimg_mp_is_const_scalar(arg1)) _cimg_mp_const_scalar(-mem[arg1]);
CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
CImg.h:          if (*s=='^' && *ns=='^' && level[s - expr._data]==clevel) { // Complex power ('^^')
CImg.h:        for (s = se2; s>ss; --s)
CImg.h:          if (*s=='^' && level[s - expr._data]==clevel) { // Power ('^')
CImg.h:        // Degree to radian postfix operator ('°' in UTF-8).
CImg.h:        // Pre/post-decrement and increment.
CImg.h:        is_sth = ss1<se1 && (*ss=='+' || *ss=='-') && *ss1==*ss; // is pre-?
CImg.h:        if (is_sth || (se2>ss && (*se1=='+' || *se1=='-') && *se2==*se1)) {
CImg.h:            _cimg_mp_op("Operator '--'");
CImg.h:          if (is_sth) variable_name.assign(ss2,(unsigned int)(se - ss1));
CImg.h:          else variable_name.assign(ss,(unsigned int)(se1 - ss));
CImg.h:        // Array-like access to vectors and image values 'i/j/I/J[_#ind,offset,_boundary]' and 'vector[offset]'.
CImg.h:          s0 = se1; while (s0>ss && (*s0!='[' || level[s0 - expr._data]!=clevel)) --s0;
CImg.h:          if (s0>ss) { s1 = s0; do { --s1; } while (cimg::is_blank(*s1)); cimg::swap(*s0,*++s1); }
CImg.h:          is_sth=s0>ss && *(s0-1)==']';  // Particular case s.a. '..[..][..]' ?
CImg.h:              s0 = ss3; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:            s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              if (_cimg_mp_is_comp(arg1)) memtype[arg1] = -1;
CImg.h:            p2 = ~0U; // 'p2' must be the dimension of the vector-valued operand if any
CImg.h:              s0 = ss3; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:            s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              if (p1!=~0U && _cimg_mp_is_comp(p1)) memtype[p1] = -1; // Prevent from being used in further optimization
CImg.h:              if (_cimg_mp_is_comp(arg1)) memtype[arg1] = -1;
CImg.h:            memtype[pos] = -1; // Prevent from being used in further optimization
CImg.h:          s0 = se1; while (s0>ss && (*s0!='[' || level[s0 - expr._data]!=clevel)) --s0;
CImg.h:              variable_name.assign(ss,(unsigned int)(s0 - ss + 1)).back() = 0;
CImg.h:                                          "CImg<%s>::%s: %s: Array brackets used on non-vector variable '%s', "
CImg.h:            s1 = s0 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:            if (s1<se1) { // Two or three arguments -> sub-vector extraction
CImg.h:              s0 = ++s1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:            // One argument -> vector value reference
CImg.h:              variable_name.assign(ss,(unsigned int)(s0 - ss)).back() = 0;
CImg.h:                                          "CImg<%s>::%s: Out-of-bounds reference '%s[%d]' "
CImg.h:              if (_cimg_mp_is_comp(arg2)) memtype[arg2] = -1; // Prevent from being used in further optimization
CImg.h:            memtype[pos] = -1; // Prevent from being used in further optimization
CImg.h:          s0 = s1 = std::strchr(ss,'('); if (s0) { do { --s1; } while (cimg::is_blank(*s1)); cimg::swap(*s0,*++s1); }
CImg.h:              s0 = ss3; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:              s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                  s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                  s3 = ++s2; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
CImg.h:                    s2 = ++s3; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:              if (p1!=~0U && _cimg_mp_is_comp(p1)) memtype[p1] = -1; // Prevent from being used in further optimization
CImg.h:              if (_cimg_mp_is_comp(arg1)) memtype[arg1] = -1;
CImg.h:              if (_cimg_mp_is_comp(arg2)) memtype[arg2] = -1;
CImg.h:              if (_cimg_mp_is_comp(arg3)) memtype[arg3] = -1;
CImg.h:            p2 = ~0U; // 'p2' must be the dimension of the vector-valued operand if any
CImg.h:              s0 = ss3; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:              s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                  s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                  s3 = ++s2; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
CImg.h:                    s2 = ++s3; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                      s3 = ++s2; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
CImg.h:              if (p1!=~0U && _cimg_mp_is_comp(p1)) memtype[p1] = -1; // Prevent from being used in further optimization
CImg.h:              if (_cimg_mp_is_comp(arg1)) memtype[arg1] = -1;
CImg.h:              if (_cimg_mp_is_comp(arg2)) memtype[arg2] = -1;
CImg.h:              if (_cimg_mp_is_comp(arg3)) memtype[arg3] = -1;
CImg.h:              if (_cimg_mp_is_comp(arg4)) memtype[arg4] = -1;
CImg.h:            memtype[pos] = -1; // Prevent from being used in further optimization
CImg.h:              s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:                p3-=1; // Number of args
CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              if (pexpr[se2 - expr._data]=='(') { // no arguments?
CImg.h:              if (pexpr[se2 - expr._data]=='(') { // no arguments?
CImg.h:              if (pexpr[se2 - expr._data]=='(') { // no arguments?
CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                s3 = ++s2; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
CImg.h:                  s1 = ++s3; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                    s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:              CImg<ulongT>::vector((ulongT)mp_critical,arg1,code._width - p1).move_to(code,p1);
CImg.h:                s0 = ss6; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:              default : // Error -> too much arguments
CImg.h:                                              "some xyzc-coordinates are unspecified, in expression '%s'.",
CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:                xend = opcode[21]!=~0U?(int)mem[opcode[21]]:wA - 1,
CImg.h:                yend = opcode[22]!=~0U?(int)mem[opcode[22]]:hA - 1,
CImg.h:                zend = opcode[23]!=~0U?(int)mem[opcode[23]]:dA - 1;
CImg.h:                                            "CImg<%s>::%s: %s: Invalid xyz-start/end arguments "
CImg.h:              arg2 = xend - xstart + 1;
CImg.h:              arg3 = yend - ystart + 1;
CImg.h:                s1 = ++s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s1 = ++s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s0 = s1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:              if (p1==~0U) compile(s1 + 1,se1,depth1,0,bloc_flags); // Missing element -> error
CImg.h:                s0 = ss + 11; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s0 = ss + 9; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              ((CImg<ulongT>::vector((ulongT)mp_debug,arg1,0,code._width - p1),
CImg.h:              if (pexpr[se2 - expr._data]=='(') { // no arguments?
CImg.h:                s1 = ss8; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                  s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                    s3 = ++s2; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
CImg.h:                      s2 = ++s3; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:              arg1 = opcode._height - 3;
CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              CImg<ulongT>::vector((ulongT)mp_do,p1,p2,arg2 - arg1,code._width - arg2,_cimg_mp_size(p1),
CImg.h:                s0 = ss6; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:              s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s0 = s1 + 1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                    s1 = s0 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                      s0 = s1 + 1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                        s1 = s0 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                  s0 = s1 + 1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                    s1 = s0 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                      s0 = s1 + 1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                s1 = s0 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                  s0 = s1 + 1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                ns = s; while (ns<se1 && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:                s0 = ss + 9; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                  s1 = s2 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                    s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:            if (!std::strncmp(ss,"f2ui(",5)) { // Special float->uint conversion
CImg.h:              s0 = ss5; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:              s1 = ++s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                variable_name.assign(s0,(unsigned int)(s1 + 1 - s0)).back() = 0;
CImg.h:                                  _cimg_mp_is_const_scalar(arg2))) { // Variable is not a vector or is a constant->error
CImg.h:                } else if (arg2==~0U) { // Variable does not exist -> create it
CImg.h:                    if (variable_def._width>=variable_pos._width) variable_pos.resize(-200,1,1,1,0);
CImg.h:                  memtype[arg2] = -1;
CImg.h:              CImg<ulongT>::vector((ulongT)mp_fill,arg1,_cimg_mp_size(arg1),arg2,arg3,code._width - p1).
CImg.h:              s0 = ss5; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:              s1 = ++s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s0 = s1 + 1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:              s3 = s2 + 1; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
CImg.h:              CImg<ulongT>::vector((ulongT)mp_for,p3,(ulongT)_cimg_mp_size(p3),p2,arg2 - arg1,arg3 - arg2,
CImg.h:                                   arg4 - arg3,code._width - arg4,
CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                _cimg_mp_const_scalar(std::exp(-val1*val1/(2*val2*val2))/(mem[arg3]?std::sqrt(2*val2*val2*cimg::PI):1));
CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:              s1 = ss3; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                                  p3 - p2,code._width - p3,arg4).move_to(code,p2);
CImg.h:              s1 = ss8; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:              s1 = s2 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:              s1 = ss7; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                  ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                                 (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                  _cimg_mp_const_scalar(mem[arg1]*(1-t) + mem[arg2]*t);
CImg.h:            if (!std::strncmp(ss,"log2(",5)) { // Base-2 logarithm
CImg.h:            if (!std::strncmp(ss,"log10(",6)) { // Base-10 logarithm
CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:              s1 = s2 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                s1 = s2 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                  s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:            if (!std::strncmp(ss,"merge(",6)) { // Merge inter-thread variables
CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                          // (0='=',1='+',2='-',3='*',4='/',5='&',6='|',7='xor',8='&&',9=='||',10='min',11='max')
CImg.h:                if (cimg_sscanf(s1," %3[=+-*/&|minaxor]%c",st_op,&sep)==2 && (sep==')' ||
CImg.h:                  if (!is_sth || (is_sth && cimg_sscanf(s1," %*[=+-*/&|minaxor ]%c",&sep)==1 && sep==')')) {
CImg.h:                      arg1 = *st_op=='='?0:*st_op=='+'?1:*st_op=='-'?2:*st_op=='*'?3:*st_op=='/'?4:
CImg.h:                                            "(should be one of '=,+,-,*,/,&,|,xor,&&,||,min,max'), "
CImg.h:              memmerge(0,memmerge._height - 1) = (int)pos;
CImg.h:              memmerge(1,memmerge._height - 1) = (int)_cimg_mp_size(pos);
CImg.h:              memmerge(2,memmerge._height - 1) = (int)arg1;
CImg.h:                s0 = ss6; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:                CImg<ulongT>::vector((ulongT)mp_normp,pos,0,(ulongT)(arg1==~0U?-1:(int)arg1)).
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:              s1 = ss7; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                s0 = ss + 9; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:                else // Vector or non-const scalar
CImg.h:            if (!std::strncmp(ss,"pseudoinvert(",13)) { // Matrix/scalar pseudo-inversion
CImg.h:              s1 = ss + 13; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                variable_name.assign(s1,(unsigned int)(se1 + 1 - s1)).back() = 0;
CImg.h:                if (variable_def._width>=variable_pos._width) variable_pos.resize(-200,1,1,1,0);
CImg.h:              else if (_cimg_mp_is_comp(arg3)) memtype[arg3] = -1;
CImg.h:              s0 = ss7; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:              s1 = ++s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                variable_name.assign(s0,(unsigned int)(s1 + 1 - s0)).back() = 0;
CImg.h:                                  _cimg_mp_is_const_scalar(arg2))) { // Variable is not a vector or is a constant->error
CImg.h:                } else if (arg2==~0U) { // Variable does not exist -> create it
CImg.h:                    if (variable_def._width>=variable_pos._width) variable_pos.resize(-200,1,1,1,0);
CImg.h:                  memtype[arg2] = -1;
CImg.h:              CImg<ulongT>::vector((ulongT)mp_repeat,arg3,arg1,arg2,code._width - p1).move_to(code,p1);
CImg.h:                  ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                                 (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:                if (opcode.height()<2) compile(s,se1,depth1,0,bloc_flags); // Not enough arguments -> throw exception
CImg.h:                  if (opcode.height()<6) compile(s,se1,depth1,0,bloc_flags); // Not enough arguments -> throw exception
CImg.h:                s0 = ss8; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                  ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                                 (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1-expr._data]!=clevel1)) ++s1;
CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                  s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                  s3 = s2 + 1; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                s3 = s2 + 1; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s0 = ++s1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s0 = ++s1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                  s1 = ++s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                s1 = s2 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                  s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                    s1 = s2 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                      s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:                s0 = ss8; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s1 = ss + 10; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              s1 = ss2; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:            if (!std::strncmp(ss,"ui2f(",5)) { // Special uint->float conversion
CImg.h:            if (!std::strncmp(ss,"unref(",6)) { // Un-reference variable
CImg.h:                    if (arg1<variable_pos._width - 1)
CImg.h:                                   sizeof(uintT)*(variable_pos._width - arg1 - 1));
CImg.h:                    --variable_pos._width;
CImg.h:                s0 = ++s; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
CImg.h:                  ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                                 (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:                !std::strncmp(ss,"vargkth(",8)) { // Multi-argument vector functions
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
CImg.h:              if (arg3==~0U) { // Auto-guess best output vector size
CImg.h:                p1 = p1?25*p1 - 1:24;
CImg.h:              s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              CImg<ulongT>::vector((ulongT)mp_while,pos,arg1,p2 - p1,code._width - p2,arg2,
CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
CImg.h:              !std::strncmp(ss,"argkth(",7)) { // Multi-argument functions
CImg.h:              ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                             (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:          // No corresponding built-in function -> Look for a user-defined macro call.
CImg.h:            variable_name.assign(ss,(unsigned int)(s0 - ss + 1)).back() = 0;
CImg.h:              ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                             (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:                                          ((mb = macro_def[l].back())==(char)p1 || mb==(char)-1)) {
CImg.h:              const bool is_variadic = mb==(char)-1;
CImg.h:                  ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                                 (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:                variable_name.assign(s,(unsigned int)(ns - s + 1)).back() = 0; // Argument to write
CImg.h:                      _expr.resize(arg1 + variable_name._width - 2,1,1,1,0);
CImg.h:                      std::memmove(_expr._data + k + variable_name._width - 1,_expr._data + k + 1,arg1 - k - 1);
CImg.h:                      std::memcpy(_expr._data + k,variable_name,variable_name._width - 1);
CImg.h:                      k+=variable_name._width - 2;
CImg.h:                      std::memmove(_expr._data + k,_expr._data + k + 1,arg1 - k - 1);
CImg.h:                      --k;
CImg.h:              pos = compile(expr._data,expr._data + expr._width - 1,depth1,p_ref,bloc_flags);
CImg.h:                --sig_nargs._width;
CImg.h:          arg1 = (unsigned int)(se1 - s1); // Original string length
CImg.h:          if (!arg1) _cimg_mp_return(0); // Empty string -> 0
CImg.h:          s2 = se2; while (s2>s1 && cimg::is_blank(*s2)) --s2;
CImg.h:            arg1 = (unsigned int)(s2 - s1 - 1); // Original string length
CImg.h:            if (!arg1) _cimg_mp_return(0); // Empty string -> 0
CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
CImg.h:                               (*ns!=']' || level[ns - expr._data]!=clevel)) ++ns;
CImg.h:              _cimg_mp_scalar7(mp_list_ixyzc,arg1,_cimg_mp_slot_x,_cimg_mp_slot_y,_cimg_mp_slot_z,*ss1 - '0',
CImg.h:        variable_name.assign(ss,(unsigned int)(se + 1 - ss)).back() = 0;
CImg.h:        // Reached an unknown item -> error.
CImg.h:          opcode._data = p_code->_data;
CImg.h:          opcode._data = p_code->_data;
CImg.h:          opcode._data = p_code->_data;
CImg.h:          mem[_cimg_mp_slot_x] = imgin._width - 1.;
CImg.h:          mem[_cimg_mp_slot_y] = imgin._height - 1.;
CImg.h:          mem[_cimg_mp_slot_z] = imgin._depth - 1.;
CImg.h:          mem[_cimg_mp_slot_c] = imgin._spectrum - 1.;
CImg.h:          opcode._data = p_code->_data;
CImg.h:          mem[_cimg_mp_slot_x] = imgin._width - 1.;
CImg.h:          mem[_cimg_mp_slot_y] = imgin._height - 1.;
CImg.h:          mem[_cimg_mp_slot_z] = imgin._depth - 1.;
CImg.h:          mem[_cimg_mp_slot_c] = imgin._spectrum - 1.;
CImg.h:          opcode._data = p_code->_data;
CImg.h:      // Merge inter-thread variables.
CImg.h:            case 2 : mp.mem[pos]-=mem[pos]; break;                                        // Operator-
CImg.h:            case 2 : // Operator-
CImg.h:              CImg<doubleT>(&mp.mem[pos + 1],siz,1,1,1,true)-=CImg<doubleT>(&mem[pos + 1],siz,1,1,1,true);
CImg.h:        return _s_arg[n_arg<sizeof(_s_arg)/sizeof(char*)?n_arg:sizeof(_s_arg)/sizeof(char*)-1];
CImg.h:      // Return a string that defines the calling function + the user-defined function scope.
CImg.h:        unsigned int mode = 0, next_mode = 0; // { 0=normal | 1=char-string | 2=vector-string
CImg.h:        CImg<uintT> res(_expr._width - 1);
CImg.h:          if (!is_escaped && *ps=='\'') { // Non-escaped character
CImg.h:            if (!mode && ps>_expr._data && *(ps - 1)=='[') next_mode = mode = 2; // Start vector-string
CImg.h:            else if (mode==2 && *(ps + 1)==']') next_mode = !mode; // End vector-string
CImg.h:            else if (mode<2) next_mode = mode?(mode = 0):1; // Start/end char-string
CImg.h:                                   *ps==')' || *ps==']'?--_level:
CImg.h:            mem_img_index = const_scalar((double)(&imgout - imglist.data()));
CImg.h:        unsigned int rp = variable_name[1]?~0U:*variable_name; // One-char variable
CImg.h:        if (variable_name[1] && !variable_name[2]) { // Two-chars variable
CImg.h:            if (c2>='0' && c2<='9') rp = 20 + c2 - '0'; // i0...i9
CImg.h:        } else if (variable_name[1] && variable_name[2] && !variable_name[3]) { // Three-chars variable
CImg.h:                   !variable_name[4]) { // Four-chars variable
CImg.h:        // Multi-char variable name : check for existing variable with same name
CImg.h:        while (siz-->0) if (*(ptr++)) { is_tmp = false; break; }
CImg.h:      // { 0=constant | 1=integer constant | 2=positive integer constant | 3=strictly-positive integer constant }
CImg.h:          if (*s_op!='F') s_arg = !n_arg?"":n_arg==1?"Left-hand":"Right-hand";
CImg.h:          if (*s_op!='F') s_arg = !n_arg?"":n_arg==1?"Left-hand":"Right-hand";
CImg.h:        // Search for built-in constant.
CImg.h:          if (val<0 && val>=-5) return (unsigned int)(10 - val);
CImg.h:            const double val_beg = *constcache_vals, val_end = constcache_vals[constcache_size - 1];
CImg.h:            else if (val_end==val) ind = constcache_size - 1;
CImg.h:              unsigned int i0 = 1, i1 = constcache_size - 2;
CImg.h:                else i1 = mid - 1;
CImg.h:                constcache_vals.resize(-200,1,1,1,0);
CImg.h:                constcache_inds.resize(-200,1,1,1,0);
CImg.h:              const int l = constcache_size - (int)ind - 1;
CImg.h:        if (mempos>=mem._width) { mem.resize(-200,1,1,1,0); memtype.resize(-200,1,1,1,0); }
CImg.h:        if (mempos>=mem._width) { mem.resize(-200,1,1,1,0); memtype.resize(mem._width,1,1,1,0); }
CImg.h:        while (siz-->0) *(ptr++) = -1;
CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1).move_to(code[code._width - 1 - siz + k]);
CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1 + k).move_to(code[code._width - 1 - siz + k]);
CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1 + k).move_to(code[code._width - 1 - siz + k]);
CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1 + k,arg2 + k).move_to(code[code._width - 1 - siz + k]);
CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1 + k,arg2).move_to(code[code._width - 1 - siz + k]);
CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1,arg2 + k).move_to(code[code._width - 1 - siz + k]);
CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1 + k,arg2,arg3).move_to(code[code._width - 1 - siz + k]);
CImg.h:          nb_args = (unsigned int)mp.opcode[2] - 4,
CImg.h:          nb_args = (unsigned int)mp.opcode[2] - 4,
CImg.h:        for (unsigned int i = 4; i<i_end; ++i) if (val==_mp_arg(i)) return i - 3.;
CImg.h:          if (_val<val) { val = _val; argval = i - 3; }
CImg.h:          if (_absval<absval) { val = _val; absval = _absval; argval = i - 3; }
CImg.h:          if (_val>val) { val = _val; argval = i - 3; }
CImg.h:          if (_absval>absval) { val = _val; absval = _absval; argval = i - 3; }
CImg.h:        return val/(i_end - 3);
CImg.h:        mp.p_code = mp.p_break - 1;
CImg.h:        const unsigned int nb_args = (unsigned int)(mp.opcode[2] - 3)/2;
CImg.h:          if (siz) { // Vector argument -> string
CImg.h:          } else { // Scalar argument -> number
CImg.h:        ptrd[1] = -imag;
CImg.h:        *ptrd =  -r1*i2/denom;
CImg.h:        *ptrd = (r2*i1 - r1*i2)/denom;
CImg.h:        *(ptrd++) = r1*r2 - i1*i2;
CImg.h:        if (cimg::abs(i2)<1e-15) { // Exponent is real
CImg.h:          if (cimg::abs(r1)<1e-15 && cimg::abs(i1)<1e-15) {
CImg.h:            if (cimg::abs(r2)<1e-15) { ro = 1; io = 0; }
CImg.h:          if (cimg::abs(r1)<1e-15 && cimg::abs(i1)<1e-15) ro = io = 0;
CImg.h:            modo = std::pow(mod1_2,0.5*r2)*std::exp(-i2*phi1),
CImg.h:        ptrd[1] = -std::sin(real)*std::sinh(imag);
CImg.h:        mp.p_code = mp.p_break - 1;
CImg.h:            mp.opcode._data = mp.p_code->_data;
CImg.h:        --mp.p_code;
CImg.h:                                                                 x + dx - 1,y + dy - 1,
CImg.h:                                                                 z + dz - 1,c + dc - 1,
CImg.h:        int siz = img?(int)img[img._height - 1]:0;
CImg.h:        if (img && (img._width!=1 || img._depth!=1 || siz<0 || siz>img.height() - 1))
CImg.h:        if (dim<1) ret = img[siz - 1]; // Scalar element
CImg.h:        else cimg_forC(img,c) ptrd[c] = img(0,siz - 1,0,c); // Vector element
CImg.h:          --siz;
CImg.h:            img.resize(1,std::max(2*siz + 1,32),1,-100,0);
CImg.h:          img[img._height - 1] = (T)siz;
CImg.h:          nb_elts = (unsigned int)mp.opcode[5] - 6,
CImg.h:          siz = img?(int)img[img._height - 1]:0,
CImg.h:        if (img && (img._width!=1 || img._depth!=1 || siz<0 || siz>img.height() - 1))
CImg.h:                                      "Invalid position %d (not in range -%d...%d).",
CImg.h:          cimg_forC(img,c) std::memmove(img.data(0,pos + nb_elts,0,c),img.data(0,pos,0,c),(siz - pos)*sizeof(T));
CImg.h:        img[img._height - 1] = (T)(siz + nb_elts);
CImg.h:        int siz = img?(int)img[img._height - 1]:0;
CImg.h:        if (img && (img._width!=1 || img._depth!=1 || siz<0 || siz>img.height() - 1))
CImg.h:          start0 = mp.opcode[3]==~0U?siz - 1:_mp_arg(3),
CImg.h:                                      "(not ordered, in range -%d...%d).",
CImg.h:                                      mp.imgout.pixel_type(),start0,end0,siz,siz - 1);
CImg.h:        if (end<siz - 1) // Move remaining data in dynamic array
CImg.h:          cimg_forC(img,c) std::memmove(img.data(0,start,0,c),img.data(0,end + 1,0,c),(siz - 1 - end)*sizeof(T));
CImg.h:        siz-=end - start + 1;
CImg.h:          img.resize(1,std::max(2*siz + 1,32),1,-100,0);
CImg.h:        img[img._height - 1] = (T)siz;
CImg.h:        const int siz = img?(int)img[img._height - 1]:0;
CImg.h:        if (img && (img._width!=1 || img._depth!=1 || siz<0 || siz>img.height() - 1))
CImg.h:        CImg<charT> expr(mp.opcode[2] - 4);
CImg.h:                       "Start debugging expression '%s', code length %u -> mem[%u] (memsize: %u)",
CImg.h:          _op.assign(1,op._height - 1);
CImg.h:                         "Opcode %p = [ %p,%s ] -> mem[%u] = %.17g",
CImg.h:          mp.debug_indent-=3;
CImg.h:            "End debugging expression '%s' -> mem[%u] = %.17g (memsize: %u)",
CImg.h:        --mp.p_code;
CImg.h:        return _mp_arg(2) - 1;
CImg.h:        const unsigned int i_end = (unsigned int)mp.opcode[2], siz = mp.opcode[2] - 3;
CImg.h:          else img.assign(ptr,siz).resize(w,h,d,s,-1);
CImg.h:        CImg<charT> expr(mp.opcode[2] - 8);
CImg.h:            mp.opcode._data = mp.p_code->_data;
CImg.h:            mp.opcode._data = mp.p_code->_data;
CImg.h:        mp.p_code = p_end - 1;
CImg.h:        const unsigned int nb_args = (unsigned int)(mp.opcode[2] - 3)/2;
CImg.h:          if (siz) { // Vector argument -> string
CImg.h:          } else { // Scalar argument -> number
CImg.h:                      r1 = -r1; r2 = -r2;
CImg.h:                      else { color.resize(k,1,1,1,-1); break; }
CImg.h:          CImg<doubleT> args(i_end - 4);
CImg.h:        cimg_for_inX(ss,0,ss.width() - 1,i) ss[i] = (char)ptrs[i];
CImg.h:        if (siz) ++ptrd; else ++siz; // Fill vector-valued slot
CImg.h:              mp.opcode._data = mp.p_code->_data;
CImg.h:              mp.opcode._data = mp.p_code->_data;
CImg.h:        mp.p_code = p_end - 1;
CImg.h:        const int _step = (int)_mp_arg(6), step = _step?_step:-1;
CImg.h:        longT ind = (longT)(mp.opcode[5]!=_cimg_mp_slot_nan?_mp_arg(5):step>0?0:siz - 1);
CImg.h:        if (ind<0 || ind>=(longT)siz) return -1.;
CImg.h:          return ptr>=ptre?-1.:(double)(ptr - ptrb);
CImg.h:        return ptr<ptrb?-1.:(double)(ptr - ptrb);
CImg.h:        const int _step = (int)_mp_arg(7), step = _step?_step:-1;
CImg.h:        longT ind = (longT)(mp.opcode[6]!=_cimg_mp_slot_nan?_mp_arg(6):step>0?0:siz1 - 1);
CImg.h:        if (ind<0 || ind>=(longT)siz1) return -1.;
CImg.h:            if (ptr1>=ptr1e) return -1.;
CImg.h:          return p2<ptr2e?-1.:(double)(ptr1 - ptr1b);
CImg.h:          if (ptr1<ptr1b) return -1.;
CImg.h:        return p2<ptr2e?-1.:(double)(ptr1 - ptr1b);
CImg.h:          mp.opcode._data = mp.p_code->_data;
CImg.h:              mp.opcode._data = mp.p_code->_data;
CImg.h:                mp.opcode._data = mp.p_code->_data;
CImg.h:              for (mp.p_code = p_post; mp.p_code<p_end; ++mp.p_code) { // Evaluate post-code
CImg.h:                mp.opcode._data = mp.p_code->_data;
CImg.h:        mp.p_code = p_end - 1;
CImg.h:        return std::exp(-x*x/(2*s*s))/(_mp_arg(4)?std::sqrt(2*s*s*cimg::PI):1);
CImg.h:        cimg_for_inX(ss,0,ss.width() - 1,i) ss[i] = (char)ptrs[i];
CImg.h:            mp.opcode._data = mp.p_code->_data;
CImg.h:            mp.opcode._data = mp.p_code->_data;
CImg.h:        if (mp.p_code==mp.p_break) --mp.p_code;
CImg.h:        else mp.p_code = p_end - 1;
CImg.h:          _w = mp.opcode[3]==~0U?-100:_mp_arg(3),
CImg.h:          _h = mp.opcode[4]==~0U?-100:_mp_arg(4),
CImg.h:          _d = mp.opcode[5]==~0U?-100:_mp_arg(5),
CImg.h:          _s = mp.opcode[6]==~0U?-100:_mp_arg(6);
CImg.h:          w = (unsigned int)(_w>=0?_w:-_w*img.width()/100),
CImg.h:          h = (unsigned int)(_h>=0?_h:-_h*img.height()/100),
CImg.h:          d = (unsigned int)(_d>=0?_d:-_d*img.depth()/100),
CImg.h:          s = (unsigned int)(_s>=0?_s:-_s*img.spectrum()/100),
CImg.h:            return (double)img[moff<whds?moff:whds2 - moff - 1];
CImg.h:            return (double)img[off<0?0:whds - 1];
CImg.h:            return (double)img._cubic_atXYZ(mx<img.width()?mx:w2 - mx - 1,
CImg.h:                                            my<img.height()?my:h2 - my - 1,
CImg.h:                                            mz<img.depth()?mz:d2 - mz - 1,
CImg.h:                                            (int)(mc<img.spectrum()?mc:s2 - mc - 1));
CImg.h:                                            (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
CImg.h:            return (double)img._linear_atXYZ(mx<img.width()?mx:w2 - mx - 1,
CImg.h:                                             my<img.height()?my:h2 - my - 1,
CImg.h:                                             mz<img.depth()?mz:d2 - mz - 1,
CImg.h:                                             (int)(mc<img.spectrum()?mc:s2 - mc - 1));
CImg.h:                                             (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
CImg.h:            return (double)img(mx<img.width()?mx:w2 - mx - 1,
CImg.h:                               my<img.height()?my:h2 - my - 1,
CImg.h:                               mz<img.depth()?mz:d2 - mz - 1,
CImg.h:                               mc<img.spectrum()?mc:s2 - mc - 1);
CImg.h:            return (double)img[moff<whds?moff:whds2 - moff - 1];
CImg.h:            return (double)img[off<0?0:whds - 1];
CImg.h:            return (double)img._cubic_atXYZ(mx<img.width()?mx:w2 - mx - 1,
CImg.h:                                            my<img.height()?my:h2 - my - 1,
CImg.h:                                            mz<img.depth()?mz:d2 - mz - 1,
CImg.h:                                            (int)(mc<img.spectrum()?mc:s2 - mc - 1));
CImg.h:                                            (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
CImg.h:            return (double)img._linear_atXYZ(mx<img.width()?mx:w2 - mx - 1,
CImg.h:                                             my<img.height()?my:h2 - my - 1,
CImg.h:                                             mz<img.depth()?mz:d2 - mz - 1,
CImg.h:                                             (int)(mc<img.spectrum()?mc:s2 - mc - 1));
CImg.h:                                             (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
CImg.h:            return (double)img(mx<img.width()?mx:w2 - mx - 1,
CImg.h:                               my<img.height()?my:h2 - my - 1,
CImg.h:                               mz<img.depth()?mz:d2 - mz - 1,
CImg.h:                               mc<img.spectrum()?mc:s2 - mc - 1);
CImg.h:        CImg<doubleT> vals(i_end - 4);
CImg.h:        return vals.kth_smallest((ulongT)(ind - 1));
CImg.h:        return _mp_arg(2)*(1-t) + _mp_arg(3)*t;
CImg.h:        return _mp_arg(2)*_mp_arg(3) - _mp_arg(4);
CImg.h:        return _mp_arg(4) - _mp_arg(2)*_mp_arg(3);
CImg.h:        const int _step = (int)_mp_arg(5), step = _step?_step:-1;
CImg.h:        longT ind = (longT)(mp.opcode[4]!=_cimg_mp_slot_nan?_mp_arg(4):step>0?0:siz - 1);
CImg.h:        if (ind<0 || ind>=(longT)siz) return -1.;
CImg.h:          return ptr>=ptre?-1.:(double)(ptr - ptrb);
CImg.h:        return ptr<ptrb?-1.:(double)(ptr - ptrb);
CImg.h:        const int _step = (bool)_mp_arg(6), step = _step?_step:-1;
CImg.h:        longT ind = (longT)(mp.opcode[5]!=_cimg_mp_slot_nan?_mp_arg(5):step>0?0:siz1 - 1);
CImg.h:        if (ind<0 || ind>=(longT)siz1) return -1.;
CImg.h:            if (ptr1>=ptr1e) return -1.;
CImg.h:          return p2<ptr2e?-1.:(double)(ptr1 - ptr1b);
CImg.h:          if (ptr1<ptr1b) return -1.;
CImg.h:        return p2<ptr2e?-1.:(double)(ptr1 - ptr1b);
CImg.h:            return (double)img[moff<whds?moff:whds2 - moff - 1];
CImg.h:            return (double)img[off<0?0:whds - 1];
CImg.h:            return (double)img._cubic_atXYZ(mx<img.width()?mx:w2 - mx - 1,
CImg.h:                                            my<img.height()?my:h2 - my - 1,
CImg.h:                                            mz<img.depth()?mz:d2 - mz - 1,
CImg.h:                                            (int)(mc<img.spectrum()?mc:s2 - mc - 1));
CImg.h:                                            (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
CImg.h:            return (double)img._linear_atXYZ(mx<img.width()?mx:w2 - mx - 1,
CImg.h:                                             my<img.height()?my:h2 - my - 1,
CImg.h:                                             mz<img.depth()?mz:d2 - mz - 1,
CImg.h:                                             (int)(mc<img.spectrum()?mc:s2 - mc - 1));
CImg.h:                                             (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
CImg.h:            return (double)img(mx<img.width()?mx:w2 - mx - 1,
CImg.h:                               my<img.height()?my:h2 - my - 1,
CImg.h:                               mz<img.depth()?mz:d2 - mz - 1,
CImg.h:                               mc<img.spectrum()?mc:s2 - mc - 1);
CImg.h:            return (double)img[moff<whds?moff:whds2 - moff - 1];
CImg.h:            return (double)img[off<0?0:whds - 1];
CImg.h:            return (double)img._cubic_atXYZ(mx<img.width()?mx:w2 - mx - 1,
CImg.h:                                            my<img.height()?my:h2 - my - 1,
CImg.h:                                            mz<img.depth()?mz:d2 - mz - 1,
CImg.h:                                            (int)(mc<img.spectrum()?mc:s2 - mc - 1));
CImg.h:                                            (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
CImg.h:            return (double)img._linear_atXYZ(mx<img.width()?mx:w2 - mx - 1,
CImg.h:                                             my<img.height()?my:h2 - my - 1,
CImg.h:                                             mz<img.depth()?mz:d2 - mz - 1,
CImg.h:                                             (int)(mc<img.spectrum()?mc:s2 - mc - 1));
CImg.h:                                             (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
CImg.h:            return (double)img(mx<img.width()?mx:w2 - mx - 1,
CImg.h:                               my<img.height()?my:h2 - my - 1,
CImg.h:                               mz<img.depth()?mz:d2 - mz - 1,
CImg.h:                               mc<img.spectrum()?mc:s2 - mc - 1);
CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:            ptrs = &img[moff<whd?moff:whd2 - moff - 1];
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:            ptrs = off<0?&img[0]:&img[whd - 1];
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
CImg.h:              cy = my<img.height()?my:h2 - my - 1,
CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ(cx,cy,cz,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ_p((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.cubic_atXYZ((float)x,(float)y,(float)z,c,(T)0);
CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
CImg.h:              cy = my<img.height()?my:h2 - my - 1,
CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ(cx,cy,cz,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ_p((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.linear_atXYZ((float)x,(float)y,(float)z,c,(T)0);
CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
CImg.h:              cy = my<img.height()?my:h2 - my - 1,
CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:              cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:            ptrs = &img[moff<whd?moff:whd2 - moff - 1];
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:            ptrs = off<0?&img[0]:&img[whd - 1];
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
CImg.h:              cy = my<img.height()?my:h2 - my - 1,
CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ(cx,cy,cz,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ_p((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.cubic_atXYZ((float)x,(float)y,(float)z,c,(T)0);
CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
CImg.h:              cy = my<img.height()?my:h2 - my - 1,
CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ(cx,cy,cz,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ_p((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.linear_atXYZ((float)x,(float)y,(float)z,c,(T)0);
CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
CImg.h:              cy = my<img.height()?my:h2 - my - 1,
CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:              cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:        if (!val_left) { mp.p_code = p_end - 1; return 0; }
CImg.h:          mp.opcode._data = mp.p_code->_data;
CImg.h:        --mp.p_code;
CImg.h:        if (val_left) { mp.p_code = p_end - 1; return 1; }
CImg.h:          mp.opcode._data = mp.p_code->_data;
CImg.h:        --mp.p_code;
CImg.h:          eoff = off + (siz - 1)*inc;
CImg.h:                                      "Out-of-bounds variable pointer "
CImg.h:                                      mp.imgin.pixel_type(),siz,inc,off,eoff,mp.mem._width - 1);
CImg.h:        const longT eoff = off + (siz - 1)*inc;
CImg.h:                                      "Out-of-bounds image pointer "
CImg.h:                                      mp.imgin.pixel_type(),siz,inc,off,eoff,img.size() - 1);
CImg.h:          omopacity = 1 - std::max(_opacity,0.f);
CImg.h:          if (is_doubled && is_doubles) { // (double*) <- (double*)
CImg.h:              if (ptrs + siz - 1<ptrd || ptrs>ptrd + siz - 1) std::memcpy(ptrd,ptrs,siz*sizeof(double));
CImg.h:              if (ptrs + (siz - 1)*inc_s<ptrd || ptrs>ptrd + (siz - 1)*inc_d) {
CImg.h:                if (_opacity>=1) while (siz-->0) { *ptrd = *ptrs; ptrd+=inc_d; ptrs+=inc_s; }
CImg.h:                else while (siz-->0) { *ptrd = omopacity**ptrd + opacity**ptrs; ptrd+=inc_d; ptrs+=inc_s; }
CImg.h:                if (_opacity>=1) while (siz-->0) { *ptrd = *(ptrs++); ptrd+=inc_d; }
CImg.h:                else while (siz-->0) { *ptrd = omopacity**ptrd + opacity**(ptrs++); ptrd+=inc_d; }
CImg.h:          } else if (is_doubled && !is_doubles) { // (double*) <- (float*)
CImg.h:            if (_opacity>=1) while (siz-->0) { *ptrd = *ptrs; ptrd+=inc_d; ptrs+=inc_s; }
CImg.h:            else while (siz-->0) { *ptrd = omopacity**ptrd + _opacity**ptrs; ptrd+=inc_d; ptrs+=inc_s; }
CImg.h:          } else if (!is_doubled && is_doubles) { // (float*) <- (double*)
CImg.h:            if (_opacity>=1) while (siz-->0) { *ptrd = (float)*ptrs; ptrd+=inc_d; ptrs+=inc_s; }
CImg.h:            else while (siz-->0) { *ptrd = (float)(omopacity**ptrd + opacity**ptrs); ptrd+=inc_d; ptrs+=inc_s; }
CImg.h:          } else { // (float*) <- (float*)
CImg.h:              if (ptrs + siz - 1<ptrd || ptrs>ptrd + siz - 1) std::memcpy(ptrd,ptrs,siz*sizeof(float));
CImg.h:              if (ptrs + (siz - 1)*inc_s<ptrd || ptrs>ptrd + (siz - 1)*inc_d) {
CImg.h:                if (_opacity>=1) while (siz-->0) { *ptrd = *ptrs; ptrd+=inc_d; ptrs+=inc_s; }
CImg.h:                else while (siz-->0) { *ptrd = omopacity**ptrd + opacity**ptrs; ptrd+=inc_d; ptrs+=inc_s; }
CImg.h:                if (_opacity>=1) while (siz-->0) { *ptrd = *(ptrs++); ptrd+=inc_d; }
CImg.h:                else while (siz-->0) { *ptrd = omopacity**ptrd + opacity**(ptrs++); ptrd+=inc_d; }
CImg.h:        return -_mp_arg(2);
CImg.h:        switch (i_end - 3) {
CImg.h:        CImg<doubleT> vals(i_end - 3);
CImg.h:        switch (i_end - 3) {
CImg.h:        switch (i_end - 3) {
CImg.h:        switch (i_end - 3) {
CImg.h:        switch (i_end - 3) {
CImg.h:            if (nbv<0) { nbv = -nbv; is_outlined = true; }
CImg.h:              else { color.resize(k,1,1,1,-1); break; }
CImg.h:          CImg<doubleT> args(i_end - 4);
CImg.h:            CImg<charT> _expr(mp.opcode[2] - 4);
CImg.h:                mp.opcode._data = mp.p_code->_data;
CImg.h:                mp.opcode._data = mp.p_code->_data;
CImg.h:        mp.p_code = p_end - 1;
CImg.h:        *(ptrd++) = -sa;
CImg.h:        return --_mp_arg(1);
CImg.h:        while (siz-->0) { target = ptrd++; (*op)(mp); }
CImg.h:        while (siz-->0) { target = ptrd++; argument = ptrs++; (*op)(mp); }
CImg.h:        return _mp_arg(1)-=_mp_arg(2);
CImg.h:        cimg_for_inX(sd,0,sd.width() - 1,i) sd[i] = (char)ptrd[i];
CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
CImg.h:        if (sn<siz) CImg<doubleT>(ptrd + sn,siz - sn,1,1,1,true) = CImg<doubleT>(ptrs + sn,siz - sn,1,1,1,true);
CImg.h:        CImg<doubleT> vals(i_end - 3);
CImg.h:        while (siz-->0) mp.mem[ptrd++] = (double)*(ptrs++);
CImg.h:        cimg_for_inX(ss,0,ss.width() - 1,i) ss[i] = (char)ptr2[i];
CImg.h:        if (!siz) return *ptrs>='0' && *ptrs<='9'?*ptrs - '0':val;
CImg.h:        CImg<charT> ss(siz + 1 - ind);
CImg.h:        const bool is_negative = *s=='-';
CImg.h:          // Check for +/-NaN and +/-inf as Microsoft's sscanf() version is not able
CImg.h:        if (is_negative) val = -val;
CImg.h:        const unsigned int nb_args = (unsigned int)(mp.opcode[3] - 3)/2;
CImg.h:          if (siz) { // Vector argument -> string
CImg.h:          } else { // Scalar argument -> number
CImg.h:        return _mp_arg(2) - _mp_arg(3);
CImg.h:        CImg<doubleT> vals(i_end - 3);
CImg.h:        if (start<0 || start + step*(sublength-1)>=length)
CImg.h:                                      "Out-of-bounds sub-vector request "
CImg.h:                                      "(length: %ld, start: %ld, sub-length: %ld, step: %ld).",
CImg.h:        switch (mp.opcode[2] - 4) {
CImg.h:        case 1 : { const double val = _mp_arg(ptrs); while (siz-->0) mp.mem[ptrd++] = val; } break;
CImg.h:        default : while (siz-->0) { mp.mem[ptrd++] = _mp_arg(ptrs++); if (ptrs>=mp.opcode[2]) ptrs = 4U; }
CImg.h:              while (still_equal && p1--) still_equal = *(ptr1++)==*(ptr2++);
CImg.h:              while (still_equal && p1--)
CImg.h:            while (still_equal && p1--) still_equal = *(ptr1++)==value;
CImg.h:            while (still_equal && p2--) still_equal = *(ptr2++)==value;
CImg.h:            while (still_equal && n--) still_equal = *(ptr1++)==(*ptr2++);
CImg.h:            while (still_equal && n--) still_equal = cimg::lowercase(*(ptr1++))==cimg::lowercase(*(ptr2++));
CImg.h:          while (still_equal && n--) still_equal = *(ptr1++)==value;
CImg.h:          while (still_equal && n--) still_equal = *(ptr2++)==value;
CImg.h:        for (unsigned int k = 0; k<siz; ++k) ptrd[k] = ptrs1[k]*(1-t) + ptrs2[k]*t;
CImg.h:        while (siz-->0) { argument2 = ptrs++; *(ptrd++) = (*op)(mp); }
CImg.h:        while (siz-->0) { argument = ptrs++; *(ptrd++) = (*op)(mp); }
CImg.h:        while (siz-->0) { argument1 = ptrs++; *(ptrd++) = (*op)(mp); }
CImg.h:        while (siz-->0) { argument1 = ptrs++; *(ptrd++) = (*op)(mp); }
CImg.h:        while (siz-->0) { argument1 = ptrs1++; argument2 = ptrs2++; *(ptrd++) = (*op)(mp); }
CImg.h:          CImg<charT> _expr(mp.opcode[2] - 5);
CImg.h:          while (siz-->0) {
CImg.h:              ptr = (unsigned int)mp.opcode[1] + 1 + siz0 - 64;
CImg.h:      const unsigned int nbargs = (unsigned int)(mp.opcode[3] - 4)/2; \
CImg.h:        cimg_pragma_openmp(for) for (longT k = sizd?sizd - 1:0; k>=0; --k) { \
CImg.h:        const double val = (+vec).get_shared_points(1,vec.width() - 1).
CImg.h:          kth_smallest((ulongT)cimg::cut((longT)*vec - 1,(longT)0,(longT)vec.width() - 2));
CImg.h:        cimg_for_inX(vec,1,vec.width()-1,ind) if (vec[ind]==val) return ind - 1.;
CImg.h:        _cimg_mp_vfunc(res = (double)(&vec.max() - vec.data()));
CImg.h:        _cimg_mp_vfunc(res = (double)(&vec.maxabs() - vec.data()));
CImg.h:        _cimg_mp_vfunc(res = (double)(&vec.min() - vec.data()));
CImg.h:        _cimg_mp_vfunc(res = (double)(&vec.minabs() - vec.data()));
CImg.h:        _cimg_mp_vfunc(res = vec.get_shared_points(1,vec.width() - 1).
CImg.h:                       kth_smallest((ulongT)cimg::cut((longT)*vec - 1,(longT)0,(longT)vec.width() - 2)));
CImg.h:        case -1 : std::strcpy(format,"%g"); break;
CImg.h:        CImg<doubleT>(ptrd,l,1,1,1,true) = str.get_shared_points(0,l - 1);
CImg.h:            mp.opcode._data = mp.p_code->_data;
CImg.h:              mp.opcode._data = mp.p_code->_data;
CImg.h:        mp.p_code = p_end - 1;
CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:            ptrs = &img[moff<whd?moff:whd2 - moff - 1];
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:            ptrs = off<0?&img[0]:&img[whd - 1];
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
CImg.h:              cy = my<img.height()?my:h2 - my - 1,
CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ(cx,cy,cz,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ_p((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.cubic_atXYZ((float)x,(float)y,(float)z,c,(T)0);
CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
CImg.h:              cy = my<img.height()?my:h2 - my - 1,
CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ(cx,cy,cz,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ_p((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.linear_atXYZ((float)x,(float)y,(float)z,c,(T)0);
CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
CImg.h:              cy = my<img.height()?my:h2 - my - 1,
CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:              cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:            ptrs = &img[moff<whd?moff:whd2 - moff - 1];
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:            ptrs = off<0?&img[0]:&img[whd - 1];
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
CImg.h:              cy = my<img.height()?my:h2 - my - 1,
CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ(cx,cy,cz,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ_p((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.cubic_atXYZ((float)x,(float)y,(float)z,c,(T)0);
CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
CImg.h:              cy = my<img.height()?my:h2 - my - 1,
CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ(cx,cy,cz,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ_p((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ((float)x,(float)y,(float)z,c);
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.linear_atXYZ((float)x,(float)y,(float)z,c,(T)0);
CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
CImg.h:              cy = my<img.height()?my:h2 - my - 1,
CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:              cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:    //! Compute the base-2 logarithm of each pixel value.
CImg.h:       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its base-2 logarithm
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:    //! Compute the base-10 logarithm of each pixel value.
CImg.h:       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its base-10 logarithm
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The sign is set to:
CImg.h:         - \c 1 if pixel value is strictly positive.
CImg.h:         - \c -1 if pixel value is strictly negative.
CImg.h:         - \c 0 if pixel value is equal to \c 0.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - Pixel values are regarded as being in \e radian.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - Pixel values are regarded as being in \e radian.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - Pixel values are regarded as being exin \e radian.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - Pixel values are regarded as being exin \e radian.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:          img_x(100,100,1,1,"x-w/2",false),   // Define an horizontal centered gradient, from '-width/2' to 'width/2'
CImg.h:          img_y(100,100,1,1,"y-h/2",false),   // Define a vertical centered gradient, from '-height/2' to 'height/2'
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:    //! In-place pointwise multiplication.
CImg.h:       - Similar to operator+=(const CImg<t>&), except that it performs a pointwise multiplication
CImg.h:       - It does \e not perform a \e matrix multiplication. For this purpose, use operator*=(const CImg<t>&) instead.
CImg.h:         shade(img.width,img.height(),1,1,"-(x-w/2)^2-(y-h/2)^2",false);
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:    //! In-place pointwise multiplication \newinstance.
CImg.h:    //! In-place pointwise division.
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:    //! In-place pointwise division \newinstance.
CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
CImg.h:      if (p==-4) { cimg_openmp_for(*this,1/(Tfloat)cimg::pow4(*ptr),32768); return *this; }
CImg.h:      if (p==-3) { cimg_openmp_for(*this,1/(Tfloat)cimg::pow3(*ptr),32768); return *this; }
CImg.h:      if (p==-2) { cimg_openmp_for(*this,1/(Tfloat)cimg::sqr(*ptr),32768); return *this; }
CImg.h:      if (p==-1) { cimg_openmp_for(*this,1/(Tfloat)*ptr,32768); return *this; }
CImg.h:      if (p==-0.5) { cimg_openmp_for(*this,1/std::sqrt((Tfloat)*ptr),8192); return *this; }
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:       \param expression Math formula as a C-string.
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:       \param expression Math formula as a C-string.
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:       \param expression Math formula as a C-string.
CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
CImg.h:       \param expression Math formula as a C-string.
CImg.h:      ulongT l = 0, ir = size() - 1;
CImg.h:            do --j; while (arr[j]>pivot);
CImg.h:          if (j>=k) ir = j - 1;
CImg.h:      return (s%2)?res:(T)((res + kth_smallest((s>>1) - 1))/2);
CImg.h:       - \c 0: Second moment, computed as
CImg.h:       \f$1/N \sum\limits_{k=1}^{N} (x_k - \bar x)^2 =
CImg.h:       1/N \left( \sum\limits_{k=1}^N x_k^2 - \left( \sum\limits_{k=1}^N x_k \right)^2 / N \right)\f$
CImg.h:       - \c 1: Best unbiased estimator, computed as \f$\frac{1}{N - 1} \sum\limits_{k=1}^{N} (x_k - \bar x)^2 \f$.
CImg.h:       - \c 2: Least median of squares.
CImg.h:       - \c 3: Least trimmed of squares.
CImg.h:        variance = (S2 - S*S/siz)/siz;
CImg.h:        variance = siz>1?(S2 - S*S/siz)/(siz - 1):0;
CImg.h:          const double val = (double)*ptrs; *ptrs = (Tfloat)cimg::abs(val - med_i); average+=val;
CImg.h:                                 (double)Icp - 4*(double)Icc);
CImg.h:                                   (double)Iccn + (double)Iccp - 6*(double)Iccc);
CImg.h:                                   (double)Icn + (double)Icp - 4*(double)Icc);
CImg.h:             (double)Iccn + (double)Iccp - 6*(double)Iccc);
CImg.h:      if (variance_method) variance = siz>1?(S2 - S*S/siz)/(siz - 1):0;
CImg.h:      else variance = (S2 - S*S/siz)/siz;
CImg.h:    //! Compute the MSE (Mean-Squared Error) between two images.
CImg.h:        const double diff = (double)*ptr1 - (double)*(ptr2++);
CImg.h:    //! Compute the PSNR (Peak Signal-to-Noise Ratio) between two images.
CImg.h:       \param expression Math formula, as a C-string.
CImg.h:       \param x Value of the pre-defined variable \c x.
CImg.h:       \param y Value of the pre-defined variable \c y.
CImg.h:       \param z Value of the pre-defined variable \c z.
CImg.h:       \param c Value of the pre-defined variable \c c.
CImg.h:    // Fast function to pre-evaluate common expressions.
CImg.h:          res = (t)(c - '0');
CImg.h:          case '-' : res = (t)(val - val2); is_success = true; break;
CImg.h:      } else if ((c=='+' || c=='-' || c=='!') && // +Value, -Value or !Value
CImg.h:        if (!expression[2]) { // [+-!] + Single digit
CImg.h:          const int ival = sep - '0';
CImg.h:          res = (t)(c=='+'?ival:c=='-'?-ival:!ival);
CImg.h:        } else if ((err = std::sscanf(expression + 1,"%lf %c%lf %c",&val,&sep,&val2,&end))==1) { // [+-!] Single value
CImg.h:          res = (t)(c=='+'?val:c=='-'?-val:(double)!val);
CImg.h:        } else if (err==3) { // [+-!] Value1 Operator Value2
CImg.h:          const double val1 = c=='+'?val:c=='-'?-val:(double)!val;
CImg.h:          case '-' : res = (t)(val1 - val2); is_success = true; break;
CImg.h:          case '^' : val = std::pow(val,val2); res = (t)(c=='+'?val:c=='-'?-val:!val); is_success = true; break;
CImg.h:      } else if (!expression[1]) switch (*expression) { // Other common single-char expressions
CImg.h:       \param expression Math formula, as a C-string.
CImg.h:       \param x Value of the pre-defined variable \c x.
CImg.h:       \param y Value of the pre-defined variable \c y.
CImg.h:       \param z Value of the pre-defined variable \c z.
CImg.h:       \param c Value of the pre-defined variable \c c.
CImg.h:       \param expression Math formula, as a C-string.
CImg.h:        _variance_value = variance_method==0?(S2 - S*S/siz)/siz:
CImg.h:        (variance_method==1?(siz>1?(S2 - S*S/siz)/(siz - 1):0):
CImg.h:    //-------------------------------------
CImg.h:    //-------------------------------------
CImg.h:       - \c -1: Linf-norm
CImg.h:       - \c 0: L0-norm
CImg.h:       - \c 1: L1-norm
CImg.h:       - \c 2: L2-norm
CImg.h:      case -1 : {
CImg.h:      case 2 : return (double)((*this)(0,0))*(double)((*this)(1,1)) - (double)((*this)(0,1))*(double)((*this)(1,0));
CImg.h:        return i*a*e - a*h*f - i*b*d + b*g*f + c*d*h - c*g*e;
CImg.h:        double res = d?(double)1:(double)-1;
CImg.h:    //! Get vector-valued pixel located at specified position.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:    //! Get (square) matrix-valued pixel located at specified position.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \note - The spectrum() of the image must be a square.
CImg.h:    //! Get tensor-valued pixel located at specified position.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:    //! Set vector-valued pixel at specified position.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:        for (unsigned int k = std::min((unsigned int)vec.size(),_spectrum); k; --k) {
CImg.h:    //! Set (square) matrix-valued pixel at specified position.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:    //! Set tensor-valued pixel at specified position.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:      const ulongT siz = size() - 1;
CImg.h:        const double delta = (double)a1 - (double)a0;
CImg.h:      (*this)[0] = (T)(y*img[2] - z*img[1]);
CImg.h:      (*this)[1] = (T)(z*img[0] - x*img[2]);
CImg.h:      (*this)[2] = (T)(x*img[1] - y*img[0]);
CImg.h:       - \c true: LU-based matrix inversion.
CImg.h:       - \c false: SVD-based matrix inversion.
CImg.h:      const double dete = _width>3?-1.:det();
CImg.h:        _data[0] = (T)(d/dete); _data[1] = (T)(-c/dete);
CImg.h:        _data[2] = (T)(-b/dete); _data[3] = (T)(a/dete);
CImg.h:        _data[0] = (T)((i*e - f*h)/dete), _data[1] = (T)((g*f - i*d)/dete), _data[2] = (T)((d*h - g*e)/dete);
CImg.h:        _data[3] = (T)((h*c - i*b)/dete), _data[4] = (T)((i*a - c*g)/dete), _data[5] = (T)((g*b - a*h)/dete);
CImg.h:        _data[6] = (T)((b*f - e*c)/dete), _data[7] = (T)((d*c - a*f)/dete), _data[8] = (T)((a*e - d*b)/dete);
CImg.h:        if (use_LU) { // LU-based
CImg.h:        } else pseudoinvert(false); // SVD-based
CImg.h:    //! Compute the Moore-Penrose pseudo-inverse of the instance image, viewed as a matrix.
CImg.h:    //! Compute the Moore-Penrose pseudo-inverse of the instance image, viewed as a matrix \newinstance.
CImg.h:      // LU-based method.
CImg.h:      // SVD-based method.
CImg.h:      const Tfloat epsilon = (sizeof(Tfloat)<=4?5.96e-8f:1.11e-16f)*std::max(_width,_height)*S.max();
CImg.h:       \param use_LU In case of non square system (least-square solution),
CImg.h:                     choose between SVD-based (\c false) or LU-based (\c true) method.
CImg.h:          det = a*d - b*c, fM = cimg::max(fa,fb,fc,fd);
CImg.h:            const double u = (double)(*this)(k,0), v = (double)(*this)(k,1), y = (a*v - c*u)/det;
CImg.h:            (*this)(k,0) = (T)((u - b*y)/a); (*this)(k,1) = (T)y;
CImg.h:            const double u = (double)(*this)(k,0), v = (double)(*this)(k,1), y = (a*v - c*u)/det;
CImg.h:            (*this)(k,0) = (T)((v - d*y)/c); (*this)(k,1) = (T)y;
CImg.h:            const double u = (double)(*this)(k,0), v = (double)(*this)(k,1), x = (d*u - b*v)/det;
CImg.h:            (*this)(k,0) = (T)x; (*this)(k,1) = (T)((u - a*x)/b);
CImg.h:            const double u = (double)(*this)(k,0), v = (double)(*this)(k,1), x = (d*u - b*v)/det;
CImg.h:            (*this)(k,0) = (T)x; (*this)(k,1) = (T)((v - c*x)/d);
CImg.h:      } else { // Least-square solution for non-square systems
CImg.h:        int INFO, N = A._width, M = A._height, LWORK = -1, LDA = M, LDB = M, NRHS = _width;
CImg.h:      int ii = -1;
CImg.h:        if (ii>=0) for (int j = ii; j<=i - 1; ++j) sum-=A(j,i)*(*this)(j);
CImg.h:      for (int i = N - 1; i>=0; --i) {
CImg.h:        for (int j = i + 1; j<N; ++j) sum-=A(j,i)*(*this)(j);
CImg.h:      const Ttfloat epsilon = 1e-4f;
CImg.h:        const Ttfloat m = A(0,i)/(B[i - 1]?B[i - 1]:epsilon);
CImg.h:        B[i] -= m*A(2,i - 1);
CImg.h:        V[i] -= m*V[i - 1];
CImg.h:      (*this)[siz - 1] = (T)(V[siz - 1]/(B[siz - 1]?B[siz - 1]:epsilon));
CImg.h:      for (int i = (int)siz - 2; i>=0; --i) (*this)[i] = (T)((V[i] - A(2,i)*(*this)[i + 1])/(B[i]?B[i]:epsilon));
CImg.h:          double f = e*e - 4*(a*d - b*c);
CImg.h:            l1 = 0.5*(e - f),
CImg.h:            norm1 = std::sqrt(cimg::sqr(l2 - a) + b2),
CImg.h:            norm2 = std::sqrt(cimg::sqr(l1 - a) + b2);
CImg.h:          if (norm1>0) { vec(0,0) = (t)(b/norm1); vec(0,1) = (t)((l2 - a)/norm1); } else { vec(0,0) = 1; vec(0,1) = 0; }
CImg.h:          if (norm2>0) { vec(1,0) = (t)(b/norm2); vec(1,1) = (t)((l1 - a)/norm2); } else { vec(1,0) = 1; vec(1,1) = 0; }
CImg.h:          e = a + d, f = std::sqrt(std::max(e*e - 4*(a*d - b*c),0.0)),
CImg.h:          l1 = 0.5*(e - f), l2 = 0.5*(e + f),
CImg.h:          n = std::sqrt(cimg::sqr(l2 - a) + b*b);
CImg.h:        if (n>0) { vec[0] = (t)(b/n); vec[2] = (t)((l2 - a)/n); } else { vec[0] = 1; vec[2] = 0; }
CImg.h:        vec[1] = -vec[2];
CImg.h:        cimg_forY(val,i) val(i) = (T)lapW[N - 1 -i];
CImg.h:        cimg_forXY(vec,k,l) vec(k,l) = (T)(lapA[(N - 1 - k)*N + l]);
CImg.h:        if (scal<0) val[p] = -val[p];
CImg.h:        val-=eig;
CImg.h:      return _quicksort(0,size() - 1,permutations,is_increasing,true);
CImg.h:       - \c 0: All pixel values are sorted, independently on their initial position.
CImg.h:       - \c 'x': Image columns are sorted, according to the first value in each column.
CImg.h:       - \c 'y': Image rows are sorted, according to the first value in each row.
CImg.h:       - \c 'z': Image slices are sorted, according to the first value in each slice.
CImg.h:       - \c 'c': Image channels are sorted, according to the first value in each channel.
CImg.h:        _quicksort(0,size() - 1,perm,is_increasing,false);
CImg.h:        get_crop(0,0,0,0,_width - 1,0,0,0).sort(perm,is_increasing);
CImg.h:        get_crop(0,0,0,0,0,_height - 1,0,0).sort(perm,is_increasing);
CImg.h:        get_crop(0,0,0,0,0,0,_depth - 1,0).sort(perm,is_increasing);
CImg.h:        get_crop(0,0,0,0,0,0,0,_spectrum - 1).sort(perm,is_increasing);
CImg.h:        if (indM - indm>=3) {
CImg.h:              while ((*this)[j]>pivot) --j;
CImg.h:                cimg::swap((*this)[i++],(*this)[j--]);
CImg.h:              while ((*this)[j]<pivot) --j;
CImg.h:                cimg::swap((*this)[i++],(*this)[j--]);
CImg.h:      const Ttfloat epsilon = (Ttfloat)1e-25;
CImg.h:              g = (Ttfloat)((f>=0?-1:1)*std::sqrt(s));
CImg.h:              h = f*g - s;
CImg.h:              U(i,i) = f - g;
CImg.h:          if (i<height() && i!=width() - 1) {
CImg.h:              g = (Ttfloat)((f>=0?-1:1)*std::sqrt(s));
CImg.h:              h = f*g - s;
CImg.h:              U(l,i) = f - g;
CImg.h:        for (int i = width() - 1; i>=0; --i) {
CImg.h:          if (i<width() - 1) {
CImg.h:        for (int i = std::min(width(),height()) - 1; i>=0; --i) {
CImg.h:        for (int k = width() - 1; k>=0; --k) {
CImg.h:            for (l = k; l>=1; --l) {
CImg.h:              nm = l - 1;
CImg.h:                s = -f*h;
CImg.h:                  U(i,j) = z*c - y*s;
CImg.h:            if (l==k) { if (z<0) { S[k] = -z; cimg_forX(U,j) V(k,j) = -V(k,j); } break; }
CImg.h:            nm = k - 1;
CImg.h:            f = ((y - z)*(y + z) + (g - h)*(g + h))/std::max(epsilon,(Ttfloat)2*h*y);
CImg.h:            f = ((x - z)*(x + z) + h*((y/(f + (f>=0?g:-g))) - h))/std::max(epsilon,(Ttfloat)x);
CImg.h:              g = g*c - x*s;
CImg.h:                V(i,jj) = z2*c - x2*s;
CImg.h:              x = c*y1 - s*g;
CImg.h:                U(i,jj) = z2*c - y2*s;
CImg.h:          for (int k = 0; k<i; ++k) sum-=(*this)(k,i)*(*this)(j,k);
CImg.h:          for (int k = 0; k<j; ++k) sum-=(*this)(k,i)*(*this)(j,k);
CImg.h:        if ((*this)(j,j)==0) (*this)(j,j) = (T)1e-20;
CImg.h:       Find the best matching projection of selected matrix onto the span of an over-complete dictionary D,
CImg.h:       Instance image must a 2D-matrix in which each column represent a signal to project.
CImg.h:         - 0 = orthogonal projection (default).
CImg.h:         - 1 = matching pursuit.
CImg.h:         - 2 = matching pursuit, with a single orthogonal projection step at the end.
CImg.h:         - >=3 = orthogonal matching pursuit where an orthogonal projection step is performed
CImg.h:                 every 'method-2' iterations.
CImg.h:                            const unsigned int max_iter=0, const double max_residual=1e-6) {
CImg.h:                                    const unsigned int max_iter=0, const double max_residual=1e-6) const {
CImg.h:        Dnorm[d] = std::max((Tfloat)1e-8,std::sqrt(norm));
CImg.h:      const unsigned int proj_step = method<3?1:method - 2;
CImg.h:              S[y]-=dotmax*D(dmax,y);
CImg.h:            S0.get_solve(sD,true).move_to(sD); // sD is now a one-column vector of weights
CImg.h:              cimg_forY(S,y) S[y]-=weight*D(ind,y);
CImg.h:      // Normalize resulting coefficients according to initial (non-normalized) dictionary.
CImg.h:      previous_node.assign(1,nb_nodes,1,1,(t)-1);
CImg.h:                for (unsigned int pos = q, par = 0; pos && distpos<dist(Q(par=(pos + 1)/2 - 1)); pos=par)
CImg.h:          Q(0) = Q(--sizeQ);
CImg.h:               ((right=2*(pos + 1),(left=right - 1))<sizeQ && distpos>dist(Q(left))) ||
CImg.h:       \param str input C-string to encode as an image.
CImg.h:    //! Return a N-numbered sequence vector from \p a0 to \p a1.
CImg.h:       \param x X-coordinate of the rotation axis, or first quaternion coordinate.
CImg.h:       \param y Y-coordinate of the rotation axis, or second quaternion coordinate.
CImg.h:       \param z Z-coordinate of the rotation axis, or third quaternion coordinate.
CImg.h:        return CImg<T>::matrix((T)(X*X + Y*Y - Z*Z - W*W),(T)(2*Y*Z - 2*X*W),(T)(2*X*Z + 2*Y*W),
CImg.h:                               (T)(2*X*W + 2*Y*Z),(T)(X*X - Y*Y + Z*Z - W*W),(T)(2*Z*W - 2*X*Y),
CImg.h:                               (T)(2*Y*W - 2*X*Z),(T)(2*X*Y + 2*Z*W),(T)(X*X - Y*Y - Z*Z + W*W));
CImg.h:      const double ang = w*cimg::PI/180, c = std::cos(ang), omc = 1 - c, s = std::sin(ang);
CImg.h:      return CImg<T>::matrix((T)(X*X*omc + c),(T)(X*Y*omc - Z*s),(T)(X*Z*omc + Y*s),
CImg.h:                             (T)(X*Y*omc + Z*s),(T)(Y*Y*omc + c),(T)(Y*Z*omc - X*s),
CImg.h:                             (T)(X*Z*omc - Y*s),(T)(Y*Z*omc + X*s),(T)(Z*Z*omc + c));
CImg.h:    //-----------------------------------
CImg.h:    //-----------------------------------
CImg.h:      T *ptrd, *ptre = end() - 1;
CImg.h:      T *ptrd, *ptre = end() - 2;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 3;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 4;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 5;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 6;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 7;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 8;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 9;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 10;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 10 : *(--ptre) = val9; // fallthrough
CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 11;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 11 : *(--ptre) = val10; // fallthrough
CImg.h:      case 10 : *(--ptre) = val9; // fallthrough
CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 12;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 12 : *(--ptre) = val11; // fallthrough
CImg.h:      case 11 : *(--ptre) = val10; // fallthrough
CImg.h:      case 10 : *(--ptre) = val9; // fallthrough
CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 13;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 13 : *(--ptre) = val12; // fallthrough
CImg.h:      case 12 : *(--ptre) = val11; // fallthrough
CImg.h:      case 11 : *(--ptre) = val10; // fallthrough
CImg.h:      case 10 : *(--ptre) = val9; // fallthrough
CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 14;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 14 : *(--ptre) = val13; // fallthrough
CImg.h:      case 13 : *(--ptre) = val12; // fallthrough
CImg.h:      case 12 : *(--ptre) = val11; // fallthrough
CImg.h:      case 11 : *(--ptre) = val10; // fallthrough
CImg.h:      case 10 : *(--ptre) = val9; // fallthrough
CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:      T *ptrd, *ptre = end() - 15;
CImg.h:      switch (ptre - ptrd) {
CImg.h:      case 15 : *(--ptre) = val14; // fallthrough
CImg.h:      case 14 : *(--ptre) = val13; // fallthrough
CImg.h:      case 13 : *(--ptre) = val12; // fallthrough
CImg.h:      case 12 : *(--ptre) = val11; // fallthrough
CImg.h:      case 11 : *(--ptre) = val10; // fallthrough
CImg.h:      case 10 : *(--ptre) = val9; // fallthrough
CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
CImg.h:       \param expression C-string describing a math formula, or a sequence of values.
CImg.h:        // Try to pre-detect regular value sequence to avoid exception thrown by _cimg_math_parser.
CImg.h:            CImg<T> base = provides_copy?provides_copy->get_shared():get_shared();
CImg.h:            if (mp.result_dim) { // Vector-valued expression
CImg.h:              T *ptrd = *expression=='<'?_data + _width*_height*_depth - 1:_data;
CImg.h:                      T *_ptrd = ptrd--; for (unsigned int n = N; n>0; --n) { *_ptrd = (T)(*ptrs++); _ptrd+=whd; }
CImg.h:                      T *_ptrd = ptrd++; for (unsigned int n = N; n>0; --n) { *_ptrd = (T)(*ptrs++); _ptrd+=whd; }
CImg.h:        for (unsigned int n = N; n>0; --n) { *_ptrd = (T)(*ptrs++); _ptrd+=whd; } \
CImg.h:            } else { // Scalar-valued expression
CImg.h:              T *ptrd = *expression=='<'?end() - 1:_data;
CImg.h:                else cimg_rofYZC(*this,y,z,c) { cimg_abort_test; cimg_rofX(*this,x) *(ptrd--) = (T)mp(x,y,z,c); }
CImg.h:          const int err = cimg_sscanf(nexpression,"%255[ \n\t0-9.eEinfa+-]%c",item._data,&sep);
CImg.h:    //! Fill pixel values along the X-axis at a specified pixel position.
CImg.h:       \param y Y-coordinate of the filled column.
CImg.h:       \param z Z-coordinate of the filled column.
CImg.h:       \param c C-coordinate of the filled column.
CImg.h:    //! Fill pixel values along the X-axis at a specified pixel position \overloading.
CImg.h:    //! Fill pixel values along the Y-axis at a specified pixel position.
CImg.h:       \param x X-coordinate of the filled row.
CImg.h:       \param z Z-coordinate of the filled row.
CImg.h:       \param c C-coordinate of the filled row.
CImg.h:    //! Fill pixel values along the Y-axis at a specified pixel position \overloading.
CImg.h:    //! Fill pixel values along the Z-axis at a specified pixel position.
CImg.h:       \param x X-coordinate of the filled slice.
CImg.h:       \param y Y-coordinate of the filled slice.
CImg.h:       \param c C-coordinate of the filled slice.
CImg.h:    //! Fill pixel values along the Z-axis at a specified pixel position \overloading.
CImg.h:    //! Fill pixel values along the C-axis at a specified pixel position.
CImg.h:       \param x X-coordinate of the filled channel.
CImg.h:       \param y Y-coordinate of the filled channel.
CImg.h:       \param z Z-coordinate of the filled channel.
CImg.h:    //! Fill pixel values along the C-axis at a specified pixel position \overloading.
CImg.h:         the method does it for all the buffer values and returns a one-column vector.
CImg.h:         is returned as a one-column vector.
CImg.h:            if (j) --i;
CImg.h:            k+=i - i0 + 1; i0 = i + 1; j = 0;
CImg.h:        if (i0<width()) { res.draw_image(k,get_columns(i0,width() - 1)); k+=width() - i0; }
CImg.h:        res.resize(k,-100,-100,-100,0);
CImg.h:            if (j) --i;
CImg.h:            k+=i - i0 + 1; i0 = i + 1; j = 0;
CImg.h:        if (i0<height()) { res.draw_image(0,k,get_rows(i0,height() - 1)); k+=height() - i0; }
CImg.h:        res.resize(-100,k,-100,-100,0);
CImg.h:            if (j) --i;
CImg.h:            k+=i - i0 + 1; i0 = i + 1; j = 0;
CImg.h:        if (i0<depth()) { res.draw_image(0,0,k,get_slices(i0,height() - 1)); k+=depth() - i0; }
CImg.h:        res.resize(-100,-100,k,-100,0);
CImg.h:            if (j) --i;
CImg.h:            k+=i - i0 + 1; i0 = i + 1; j = 0;
CImg.h:        if (i0<spectrum()) { res.draw_image(0,0,k,get_channels(i0,height() - 1)); k+=spectrum() - i0; }
CImg.h:        res.resize(-100,-100,-100,k,0);
CImg.h:              if (j) --i;
CImg.h:              std::memcpy(res._data + k,_data + i0,(i - i0 + 1)*sizeof(T));
CImg.h:              k+=i - i0 + 1; i0 = (int)i + 1; j = 0;
CImg.h:          if ((ulongT)i0<siz) { std::memcpy(res._data + k,_data + i0,(siz - i0)*sizeof(T)); k+=siz - i0; }
CImg.h:        res.resize(j,-100,-100,-100,0);
CImg.h:        res.resize(-100,j,-100,-100,0);
CImg.h:        res.resize(-100,-100,j,-100,0);
CImg.h:        res.resize(-100,-100,-100,j,0);
CImg.h:        res.resize(-100,j,-100,-100,0);
CImg.h:      const float delta = (float)val_max - (float)val_min + (cimg::type<T>::is_float()?0:1);
CImg.h:       - \c -1: Backward.
CImg.h:       - \c 0: Nearest.
CImg.h:       - \c 1: Forward.
CImg.h:       - For Poisson noise (\p noise_type=3), parameter \p sigma is ignored, as Poisson noise only depends on
CImg.h:       - Function \p CImg<T>::get_noise() is also defined. It returns a non-shared modified copy of the image instance.
CImg.h:      if (nsigma<0) nsigma = (Tfloat)(-nsigma*(M-m)/100.);
CImg.h:            Tfloat val = (Tfloat)(_data[off] + nsigma*cimg::rand(-1,1,&rng));
CImg.h:        if (nsigma<0) nsigma = -nsigma;
CImg.h:          if (cimg::type<T>::is_float()) { --m; ++M; }
CImg.h:                    (T)((1 - constant_case_ratio)*a + constant_case_ratio*b));
CImg.h:      if (m!=a || M!=b) cimg_rof(*this,ptrd,T) *ptrd = (T)((*ptrd - fm)/(fM - fm)*(b - a) + a);
CImg.h:    //! Normalize multi-valued pixels of the image instance, with respect to their L2-norm.
CImg.h:    //! Normalize multi-valued pixels of the image instance, with respect to their L2-norm \newinstance.
CImg.h:    //! Compute Lp-norm of each multi-valued pixel of the image instance.
CImg.h:       \param norm_type Type of computed vector norm (can be \p -1=Linf, or \p greater or equal than 0).
CImg.h:    //! Compute L2-norm of each multi-valued pixel of the image instance \newinstance.
CImg.h:      case -1 : { // Linf-norm
CImg.h:      case 0 : { // L0-norm
CImg.h:      case 1 : { // L1-norm
CImg.h:      case 2 : { // L2-norm
CImg.h:      default : { // Linf-norm
CImg.h:      Tfloat m, M = (Tfloat)max_min(m), range = M - m;
CImg.h:            const unsigned int val = (unsigned int)((_data[off] - m)*nb_levels/range);
CImg.h:            _data[off] = (T)(m + std::min(val,nb_levels - 1)*range/nb_levels);
CImg.h:            const unsigned int val = (unsigned int)((_data[off] - m)*nb_levels/range);
CImg.h:            _data[off] = (T)std::min(val,nb_levels - 1);
CImg.h:          const ulongT wF = size() - wB;
CImg.h:            mF = (double)(sum - sumB)/wF,
CImg.h:            variance = wB*wF*cimg::sqr(mB - mF);
CImg.h:      return m + best_t*(M - m)/(hist.width() - 1);
CImg.h:            _data[off] = v>value?(T)(v-value):v<-(float)value?(T)(v + value):(T)0;
CImg.h:            _data[off] = v>=value?(T)(v-value):v<=-(float)value?(T)(v + value):(T)0;
CImg.h:       - The histogram H of an image I is the 1D function where H(x) counts the number of occurrences of the value x
CImg.h:       - The resulting histogram is always defined in 1D. Histograms of multi-valued images are not multi-dimensional.
CImg.h:        if (val>=vmin && val<=vmax) ++res[val==vmax?nb_levels - 1:(unsigned int)((val - vmin)*nb_levels/(vmax - vmin))];
CImg.h:        const int pos = (int)((_data[off] - vmin)*(nb_levels - 1.)/(vmax - vmin));
CImg.h:        if (pos>=0 && pos<(int)nb_levels) _data[off] = (T)(vmin + (vmax - vmin)*hist[pos]/cumul);
CImg.h:    //! Index multi-valued pixels regarding to a specified colormap.
CImg.h:       \param colormap Multi-valued colormap used as the basis for multi-valued pixel indexing.
CImg.h:       - \p img.index(colormap,dithering,1) is equivalent to <tt>img.index(colormap,dithering,0).map(colormap)</tt>.
CImg.h:    //! Index multi-valued pixels regarding to a specified colormap \newinstance.
CImg.h:        CImg<Tfloat> cache = get_crop(-1,0,0,0,_width,1,0,_spectrum - 1);
CImg.h:            if (y<height() - 2) {
CImg.h:                const Tfloat pval0 = (Tfloat)*(ptrp0++) - val0, dist = pval0*pval0;
CImg.h:                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
CImg.h:              const Tfloat err0 = ((*(ptrs0++)=val0) - (Tfloat)*ptrmin0)*ndithering;
CImg.h:              *ptrs0+=7*err0; *(ptrsn0 - 1)+=3*err0; *(ptrsn0++)+=5*err0; *ptrsn0+=err0;
CImg.h:              if (map_indexes) *(ptrd++) = (tuint)*ptrmin0; else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
CImg.h:            if (y<height() - 2) {
CImg.h:                  pval0 = (Tfloat)*(ptrp0++) - val0, pval1 = (Tfloat)*(ptrp1++) - val1,
CImg.h:                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
CImg.h:                err0 = ((*(ptrs0++)=val0) - (Tfloat)*ptrmin0)*ndithering,
CImg.h:                err1 = ((*(ptrs1++)=val1) - (Tfloat)*ptrmin1)*ndithering;
CImg.h:              *(ptrsn0 - 1)+=3*err0; *(ptrsn1 - 1)+=3*err1;
CImg.h:              else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
CImg.h:            if (y<height() - 2) {
CImg.h:                  pval0 = (Tfloat)*(ptrp0++) - val0,
CImg.h:                  pval1 = (Tfloat)*(ptrp1++) - val1,
CImg.h:                  pval2 = (Tfloat)*(ptrp2++) - val2,
CImg.h:                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
CImg.h:                err0 = ((*(ptrs0++)=val0) - (Tfloat)*ptrmin0)*ndithering,
CImg.h:                err1 = ((*(ptrs1++)=val1) - (Tfloat)*ptrmin1)*ndithering,
CImg.h:                err2 = ((*(ptrs2++)=val2) - (Tfloat)*ptrmin2)*ndithering;
CImg.h:              *(ptrsn0 - 1)+=3*err0; *(ptrsn1 - 1)+=3*err1; *(ptrsn2 - 1)+=3*err2;
CImg.h:              } else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
CImg.h:            if (y<height() - 2) {
CImg.h:                  dist+=cimg::sqr((*_ptrs=val) - (Tfloat)*_ptrp); _ptrs+=cwhd; _ptrp+=pwhd;
CImg.h:              const t *_ptrmin = ptrmin; Tfloat *_ptrs = ptrs++, *_ptrsn = (ptrsn++) - 1;
CImg.h:                const Tfloat err = (*(_ptrs++) - (Tfloat)*_ptrmin)*ndithering;
CImg.h:                _ptrmin+=pwhd; _ptrs+=cwhd - 1; _ptrsn+=cwhd - 2;
CImg.h:              else *(ptrd++) = (tuint)(ptrmin - colormap._data);
CImg.h:      } else { // Non-dithered versions
CImg.h:                const Tfloat pval0 = (Tfloat)*(ptrp0++) - val0, dist = pval0*pval0;
CImg.h:                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
CImg.h:              if (map_indexes) *(ptrd++) = (tuint)*ptrmin0; else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
CImg.h:                  pval0 = (Tfloat)*(ptrp0++) - val0, pval1 = (Tfloat)*(ptrp1++) - val1,
CImg.h:                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
CImg.h:              else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
CImg.h:                  pval0 = (Tfloat)*(ptrp0++) - val0,
CImg.h:                  pval1 = (Tfloat)*(ptrp1++) - val1,
CImg.h:                  pval2 = (Tfloat)*(ptrp2++) - val2,
CImg.h:                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
CImg.h:              } else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
CImg.h:                cimg_forC(*this,c) { dist+=cimg::sqr((Tfloat)*_ptrs - (Tfloat)*_ptrp); _ptrs+=whd; _ptrp+=pwhd; }
CImg.h:              else *(ptrd++) = (tuint)(ptrmin - colormap._data);
CImg.h:       \param colormap Multi-valued colormap used for mapping the indexes.
CImg.h:            res[off] = colormap[ind<cwhd?ind:cwhd2 - ind - 1];
CImg.h:            res[off] = colormap[cimg::cut(ind,(longT)0,(longT)cwhd - 1)];
CImg.h:                ind = _ind<cwhd?_ind:cwhd2 - _ind - 1;
CImg.h:              const longT ind = cimg::cut((longT)ptrs[off],(longT)0,(longT)cwhd - 1);
CImg.h:                ind = _ind<cwhd?_ind:cwhd2 - _ind - 1;
CImg.h:              const longT ind = cimg::cut((longT)ptrs[off],(longT)0,(longT)cwhd - 1);
CImg.h:                ind = _ind<cwhd?_ind:cwhd2 - _ind - 1;
CImg.h:              const longT ind = cimg::cut((longT)ptrs[off],(longT)0,(longT)cwhd - 1);
CImg.h:       \param is_high_connectivity Boolean that choose between 4(false)- or 8(true)-connectivity
CImg.h:       in 2D case, and between 6(false)- or 26(true)-connectivity in 3D case.
CImg.h:       In: Science of Computer Programming 41 (2001), pp. 173--194'.
CImg.h:        dx[nb] = 1; dy[nb] = -1; dz[nb++] = 0;
CImg.h:          dx[nb] = 1; dy[nb] = 1; dz[nb++] = -1;
CImg.h:          dx[nb] = 1; dy[nb] = 0; dz[nb++] = -1;
CImg.h:          dx[nb] = 1; dy[nb] = -1; dz[nb++] = -1;
CImg.h:          dx[nb] = 0; dy[nb] = 1; dz[nb++] = -1;
CImg.h:          dx[nb] = 1; dy[nb] = -1; dz[nb++] = 1;
CImg.h:      // For each neighbour-direction, label.
CImg.h:            x0 = _dx<0?-_dx:0,
CImg.h:            x1 = _dx<0?width():width() - _dx,
CImg.h:            y0 = _dy<0?-_dy:0,
CImg.h:            y1 = _dy<0?height():height() - _dy,
CImg.h:            z0 = _dz<0?-_dz:0,
CImg.h:            z1 = _dz<0?depth():depth() - _dz;
CImg.h:                  diff = cimg::abs((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd));
CImg.h:                    diff = cimg::sqr((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd)) +
CImg.h:                      cimg::sqr((Tfloat)(*this)(x,y,z,1,wh,whd) - (Tfloat)(*this)(nx,ny,nz,1,wh,whd));
CImg.h:                    diff = cimg::abs((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd)) +
CImg.h:                      cimg::abs((Tfloat)(*this)(x,y,z,1,wh,whd) - (Tfloat)(*this)(nx,ny,nz,1,wh,whd));
CImg.h:                    diff = cimg::sqr((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd)) +
CImg.h:                      cimg::sqr((Tfloat)(*this)(x,y,z,1,wh,whd) - (Tfloat)(*this)(nx,ny,nz,1,wh,whd)) +
CImg.h:                      cimg::sqr((Tfloat)(*this)(x,y,z,2,wh,whd) - (Tfloat)(*this)(nx,ny,nz,2,wh,whd));
CImg.h:                    diff = cimg::abs((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd)) +
CImg.h:                      cimg::abs((Tfloat)(*this)(x,y,z,1,wh,whd) - (Tfloat)(*this)(nx,ny,nz,1,wh,whd)) +
CImg.h:                      cimg::abs((Tfloat)(*this)(x,y,z,2,wh,whd) - (Tfloat)(*this)(nx,ny,nz,2,wh,whd));
CImg.h:                    diff = cimg::sqr((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd)) +
CImg.h:                      cimg::sqr((Tfloat)(*this)(x,y,z,1,wh,whd) - (Tfloat)(*this)(nx,ny,nz,1,wh,whd)) +
CImg.h:                      cimg::sqr((Tfloat)(*this)(x,y,z,2,wh,whd) - (Tfloat)(*this)(nx,ny,nz,2,wh,whd)) +
CImg.h:                      cimg::sqr((Tfloat)(*this)(x,y,z,3,wh,whd) - (Tfloat)(*this)(nx,ny,nz,3,wh,whd));
CImg.h:                    diff = cimg::abs((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd)) +
CImg.h:                      cimg::abs((Tfloat)(*this)(x,y,z,1,wh,whd) - (Tfloat)(*this)(nx,ny,nz,1,wh,whd)) +
CImg.h:                      cimg::abs((Tfloat)(*this)(x,y,z,2,wh,whd) - (Tfloat)(*this)(nx,ny,nz,2,wh,whd)) +
CImg.h:                      cimg::abs((Tfloat)(*this)(x,y,z,3,wh,whd) - (Tfloat)(*this)(nx,ny,nz,3,wh,whd));
CImg.h:                      diff+=cimg::sqr((Tfloat)(*this)(x,y,z,c,wh,whd) - (Tfloat)(*this)(nx,ny,nz,c,wh,whd));
CImg.h:                      diff+=cimg::abs((Tfloat)(*this)(x,y,z,c,wh,whd) - (Tfloat)(*this)(nx,ny,nz,c,wh,whd));
CImg.h:#define cimg_system_strescape(c,s) case c : if (p!=ptrs) CImg<T>(ptrs,(unsigned int)(p-ptrs),1,1,1,false).\
CImg.h:      if (ptrs<end()) CImg<T>(ptrs,(unsigned int)(end()-ptrs),1,1,1,false).move_to(list);
CImg.h:    //---------------------------------
CImg.h:    //---------------------------------
CImg.h:          sval = (Tfloat)(val<=0.0031308f?val*12.92f:1.055f*std::pow(val,0.416667f) - 0.055f);
CImg.h:          C = M - m,
CImg.h:          H = 60*(C==0?0:M==R?cimg::mod((G - B)/C,(Tfloat)6):M==G?(B - R)/C + 2:(R - G)/C + 4),
CImg.h:          S = sum<=0?0:1 - 3*m/sum,
CImg.h:          Z = 1 - cimg::abs(cimg::mod(H,(Tfloat)2) - 1),
CImg.h:          m = I*(1 - S)/3;
CImg.h:          C = M - m,
CImg.h:          H = 60*(C==0?0:M==R?cimg::mod((G - B)/C,(Tfloat)6):M==G?(B - R)/C + 2:(R - G)/C + 4),
CImg.h:          S = L==1 || L==0?0:C/(1 - cimg::abs(2*L - 1))/255;
CImg.h:          C = (1 - cimg::abs(2*L - 1))*S,
CImg.h:          X = C*(1 - cimg::abs(cimg::mod(H,(Tfloat)2) - 1)),
CImg.h:          m = L - C/2;
CImg.h:          C = M - cimg::min(R,G,B),
CImg.h:          H = 60*(C==0?0:M==R?cimg::mod((G-B)/C,(Tfloat)6):M==G?(B - R)/C + 2:(R - G)/C + 4),
CImg.h:          X = C*(1 - cimg::abs(cimg::mod(H,(Tfloat)2) - 1)),
CImg.h:          m = V - C;
CImg.h:          Cb = (-38*R - 74*G + 112*B + 128)/256 + 128,
CImg.h:          Cr = (112*R - 94*G - 18*B + 128)/256 + 128;
CImg.h:          Y = (Tfloat)p1[N] - 16,
CImg.h:          Cb = (Tfloat)p2[N] - 128,
CImg.h:          Cr = (Tfloat)p3[N] - 128,
CImg.h:          G = (298*Y - 100*Cb - 208*Cr + 128)/256,
CImg.h:        p2[N] = (T)(0.492f*(B - Y));
CImg.h:        p3[N] = (T)(0.877*(R - Y));
CImg.h:          G = (Y - 0.395f*U - 0.581f*V)*255,
CImg.h:          C = 255 - R,
CImg.h:          M = 255 - G,
CImg.h:          Y = 255 - B;
CImg.h:          R = 255 - C,
CImg.h:          G = 255 - M,
CImg.h:          B = 255 - Y;
CImg.h:        else { const Tfloat K1 = 255 - K; C = 255*(C - K)/K1; M = 255*(M - K)/K1; Y = 255*(Y - K)/K1; }
CImg.h:          K1 = 1 - K/255,
CImg.h:          p1[N] = (T)cimg::cut(3.2404542*X - 1.5371385*Y - 0.4985314*Z,0,255);
CImg.h:          p2[N] = (T)cimg::cut(-0.9692660*X + 1.8760108*Y + 0.0415560*Z,0,255);
CImg.h:          p3[N] = (T)cimg::cut(0.0556434*X - 0.2040259*Y + 1.0572252*Z,0,255);
CImg.h:          p1[N] = (T)cimg::cut(3.134274799724*X  - 1.617275708956*Y - 0.490724283042*Z,0,255);
CImg.h:          p2[N] = (T)cimg::cut(-0.978795575994*X + 1.916161689117*Y + 0.033453331711*Z,0,255);
CImg.h:          p3[N] = (T)cimg::cut(0.071976988401*X - 0.228984974402*Y + 1.405718224383*Z,0,255);
CImg.h:        p1[N] = (T)cimg::cut(116*fY - 16,0,100);
CImg.h:        p2[N] = (T)(500*(fX - fY));
CImg.h:        p3[N] = (T)(200*(fY - fZ));
CImg.h:          cZ = cY - b/200,
CImg.h:          X = (Tfloat)(24389*cX>216?cX*cX*cX:(116*cX - 16)*27/24389),
CImg.h:          Z = (Tfloat)(24389*cZ>216?cZ*cZ*cZ:(116*cZ - 16)*27/24389);
CImg.h:        p3[N] = (T)((1 - px - py)*Y/ny);
CImg.h:    //------------------------------------------
CImg.h:    //------------------------------------------
CImg.h:      if (x<=-2 || x>=2) return 0;
CImg.h:       \param size_x Number of columns (new size along the X-axis).
CImg.h:       \param size_y Number of rows (new size along the Y-axis).
CImg.h:       \param size_z Number of slices (new size along the Z-axis).
CImg.h:       \param size_c Number of vector-channels (new size along the C-axis).
CImg.h:       - -1 = no interpolation: raw memory resizing.
CImg.h:       - 0 = no interpolation: additional space is filled according to \p boundary_conditions.
CImg.h:       - 1 = nearest-neighbor interpolation.
CImg.h:       - 2 = moving average interpolation.
CImg.h:       - 3 = linear interpolation.
CImg.h:       - 4 = grid interpolation.
CImg.h:       - 5 = cubic interpolation.
CImg.h:       - 6 = lanczos interpolation.
CImg.h:       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
CImg.h:    CImg<T>& resize(const int size_x, const int size_y=-100,
CImg.h:                    const int size_z=-100, const int size_c=-100,
CImg.h:        _sx = (unsigned int)(size_x<0?-size_x*width()/100:size_x),
CImg.h:        _sy = (unsigned int)(size_y<0?-size_y*height()/100:size_y),
CImg.h:        _sz = (unsigned int)(size_z<0?-size_z*depth()/100:size_z),
CImg.h:        _sc = (unsigned int)(size_c<0?-size_c*spectrum()/100:size_c),
CImg.h:      if (interpolation_type==-1 && sx*sy*sz*sc==size()) {
CImg.h:    CImg<T> get_resize(const int size_x, const int size_y = -100,
CImg.h:                       const int size_z = -100, const int size_c = -100,
CImg.h:        sx = std::max(1U,(unsigned int)(size_x>=0?size_x:-size_x*width()/100)),
CImg.h:        sy = std::max(1U,(unsigned int)(size_y>=0?size_y:-size_y*height()/100)),
CImg.h:        sz = std::max(1U,(unsigned int)(size_z>=0?size_z:-size_z*depth()/100)),
CImg.h:        sc = std::max(1U,(unsigned int)(size_c>=0?size_c:-size_c*spectrum()/100));
CImg.h:      case -1 :
CImg.h:          xc = (int)(centering_x*((int)sx - width())),
CImg.h:          yc = (int)(centering_y*((int)sy - height())),
CImg.h:          zc = (int)(centering_z*((int)sz - depth())),
CImg.h:          cc = (int)(centering_c*((int)sc - spectrum()));
CImg.h:              mx = cimg::mod(x - xc,w2), my = cimg::mod(y - yc,h2),
CImg.h:              mz = cimg::mod(z - zc,d2), mc = cimg::mod(c - cc,s2);
CImg.h:            res(x,y,z,c) = (*this)(mx<width()?mx:w2 - mx - 1,
CImg.h:                                   my<height()?my:h2 - my - 1,
CImg.h:                                   mz<depth()?mz:d2 - mz - 1,
CImg.h:                                   mc<spectrum()?mc:s2 - mc - 1);
CImg.h:            x0 = ((int)xc%width()) - width(),
CImg.h:            y0 = ((int)yc%height()) - height(),
CImg.h:            z0 = ((int)zc%depth()) - depth(),
CImg.h:            c0 = ((int)cc%spectrum()) - spectrum(),
CImg.h:          if (xc>0) {  // X-backward
CImg.h:            res.get_crop(xc,yc,zc,cc,xc,yc + height() - 1,zc + depth() - 1,cc + spectrum() - 1).move_to(sprite);
CImg.h:            for (int x = xc - 1; x>=0; --x) res.draw_image(x,yc,zc,cc,sprite);
CImg.h:          if (xc + width()<(int)sx) { // X-forward
CImg.h:            res.get_crop(xc + width() - 1,yc,zc,cc,xc + width() - 1,yc + height() - 1,
CImg.h:                         zc + depth() - 1,cc + spectrum() - 1).move_to(sprite);
CImg.h:          if (yc>0) {  // Y-backward
CImg.h:            res.get_crop(0,yc,zc,cc,sx - 1,yc,zc + depth() - 1,cc + spectrum() - 1).move_to(sprite);
CImg.h:            for (int y = yc - 1; y>=0; --y) res.draw_image(0,y,zc,cc,sprite);
CImg.h:          if (yc + height()<(int)sy) { // Y-forward
CImg.h:            res.get_crop(0,yc + height() - 1,zc,cc,sx - 1,yc + height() - 1,
CImg.h:                         zc + depth() - 1,cc + spectrum() - 1).move_to(sprite);
CImg.h:          if (zc>0) {  // Z-backward
CImg.h:            res.get_crop(0,0,zc,cc,sx - 1,sy - 1,zc,cc + spectrum() - 1).move_to(sprite);
CImg.h:            for (int z = zc - 1; z>=0; --z) res.draw_image(0,0,z,cc,sprite);
CImg.h:          if (zc + depth()<(int)sz) { // Z-forward
CImg.h:            res.get_crop(0,0,zc  +depth() - 1,cc,sx - 1,sy - 1,zc + depth() - 1,cc + spectrum() - 1).move_to(sprite);
CImg.h:          if (cc>0) {  // C-backward
CImg.h:            res.get_crop(0,0,0,cc,sx - 1,sy - 1,sz - 1,cc).move_to(sprite);
CImg.h:            for (int c = cc - 1; c>=0; --c) res.draw_image(0,0,0,c,sprite);
CImg.h:          if (cc + spectrum()<(int)sc) { // C-forward
CImg.h:            res.get_crop(0,0,0,cc + spectrum() - 1,sx - 1,sy - 1,sz - 1,cc + spectrum() - 1).move_to(sprite);
CImg.h:            *(poff_x++) = curr - old;
CImg.h:            *(poff_y++) = _width*(curr - old);
CImg.h:            *(poff_z++) = wh*(curr - old);
CImg.h:            *(poff_c++) = whd*(curr - old);
CImg.h:              for ( ; !dy && y<dy; std::memcpy(ptrd,ptrd - sx,sizeof(T)*sx), ++y, ptrd+=sx, dy = *(poff_y++)) {}
CImg.h:            for ( ; !dz && z<dz; std::memcpy(ptrd,ptrd - sxy,sizeof(T)*sxy), ++z, ptrd+=sxy, dz = *(poff_z++)) {}
CImg.h:          for ( ; !dc && c<dc; std::memcpy(ptrd,ptrd - sxyz,sizeof(T)*sxyz), ++c, ptrd+=sxyz, dc = *(poff_c++)) {}
CImg.h:                a-=d; b-=d; c-=d;
CImg.h:                a-=d; b-=d; c-=d;
CImg.h:                a-=d; b-=d; c-=d;
CImg.h:                a-=d; b-=d; c-=d;
CImg.h:            const double fx = (!boundary_conditions && sx>_width)?(sx>1?(_width - 1.)/(sx - 1):0):
CImg.h:                *(pfoff++) = curr - (unsigned int)curr;
CImg.h:                curr = std::min(width() - 1.,curr + fx);
CImg.h:                *(poff++) = (unsigned int)curr - (unsigned int)old;
CImg.h:              const T *ptrs = data(0,y,z,c), *const ptrsmax = ptrs + _width - 1;
CImg.h:                *(ptrd++) = (T)((1 - alpha)*val1 + alpha*val2);
CImg.h:              const double fy = (!boundary_conditions && sy>_height)?(sy>1?(_height - 1.)/(sy - 1):0):
CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
CImg.h:                  curr = std::min(height() - 1.,curr + fy);
CImg.h:                  *(poff++) = sx*((unsigned int)curr - (unsigned int)old);
CImg.h:                const T *ptrs = resx.data(x,0,z,c), *const ptrsmax = ptrs + (_height - 1)*sx;
CImg.h:                  *ptrd = (T)((1 - alpha)*val1 + alpha*val2);
CImg.h:              const double fz = (!boundary_conditions && sz>_depth)?(sz>1?(_depth - 1.)/(sz - 1):0):
CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
CImg.h:                  curr = std::min(depth() - 1.,curr + fz);
CImg.h:                  *(poff++) = sxy*((unsigned int)curr - (unsigned int)old);
CImg.h:                const T *ptrs = resy.data(x,y,0,c), *const ptrsmax = ptrs + (_depth - 1)*sxy;
CImg.h:                  *ptrd = (T)((1 - alpha)*val1 + alpha*val2);
CImg.h:              const double fc = (!boundary_conditions && sc>_spectrum)?(sc>1?(_spectrum - 1.)/(sc - 1):0):
CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
CImg.h:                  curr = std::min(spectrum() - 1.,curr + fc);
CImg.h:                  *(poff++) = sxyz*((unsigned int)curr - (unsigned int)old);
CImg.h:                const T *ptrs = resz.data(x,y,z,0), *const ptrsmax = ptrs + (_spectrum - 1)*sxyz;
CImg.h:                  *ptrd = (T)((1 - alpha)*val1 + alpha*val2);
CImg.h:            int err = (int)(dy + centering_x*(sx*dy/width() - dy)), xs = 0;
CImg.h:            cimg_forX(resx,x) if ((err-=dy)<=0) {
CImg.h:            int err = (int)(dy + centering_y*(sy*dy/height() - dy)), ys = 0;
CImg.h:            cimg_forY(resy,y) if ((err-=dy)<=0) {
CImg.h:            int err = (int)(dy + centering_z*(sz*dy/depth() - dy)), zs = 0;
CImg.h:            cimg_forZ(resz,z) if ((err-=dy)<=0) {
CImg.h:            int err = (int)(dy + centering_c*(sc*dy/spectrum() - dy)), cs = 0;
CImg.h:            cimg_forC(resc,c) if ((err-=dy)<=0) {
CImg.h:              const double fx = (!boundary_conditions && sx>_width)?(sx>1?(_width - 1.)/(sx - 1):0):
CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
CImg.h:                  curr = std::min(width() - 1.,curr + fx);
CImg.h:                  *(poff++) = (unsigned int)curr - (unsigned int)old;
CImg.h:                const T *const ptrs0 = data(0,y,z,c), *ptrs = ptrs0, *const ptrsmax = ptrs + (_width - 2);
CImg.h:                    val0 = ptrs>ptrs0?(double)*(ptrs - 1):val1,
CImg.h:                    val = val1 + 0.5f*(t*(-val0 + val2) + t*t*(2*val0 - 5*val1 + 4*val2 - val3) +
CImg.h:                                       t*t*t*(-val0 + 3*val1 - 3*val2 + val3));
CImg.h:              const double fy = (!boundary_conditions && sy>_height)?(sy>1?(_height - 1.)/(sy - 1):0):
CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
CImg.h:                  curr = std::min(height() - 1.,curr + fy);
CImg.h:                  *(poff++) = sx*((unsigned int)curr - (unsigned int)old);
CImg.h:                const T *const ptrs0 = resx.data(x,0,z,c), *ptrs = ptrs0, *const ptrsmax = ptrs + (_height - 2)*sx;
CImg.h:                    val0 = ptrs>ptrs0?(double)*(ptrs - sx):val1,
CImg.h:                    val = val1 + 0.5f*(t*(-val0 + val2) + t*t*(2*val0 - 5*val1 + 4*val2 - val3) +
CImg.h:                                       t*t*t*(-val0 + 3*val1 - 3*val2 + val3));
CImg.h:              const double fz = (!boundary_conditions && sz>_depth)?(sz>1?(_depth - 1.)/(sz - 1):0):
CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
CImg.h:                  curr = std::min(depth() - 1.,curr + fz);
CImg.h:                  *(poff++) = sxy*((unsigned int)curr - (unsigned int)old);
CImg.h:                const T *const ptrs0 = resy.data(x,y,0,c), *ptrs = ptrs0, *const ptrsmax = ptrs + (_depth - 2)*sxy;
CImg.h:                    val0 = ptrs>ptrs0?(double)*(ptrs - sxy):val1,
CImg.h:                    val = val1 + 0.5f*(t*(-val0 + val2) + t*t*(2*val0 - 5*val1 + 4*val2 - val3) +
CImg.h:                                       t*t*t*(-val0 + 3*val1 - 3*val2 + val3));
CImg.h:              const double fc = (!boundary_conditions && sc>_spectrum)?(sc>1?(_spectrum - 1.)/(sc - 1):0):
CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
CImg.h:                  curr = std::min(spectrum() - 1.,curr + fc);
CImg.h:                  *(poff++) = sxyz*((unsigned int)curr - (unsigned int)old);
CImg.h:                const T *const ptrs0 = resz.data(x,y,z,0), *ptrs = ptrs0, *const ptrsmax = ptrs + (_spectrum - 2)*sxyz;
CImg.h:                    val0 = ptrs>ptrs0?(double)*(ptrs - sxyz):val1,
CImg.h:                    val = val1 + 0.5f*(t*(-val0 + val2) + t*t*(2*val0 - 5*val1 + 4*val2 - val3) +
CImg.h:                                       t*t*t*(-val0 + 3*val1 - 3*val2 + val3));
CImg.h:              const double fx = (!boundary_conditions && sx>_width)?(sx>1?(_width - 1.)/(sx - 1):0):
CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
CImg.h:                  curr = std::min(width() - 1.,curr + fx);
CImg.h:                  *(poff++) = (unsigned int)curr - (unsigned int)old;
CImg.h:                  *const ptrsmax = ptrs0 + (_width - 2);
CImg.h:                    w3 = _cimg_lanczos(t - 1),
CImg.h:                    w4 = _cimg_lanczos(t - 2),
CImg.h:                    val1 = ptrs>=ptrsmin?(double)*(ptrs - 1):val2,
CImg.h:                    val0 = ptrs>ptrsmin?(double)*(ptrs - 2):val1,
CImg.h:              const double fy = (!boundary_conditions && sy>_height)?(sy>1?(_height - 1.)/(sy - 1):0):
CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
CImg.h:                  curr = std::min(height() - 1.,curr + fy);
CImg.h:                  *(poff++) = sx*((unsigned int)curr - (unsigned int)old);
CImg.h:                  *const ptrsmax = ptrs0 + (_height - 2)*sx;
CImg.h:                    w3 = _cimg_lanczos(t - 1),
CImg.h:                    w4 = _cimg_lanczos(t - 2),
CImg.h:                    val1 = ptrs>=ptrsmin?(double)*(ptrs - sx):val2,
CImg.h:                    val0 = ptrs>ptrsmin?(double)*(ptrs - 2*sx):val1,
CImg.h:              const double fz = (!boundary_conditions && sz>_depth)?(sz>1?(_depth - 1.)/(sz - 1):0):
CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
CImg.h:                  curr = std::min(depth() - 1.,curr + fz);
CImg.h:                  *(poff++) = sxy*((unsigned int)curr - (unsigned int)old);
CImg.h:                  *const ptrsmax = ptrs0 + (_depth - 2)*sxy;
CImg.h:                    w3 = _cimg_lanczos(t - 1),
CImg.h:                    w4 = _cimg_lanczos(t - 2),
CImg.h:                    val1 = ptrs>=ptrsmin?(double)*(ptrs - sxy):val2,
CImg.h:                    val0 = ptrs>ptrsmin?(double)*(ptrs - 2*sxy):val1,
CImg.h:              const double fc = (!boundary_conditions && sc>_spectrum)?(sc>1?(_spectrum - 1.)/(sc - 1):0):
CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
CImg.h:                  curr = std::min(spectrum() - 1.,curr + fc);
CImg.h:                  *(poff++) = sxyz*((unsigned int)curr - (unsigned int)old);
CImg.h:                  *const ptrsmax = ptrs + (_spectrum - 2)*sxyz;
CImg.h:                    w3 = _cimg_lanczos(t - 1),
CImg.h:                    w4 = _cimg_lanczos(t - 2),
CImg.h:                    val1 = ptrs>=ptrsmin?(double)*(ptrs - sxyz):val2,
CImg.h:                    val0 = ptrs>ptrsmin?(double)*(ptrs - 2*sxyz):val1,
CImg.h:                                    "(should be { -1=raw | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | "
CImg.h:    //! Resize image to half-size along XY axes, using an optimized filter.
CImg.h:    //! Resize image to half-size along XY axes, using an optimized filter \newinstance.
CImg.h:    //! Resize image to double-size, using the Scale2X algorithm.
CImg.h:    //! Resize image to double-size, using the Scale2X algorithm \newinstance.
CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1; \
CImg.h:      _n1##i<(int)(bound) || i==--_n1##i; \
CImg.h:   1>=(img)._width?(img).width() - 1:1); \
CImg.h:   x==--_n1##x; \
CImg.h:    //! Resize image to triple-size, using the Scale3X algorithm.
CImg.h:    //! Resize image to triple-size, using the Scale3X algorithm \newinstance.
CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1; \
CImg.h:      _n1##i<(int)(bound) || i==--_n1##i; \
CImg.h:   1>=(img)._width?(img).width() - 1:1); \
CImg.h:   x==--_n1##x; \
CImg.h:        pf = _data; pb = data(_width - 1);
CImg.h:          for (unsigned int x = 0; x<width2; ++x) { const T val = *pf; *(pf++) = *pb; *(pb--) = val; }
CImg.h:          pf+=_width - width2;
CImg.h:        pf = _data; pb = data(0,_height - 1);
CImg.h:            pb-=_width;
CImg.h:          pf+=(ulongT)_width*(_height - height2);
CImg.h:        pf = _data; pb = data(0,0,_depth - 1);
CImg.h:            pb-=(ulongT)_width*_height;
CImg.h:          pf+=(ulongT)_width*_height*(_depth - depth2);
CImg.h:        pf = _data; pb = data(0,0,0,_spectrum - 1);
CImg.h:          pb-=(ulongT)_width*_height*_depth;
CImg.h:       \param axes Mirror axes, as a C-string.
CImg.h:       \param delta_x Amount of displacement along the X-axis.
CImg.h:       \param delta_y Amount of displacement along the Y-axis.
CImg.h:       \param delta_z Amount of displacement along the Z-axis.
CImg.h:       \param delta_c Amount of displacement along the C-axis.
CImg.h:        return get_crop(-delta_x,-delta_y,-delta_z,-delta_c,
CImg.h:                        width() - delta_x - 1,
CImg.h:                        height() - delta_y - 1,
CImg.h:                        depth() - delta_z - 1,
CImg.h:                        spectrum() - delta_c - 1,3).move_to(*this);
CImg.h:      if (delta_x) // Shift along X-axis
CImg.h:          const int ml = cimg::mod(-delta_x,width()), ndelta_x = (ml<=width()/2)?ml:(ml-width());
CImg.h:              std::memmove(data(0,y,z,c),data(ndelta_x,y,z,c),(_width-ndelta_x)*sizeof(T));
CImg.h:              std::memcpy(data(_width-ndelta_x,y,z,c),buf,ndelta_x*sizeof(T));
CImg.h:              std::memcpy(buf,data(_width + ndelta_x,y,z,c),-ndelta_x*sizeof(T));
CImg.h:              std::memmove(data(-ndelta_x,y,z,c),data(0,y,z,c),(_width + ndelta_x)*sizeof(T));
CImg.h:              std::memcpy(data(0,y,z,c),buf,-ndelta_x*sizeof(T));
CImg.h:            const int ndelta_x = (-delta_x>=width())?width() - 1:-delta_x;
CImg.h:              std::memmove(data(0,y,z,c),data(ndelta_x,y,z,c),(_width-ndelta_x)*sizeof(T));
CImg.h:              T *ptrd = data(_width - 1,y,z,c);
CImg.h:              for (int l = 0; l<ndelta_x - 1; ++l) *(--ptrd) = val;
CImg.h:            const int ndelta_x = (delta_x>=width())?width() - 1:delta_x;
CImg.h:              std::memmove(data(ndelta_x,y,z,c),data(0,y,z,c),(_width-ndelta_x)*sizeof(T));
CImg.h:              for (int l = 0; l<ndelta_x - 1; ++l) *(++ptrd) = val;
CImg.h:          if (delta_x<=-width() || delta_x>=width()) return fill((T)0);
CImg.h:              std::memmove(data(0,y,z,c),data(-delta_x,y,z,c),(_width + delta_x)*sizeof(T));
CImg.h:              std::memset(data(_width + delta_x,y,z,c),0,-delta_x*sizeof(T));
CImg.h:              std::memmove(data(delta_x,y,z,c),data(0,y,z,c),(_width-delta_x)*sizeof(T));
CImg.h:      if (delta_y) // Shift along Y-axis
CImg.h:          const int ml = cimg::mod(-delta_y,height()), ndelta_y = (ml<=height()/2)?ml:(ml-height());
CImg.h:              std::memmove(data(0,0,z,c),data(0,ndelta_y,z,c),_width*(_height-ndelta_y)*sizeof(T));
CImg.h:              std::memcpy(data(0,_height-ndelta_y,z,c),buf,_width*ndelta_y*sizeof(T));
CImg.h:              std::memcpy(buf,data(0,_height + ndelta_y,z,c),-ndelta_y*_width*sizeof(T));
CImg.h:              std::memmove(data(0,-ndelta_y,z,c),data(0,0,z,c),_width*(_height + ndelta_y)*sizeof(T));
CImg.h:              std::memcpy(data(0,0,z,c),buf,-ndelta_y*_width*sizeof(T));
CImg.h:            const int ndelta_y = (-delta_y>=height())?height() - 1:-delta_y;
CImg.h:              std::memmove(data(0,0,z,c),data(0,ndelta_y,z,c),_width*(_height-ndelta_y)*sizeof(T));
CImg.h:              T *ptrd = data(0,_height-ndelta_y,z,c), *ptrs = data(0,_height - 1,z,c);
CImg.h:              for (int l = 0; l<ndelta_y - 1; ++l) { std::memcpy(ptrd,ptrs,_width*sizeof(T)); ptrd+=_width; }
CImg.h:            const int ndelta_y = (delta_y>=height())?height() - 1:delta_y;
CImg.h:              std::memmove(data(0,ndelta_y,z,c),data(0,0,z,c),_width*(_height-ndelta_y)*sizeof(T));
CImg.h:              for (int l = 0; l<ndelta_y - 1; ++l) { std::memcpy(ptrd,ptrs,_width*sizeof(T)); ptrd+=_width; }
CImg.h:          if (delta_y<=-height() || delta_y>=height()) return fill((T)0);
CImg.h:              std::memmove(data(0,0,z,c),data(0,-delta_y,z,c),_width*(_height + delta_y)*sizeof(T));
CImg.h:              std::memset(data(0,_height + delta_y,z,c),0,-delta_y*_width*sizeof(T));
CImg.h:              std::memmove(data(0,delta_y,z,c),data(0,0,z,c),_width*(_height-delta_y)*sizeof(T));
CImg.h:      if (delta_z) // Shift along Z-axis
CImg.h:          const int ml = cimg::mod(-delta_z,depth()), ndelta_z = (ml<=depth()/2)?ml:(ml-depth());
CImg.h:              std::memmove(data(0,0,0,c),data(0,0,ndelta_z,c),_width*_height*(_depth-ndelta_z)*sizeof(T));
CImg.h:              std::memcpy(data(0,0,_depth-ndelta_z,c),buf,_width*_height*ndelta_z*sizeof(T));
CImg.h:              std::memcpy(buf,data(0,0,_depth + ndelta_z,c),-ndelta_z*_width*_height*sizeof(T));
CImg.h:              std::memmove(data(0,0,-ndelta_z,c),data(0,0,0,c),_width*_height*(_depth + ndelta_z)*sizeof(T));
CImg.h:              std::memcpy(data(0,0,0,c),buf,-ndelta_z*_width*_height*sizeof(T));
CImg.h:            const int ndelta_z = (-delta_z>=depth())?depth() - 1:-delta_z;
CImg.h:              std::memmove(data(0,0,0,c),data(0,0,ndelta_z,c),_width*_height*(_depth-ndelta_z)*sizeof(T));
CImg.h:              T *ptrd = data(0,0,_depth-ndelta_z,c), *ptrs = data(0,0,_depth - 1,c);
CImg.h:              for (int l = 0; l<ndelta_z - 1; ++l) {
CImg.h:            const int ndelta_z = (delta_z>=depth())?depth() - 1:delta_z;
CImg.h:              std::memmove(data(0,0,ndelta_z,c),data(0,0,0,c),_width*_height*(_depth-ndelta_z)*sizeof(T));
CImg.h:              for (int l = 0; l<ndelta_z - 1; ++l) {
CImg.h:          if (delta_z<=-depth() || delta_z>=depth()) return fill((T)0);
CImg.h:              std::memmove(data(0,0,0,c),data(0,0,-delta_z,c),_width*_height*(_depth + delta_z)*sizeof(T));
CImg.h:              std::memset(data(0,0,_depth + delta_z,c),0,_width*_height*(-delta_z)*sizeof(T));
CImg.h:              std::memmove(data(0,0,delta_z,c),data(0,0,0,c),_width*_height*(_depth-delta_z)*sizeof(T));
CImg.h:      if (delta_c) // Shift along C-axis
CImg.h:          const int ml = cimg::mod(-delta_c,spectrum()), ndelta_c = (ml<=spectrum()/2)?ml:(ml-spectrum());
CImg.h:            std::memmove(_data,data(0,0,0,ndelta_c),_width*_height*_depth*(_spectrum-ndelta_c)*sizeof(T));
CImg.h:            std::memcpy(data(0,0,0,_spectrum-ndelta_c),buf,_width*_height*_depth*ndelta_c*sizeof(T));
CImg.h:            std::memcpy(buf,data(0,0,0,_spectrum + ndelta_c),-ndelta_c*_width*_height*_depth*sizeof(T));
CImg.h:            std::memmove(data(0,0,0,-ndelta_c),_data,_width*_height*_depth*(_spectrum + ndelta_c)*sizeof(T));
CImg.h:            std::memcpy(_data,buf,-ndelta_c*_width*_height*_depth*sizeof(T));
CImg.h:            const int ndelta_c = (-delta_c>=spectrum())?spectrum() - 1:-delta_c;
CImg.h:            std::memmove(_data,data(0,0,0,ndelta_c),_width*_height*_depth*(_spectrum-ndelta_c)*sizeof(T));
CImg.h:            T *ptrd = data(0,0,0,_spectrum-ndelta_c), *ptrs = data(0,0,0,_spectrum - 1);
CImg.h:            for (int l = 0; l<ndelta_c - 1; ++l) {
CImg.h:            const int ndelta_c = (delta_c>=spectrum())?spectrum() - 1:delta_c;
CImg.h:            std::memmove(data(0,0,0,ndelta_c),_data,_width*_height*_depth*(_spectrum-ndelta_c)*sizeof(T));
CImg.h:            for (int l = 0; l<ndelta_c - 1; ++l) {
CImg.h:          if (delta_c<=-spectrum() || delta_c>=spectrum()) return fill((T)0);
CImg.h:            std::memmove(_data,data(0,0,0,-delta_c),_width*_height*_depth*(_spectrum + delta_c)*sizeof(T));
CImg.h:            std::memset(data(0,0,0,_spectrum + delta_c),0,_width*_height*_depth*(-delta_c)*sizeof(T));
CImg.h:            std::memmove(data(0,0,0,delta_c),_data,_width*_height*_depth*(_spectrum-delta_c)*sizeof(T));
CImg.h:       \param axes_order Axes permutations, as a C-string of 4 characters.
CImg.h:            for (unsigned int siz = _height*_depth*_spectrum; siz; --siz) {
CImg.h:            for (unsigned int siz = _height*_depth*_spectrum; siz; --siz) {
CImg.h:            for (unsigned int siz = _height*_depth*_spectrum; siz; --siz) {
CImg.h:            for (unsigned int siz = _height*_depth*_spectrum; siz; --siz) {
CImg.h:            for (ulongT siz = (ulongT)_width*_height*_depth; siz; --siz) *(ptrd++) = (t)*(ptr_r++);
CImg.h:            for (ulongT siz = (ulongT)_width*_height*_depth; siz; --siz) {
CImg.h:            for (ulongT siz = (ulongT)_width*_height*_depth; siz; --siz) {
CImg.h:            for (ulongT siz = (ulongT)_width*_height*_depth; siz; --siz) {
CImg.h:        const int wm1 = width() - 1, hm1 = height() - 1;
CImg.h:          cimg_forXYZC(res,x,y,z,c) *(ptrd++) = (*this)(y,hm1 - x,z,c);
CImg.h:          cimg_forXYZC(res,x,y,z,c) *(ptrd++) = (*this)(wm1 - x,hm1 - y,z,c);
CImg.h:          cimg_forXYZC(res,x,y,z,c) *(ptrd++) = (*this)(wm1 - y,x,z,c);
CImg.h:          ux = cimg::abs((_width - 1)*ca), uy = cimg::abs((_width - 1)*sa),
CImg.h:          vx = cimg::abs((_height - 1)*sa), vy = cimg::abs((_height - 1)*ca),
CImg.h:          w2 = 0.5f*(_width - 1), h2 = 0.5f*(_height - 1);
CImg.h:        const float rw2 = 0.5f*(res._width - 1), rh2 = 0.5f*(res._height - 1);
CImg.h:       \param cx X-coordinate of the rotation center.
CImg.h:       \param cy Y-coordinate of the rotation center.
CImg.h:            const float xc = x - rw2, yc = y - rh2,
CImg.h:              my = cimg::mod(h2 - xc*sa + yc*ca,hh);
CImg.h:            res(x,y,z,c) = _cubic_atXY_c(mx<width()?mx:ww - mx - 1,my<height()?my:hh - my - 1,z,c);
CImg.h:            const float xc = x - rw2, yc = y - rh2,
CImg.h:              my = cimg::mod(h2 - xc*sa + yc*ca,hh);
CImg.h:            res(x,y,z,c) = (T)_linear_atXY(mx<width()?mx:ww - mx - 1,my<height()?my:hh - my - 1,z,c);
CImg.h:        default : { // Nearest-neighbor interpolation
CImg.h:            const float xc = x - rw2, yc = y - rh2,
CImg.h:              my = cimg::mod((int)cimg::round(h2 - xc*sa + yc*ca),hh);
CImg.h:            res(x,y,z,c) = (*this)(mx<width()?mx:ww - mx - 1,my<height()?my:hh - my - 1,z,c);
CImg.h:            const float xc = x - rw2, yc = y - rh2;
CImg.h:            res(x,y,z,c) = _cubic_atXY_pc(w2 + xc*ca + yc*sa,h2 - xc*sa + yc*ca,z,c);
CImg.h:            const float xc = x - rw2, yc = y - rh2;
CImg.h:            res(x,y,z,c) = (T)_linear_atXY_p(w2 + xc*ca + yc*sa,h2 - xc*sa + yc*ca,z,c);
CImg.h:        default : { // Nearest-neighbor interpolation
CImg.h:            const float xc = x - rw2, yc = y - rh2;
CImg.h:                                   cimg::mod((int)cimg::round(h2 - xc*sa + yc*ca),(float)height()),z,c);
CImg.h:            const float xc = x - rw2, yc = y - rh2;
CImg.h:            res(x,y,z,c) = _cubic_atXY_c(w2 + xc*ca + yc*sa,h2 - xc*sa + yc*ca,z,c);
CImg.h:            const float xc = x - rw2, yc = y - rh2;
CImg.h:            res(x,y,z,c) = (T)_linear_atXY(w2 + xc*ca + yc*sa,h2 - xc*sa + yc*ca,z,c);
CImg.h:        default : { // Nearest-neighbor interpolation
CImg.h:            const float xc = x - rw2, yc = y - rh2;
CImg.h:                                 (int)cimg::round(h2 - xc*sa + yc*ca),z,c);
CImg.h:            const float xc = x - rw2, yc = y - rh2;
CImg.h:            res(x,y,z,c) = cubic_atXY_c(w2 + xc*ca + yc*sa,h2 - xc*sa + yc*ca,z,c,(T)0);
CImg.h:            const float xc = x - rw2, yc = y - rh2;
CImg.h:            res(x,y,z,c) = (T)linear_atXY(w2 + xc*ca + yc*sa,h2 - xc*sa + yc*ca,z,c,(T)0);
CImg.h:        default : { // Nearest-neighbor interpolation
CImg.h:            const float xc = x - rw2, yc = y - rh2;
CImg.h:                                (int)cimg::round(h2 - xc*sa + yc*ca),z,c,(T)0);
CImg.h:       \param u X-coordinate of the 3D rotation axis.
CImg.h:       \param v Y-coordinate of the 3D rotation axis.
CImg.h:       \param w Z-coordinate of the 3D rotation axis.
CImg.h:        w1 = _width - 1, h1 = _height - 1, d1 = _depth -1,
CImg.h:        dx = (int)cimg::round(xM - xm),
CImg.h:        dy = (int)cimg::round(yM - ym),
CImg.h:        dz = (int)cimg::round(zM - zm);
CImg.h:       \param u X-coordinate of the 3D rotation axis.
CImg.h:       \param v Y-coordinate of the 3D rotation axis.
CImg.h:       \param w Z-coordinate of the 3D rotation axis.
CImg.h:       \param cx X-coordinate of the rotation center.
CImg.h:       \param cy Y-coordinate of the rotation center.
CImg.h:       \param cz Z-coordinate of the rotation center.
CImg.h:      CImg<floatT> R = CImg<floatT>::rotation_matrix(u,v,w,-angle);
CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
CImg.h:            cimg_forC(res,c) res(x,y,z,c) = _cubic_atXYZ_c(X<width()?X:ww - X - 1,
CImg.h:                                                           Y<height()?Y:hh - Y - 1,
CImg.h:                                                           Z<depth()?Z:dd - Z - z,c);
CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
CImg.h:            cimg_forC(res,c) res(x,y,z,c) = (T)_linear_atXYZ(X<width()?X:ww - X - 1,
CImg.h:                                                             Y<height()?Y:hh - Y - 1,
CImg.h:                                                             Z<depth()?Z:dd - Z - 1,c);
CImg.h:        default : { // Nearest-neighbor interpolation
CImg.h:            const float xc = x - rw2, yc = y - rh2, zc = z - rd2;
CImg.h:            cimg_forC(res,c) res(x,y,z,c) = (*this)(X<width()?X:ww - X - 1,
CImg.h:                                                    Y<height()?Y:hh - Y - 1,
CImg.h:                                                    Z<depth()?Z:dd - Z -  1,c);
CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
CImg.h:        default : { // Nearest-neighbor interpolation
CImg.h:            const float xc = x - rw2, yc = y - rh2, zc = z - rd2;
CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
CImg.h:        default : { // Nearest-neighbor interpolation
CImg.h:            const float xc = x - rw2, yc = y - rh2, zc = z - rd2;
CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
CImg.h:        default : { // Nearest-neighbor interpolation
CImg.h:            const float xc = x - rw2, yc = y - rh2, zc = z - rd2;
CImg.h:       \param mode Can be { 0=backward-absolute | 1=backward-relative | 2=forward-absolute | 3=foward-relative }
CImg.h:        if (mode>=3) { // Forward-relative warp
CImg.h:          else // Nearest-neighbor interpolation
CImg.h:        } else if (mode==2) { // Forward-absolute warp
CImg.h:          else // Nearest-neighbor interpolation
CImg.h:        } else if (mode==1) { // Backward-relative warp
CImg.h:                  const float mx = cimg::mod(x - (float)*(ptrs0++),w2);
CImg.h:                  *(ptrd++) = _cubic_atX_c(mx<width()?mx:w2 - mx - 1,y,z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = _cubic_atX_pc(x - (float)*(ptrs0++),y,z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = _cubic_atX_c(x - (float)*(ptrs0++),y,z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = cubic_atX_c(x - (float)*(ptrs0++),y,z,c,(T)0);
CImg.h:                  const float mx = cimg::mod(x - (float)*(ptrs0++),w2);
CImg.h:                  *(ptrd++) = (T)_linear_atX(mx<width()?mx:w2 - mx - 1,y,z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)_linear_atX_p(x - (float)*(ptrs0++),y,z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)_linear_atX(x - (float)*(ptrs0++),y,z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)linear_atX(x - (float)*(ptrs0++),y,z,c,(T)0);
CImg.h:          else // Nearest-neighbor interpolation
CImg.h:                  const int mx = cimg::mod(x - (int)cimg::round(*(ptrs0++)),w2);
CImg.h:                  *(ptrd++) = (*this)(mx<width()?mx:w2 - mx - 1,y,z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = (*this)(cimg::mod(x - (int)cimg::round(*(ptrs0++)),width()),y,z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = _atX(x - (int)cimg::round(*(ptrs0++)),y,z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = atX(x - (int)cimg::round(*(ptrs0++)),y,z,c,(T)0);
CImg.h:        else { // Backward-absolute warp
CImg.h:                  *(ptrd++) = _cubic_atX_c(mx<width()?mx:w2 - mx - 1,0,0,c);
CImg.h:                  *(ptrd++) = (T)_linear_atX(mx<width()?mx:w2 - mx - 1,0,0,c);
CImg.h:          else // Nearest-neighbor interpolation
CImg.h:                  *(ptrd++) = (*this)(mx<width()?mx:w2 - mx - 1,0,0,c);
CImg.h:        if (mode>=3) { // Forward-relative warp
CImg.h:          else // Nearest-neighbor interpolation
CImg.h:        } else if (mode==2) { // Forward-absolute warp
CImg.h:          else // Nearest-neighbor interpolation
CImg.h:        } else if (mode==1) { // Backward-relative warp
CImg.h:                    mx = cimg::mod(x - (float)*(ptrs0++),w2),
CImg.h:                    my = cimg::mod(y - (float)*(ptrs1++),h2);
CImg.h:                  *(ptrd++) = _cubic_atXY_c(mx<width()?mx:w2 - mx - 1,my<height()?my:h2 - my - 1,z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = _cubic_atXY_pc(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = _cubic_atXY_c(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = cubic_atXY_c(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c,(T)0);
CImg.h:                    mx = cimg::mod(x - (float)*(ptrs0++),w2),
CImg.h:                    my = cimg::mod(y - (float)*(ptrs1++),h2);
CImg.h:                  *(ptrd++) = (T)_linear_atXY(mx<width()?mx:w2 - mx - 1,my<height()?my:h2 - my - 1,z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)_linear_atXY_p(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)_linear_atXY(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)linear_atXY(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c,(T)0);
CImg.h:          else // Nearest-neighbor interpolation
CImg.h:                    mx = cimg::mod(x - (int)cimg::round(*(ptrs0++)),w2),
CImg.h:                    my = cimg::mod(y - (int)cimg::round(*(ptrs1++)),h2);
CImg.h:                  *(ptrd++) = (*this)(mx<width()?mx:w2 - mx - 1,my<height()?my:h2 - my - 1,z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = (*this)(cimg::mod(x - (int)cimg::round(*(ptrs0++)),width()),
CImg.h:                                                     cimg::mod(y - (int)cimg::round(*(ptrs1++)),height()),z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = _atXY(x - (int)cimg::round(*(ptrs0++)),
CImg.h:                                                   y - (int)cimg::round(*(ptrs1++)),z,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = atXY(x - (int)cimg::round(*(ptrs0++)),
CImg.h:                                                  y - (int)cimg::round(*(ptrs1++)),z,c,(T)0);
CImg.h:        } else { // Backward-absolute warp
CImg.h:                  *(ptrd++) = _cubic_atXY_c(mx<width()?mx:w2 - mx - 1,my<height()?my:h2 - my - 1,0,c);
CImg.h:                  *(ptrd++) = (T)_linear_atXY(mx<width()?mx:w2 - mx - 1,my<height()?my:h2 - my - 1,0,c);
CImg.h:          else // Nearest-neighbor interpolation
CImg.h:                  *(ptrd++) = (*this)(mx<width()?mx:w2 - mx - 1,my<height()?my:h2 - my - 1,0,c);
CImg.h:        if (mode>=3) { // Forward-relative warp
CImg.h:          else // Nearest-neighbor interpolation
CImg.h:        } else if (mode==2) { // Forward-absolute warp
CImg.h:          else // Nearest-neighbor interpolation
CImg.h:        } else if (mode==1) { // Backward-relative warp
CImg.h:                    mx = cimg::mod(x - (float)*(ptrs0++),w2),
CImg.h:                    my = cimg::mod(y - (float)*(ptrs1++),h2),
CImg.h:                    mz = cimg::mod(z - (float)*(ptrs2++),d2);
CImg.h:                  *(ptrd++) = _cubic_atXYZ_c(mx<width()?mx:w2 - mx - 1,
CImg.h:                                             my<height()?my:h2 - my - 1,
CImg.h:                                             mz<depth()?mz:d2 - mz - 1,c);
CImg.h:                  *(ptrd++) = _cubic_atXYZ_pc(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c);
CImg.h:                  *(ptrd++) = _cubic_atXYZ_c(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c);
CImg.h:                  *(ptrd++) = cubic_atXYZ_c(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c,(T)0);
CImg.h:                    mx = cimg::mod(x - (float)*(ptrs0++),w2),
CImg.h:                    my = cimg::mod(y - (float)*(ptrs1++),h2),
CImg.h:                    mz = cimg::mod(z - (float)*(ptrs2++),d2);
CImg.h:                  *(ptrd++) = (T)_linear_atXYZ(mx<width()?mx:w2 - mx - 1,
CImg.h:                                               my<height()?my:h2 - my - 1,
CImg.h:                                               mz<depth()?mz:d2 - mz - 1,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)_linear_atXYZ_p(x - (float)*(ptrs0++),y - (float)*(ptrs1++),
CImg.h:                                                                z - (float)*(ptrs2++),c);
CImg.h:                  *(ptrd++) = (T)_linear_atXYZ(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c);
CImg.h:                  *(ptrd++) = (T)linear_atXYZ(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c,(T)0);
CImg.h:                    mx = cimg::mod(x - (int)cimg::round(*(ptrs0++)),w2),
CImg.h:                    my = cimg::mod(y - (int)cimg::round(*(ptrs1++)),h2),
CImg.h:                    mz = cimg::mod(z - (int)cimg::round(*(ptrs2++)),d2);
CImg.h:                  *(ptrd++) = (*this)(mx<width()?mx:w2 - mx - 1,
CImg.h:                                      my<height()?my:h2 - my - 1,
CImg.h:                                      mz<depth()?mz:d2 - mz - 1,c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = (*this)(cimg::mod(x - (int)cimg::round(*(ptrs0++)),width()),
CImg.h:                                                     cimg::mod(y - (int)cimg::round(*(ptrs1++)),height()),
CImg.h:                                                     cimg::mod(z - (int)cimg::round(*(ptrs2++)),depth()),c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = _atXYZ(x - (int)cimg::round(*(ptrs0++)),
CImg.h:                                                    y - (int)cimg::round(*(ptrs1++)),
CImg.h:                                                    z - (int)cimg::round(*(ptrs2++)),c);
CImg.h:                cimg_forX(res,x) *(ptrd++) = atXYZ(x - (int)cimg::round(*(ptrs0++)),
CImg.h:                                                   y - (int)cimg::round(*(ptrs1++)),
CImg.h:                                                   z - (int)cimg::round(*(ptrs2++)),c,(T)0);
CImg.h:        } else { // Backward-absolute warp
CImg.h:                  *(ptrd++) = _cubic_atXYZ_c(mx<width()?mx:w2 - mx - 1,
CImg.h:                                             my<height()?my:h2 - my - 1,
CImg.h:                                             mz<depth()?mz:d2 - mz - 1,c);
CImg.h:                  *(ptrd++) = (T)_linear_atXYZ(mx<width()?mx:w2 - mx - 1,
CImg.h:                                               my<height()?my:h2 - my - 1,
CImg.h:                                               mz<depth()?mz:d2 - mz - 1,c);
CImg.h:          else // Nearest-neighbor interpolation
CImg.h:                  *(ptrd++) = (*this)(mx<width()?mx:w2 - mx - 1,
CImg.h:                                      my<height()?my:h2 - my - 1,
CImg.h:                                      mz<depth()?mz:d2 - mz - 1,c);
CImg.h:       \param x0 X-coordinate of the projection point.
CImg.h:       \param y0 Y-coordinate of the projection point.
CImg.h:       \param z0 Z-coordinate of the projection point.
CImg.h:        _x0 = (x0>=_width)?_width - 1:x0,
CImg.h:        _y0 = (y0>=_height)?_height - 1:y0,
CImg.h:        _z0 = (z0>=_depth)?_depth - 1:z0;
CImg.h:        img_xy = get_crop(0,0,_z0,0,_width - 1,_height - 1,_z0,_spectrum - 1),
CImg.h:        img_zy = get_crop(_x0,0,0,0,_x0,_height - 1,_depth - 1,_spectrum - 1).permute_axes("xzyc").
CImg.h:        resize(_depth,_height,1,-100,-1),
CImg.h:        img_xz = get_crop(0,_y0,0,0,_width - 1,_y0,_depth - 1,_spectrum - 1).resize(_width,_depth,1,-100,-1);
CImg.h:       \param x0 = X-coordinate of the upper-left crop rectangle corner.
CImg.h:       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
CImg.h:       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
CImg.h:       \param c0 = C-coordinate of the upper-left crop rectangle corner.
CImg.h:       \param x1 = X-coordinate of the lower-right crop rectangle corner.
CImg.h:       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
CImg.h:       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
CImg.h:       \param c1 = C-coordinate of the lower-right crop rectangle corner.
CImg.h:      CImg<T> res(1U + nx1 - nx0,1U + ny1 - ny0,1U + nz1 - nz0,1U + nc1 - nc0);
CImg.h:            res(x,y,z,c) = (*this)(mx<width()?mx:w2 - mx - 1,
CImg.h:                                   my<height()?my:h2 - my - 1,
CImg.h:                                   mz<depth()?mz:d2 - mz - 1,
CImg.h:                                   mc<spectrum()?mc:s2 - mc - 1);
CImg.h:          res.fill((T)0).draw_image(-nx0,-ny0,-nz0,-nc0,*this);
CImg.h:      else res.draw_image(-nx0,-ny0,-nz0,-nc0,*this);
CImg.h:      return crop(x0,y0,z0,0,x1,y1,z1,_spectrum - 1,boundary_conditions);
CImg.h:      return get_crop(x0,y0,z0,0,x1,y1,z1,_spectrum - 1,boundary_conditions);
CImg.h:      return crop(x0,y0,0,0,x1,y1,_depth - 1,_spectrum - 1,boundary_conditions);
CImg.h:      return get_crop(x0,y0,0,0,x1,y1,_depth - 1,_spectrum - 1,boundary_conditions);
CImg.h:      return crop(x0,0,0,0,x1,_height - 1,_depth - 1,_spectrum - 1,boundary_conditions);
CImg.h:      return get_crop(x0,0,0,0,x1,_height - 1,_depth - 1,_spectrum - 1,boundary_conditions);
CImg.h:        if (coords[0]==-1 && coords[1]==-1) return assign(); // Image has only 'value' pixels
CImg.h:          if (y0>=0 && y1>=0) crop(0,y0,_width - 1,y1);
CImg.h:          if (z0>=0 && z1>=0) crop(0,0,z0,_width - 1,_height - 1,z1);
CImg.h:          if (c0>=0 && c1>=0) crop(0,0,0,c0,_width - 1,_height - 1,_depth - 1,c1);
CImg.h:          const CImg<T> col2 = get_vector_at(w - 1,h - 1,d - 1);
CImg.h:          int x0 = width(), x1 = -1;
CImg.h:          if (x0==width() && x1==-1) return assign(); else crop(x0,x1);
CImg.h:          int y0 = height(), y1 = -1;
CImg.h:          if (y0==height() && y1==-1) return assign(); else crop(0,y0,_width - 1,y1);
CImg.h:          int z0 = depth(), z1 = -1;
CImg.h:          if (z0==depth() && z1==-1) return assign(); else crop(0,0,z0,_width - 1,_height - 1,z1);
CImg.h:        int x0 = -1, x1 = -1;
CImg.h:          for (int x = width() - 1; x>=0; --x) cimg_forYZC(*this,y,z,c)
CImg.h:        int y0 = -1, y1 = -1;
CImg.h:          for (int y = height() - 1; y>=0; --y) cimg_forXZC(*this,x,z,c)
CImg.h:        int z0 = -1, z1 = -1;
CImg.h:          for (int z = depth() - 1; z>=0; --z) cimg_forXYC(*this,x,y,c)
CImg.h:        int c0 = -1, c1 = -1;
CImg.h:          for (int c = spectrum() - 1; c>=0; --c) cimg_forXYZ(*this,x,y,z)
CImg.h:      return get_crop(x0,0,0,0,x1,height() - 1,depth() - 1,spectrum() - 1);
CImg.h:      return get_crop(0,y0,0,0,width() - 1,y1,depth() - 1,spectrum() - 1);
CImg.h:      return get_crop(0,0,z0,0,width() - 1,height() - 1,z1,spectrum() - 1);
CImg.h:      return get_crop(0,0,0,c0,width() - 1,height() - 1,depth() - 1,c1);
CImg.h:                            0,0,0,_width - 1.f,_height - 1.f,0.f);
CImg.h:                            0,0,0,_width - 1.f,_height - 1.f,0.f);
CImg.h:                          0,0,0,_width - 1.f,_height - 1.f,_depth - 1.f);
CImg.h:                        0,0,0,_width - 1.f,_height - 1.f,_depth - 1.f);
CImg.h:       \param x X-coordinate of the starting point of the streamline.
CImg.h:       \param y Y-coordinate of the starting point of the streamline.
CImg.h:       \param z Z-coordinate of the starting point of the streamline.
CImg.h:         Can be <tt>{ 0=nearest int | 1=linear | 2=2nd-order RK | 3=4th-order RK. }</tt>.
CImg.h:       \param x0 X-coordinate of the first bounding-box vertex.
CImg.h:       \param y0 Y-coordinate of the first bounding-box vertex.
CImg.h:       \param z0 Z-coordinate of the first bounding-box vertex.
CImg.h:       \param x1 X-coordinate of the second bounding-box vertex.
CImg.h:       \param y1 Y-coordinate of the second bounding-box vertex.
CImg.h:       \param z1 Z-coordinate of the second bounding-box vertex.
CImg.h:            xi = (int)(X>0?X + 0.5f:X - 0.5f),
CImg.h:            yi = (int)(Y>0?Y + 0.5f:Y - 0.5f),
CImg.h:            zi = (int)(Z>0?Z + 0.5f:Z - 0.5f);
CImg.h:          if (is_oriented_only && u*pu + v*pv + w*pw<0) { u = -u; v = -v; w = -w; }
CImg.h:          if (is_backward_tracking) { X-=(pu=u); Y-=(pv=v); Z-=(pw=w); } else { X+=(pu=u); Y+=(pv=v); Z+=(pw=w); }
CImg.h:      case 1 : { // First-order interpolation
CImg.h:          if (is_oriented_only && u*pu + v*pv + w*pw<0) { u = -u; v = -v; w = -w; }
CImg.h:          if (is_backward_tracking) { X-=(pu=u); Y-=(pv=v); Z-=(pw=w); } else { X+=(pu=u); Y+=(pv=v); Z+=(pw=w); }
CImg.h:          if (is_oriented_only && u0*pu + v0*pv + w0*pw<0) { u0 = -u0; v0 = -v0; w0 = -w0; }
CImg.h:          if (is_oriented_only && u*pu + v*pv + w*pw<0) { u = -u; v = -v; w = -w; }
CImg.h:          if (is_backward_tracking) { X-=(pu=u); Y-=(pv=v); Z-=(pw=w); } else { X+=(pu=u); Y+=(pv=v); Z+=(pw=w); }
CImg.h:          if (is_oriented_only && u0*pu + v0*pv + w0*pw<0) { u0 = -u0; v0 = -v0; w0 = -w0; }
CImg.h:          if (is_oriented_only && u1*pu + v1*pv + w1*pw<0) { u1 = -u1; v1 = -v1; w1 = -w1; }
CImg.h:          if (is_oriented_only && u2*pu + v2*pv + w2*pw<0) { u2 = -u2; v2 = -v2; w2 = -w2; }
CImg.h:          if (is_oriented_only && u2*pu + v2*pv + w2*pw<0) { u3 = -u3; v3 = -v3; w3 = -w3; }
CImg.h:          if (is_backward_tracking) { X-=(pu=u); Y-=(pv=v); Z-=(pw=w); } else { X+=(pu=u); Y+=(pv=v); Z+=(pw=w); }
CImg.h:      if (ptr_x!=coordinates.data(0,1)) coordinates.resize((int)(ptr_x-coordinates.data()),3,1,1,0);
CImg.h:        if (I(i,j,0)*I(0,0,0) + I(i,j,1)*I(0,0,1)<0) { I(i,j,0) = -I(i,j,0); I(i,j,1) = -I(i,j,1); }
CImg.h:          xi = (int)x - (x>=0?0:1), nxi = xi + 1,
CImg.h:          yi = (int)y - (y>=0?0:1), nyi = yi + 1,
CImg.h:          dx = x - xi,
CImg.h:          dy = y - yi;
CImg.h:          if (xi>=ref.width()) xi = ref.width() - 1;
CImg.h:          if (nxi>=ref.width()) nxi = ref.width() - 1;
CImg.h:          if (yi>=ref.height()) yi = ref.height() - 1;
CImg.h:          if (nyi>=ref.height()) nyi = ref.height() - 1;
CImg.h:        return c<2?(float)pI->_linear_atXY(dx,dy,0,c):0;
CImg.h:  I(i,j,k,0) = -I(i,j,k,0); I(i,j,k,1) = -I(i,j,k,1); I(i,j,k,2) = -I(i,j,k,2); }
CImg.h:          xi = (int)x - (x>=0?0:1), nxi = xi + 1,
CImg.h:          yi = (int)y - (y>=0?0:1), nyi = yi + 1,
CImg.h:          zi = (int)z - (z>=0?0:1), nzi = zi + 1;
CImg.h:          dx = x - xi,
CImg.h:          dy = y - yi,
CImg.h:          dz = z - zi;
CImg.h:          if (xi>=ref.width()) xi = ref.width() - 1;
CImg.h:          if (nxi>=ref.width()) nxi = ref.width() - 1;
CImg.h:          if (yi>=ref.height()) yi = ref.height() - 1;
CImg.h:          if (nyi>=ref.height()) nyi = ref.height() - 1;
CImg.h:          if (zi>=ref.depth()) zi = ref.depth() - 1;
CImg.h:          if (nzi>=ref.depth()) nzi = ref.depth() - 1;
CImg.h:        return (float)pI->_linear_atXYZ(dx,dy,dz,c);
CImg.h:      ~_functor4d_streamline_expr() { mp->end(); delete mp; }
CImg.h:    //! Return a shared-memory image referencing a range of pixels of the image instance.
CImg.h:       \param x0 X-coordinate of the starting pixel.
CImg.h:       \param x1 X-coordinate of the ending pixel.
CImg.h:       \param y0 Y-coordinate.
CImg.h:       \param z0 Z-coordinate.
CImg.h:       \param c0 C-coordinate.
CImg.h:                                    "get_shared_points(): Invalid request of a shared-memory subset (%u->%u,%u,%u,%u).",
CImg.h:      return CImg<T>(_data + beg,x1 - x0 + 1,1,1,1,true);
CImg.h:    //! Return a shared-memory image referencing a range of pixels of the image instance \const.
CImg.h:                                    "get_shared_points(): Invalid request of a shared-memory subset (%u->%u,%u,%u,%u).",
CImg.h:      return CImg<T>(_data + beg,x1 - x0 + 1,1,1,1,true);
CImg.h:    //! Return a shared-memory image referencing a range of rows of the image instance.
CImg.h:       \param y0 Y-coordinate of the starting row.
CImg.h:       \param y1 Y-coordinate of the ending row.
CImg.h:       \param z0 Z-coordinate.
CImg.h:       \param c0 C-coordinate.
CImg.h:                                    "get_shared_rows(): Invalid request of a shared-memory subset "
CImg.h:                                    "(0->%u,%u->%u,%u,%u).",
CImg.h:                                    _width - 1,y0,y1,z0,c0);
CImg.h:      return CImg<T>(_data + beg,_width,y1 - y0 + 1,1,1,true);
CImg.h:    //! Return a shared-memory image referencing a range of rows of the image instance \const.
CImg.h:                                    "get_shared_rows(): Invalid request of a shared-memory subset "
CImg.h:                                    "(0->%u,%u->%u,%u,%u).",
CImg.h:                                    _width - 1,y0,y1,z0,c0);
CImg.h:      return CImg<T>(_data + beg,_width,y1 - y0 + 1,1,1,true);
CImg.h:    //! Return a shared-memory image referencing one row of the image instance.
CImg.h:       \param y0 Y-coordinate.
CImg.h:       \param z0 Z-coordinate.
CImg.h:       \param c0 C-coordinate.
CImg.h:    //! Return a shared-memory image referencing one row of the image instance \const.
CImg.h:       \param z0 Z-coordinate of the starting slice.
CImg.h:       \param z1 Z-coordinate of the ending slice.
CImg.h:       \param c0 C-coordinate.
CImg.h:                                    "get_shared_slices(): Invalid request of a shared-memory subset "
CImg.h:                                    "(0->%u,0->%u,%u->%u,%u).",
CImg.h:                                    _width - 1,_height - 1,z0,z1,c0);
CImg.h:      return CImg<T>(_data + beg,_width,_height,z1 - z0 + 1,1,true);
CImg.h:                                    "get_shared_slices(): Invalid request of a shared-memory subset "
CImg.h:                                    "(0->%u,0->%u,%u->%u,%u).",
CImg.h:                                    _width - 1,_height - 1,z0,z1,c0);
CImg.h:      return CImg<T>(_data + beg,_width,_height,z1 - z0 + 1,1,true);
CImg.h:    //! Return a shared-memory image referencing one slice of the image instance.
CImg.h:       \param z0 Z-coordinate.
CImg.h:       \param c0 C-coordinate.
CImg.h:    //! Return a shared-memory image referencing one slice of the image instance \const.
CImg.h:    //! Return a shared-memory image referencing a range of channels of the image instance.
CImg.h:       \param c0 C-coordinate of the starting channel.
CImg.h:       \param c1 C-coordinate of the ending channel.
CImg.h:                                    "get_shared_channels(): Invalid request of a shared-memory subset "
CImg.h:                                    "(0->%u,0->%u,0->%u,%u->%u).",
CImg.h:                                    _width - 1,_height - 1,_depth - 1,c0,c1);
CImg.h:      return CImg<T>(_data + beg,_width,_height,_depth,c1 - c0 + 1,true);
CImg.h:    //! Return a shared-memory image referencing a range of channels of the image instance \const.
CImg.h:                                    "get_shared_channels(): Invalid request of a shared-memory subset "
CImg.h:                                    "(0->%u,0->%u,0->%u,%u->%u).",
CImg.h:                                    _width - 1,_height - 1,_depth - 1,c0,c1);
CImg.h:      return CImg<T>(_data + beg,_width,_height,_depth,c1 - c0 + 1,true);
CImg.h:    //! Return a shared-memory image referencing one channel of the image instance.
CImg.h:       \param c0 C-coordinate.
CImg.h:    //! Return a shared-memory image referencing one channel of the image instance \const.
CImg.h:    //! Return a shared-memory version of the image instance.
CImg.h:    //! Return a shared-memory version of the image instance \const.
CImg.h:       - If \c nb==0, instance image is split into blocs of equal values along the specified axis.
CImg.h:       - If \c nb<=0, instance image is split into blocs of -\c nb pixel wide.
CImg.h:       - If \c nb>0, instance image is split into \c nb blocs.
CImg.h:    CImgList<T> get_split(const char axis, const int nb=-1) const {
CImg.h:        const unsigned int dp = (unsigned int)(nb?-nb:1);
CImg.h:            const unsigned int pe = _width - dp;
CImg.h:              get_crop(p,0,0,0,p + dp - 1,_height - 1,_depth - 1,_spectrum - 1).move_to(res[p/dp]);
CImg.h:            get_crop((res._width - 1)*dp,0,0,0,_width - 1,_height - 1,_depth - 1,_spectrum - 1).move_to(res.back());
CImg.h:            const unsigned int pe = _height - dp;
CImg.h:              get_crop(0,p,0,0,_width - 1,p + dp - 1,_depth - 1,_spectrum - 1).move_to(res[p/dp]);
CImg.h:            get_crop(0,(res._width - 1)*dp,0,0,_width - 1,_height - 1,_depth - 1,_spectrum - 1).move_to(res.back());
CImg.h:            const unsigned int pe = _depth - dp;
CImg.h:              get_crop(0,0,p,0,_width - 1,_height - 1,p + dp - 1,_spectrum - 1).move_to(res[p/dp]);
CImg.h:            get_crop(0,0,(res._width - 1)*dp,0,_width - 1,_height - 1,_depth - 1,_spectrum - 1).move_to(res.back());
CImg.h:            const unsigned int pe = _spectrum - dp;
CImg.h:              get_crop(0,0,0,p,_width - 1,_height - 1,_depth - 1,p + dp - 1).move_to(res[p/dp]);
CImg.h:            get_crop(0,0,0,(res._width - 1)*dp,_width - 1,_height - 1,_depth - 1,_spectrum - 1).move_to(res.back());
CImg.h:      } else if (nb>0) { // Split by number of (non-homogeneous) blocs
CImg.h:                                      "get_split(): Instance cannot be split along %c-axis into %u blocs.",
CImg.h:            cimg_forX(*this,p) if ((err-=nb)<=0) {
CImg.h:              get_crop(_p,0,0,0,p,_height - 1,_depth - 1,_spectrum - 1).move_to(res);
CImg.h:            cimg_forY(*this,p) if ((err-=nb)<=0) {
CImg.h:              get_crop(0,_p,0,0,_width - 1,p,_depth - 1,_spectrum - 1).move_to(res);
CImg.h:            cimg_forZ(*this,p) if ((err-=nb)<=0) {
CImg.h:              get_crop(0,0,_p,0,_width - 1,_height - 1,p,_spectrum - 1).move_to(res);
CImg.h:            cimg_forC(*this,p) if ((err-=nb)<=0) {
CImg.h:              get_crop(0,0,0,_p,_width - 1,_height - 1,_depth - 1,p).move_to(res);
CImg.h:            if ((*this)(i)!=current) { get_columns(i0,i - 1).move_to(res); i0 = i; current = (*this)(i); }
CImg.h:          get_columns(i0,width() - 1).move_to(res);
CImg.h:            if ((*this)(0,i)!=current) { get_rows(i0,i - 1).move_to(res); i0 = i; current = (*this)(0,i); }
CImg.h:          get_rows(i0,height() - 1).move_to(res);
CImg.h:            if ((*this)(0,0,i)!=current) { get_slices(i0,i - 1).move_to(res); i0 = i; current = (*this)(0,0,i); }
CImg.h:          get_slices(i0,depth() - 1).move_to(res);
CImg.h:            if ((*this)(0,0,0,i)!=current) { get_channels(i0,i - 1).move_to(res); i0 = i; current = (*this)(0,0,0,i); }
CImg.h:          get_channels(i0,spectrum() - 1).move_to(res);
CImg.h:              CImg<T>(_data + i0,1,(unsigned int)(i - i0)).move_to(res);
CImg.h:          CImg<T>(_data + i0,1,(unsigned int)(size() - i0)).move_to(res);
CImg.h:    //! Split image into a list of sub-images, according to a specified splitting value sequence and optionally axis.
CImg.h:            if (i>i0) { if (keep_values) get_columns(i0,i - 1).move_to(res); i0 = i; }
CImg.h:            if (i>i0) { get_columns(i0,i - 1).move_to(res); i0 = i; }
CImg.h:            if (i>i0) { if (keep_values) get_rows(i0,i - 1).move_to(res); i0 = i; }
CImg.h:            if (i>i0) { get_rows(i0,i - 1).move_to(res); i0 = i; }
CImg.h:            if (i>i0) { if (keep_values) get_slices(i0,i - 1).move_to(res); i0 = i; }
CImg.h:            if (i>i0) { get_slices(i0,i - 1).move_to(res); i0 = i; }
CImg.h:            if (i>i0) { if (keep_values) get_channels(i0,i - 1).move_to(res); i0 = i; }
CImg.h:            if (i>i0) { get_channels(i0,i - 1).move_to(res); i0 = i; }
CImg.h:              if (keep_values) CImg<T>(_data + i0,1,(unsigned int)(i - i0)).move_to(res);
CImg.h:            if (i>i0) { CImg<T>(_data + i0,1,(unsigned int)(i - i0)).move_to(res); i0 = i; }
CImg.h:              i-=j;
CImg.h:                if (i1>i0) get_columns(i0,i1 - 1).move_to(res);
CImg.h:                if (keep_values) get_columns(i1,i - 1).move_to(res);
CImg.h:          if (i0<_width) get_columns(i0,width() - 1).move_to(res);
CImg.h:              i-=j;
CImg.h:                if (i1>i0) get_rows(i0,i1 - 1).move_to(res);
CImg.h:                if (keep_values) get_rows(i1,i - 1).move_to(res);
CImg.h:          if (i0<_height) get_rows(i0,height() - 1).move_to(res);
CImg.h:              i-=j;
CImg.h:                if (i1>i0) get_slices(i0,i1 - 1).move_to(res);
CImg.h:                if (keep_values) get_slices(i1,i - 1).move_to(res);
CImg.h:          if (i0<_depth) get_slices(i0,depth() - 1).move_to(res);
CImg.h:              i-=j;
CImg.h:                if (i1>i0) get_channels(i0,i1 - 1).move_to(res);
CImg.h:                if (keep_values) get_channels(i1,i - 1).move_to(res);
CImg.h:          if (i0<_spectrum) get_channels(i0,spectrum() - 1).move_to(res);
CImg.h:              i-=j;
CImg.h:                if (i1>i0) CImg<T>(_data + i0,1,(unsigned int)(i1 - i0)).move_to(res);
CImg.h:                if (keep_values) CImg<T>(_data + i1,1,(unsigned int)(i - i1)).move_to(res);
CImg.h:          if (i0<siz) CImg<T>(_data + i0,1,(unsigned int)(siz - i0)).move_to(res);
CImg.h:    //---------------------------------------
CImg.h:    //---------------------------------------
CImg.h:       \param xcenter X-coordinate of the kernel center (~0U>>1 means 'centered').
CImg.h:       \param ycenter Y-coordinate of the kernel center (~0U>>1 means 'centered').
CImg.h:       \param zcenter Z-coordinate of the kernel center (~0U>>1 means 'centered').
CImg.h:       \param xstart Starting X-coordinate of the instance image.
CImg.h:       \param ystart Starting Y-coordinate of the instance image.
CImg.h:       \param zstart Starting Z-coordinate of the instance image.
CImg.h:       \param xend Ending X-coordinate of the instance image.
CImg.h:       \param yend Ending Y-coordinate of the instance image.
CImg.h:       \param zend Ending Z-coordinate of the instance image.
CImg.h:       \param xstride Stride along the X-axis.
CImg.h:       \param ystride Stride along the Y-axis.
CImg.h:       \param zstride Stride along the Z-axis.
CImg.h:       \param xdilation Dilation along the X-axis.
CImg.h:       \param ydilation Dilation along the Y-axis.
CImg.h:       \param zdilation Dilation along the Z-axis.
CImg.h:       - The correlation of the image instance \p *this by the kernel \p kernel is defined to be:
CImg.h:       res(x,y,z) = sum_{i,j,k} (*this)(\alpha_x\;x + \beta_x\;(i - c_x),\alpha_y\;y + \beta_y\;(j -
CImg.h:                    c_y),\alpha_z\;z + \beta_z\;(k - c_z))*kernel(i,j,k).
CImg.h:                                    "%s(): Invalid xyz-start/end arguments (start = (%d,%d,%d), end = (%d,%d,%d)).",
CImg.h:        _xcenter = xcenter==(int)(~0U>>1)?kernel.width()/2 - 1 + (kernel.width()%2):
CImg.h:        std::min(xcenter,kernel.width() - 1),
CImg.h:        _ycenter = ycenter==(int)(~0U>>1)?kernel.height()/2 - 1 + (kernel.height()%2):
CImg.h:        std::min(ycenter,kernel.height() - 1),
CImg.h:        _zcenter = zcenter==(int)(~0U>>1)?kernel.depth()/2 - 1 + (kernel.depth()%2):
CImg.h:        std::min(zcenter,kernel.depth() - 1);
CImg.h:            get_mirror('x').resize(kernel,-1);
CImg.h:          _xcenter = kernel.width() - 1 - _xcenter;
CImg.h:          _ycenter = kernel.height() - 1 - _ycenter;
CImg.h:          _zcenter = kernel.depth() - _zcenter - 1;
CImg.h:        } else { _kernel = kernel.get_shared(); _xdilation*=-1; _ydilation*=-1; _zdilation*=-1; }
CImg.h:        _xend = xend==(int)(~0U>>1)?width() - 1:xend,
CImg.h:        _yend = yend==(int)(~0U>>1)?height() - 1:yend,
CImg.h:        _zend = zend==(int)(~0U>>1)?depth() - 1:zend,
CImg.h:        res_width = _xend - xstart + 1,
CImg.h:        res_height = _yend - ystart + 1,
CImg.h:        w1 = w  - 1, h1 = h - 1, d1 = d - 1,
CImg.h:        _kernel.assign(_kernel.get_resize(M + 1 - (M%2),M + 1 - (M%2),_kernel._depth>1?M + 1 - (M%2):1,-100,
CImg.h:                  px = x - i_xdilation>0?x - i_xdilation:0, nx = x + i_xdilation<w1?x + i_xdilation:w1,
CImg.h:                  py = y - i_ydilation>0?y - i_ydilation:0, ny = y + i_ydilation<h1?y + i_ydilation:h1,
CImg.h:                  pz = z - i_zdilation>0?z - i_zdilation:0, nz = z + i_zdilation<d1?z + i_zdilation:d1;
CImg.h:                  px = x - i_xdilation>0?x - i_xdilation:0, nx = x + i_xdilation<w1?x + i_xdilation:w1,
CImg.h:                  py = y - i_ydilation>0?y - i_ydilation:0, ny = y + i_ydilation<h1?y + i_ydilation:h1,
CImg.h:                  pz = z - i_zdilation>0?z - i_zdilation:0, nz = z + i_zdilation<d1?z + i_zdilation:d1;
CImg.h:                    px = x - i_xdilation>0?x - i_xdilation:0, bx = px - i_xdilation>0?px - i_xdilation:0,
CImg.h:                    py = y - i_ydilation>0?y - i_ydilation:0, by = py - i_ydilation>0?py - i_ydilation:0,
CImg.h:                    px = x - i_xdilation>0?x - i_xdilation:0, bx = px - i_xdilation>0?px - i_xdilation:0,
CImg.h:                    py = y - i_ydilation>0?y - i_ydilation:0, by = py - i_ydilation>0?py - i_ydilation:0,
CImg.h:                    px = x - i_xdilation>0?x - i_xdilation:0, nx = x + i_xdilation<w1?x + i_xdilation:w1,
CImg.h:                    py = y - i_ydilation>0?y - i_ydilation:0, ny = y + i_ydilation<h1?y + i_ydilation:h1;
CImg.h:                    px = x - i_xdilation>0?x - i_xdilation:0, nx = x + i_xdilation<w1?x + i_xdilation:w1,
CImg.h:                    py = y - i_ydilation>0?y - i_ydilation:0, ny = y + i_ydilation<h1?y + i_ydilation:h1;
CImg.h:#define _cimg_correlate_x_int const int ix = xstart + i_xstride*x + i_xdilation*(p - _xcenter)
CImg.h:#define _cimg_correlate_y_int const int iy = ystart + i_ystride*y + i_ydilation*(q - _ycenter)
CImg.h:#define _cimg_correlate_z_int const int iz = zstart + i_zstride*z + i_zdilation*(r - _zcenter)
CImg.h:#define _cimg_correlate_x_float const float ix = xstart + xstride*x + _xdilation*(p - _xcenter)
CImg.h:#define _cimg_correlate_y_float const float iy = ystart + ystride*y + _ydilation*(q - _ycenter)
CImg.h:#define _cimg_correlate_z_float const float iz = zstart + zstride*z + _zdilation*(r - _zcenter)
CImg.h:#define _cimg_correlate_x_int_mirror const int mx = cimg::mod(ix,w2), nix = mx<w?mx:w2 - mx - 1
CImg.h:#define _cimg_correlate_y_int_mirror const int my = cimg::mod(iy,h2), niy = my<h?my:h2 - my - 1
CImg.h:#define _cimg_correlate_z_int_mirror const int mz = cimg::mod(iz,d2), niz = mz<d?mz:d2 - mz - 1
CImg.h:#define _cimg_correlate_x_float_mirror const float mx = cimg::mod(ix,w2), nix = mx<w?mx:w2 - mx - 1
CImg.h:#define _cimg_correlate_y_float_mirror const float my = cimg::mod(iy,h2), niy = my<h?my:h2 - my - 1
CImg.h:#define _cimg_correlate_z_float_mirror const float mz = cimg::mod(iz,d2), niz = mz<d?mz:d2 - mz - 1
CImg.h:            else if (interpolation_type) // Non-integer stride or dilation, linear interpolation
CImg.h:            else // Non-integer stride or dilation, nearest-neighbor interpolation
CImg.h:            else if (interpolation_type) // Non-integer stride or dilation, linear interpolation
CImg.h:            else // Non-integer stride or dilation, nearest-neighbor interpolation
CImg.h:       \param xcenter X-coordinate of the kernel center (~0U means 'centered').
CImg.h:       \param ycenter Y-coordinate of the kernel center (~0U means 'centered').
CImg.h:       \param zcenter Z-coordinate of the kernel center (~0U means 'centered').
CImg.h:       \param xstart Starting X-coordinate of the instance image.
CImg.h:       \param ystart Starting Y-coordinate of the instance image.
CImg.h:       \param zstart Starting Z-coordinate of the instance image.
CImg.h:       \param xend Ending X-coordinate of the instance image.
CImg.h:       \param yend Ending Y-coordinate of the instance image.
CImg.h:       \param zend Ending Z-coordinate of the instance image.
CImg.h:       \param xstride Stride along the X-axis.
CImg.h:       \param ystride Stride along the Y-axis.
CImg.h:       \param zstride Stride along the Z-axis.
CImg.h:       \param xdilation Dilation along the X-axis.
CImg.h:       \param ydilation Dilation along the Y-axis.
CImg.h:       \param zdilation Dilation along the Z-axis.
CImg.h:       - The convolution of the image instance \p *this by the kernel \p kernel is defined to be:
CImg.h:       res(x,y,z) = sum_{i,j,k} (*this)(\alpha_x\;x - \beta_x\;(i - c_x),\alpha_y\;y
CImg.h:                    - \beta_y\;(j - c_y),\alpha_z\;z - \beta_z\;(k - c_z))*kernel(i,j,k).
CImg.h:       \param axes Cumulation axes, as a C-string.
CImg.h:       \param is_real Do the erosion in real (a.k.a 'non-flat') mode (\c true) rather than binary mode (\c false).
CImg.h:        mx1 = kernel.width() - mx2 - 1, my1 = kernel.height() - my2 - 1, mz1 = kernel.depth() - mz2 - 1,
CImg.h:        mxe = width() - mx2, mye = height() - my2, mze = depth() - mz2,
CImg.h:                for (int zm = -mz1; zm<=mz2; ++zm)
CImg.h:                  for (int ym = -my1; ym<=my2; ++ym)
CImg.h:                    for (int xm = -mx1; xm<=mx2; ++xm) {
CImg.h:                      const Tt cval = (Tt)(img(x + xm,y + ym,z + zm) - mval);
CImg.h:            for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1 - 1 || x>=mxe)?++x:(x=mxe))) {
CImg.h:              for (int zm = -mz1; zm<=mz2; ++zm)
CImg.h:                for (int ym = -my1; ym<=my2; ++ym)
CImg.h:                  for (int xm = -mx1; xm<=mx2; ++xm) {
CImg.h:                    case 0 : cval = (Tt)(img.atXYZ(x + xm,y + ym,z + zm,0,(T)0) - mval); break;
CImg.h:                    case 1 : cval = (Tt)(img._atXYZ(x + xm,y + ym,z + zm) - mval); break;
CImg.h:                      cval = img(nx,ny,nz) - mval;
CImg.h:                        nx = tx<width()?tx:w2 - tx - 1,
CImg.h:                        ny = ty<height()?ty:h2 - ty - 1,
CImg.h:                        nz = tz<depth()?tz:d2 - tz - 1;
CImg.h:                      cval = img(nx,ny,nz) - mval;
CImg.h:                for (int zm = -mz1; zm<=mz2; ++zm)
CImg.h:                  for (int ym = -my1; ym<=my2; ++ym)
CImg.h:                    for (int xm = -mx1; xm<=mx2; ++xm)
CImg.h:            for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1 - 1 || x>=mxe)?++x:(x=mxe))) {
CImg.h:              for (int zm = -mz1; zm<=mz2; ++zm)
CImg.h:                for (int ym = -my1; ym<=my2; ++ym)
CImg.h:                  for (int xm = -mx1; xm<=mx2; ++xm) {
CImg.h:                          nx = tx<width()?tx:w2 - tx - 1,
CImg.h:                          ny = ty<height()?ty:h2 - ty - 1,
CImg.h:                          nz = tz<depth()?tz:d2 - tz - 1;
CImg.h:      if (sx>1 && _width>1) { // Along X-axis
CImg.h:        const int L = width(), off = 1, s = (int)sx, _s2 = s/2 + 1, _s1 = s - _s2, s1 = _s1>L?L:_s1, s2 = _s2>L?L:_s2;
CImg.h:          T *const ptrdb = buf._data, *ptrd = buf._data, *const ptrde = buf._data + L - 1;
CImg.h:          const T *const ptrsb = data(0,y,z,c), *ptrs = ptrsb, *const ptrse = ptrs + (ulongT)L*off - off;
CImg.h:          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
CImg.h:            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
CImg.h:            for (int p = L - s - 1; p>0; --p) {
CImg.h:                const T *nptrs = ptrs - off; cur = val;
CImg.h:                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval<cur) cur = nval; }
CImg.h:                nptrs-=off; const T nval = *nptrs; if (nval<cur) { cur = nval; is_first = true; } else is_first = false;
CImg.h:              } else { if (val<=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
CImg.h:            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
CImg.h:            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
CImg.h:              const T val = *ptrs; ptrs-=off; if (val<cur) cur = val;
CImg.h:            *(ptrd--) = cur;
CImg.h:            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
CImg.h:              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val<cur) cur = val; *(ptrd--) = cur;
CImg.h:      if (sy>1 && _height>1) { // Along Y-axis
CImg.h:        const int L = height(), off = width(), s = (int)sy, _s2 = s/2 + 1, _s1 = s - _s2, s1 = _s1>L?L:_s1,
CImg.h:          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
CImg.h:          const T *const ptrsb = data(x,0,z,c), *ptrs = ptrsb, *const ptrse = ptrs + (ulongT)L*off - off;
CImg.h:          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
CImg.h:            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
CImg.h:            for (int p = L - s - 1; p>0; --p) {
CImg.h:                const T *nptrs = ptrs - off; cur = val;
CImg.h:                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval<cur) cur = nval; }
CImg.h:                nptrs-=off; const T nval = *nptrs; if (nval<cur) { cur = nval; is_first = true; } else is_first = false;
CImg.h:              } else { if (val<=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
CImg.h:            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
CImg.h:            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
CImg.h:              const T val = *ptrs; ptrs-=off; if (val<cur) cur = val;
CImg.h:            *(ptrd--) = cur;
CImg.h:            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
CImg.h:              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val<cur) cur = val; *(ptrd--) = cur;
CImg.h:      if (sz>1 && _depth>1) { // Along Z-axis
CImg.h:        const int L = depth(), off = width()*height(), s = (int)sz, _s2 = s/2 + 1, _s1 = s - _s2, s1 = _s1>L?L:_s1,
CImg.h:          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
CImg.h:          const T *const ptrsb = data(x,y,0,c), *ptrs = ptrsb, *const ptrse = ptrs + (ulongT)L*off - off;
CImg.h:          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
CImg.h:            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
CImg.h:            for (int p = L - s - 1; p>0; --p) {
CImg.h:                const T *nptrs = ptrs - off; cur = val;
CImg.h:                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval<cur) cur = nval; }
CImg.h:                nptrs-=off; const T nval = *nptrs; if (nval<cur) { cur = nval; is_first = true; } else is_first = false;
CImg.h:              } else { if (val<=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
CImg.h:            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
CImg.h:            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
CImg.h:              const T val = *ptrs; ptrs-=off; if (val<cur) cur = val;
CImg.h:            *(ptrd--) = cur;
CImg.h:            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
CImg.h:              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val<cur) cur = val; *(ptrd--) = cur;
CImg.h:       \param is_real Do the dilation in real (a.k.a 'non-flat') mode (\c true) rather than binary mode (\c false).
CImg.h:        mx2 = kernel.width() - mx1 - 1, my2 = kernel.height() - my1 - 1, mz2 = kernel.depth() - mz1 - 1,
CImg.h:        mxe = width() - mx2, mye = height() - my2, mze = depth() - mz2,
CImg.h:                for (int zm = -mz1; zm<=mz2; ++zm)
CImg.h:                  for (int ym = -my1; ym<=my2; ++ym)
CImg.h:                    for (int xm = -mx1; xm<=mx2; ++xm) {
CImg.h:                      const t mval = K(mx2 - xm,my2 - ym,mz2 - zm);
CImg.h:            for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1 - 1 || x>=mxe)?++x:(x=mxe))) {
CImg.h:              for (int zm = -mz1; zm<=mz2; ++zm)
CImg.h:                for (int ym = -my1; ym<=my2; ++ym)
CImg.h:                  for (int xm = -mx1; xm<=mx2; ++xm) {
CImg.h:                    const t mval = K(mx2 - xm,my2 - ym,mz2 - zm);
CImg.h:                        nx = tx<width()?tx:w2 - tx - 1,
CImg.h:                        ny = ty<height()?ty:h2 - ty - 1,
CImg.h:                        nz = tz<depth()?tz:d2 - tz - 1;
CImg.h:                for (int zm = -mz1; zm<=mz2; ++zm)
CImg.h:                  for (int ym = -my1; ym<=my2; ++ym)
CImg.h:                    for (int xm = -mx1; xm<=mx2; ++xm)
CImg.h:                      if (K(mx2 - xm,my2 - ym,mz2 - zm)) {
CImg.h:            for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1 - 1 || x>=mxe)?++x:(x=mxe))) {
CImg.h:              for (int zm = -mz1; zm<=mz2; ++zm)
CImg.h:                for (int ym = -my1; ym<=my2; ++ym)
CImg.h:                  for (int xm = -mx1; xm<=mx2; ++xm) {
CImg.h:                    if (K(mx2 - xm,my2 - ym,mz2 - zm)) {
CImg.h:                          nx = tx<width()?tx:w2 - tx - 1,
CImg.h:                          ny = ty<height()?ty:h2 - ty - 1,
CImg.h:                          nz = tz<depth()?tz:d2 - tz - 1;
CImg.h:      if (sx>1 && _width>1) { // Along X-axis
CImg.h:        const int L = width(), off = 1, s = (int)sx, _s1 = s/2, _s2 = s - _s1, s1 = _s1>L?L:_s1, s2 = _s2>L?L:_s2;
CImg.h:          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
CImg.h:          const T *const ptrsb = data(0,y,z,c), *ptrs = ptrsb, *const ptrse = ptrs + (ulongT)L*off - off;
CImg.h:          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
CImg.h:            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
CImg.h:            for (int p = L - s - 1; p>0; --p) {
CImg.h:                const T *nptrs = ptrs - off; cur = val;
CImg.h:                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval>cur) cur = nval; }
CImg.h:                nptrs-=off; const T nval = *nptrs; if (nval>cur) { cur = nval; is_first = true; } else is_first = false;
CImg.h:              } else { if (val>=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
CImg.h:            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
CImg.h:            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
CImg.h:              const T val = *ptrs; ptrs-=off; if (val>cur) cur = val;
CImg.h:            *(ptrd--) = cur;
CImg.h:            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
CImg.h:              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val>cur) cur = val; *(ptrd--) = cur;
CImg.h:      if (sy>1 && _height>1) { // Along Y-axis
CImg.h:        const int L = height(), off = width(), s = (int)sy, _s1 = s/2, _s2 = s - _s1, s1 = _s1>L?L:_s1,
CImg.h:          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
CImg.h:          const T *const ptrsb = data(x,0,z,c), *ptrs = ptrsb, *const ptrse = ptrs + (ulongT)L*off - off;
CImg.h:          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
CImg.h:            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
CImg.h:            for (int p = L - s - 1; p>0; --p) {
CImg.h:                const T *nptrs = ptrs - off; cur = val;
CImg.h:                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval>cur) cur = nval; }
CImg.h:                nptrs-=off; const T nval = *nptrs; if (nval>cur) { cur = nval; is_first = true; } else is_first = false;
CImg.h:              } else { if (val>=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
CImg.h:            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
CImg.h:            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
CImg.h:              const T val = *ptrs; ptrs-=off; if (val>cur) cur = val;
CImg.h:            *(ptrd--) = cur;
CImg.h:            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
CImg.h:              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val>cur) cur = val; *(ptrd--) = cur;
CImg.h:      if (sz>1 && _depth>1) { // Along Z-axis
CImg.h:        const int L = depth(), off = width()*height(), s = (int)sz, _s1 = s/2, _s2 = s - _s1, s1 = _s1>L?L:_s1,
CImg.h:          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
CImg.h:          const T *const ptrsb = data(x,y,0,c), *ptrs = ptrsb, *const ptrse = ptrs + (ulongT)L*off - off;
CImg.h:          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
CImg.h:            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
CImg.h:            for (int p = L - s - 1; p>0; --p) {
CImg.h:                const T *nptrs = ptrs - off; cur = val;
CImg.h:                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval>cur) cur = nval; }
CImg.h:                nptrs-=off; const T nval = *nptrs; if (nval>cur) { cur = nval; is_first = true; } else is_first = false;
CImg.h:              } else { if (val>=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
CImg.h:            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
CImg.h:            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
CImg.h:              const T val = *ptrs; ptrs-=off; if (val>cur) cur = val;
CImg.h:            *(ptrd--) = cur;
CImg.h:            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
CImg.h:              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val>cur) cur = val; *(ptrd--) = cur;
CImg.h:       \param is_real Do the closing in real (a.k.a 'non-flat') mode (\c true) rather than binary mode (\c false).
CImg.h:      const int sx1 = (int)(sx - 1)/2, sy1 = (int)(sy - 1)/2, sz1 = (int)(sz - 1)/2;
CImg.h:      const int sx1 = (int)(sx - 1)/2, sy1 = (int)(sy - 1)/2, sz1 = (int)(sz - 1)/2;
CImg.h:       \param is_real Do the opening in real (a.k.a 'non-flat') mode (\c true) rather than binary mode (\c false).
CImg.h:      const int sx1 = (int)(sx - 1)/2, sy1 = (int)(sy - 1)/2, sz1 = (int)(sz - 1)/2;
CImg.h:      const int sx1 = (int)(sx - 1)/2, sy1 = (int)(sy - 1)/2, sz1 = (int)(sz - 1)/2;
CImg.h:       \param is_high_connectivity Boolean that choose between 4(false)- or 8(true)-connectivity
CImg.h:       in 2D case, and between 6(false)- or 26(true)-connectivity in 3D case.
CImg.h:       \note Non-zero values of the instance instance are propagated to zero-valued ones according to
CImg.h:          ns = labels(X,Y,Z) - 1; xs = seeds(ns,0); ys = seeds(ns,1); zs = seeds(ns,2); \
CImg.h:          d = cimg::sqr((float)x - xs) + cimg::sqr((float)y - ys) + cimg::sqr((float)z - zs); \
CImg.h:        px = x - 1; nx = x + 1;
CImg.h:        py = y - 1; ny = y + 1;
CImg.h:        pz = z - 1; nz = z + 1;
CImg.h:        px = x - 1; nx = x + 1;
CImg.h:        py = y - 1; ny = y + 1;
CImg.h:        pz = z - 1; nz = z + 1;
CImg.h:      (*this)(siz - 1,0) = (T)value;
CImg.h:      (*this)(siz - 1,1) = (T)x;
CImg.h:      (*this)(siz - 1,2) = (T)y;
CImg.h:      (*this)(siz - 1,3) = (T)z;
CImg.h:      for (unsigned int pos = siz - 1, par = 0; pos && value>(tv)(*this)(par=(pos + 1)/2 - 1,0); pos = par) {
CImg.h:      (*this)(0,0) = (*this)(--siz,0);
CImg.h:       \param order Order of the filter. Can be <tt>{ 0=smooth-filter | 1=1st-derivative | 2=2nd-derivative }</tt>.
CImg.h:    const double yc = *(ptrY++) = (double)(a0*xc + a1*xp - b1*yp - b2*yb); \
CImg.h:  if (boundary_conditions) { xn = xa = *(ptrX - off); yn = ya = (double)coefn*xn; } \
CImg.h:  for (int n = N - 1; n>=0; --n) { \
CImg.h:    const T xc = *(ptrX-=off); \
CImg.h:    const double yc = (double)(a2*xn + a3*xa - b1*yn - b2*ya); \
CImg.h:    *ptrX = (T)(*(--ptrY)+yc); \
CImg.h:                                    "('order' can be { 0=smoothing | 1=1st-derivative | 2=2nd-derivative }).",
CImg.h:        nsigma = sigma>=0?sigma:-sigma*(naxis=='x'?_width:
CImg.h:                            deriche(nnsigma,order,naxis,1).columns(border,w - 1 + border));
CImg.h:                            deriche(nnsigma,order,naxis,1).rows(border,h - 1 + border));
CImg.h:                            deriche(nnsigma,order,naxis,1).slices(border,d - 1 + border));
CImg.h:                            deriche(nnsigma,order,naxis,1).channels(border,d - 1 + border));
CImg.h:        ema = std::exp(-alpha),
CImg.h:        ema2 = std::exp(-2*alpha),
CImg.h:        b1 = -2*ema,
CImg.h:        const double k = (1-ema)*(1-ema)/(1 + 2*alpha*ema-ema2);
CImg.h:        a1 = k*(alpha - 1)*ema;
CImg.h:        a3 = -k*ema2;
CImg.h:        const double k = -(1-ema)*(1-ema)*(1-ema)/(2*(ema + 1)*ema);
CImg.h:        a2 = -a1;
CImg.h:          ea = std::exp(-alpha),
CImg.h:          k = -(ema2 - 1)/(2*alpha*ema),
CImg.h:          kn = (-2*(-1 + 3*ea - 3*ea*ea + ea*ea*ea)/(3*ea + 1 + 3*ea*ea + ea*ea*ea));
CImg.h:        a1 = -kn*(1 + k*alpha)*ema;
CImg.h:        a2 = kn*(1 - k*alpha)*ema;
CImg.h:        a3 = -kn*ema2;
CImg.h:       \param filter the coefficient of the filter in the following order [n,n - 1,n - 2,n - 3].
CImg.h:      double val[4] = { 0 };  // res[n,n - 1,n - 2,n - 3,..] or res[n,n + 1,n + 2,n + 3,..]
CImg.h:        scaleM = 1. / ( (1. + a1 - a2 + a3) * (1. - a1 - a2 - a3) * (1. + a2 + (a1 - a3) * a3) );
CImg.h:      M[0] = scaleM * (-a3 * a1 + 1. - a3 * a3 - a2);
CImg.h:      M[4] = -scaleM * (a2 - 1.) * (a2 + a3 * a1);
CImg.h:      M[5] = -scaleM * a3 * (a3 * a1 + a3 * a3 + a2 - 1.);
CImg.h:      M[6] = scaleM * (a3 * a1 + a2 + a1 * a1 - a2 * a2);
CImg.h:      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);
CImg.h:        const double iplus = (boundary_conditions?data[(N - 1)*off]:(T)0);
CImg.h:              uplus = iplus/(1. - a1 - a2 - a3), vplus = uplus/(1. - a1 - a2 - a3),
CImg.h:              unp  = val[1] - uplus, unp1 = val[2] - uplus, unp2 = val[3] - uplus;
CImg.h:            data -= off;
CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
CImg.h:            if (!pass) data += off; else data -= off;
CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
CImg.h:          if (!pass) data -= off;
CImg.h:            data -= off;
CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
CImg.h:          for (int n = pass; n<N - 1; ++n) {
CImg.h:              val[0] = 0.5f * (x[0] - x[2]);
CImg.h:              for (int k = 2; k>0; --k) x[k] = x[k - 1];
CImg.h:            } else { data-=off;}
CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
CImg.h:            data -= off;
CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
CImg.h:          for (int n = pass; n<N - 1; ++n) {
CImg.h:            if (!pass) { x[0] = *(data + off); val[0] = (x[1] - x[2]); }
CImg.h:            else { x[0] = *(data - off); val[0] = (x[2] - x[1]) * sum; }
CImg.h:            if (!pass) data += off; else data -= off;
CImg.h:            for (int k = 2; k>0; --k) x[k] = x[k - 1];
CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
CImg.h:            data -= off;
CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
CImg.h:          for (int n = pass; n<N - 1; ++n) {
CImg.h:            if (!pass) { x[0] = *(data + off); val[0] = (x[0] - 2*x[1] + x[2]); }
CImg.h:            else { x[0] = *(data - off); val[0] = 0.5f * (x[2] - x[0]) * sum; }
CImg.h:            if (!pass) data += off; else data -= off;
CImg.h:            for (int k = 2; k>0; --k) x[k] = x[k - 1];
CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
CImg.h:       IEEE Trans. Sig. Proc., vol. 50, pp. 2799-2805, 2002.
CImg.h:       (this is an improvement over Young-Van Vliet, Sig. Proc. 44, 1995)
CImg.h:       B. Triggs and M. Sdika. Boundary conditions for Young-van Vliet
CImg.h:       vol. 54, pp. 2365-2367, 2006.
CImg.h:                                    "('order' can be { 0=smoothing | 1=1st-derivative | 2=2nd-derivative }).",
CImg.h:        nsigma = sigma>=0?sigma:-sigma*(naxis=='x'?_width:
CImg.h:                            vanvliet(nnsigma,order,naxis,1).columns(border,w - 1 + border));
CImg.h:                            vanvliet(nnsigma,order,naxis,1).rows(border,h - 1 + border));
CImg.h:                            vanvliet(nnsigma,order,naxis,1).slices(border,d - 1 + border));
CImg.h:                            vanvliet(nnsigma,order,naxis,1).channels(border,d - 1 + border));
CImg.h:        q = (nnsigma<3.556?-0.2568 + 0.5784*nnsigma + 0.0561*nnsigma*nnsigma:2.5091 + 0.9804*(nnsigma - 3.556)),
CImg.h:        b1 = -q * (2 * m0 * m1 + m1sq + m2sq + (2 * m0 + 4 * m1) * q + 3 * qsq) / scale,
CImg.h:        b3 = -qsq * q / scale,
CImg.h:      filter[0] = B; filter[1] = -b1; filter[2] = -b2; filter[3] = -b3;
CImg.h:       \param sigma_x Standard deviation of the blur, along the X-axis.
CImg.h:       \param sigma_y Standard deviation of the blur, along the Y-axis.
CImg.h:       \param sigma_z Standard deviation of the blur, along the Z-axis.
CImg.h:       \param is_gaussian Tells if the blur uses a gaussian (\c true) or quasi-gaussian (\c false) kernel.
CImg.h:       - The blur is computed as a 0-order Vanvliet (gaussian) or Deriche filter (quasi-gaussian).
CImg.h:       - This is a recursive algorithm, not depending on the values of the standard deviations.
CImg.h:       \param is_gaussian Use a gaussian kernel (VanVliet) is set, a quasi-gaussian (Deriche) otherwise.
CImg.h:      const float nsigma = sigma>=0?sigma:-sigma*cimg::max(_width,_height,_depth)/100;
CImg.h:         Can be <tt>{ 0=nearest-neighbor | 1=linear | 2=Runge-Kutta }</tt>.
CImg.h:      const float namplitude = amplitude>=0?amplitude:-amplitude*cimg::max(_width,_height,_depth)/100;
CImg.h:                  ixx = Incc + Ipcc - 2*Iccc,
CImg.h:                  ixy = (Innc + Ippc - Inpc - Ipnc)/4,
CImg.h:                  ixz = (Incn + Ipcp - Incp - Ipcn)/4,
CImg.h:                  iyy = Icnc + Icpc - 2*Iccc,
CImg.h:                  iyz = (Icnn + Icpp - Icnp - Icpn)/4,
CImg.h:                  izz = Iccn + Iccp - 2*Iccc,
CImg.h:                if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
CImg.h:                  ixx = Inc + Ipc - 2*Icc,
CImg.h:                  ixy = (Inn + Ipp - Inp - Ipn)/4,
CImg.h:                  iyy = Icn + Icp - 2*Icc,
CImg.h:                if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
CImg.h:      } else { // LIC-based smoothing
CImg.h:        const int dx1 = width() - 1, dy1 = height() - 1, dz1 = depth() - 1;
CImg.h:                  n = 1e-5f + cimg::hypot(u,v,w),
CImg.h:                        const float coef = (float)std::exp(-l*l/fsigma2);
CImg.h:                        const float coef = (float)std::exp(-l*l/fsigma2);
CImg.h:                        const float coef = (float)std::exp(-l*l/fsigma2);
CImg.h:                n = std::max(1e-5f,cimg::hypot(u,v)),
CImg.h:                case 0 : { // Nearest-neighbor
CImg.h:                      const float coef = (float)std::exp(-l*l/fsigma2);
CImg.h:                      const float coef = (float)std::exp(-l*l/fsigma2);
CImg.h:                default : { // 2nd-order Runge-kutta interpolation
CImg.h:                      const float coef = (float)std::exp(-l*l/fsigma2);
CImg.h:    //! Blur image anisotropically, in an edge-preserving way.
CImg.h:         Can be <tt>{ 0=nearest-neighbor | 1=linear | 2=Runge-Kutta }</tt>.
CImg.h:      const float nalpha = alpha>=0?alpha:-alpha*cimg::max(_width,_height,_depth)/100;
CImg.h:      const float nsigma = sigma>=0?sigma:-sigma*cimg::max(_width,_height,_depth)/100;
CImg.h:    //! Blur image anisotropically, in an edge-preserving way \newinstance.
CImg.h:       \param sigma_x Amount of blur along the X-axis.
CImg.h:       \param sigma_y Amount of blur along the Y-axis.
CImg.h:       \param sigma_z Amount of blur along the Z-axis.
CImg.h:       \param sampling_x Amount of downsampling along the X-axis used for the approximation.
CImg.h:       \param sampling_y Amount of downsampling along the Y-axis used for the approximation.
CImg.h:       \param sampling_z Amount of downsampling along the Z-axis used for the approximation.
CImg.h:        edge_delta = (float)(edge_max - edge_min),
CImg.h:        _sigma_x = sigma_x>=0?sigma_x:-sigma_x*_width/100,
CImg.h:        _sigma_y = sigma_y>=0?sigma_y:-sigma_y*_height/100,
CImg.h:        _sigma_z = sigma_z>=0?sigma_z:-sigma_z*_depth/100,
CImg.h:        _sigma_r = sigma_r>=0?sigma_r:-sigma_r*edge_delta/100,
CImg.h:        bx = (unsigned int)((_width  - 1)/_sampling_x + 1 + 2*padding_x),
CImg.h:        by = (unsigned int)((_height - 1)/_sampling_y + 1 + 2*padding_y),
CImg.h:        bz = (unsigned int)((_depth  - 1)/_sampling_z + 1 + 2*padding_z),
CImg.h:                R = (int)cimg::round((edge - edge_min)/_sampling_r) + padding_r;
CImg.h:                R = (edge - edge_min)/_sampling_r + padding_r;
CImg.h:                R = (int)cimg::round((edge - edge_min)/_sampling_r) + padding_r;
CImg.h:                R = (edge - edge_min)/_sampling_r + padding_r;
CImg.h:       \param sigma_s Amount of blur along the XYZ-axes.
CImg.h:       \param sampling_s Amount of downsampling along the XYZ-axes used for the approximation. Defaults to sigma_s.
CImg.h:      const float _sigma_s = sigma_s>=0?sigma_s:-sigma_s*cimg::max(_width,_height,_depth)/100;
CImg.h:        const int w2 = (int)(boxsize - 1)/2;
CImg.h:        const double frac = (boxsize - winsize)/2.;
CImg.h:          for (int x = -w2; x<=w2; ++x) {
CImg.h:            prev = __cimg_blur_box_apply(ptr,N,off,nboundary_conditions,-w2 - 1),
CImg.h:          for (int x = 0; x < N - 1; ++x) {
CImg.h:            sum-=prev;
CImg.h:          ptr[(N - 1)*off] = (T)(sum2/boxsize);
CImg.h:          p = __cimg_blur_box_apply(ptr,N,off,nboundary_conditions,-1),
CImg.h:        for (int x = 0; x<N - 1; ++x) {
CImg.h:          ptr[x*off] = (T)((n-p)/2.);
CImg.h:        ptr[(N - 1)*off] = (T)((n-p)/2.);
CImg.h:          p = __cimg_blur_box_apply(ptr,N,off,nboundary_conditions,-1),
CImg.h:        for (int x = 0; x<N - 1; ++x) {
CImg.h:          ptr[x*off] = (T)(n - 2*c + p);
CImg.h:        ptr[(N - 1)*off] = (T)(n - 2*c + p);
CImg.h:        const int nx = x<0?0:x>=N?N - 1:x;
CImg.h:          nx = tx<N?tx:N2 - tx - 1;
CImg.h:      const float nboxsize = boxsize>=0?boxsize:-boxsize*
CImg.h:       \param boxsize_x Size of the box window, along the X-axis (can be subpixel).
CImg.h:       \param boxsize_y Size of the box window, along the Y-axis (can be subpixel).
CImg.h:       \param boxsize_z Size of the box window, along the Z-axis (can be subpixel).
CImg.h:       - This is a recursive algorithm, not depending on the values of the box kernel size.
CImg.h:      const float nboxsize = boxsize>=0?boxsize:-boxsize*cimg::max(_width,_height,_depth)/100;
CImg.h:      const int _radius = radius>=0?(int)radius:(int)(-radius*cimg::max(_width,_height,_depth)/100);
CImg.h:        _regularization = -regularization*(edge_max - edge_min)/100;
CImg.h:        cov_Ip = get_mul(guide).blur_box(psize,true)-=mean_p.get_mul(mean_I),
CImg.h:        var_I = guide.get_sqr().blur_box(psize,true)-=mean_I.get_sqr(),
CImg.h:        &b = mean_p-=a.get_mul(mean_I);
CImg.h:    //! Blur image using patch-based space.
CImg.h:       \param sigma_s Amount of blur along the XYZ-axes.
CImg.h:    //! Blur image using patch-based space \newinstance.
CImg.h:        const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1, \
CImg.h:          if (cimg::abs(_guide(x,y,z,0) - _guide(p,q,r,0))<sigma_r3) { \
CImg.h:            pQ = Q._data; cimg_for(P,_pP,tfloat) { const tfloat dI = *_pP - *(pQ++); distance2+=dI*dI; } \
CImg.h:            const tfloat dx = (tfloat)p - x, dy = (tfloat)q - y, dz = (tfloat)r - z, \
CImg.h:        if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,z,c)/=(Tfloat)sum_weights; \
CImg.h:        const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1, \
CImg.h:          pQ = Q._data; cimg_for(P,_pP,tfloat) { const tfloat dI = *_pP - *(pQ++); distance2+=dI*dI; } \
CImg.h:          const tfloat dx = (tfloat)p - x, dy = (tfloat)q - y, dz = (tfloat)r - z, \
CImg.h:            alldist = distance2 + (dx*dx + dy*dy + dz*dz)/sigma_s2, weight = std::exp(-alldist); \
CImg.h:        if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,z,c)/=(Tfloat)sum_weights; \
CImg.h:          const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; \
CImg.h:            if (cimg::abs(_guide(x,y,0,0) - _guide(p,q,0,0))<sigma_r3) { \
CImg.h:              pQ = Q._data; cimg_for(P,_pP,tfloat) { const tfloat dI = *_pP - *(pQ++); distance2+=dI*dI; } \
CImg.h:              const tfloat dx = (tfloat)p - x, dy = (tfloat)q - y, \
CImg.h:          if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,c)/=(Tfloat)sum_weights; \
CImg.h:          const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; \
CImg.h:            pQ = Q._data; cimg_for(P,_pP,tfloat) { const tfloat dI = *_pP - *(pQ++); distance2+=dI*dI; } \
CImg.h:            const tfloat dx = (tfloat)p - x, dy = (tfloat)q - y, \
CImg.h:              alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = std::exp(-alldist); \
CImg.h:          if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,c)/=(Tfloat)sum_weights; \
CImg.h:        guide_delta = (float)(guide_max - guide_min),
CImg.h:        _sigma_s = sigma_s>=0?sigma_s:-sigma_s*cimg::max(_width,_height,_depth)/100,
CImg.h:        _sigma_r = sigma_r>=0?sigma_r:-sigma_r*guide_delta/100,
CImg.h:      const int rsize2 = (int)lookup_size/2, rsize1 = (int)lookup_size - rsize2 - 1;
CImg.h:          const int psize2 = (int)patch_size/2, psize1 = (int)patch_size - psize2 - 1;
CImg.h:              P = _guide.get_crop(x - psize1,y - psize1,z - psize1,x + psize2,y + psize2,z + psize2,true);
CImg.h:              const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1,
CImg.h:                if (cimg::abs(_guide(x,y,z,0) - _guide(p,q,r,0))<sigma_r3) {
CImg.h:                  (Q = _guide.get_crop(p - psize1,q - psize1,r - psize1,p + psize2,q + psize2,r + psize2,true))-=P;
CImg.h:                    dx = (tfloat)x - p, dy = (tfloat)y - q, dz = (tfloat)z - r,
CImg.h:              if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,z,c)/=(Tfloat)sum_weights;
CImg.h:              P = _guide.get_crop(x - psize1,y - psize1,z - psize1,x + psize2,y + psize2,z + psize2,true);
CImg.h:              const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1,
CImg.h:                (Q = _guide.get_crop(p - psize1,q - psize1,r - psize1,p + psize2,q + psize2,r + psize2,true))-=P;
CImg.h:                  dx = (tfloat)x - p, dy = (tfloat)y - q, dz = (tfloat)z - r,
CImg.h:                  weight = std::exp(-distance2);
CImg.h:              if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,z,c)/=(Tfloat)sum_weights;
CImg.h:          const int psize2 = (int)patch_size/2, psize1 = (int)patch_size - psize2 - 1;
CImg.h:              P = _guide.get_crop(x - psize1,y - psize1,x + psize2,y + psize2,true);
CImg.h:              const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2;
CImg.h:                if (cimg::abs(_guide(x,y,0) - _guide(p,q,0))<sigma_r3) {
CImg.h:                  (Q = _guide.get_crop(p - psize1,q - psize1,p + psize2,q + psize2,true))-=P;
CImg.h:                    dx = (tfloat)x - p, dy = (tfloat)y - q,
CImg.h:              if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,c)/=(Tfloat)sum_weights;
CImg.h:              P = _guide.get_crop(x - psize1,y - psize1,x + psize2,y + psize2,true);
CImg.h:              const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2;
CImg.h:                (Q = _guide.get_crop(p - psize1,q - psize1,p + psize2,q + psize2,true))-=P;
CImg.h:                  dx = (tfloat)x - p, dy = (tfloat)y - q,
CImg.h:                  weight = std::exp(-distance2);
CImg.h:              if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,c)/=(Tfloat)sum_weights;
CImg.h:    //! Blur image using patch-based space \simplification.
CImg.h:    //! Blur image using patch-based space \simplification \newinstance.
CImg.h:      const int hr = (int)n/2, hl = n - hr - 1;
CImg.h:              x0 = x - hl, y0 = y - hl, z0 = z - hl, x1 = x + hr, y1 = y + hr, z1 = z + hr,
CImg.h:              nx1 = x1>=width()?width() - 1:x1, ny1 = y1>=height()?height() - 1:y1, nz1 = z1>=depth()?depth() - 1:z1;
CImg.h:              if (cimg::abs((*this)(p,q,r,c) - val0)<=threshold) { *(_ptrd++) = (*this)(p,q,r,c); ++nb_values; }
CImg.h:            res(x,y,z,c) = nb_values?values.get_shared_points(0,nb_values - 1).median():(*this)(x,y,z,c);
CImg.h:              x0 = x - hl, y0 = y - hl, z0 = z - hl, x1 = x + hr, y1 = y + hr, z1 = z + hr,
CImg.h:              nx1 = x1>=width()?width() - 1:x1, ny1 = y1>=height()?height() - 1:y1, nz1 = z1>=depth()?depth() - 1:z1;
CImg.h:              x0 = x - hl, y0 = y - hl, x1 = x + hr, y1 = y + hr,
CImg.h:                                        nx1 = x1>=width()?width() - 1:x1, ny1 = y1>=height()?height() - 1:y1;
CImg.h:              if (cimg::abs((*this)(p,q,c) - val0)<=threshold) { *(_ptrd++) = (*this)(p,q,c); ++nb_values; }
CImg.h:            res(x,y,c) = nb_values?values.get_shared_points(0,nb_values - 1).median():(*this)(x,y,c);
CImg.h:            w1 = width() - 1, h1 = height() - 1,
CImg.h:            w2 = width() - 2, h2 = height() - 2,
CImg.h:            w3 = width() - 3, h3 = height() - 3,
CImg.h:            w4 = width() - 4, h4 = height() - 4;
CImg.h:                res(x,y,c) = get_crop(std::max(0,x - 1),std::max(0,y - 1),0,c,
CImg.h:                res(x,y,c) = get_crop(std::max(0,x - 2),std::max(0,y - 2),0,c,
CImg.h:                res(x,y,c) = get_crop(std::max(0,x - 3),std::max(0,y - 3),0,c,
CImg.h:                x0 = x - hl, y0 = y - hl, x1 = x + hr, y1 = y + hr,
CImg.h:                                          nx1 = x1>=width()?width() - 1:x1, ny1 = y1>=height()?height() - 1:y1;
CImg.h:              *(ptrG3++) = 1 - (Tfloat)std::pow(1 + val[0] + val[1] + val[2],-(Tfloat)nedge);
CImg.h:                ixx = Incc + Ipcc - 2*Iccc,
CImg.h:                ixy = (Innc + Ippc - Inpc - Ipnc)/4,
CImg.h:                ixz = (Incn + Ipcp - Incp - Ipcn)/4,
CImg.h:                iyy = Icnc + Icpc - 2*Iccc,
CImg.h:                iyz = (Icnn + Icpp - Icnp - Icpn)/4,
CImg.h:                izz = Iccn + Iccp - 2*Iccc,
CImg.h:                ixf = Incc - Iccc,
CImg.h:                ixb = Iccc - Ipcc,
CImg.h:                iyf = Icnc - Iccc,
CImg.h:                iyb = Iccc - Icpc,
CImg.h:                izf = Iccn - Iccc,
CImg.h:                izb = Iccc - Iccp,
CImg.h:                veloc = -amp*cimg::sign(itt)*cimg::abs(it);
CImg.h:              if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
CImg.h:              const Tfloat veloc = -Ipcc - Incc - Icpc - Icnc - Iccp - Iccn + 6*Iccc;
CImg.h:              if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
CImg.h:              *(ptrG2++) = 1 - (Tfloat)std::pow(1 + val[0] + val[1],-(Tfloat)nedge);
CImg.h:                ixx = Inc + Ipc - 2*Icc,
CImg.h:                ixy = (Inn + Ipp - Inp - Ipn)/4,
CImg.h:                iyy = Icn + Icp - 2*Icc,
CImg.h:                ixf = Inc - Icc,
CImg.h:                ixb = Icc - Ipc,
CImg.h:                iyf = Icn - Icc,
CImg.h:                iyb = Icc - Icp,
CImg.h:                veloc = -amp*cimg::sign(itt)*cimg::abs(it);
CImg.h:              if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
CImg.h:              const Tfloat veloc = -Ipc - Inc - Icp - Icn + 4*Icc;
CImg.h:              if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
CImg.h:       \param axes Axes considered for the gradient computation, as a C-string (e.g "xy").
CImg.h:       - -1 = Backward finite differences
CImg.h:       - 0 = Centered finite differences (default)
CImg.h:       - 1 = Forward finite differences
CImg.h:       - 2 = Using Sobel kernels
CImg.h:       - 3 = Using rotation invariant kernels
CImg.h:       - 4 = Using Deriche recursive filter.
CImg.h:       - 5 = Using Van Vliet recursive filter.
CImg.h:        case -1 : { // Backward finite differences
CImg.h:              grad[pos] = (Tfloat)_data[pos] - _data[pos - off];
CImg.h:            if ((axis=='x' && x==width() - 1) || (axis=='y' && y==height() - 1) || (axis=='z' && z==depth() - 1))
CImg.h:              grad[pos] = (Tfloat)_data[pos + off] - _data[pos];
CImg.h:          if (axis=='x') // X-axis
CImg.h:              cimg_for3x3(*this,x,y,z,c,I,Tfloat) grad(x,y,z,c) = - Ipp + Inp - 2*Ipc + 2*Inc - Ipn + Inn;
CImg.h:          else // Y-axis
CImg.h:              cimg_for3x3(*this,x,y,z,c,I,Tfloat) grad(x,y,z,c) = - Ipp - 2*Icp - Inp + Ipn + 2*Icn + Inn;
CImg.h:          const Tfloat a = (Tfloat)(0.25f*(2 - std::sqrt(2.f))), b = (Tfloat)(0.5f*(std::sqrt(2.f) - 1));
CImg.h:          if (axis=='x') // X-axis
CImg.h:              cimg_for3x3(*this,x,y,z,c,I,Tfloat) grad(x,y,z,c) = -a*Ipp - b*Ipc - a*Ipn + a*Inp + b*Inc + a*Inn;
CImg.h:          else // Y-axis
CImg.h:              cimg_for3x3(*this,x,y,z,c,I,Tfloat) grad(x,y,z,c) = -a*Ipp - b*Icp - a*Inp + a*Ipn + b*Icn + a*Inn;
CImg.h:              grad[pos] = ((Tfloat)_data[pos + off] - _data[pos])/2;
CImg.h:            else if ((axis=='x' && x==width() - 1) || (axis=='y' && y==height() - 1) || (axis=='z' && z==depth() - 1))
CImg.h:              grad[pos] = ((Tfloat)_data[pos] - _data[pos - off])/2;
CImg.h:              grad[pos] = ((Tfloat)_data[pos + off] - _data[pos - off])/2;
CImg.h:       \param axes Axes considered for the hessian computation, as a C-string (e.g "xy").
CImg.h:              hess[pos] = (Tfloat)_data[pos + off] - _data[pos];
CImg.h:            else if ((axis1=='x' && x==width() - 1) ||
CImg.h:                     (axis1=='y' && y==height() - 1) ||
CImg.h:                     (axis1=='z' && z==depth() - 1))
CImg.h:              hess[pos] = (Tfloat)_data[pos - off] - _data[pos];
CImg.h:              hess[pos] = (Tfloat)_data[pos + off] + _data[pos - off] - 2*_data[pos];
CImg.h:            cimg_for3x3(*this,x,y,z,c,I,Tfloat) hess(x,y,z,c) = (Inn + Ipp - Inp - Ipn)/4;
CImg.h:            cimg_for3x3x3(*this,x,y,z,c,I,Tfloat) hess(x,y,z,c) = (Incn + Ipcp - Incp - Ipcn)/4;
CImg.h:            cimg_for3x3x3(*this,x,y,z,c,I,Tfloat) hess(x,y,z,c) = (Icnn + Icpp - Icnp - Icpn)/4;
CImg.h:          cimg_for3x3x3(*this,x,y,z,c,I,Tfloat) *(ptrd++) = Incc + Ipcc + Icnc + Icpc + Iccn + Iccp - 6*Iccc;
CImg.h:          cimg_for3x3(*this,x,y,0,c,I,Tfloat) *(ptrd++) = Inc + Ipc + Icn + Icp - 4*Icc;
CImg.h:          cimg_for3x3(*this,x,y,0,c,I,Tfloat) *(ptrd++) = Inc + Ipc - 2*Icc;
CImg.h:       \param is_fwbw_scheme scheme. Can be <tt>{ false=centered | true=forward-backward }</tt>
CImg.h:                ix = (Incc - Ipcc)/2,
CImg.h:                iy = (Icnc - Icpc)/2,
CImg.h:                iz = (Iccn - Iccp)/2;
CImg.h:                ixf = Incc - Iccc, ixb = Iccc - Ipcc, ixc = (Incc - Ipcc)/2,
CImg.h:                iyf = Icnc - Iccc, iyb = Iccc - Icpc, iyc = (Icnc - Icpc)/2,
CImg.h:                izf = Iccn - Iccc, izb = Iccc - Iccp, izc = (Iccn - Iccp)/2;
CImg.h:                ix = (Inc - Ipc)/2,
CImg.h:                iy = (Icn - Icp)/2;
CImg.h:                ixf = Inc - Icc, ixb = Icc - Ipc, ixc = (Inc - Ipc)/2,
CImg.h:                iyf = Icn - Icc, iyb = Icc - Icp, iyc = (Icn - Icp)/2;
CImg.h:    //! Compute field of diffusion tensors for edge-preserving smoothing.
CImg.h:        nsharpness = std::max(sharpness,1e-5f),
CImg.h:        power2 = power1/(1e-7f + 1 - anisotropy);
CImg.h:              n1 = (float)std::pow(1 + l1 + l2 + l3,-power1),
CImg.h:              n2 = (float)std::pow(1 + l1 + l2 + l3,-power2);
CImg.h:              n1 = (float)std::pow(1 + l1 + l2,-power1),
CImg.h:              n2 = (float)std::pow(1 + l1 + l2,-power2);
CImg.h:    //! Compute field of diffusion tensors for edge-preserving smoothing \newinstance.
CImg.h:       \param is_backward If false, match I2(X + U(X)) = I1(X), else match I2(X) = I1(X - U(X)).
CImg.h:      const float _precision = (float)std::pow(10.,-(double)precision);
CImg.h:      const float sdelta = sm==sM?1:(sM - sm), tdelta = tm==tM?1:(tM - tm);
CImg.h:      for (int scale = (int)_nb_scales - 1; scale>=0; --scale) {
CImg.h:          I1 = (source.get_resize(sw,sh,sd,-100,2)-=sm)/=sdelta,
CImg.h:          I2 = (get_resize(I1,2)-=tm)/=tdelta;
CImg.h:        if (guide._spectrum>constraint) guide.get_resize(I2._width,I2._height,I2._depth,-100,1).move_to(V);
CImg.h:        if (U) (U*=1.5f).resize(I2._width,I2._height,I2._depth,-100,3);
CImg.h:            guide.get_shared_channels(0,is_3d?2:1).get_resize(I2._width,I2._height,I2._depth,-100,2).move_to(U);
CImg.h:                  _p1y = y?y - 1:0, _n1y = y<U.height() - 1?y + 1:y,
CImg.h:                  _p1z = z?z - 1:0, _n1z = z<U.depth() - 1?z + 1:z;
CImg.h:                    X = is_backward?x - U(x,y,z,0):x + U(x,y,z,0),
CImg.h:                    Y = is_backward?y - U(x,y,z,1):y + U(x,y,z,1),
CImg.h:                    Z = is_backward?z - U(x,y,z,2):z + U(x,y,z,2);
CImg.h:                  if (is_backward) cimg_forC(I2,c) delta_I+=(float)(I1._linear_atXYZ(X,Y,Z,c) - I2(x,y,z,c));
CImg.h:                  else cimg_forC(I2,c) delta_I+=(float)(I1(x,y,z,c) - I2._linear_atXYZ(X,Y,Z,c));
CImg.h:                      Ux = 0.5f*(U(_n1x,y,z,c) - U(_p1x,y,z,c)),
CImg.h:                      Uy = 0.5f*(U(x,_n1y,z,c) - U(x,_p1y,z,c)),
CImg.h:                      Uz = 0.5f*(U(x,y,_n1z,c) - U(x,y,_p1z,c)),
CImg.h:                    bound = (float)x - _width; if (U(x,y,z,0)<=bound) U(x,y,z,0) = bound;
CImg.h:                    bound = (float)y - _height; if (U(x,y,z,1)<=bound) U(x,y,z,1) = bound;
CImg.h:                    bound = (float)z - _depth; if (U(x,y,z,2)<=bound) U(x,y,z,2) = bound;
CImg.h:                    if (U(x,y,z,0)<-x) U(x,y,z,0) = -(float)x;
CImg.h:                    if (U(x,y,z,1)<-y) U(x,y,z,1) = -(float)y;
CImg.h:                    if (U(x,y,z,2)<-z) U(x,y,z,2) = -(float)z;
CImg.h:                    bound = (float)_width - x; if (U(x,y,z,0)>=bound) U(x,y,z,0) = bound;
CImg.h:                    bound = (float)_height - y; if (U(x,y,z,1)>=bound) U(x,y,z,1) = bound;
CImg.h:                    bound = (float)_depth - z; if (U(x,y,z,2)>=bound) U(x,y,z,2) = bound;
CImg.h:              const float nsmoothness = -smoothness;
CImg.h:                  _p1y = y?y - 1:0, _n1y = y<U.height() - 1?y + 1:y,
CImg.h:                  _p1z = z?z - 1:0, _n1z = z<U.depth() - 1?z + 1:z;
CImg.h:                    X = is_backward?x - U(x,y,z,0):x + U(x,y,z,0),
CImg.h:                    Y = is_backward?y - U(x,y,z,1):y + U(x,y,z,1),
CImg.h:                    Z = is_backward?z - U(x,y,z,2):z + U(x,y,z,2);
CImg.h:                  if (is_backward) cimg_forC(I2,c) delta_I+=(float)(I1._linear_atXYZ(X,Y,Z,c) - I2(x,y,z,c));
CImg.h:                  else cimg_forC(I2,c) delta_I+=(float)(I1(x,y,z,c) - I2._linear_atXYZ(X,Y,Z,c));
CImg.h:                      Ux = 0.5f*(U(_n1x,y,z,c) - U(_p1x,y,z,c)),
CImg.h:                      Uy = 0.5f*(U(x,_n1y,z,c) - U(x,_p1y,z,c)),
CImg.h:                      Uz = 0.5f*(U(x,y,_n1z,c) - U(x,y,_p1z,c)),
CImg.h:                      N3 = 1e-5f + N2*N,
CImg.h:                      coef_a = (1 - Ux*Ux/N2)/N,
CImg.h:                      coef_b = -2*Ux*Uy/N3,
CImg.h:                      coef_c = -2*Ux*Uz/N3,
CImg.h:                      coef_d = (1 - Uy*Uy/N2)/N,
CImg.h:                      coef_e = -2*Uy*Uz/N3,
CImg.h:                      coef_f = (1 - Uz*Uz/N2)/N,
CImg.h:                      Uxy = 0.25f*(U(_n1x,_n1y,z,c) + U(_p1x,_p1y,z,c) - U(_n1x,_p1y,z,c) - U(_n1x,_p1y,z,c)),
CImg.h:                      Uxz = 0.25f*(U(_n1x,y,_n1z,c) + U(_p1x,y,_p1z,c) - U(_n1x,y,_p1z,c) - U(_n1x,y,_p1z,c)),
CImg.h:                      Uyz = 0.25f*(U(x,_n1y,_n1z,c) + U(x,_p1y,_p1z,c) - U(x,_n1y,_p1z,c) - U(x,_n1y,_p1z,c));
CImg.h:                    bound = (float)x - _width; if (U(x,y,z,0)<=bound) U(x,y,z,0) = bound;
CImg.h:                    bound = (float)y - _height; if (U(x,y,z,1)<=bound) U(x,y,z,1) = bound;
CImg.h:                    bound = (float)z - _depth; if (U(x,y,z,2)<=bound) U(x,y,z,2) = bound;
CImg.h:                    if (U(x,y,z,0)<-x) U(x,y,z,0) = -(float)x;
CImg.h:                    if (U(x,y,z,1)<-y) U(x,y,z,1) = -(float)y;
CImg.h:                    if (U(x,y,z,2)<-z) U(x,y,z,2) = -(float)z;
CImg.h:                    bound = (float)_width - x; if (U(x,y,z,0)>=bound) U(x,y,z,0) = bound;
CImg.h:                    bound = (float)_height - y; if (U(x,y,z,1)>=bound) U(x,y,z,1) = bound;
CImg.h:                    bound = (float)_depth - z; if (U(x,y,z,2)>=bound) U(x,y,z,2) = bound;
CImg.h:                const int _p1y = y?y - 1:0, _n1y = y<U.height() - 1?y + 1:y;
CImg.h:                    X = is_backward?x - U(x,y,0):x + U(x,y,0),
CImg.h:                    Y = is_backward?y - U(x,y,1):y + U(x,y,1);
CImg.h:                  if (is_backward) cimg_forC(I2,c) delta_I+=(float)(I1._linear_atXY(X,Y,c) - I2(x,y,c));
CImg.h:                  else cimg_forC(I2,c) delta_I+=(float)(I1(x,y,c) - I2._linear_atXY(X,Y,c));
CImg.h:                      Ux = 0.5f*(U(_n1x,y,c) - U(_p1x,y,c)),
CImg.h:                      Uy = 0.5f*(U(x,_n1y,c) - U(x,_p1y,c)),
CImg.h:                    bound = (float)x - _width; if (U(x,y,0)<=bound) U(x,y,0) = bound;
CImg.h:                    bound = (float)y - _height; if (U(x,y,1)<=bound) U(x,y,1) = bound;
CImg.h:                    if (U(x,y,0)<-x) U(x,y,0) = -(float)x;
CImg.h:                    if (U(x,y,1)<-y) U(x,y,1) = -(float)y;
CImg.h:                    bound = (float)_width - x; if (U(x,y,0)>=bound) U(x,y,0) = bound;
CImg.h:                    bound = (float)_height - y; if (U(x,y,1)>=bound) U(x,y,1) = bound;
CImg.h:              const float nsmoothness = -smoothness;
CImg.h:                const int _p1y = y?y - 1:0, _n1y = y<U.height() - 1?y + 1:y;
CImg.h:                    X = is_backward?x - U(x,y,0):x + U(x,y,0),
CImg.h:                    Y = is_backward?y - U(x,y,1):y + U(x,y,1);
CImg.h:                  if (is_backward) cimg_forC(I2,c) delta_I+=(float)(I1._linear_atXY(X,Y,c) - I2(x,y,c));
CImg.h:                  else cimg_forC(I2,c) delta_I+=(float)(I1(x,y,c) - I2._linear_atXY(X,Y,c));
CImg.h:                      Ux = 0.5f*(U(_n1x,y,c) - U(_p1x,y,c)),
CImg.h:                      Uy = 0.5f*(U(x,_n1y,c) - U(x,_p1y,c)),
CImg.h:                      N3 = 1e-5f + N2*N,
CImg.h:                      coef_b = -2*Ux*Uy/N3,
CImg.h:                      Uxy = 0.25f*(U(_n1x,_n1y,c) + U(_p1x,_p1y,c) - U(_n1x,_p1y,c) - U(_n1x,_p1y,c));
CImg.h:                    bound = (float)x - _width; if (U(x,y,0)<=bound) U(x,y,0) = bound;
CImg.h:                    bound = (float)y - _height; if (U(x,y,1)<=bound) U(x,y,1) = bound;
CImg.h:                    if (U(x,y,0)<-x) U(x,y,0) = -(float)x;
CImg.h:                    if (U(x,y,1)<-y) U(x,y,1) = -(float)y;
CImg.h:                    bound = (float)_width - x; if (U(x,y,0)>=bound) U(x,y,0) = bound;
CImg.h:                    bound = (float)_height - y; if (U(x,y,1)>=bound) U(x,y,1) = bound;
CImg.h:          const float d_energy = (_energy - energy)/(sw*sh*sd);
CImg.h:          if (d_energy<=0 && -d_energy<_precision) break;
CImg.h:    //! Compute correspondence map between two images, using a patch-matching algorithm.
CImg.h:        \param nb_iterations Number of patch-match iterations.
CImg.h:    //! Compute correspondence map between two images, using the patch-match algorithm \newinstance.
CImg.h:    //! Compute correspondence map between two images, using the patch-match algorithm \overloading.
CImg.h:    //! Compute correspondence map between two images, using the patch-match algorithm \overloading.
CImg.h:        psizew = (int)patch_width,  psizew1 = psizew/2, psizew2 = psizew - psizew1 - 1,
CImg.h:        psizeh = (int)patch_height, psizeh1 = psizeh/2, psizeh2 = psizeh - psizeh1 - 1,
CImg.h:        psized = (int)patch_depth,  psized1 = psized/2, psized2 = psized - psized1 - 1;
CImg.h:      // Interleave image buffers to speed up patch comparison (more cache-friendly).
CImg.h:            cimg_forXYZ(*this,x,y,z) { // User-defined initialization
CImg.h:              cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),  cx2 = psizew - cx1 - 1,
CImg.h:              cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()), cy2 = psizeh - cy1 - 1,
CImg.h:              cz1 = z<=psized1?z:(z<depth()  - psized2?psized1:psized + z - depth()),  cz2 = psized - cz1 - 1,
CImg.h:              u = cimg::cut((int)guide(x,y,z,0),cx1,patch_image.width() - 1 - cx2),
CImg.h:              v = cimg::cut((int)guide(x,y,z,1),cy1,patch_image.height() - 1 - cy2),
CImg.h:              w = cimg::cut((int)guide(x,y,z,2),cz1,patch_image.depth() - 1 - cz2);
CImg.h:                                       x - cx1,y - cy1,z - cz1,
CImg.h:                                       u - cx1,v - cy1,w - cz1,
CImg.h:                cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),  cx2 = psizew - cx1 - 1,
CImg.h:                cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()), cy2 = psizeh - cy1 - 1,
CImg.h:                cz1 = z<=psized1?z:(z<depth()  - psized2?psized1:psized + z - depth()),  cz2 = psized - cz1 - 1,
CImg.h:                u = (int)cimg::round(cimg::rand(cx1,patch_image.width() - 1 - cx2,&rng)),
CImg.h:                v = (int)cimg::round(cimg::rand(cy1,patch_image.height() - 1 - cy2,&rng)),
CImg.h:                w = (int)cimg::round(cimg::rand(cz1,patch_image.depth() - 1 - cz2,&rng));
CImg.h:                                         x - cx1,y - cy1,z - cz1,
CImg.h:                                         u - cx1,v - cy1,w - cz1,
CImg.h:          const unsigned int cmask = is_backward?1:2, nmask = 3 - cmask;
CImg.h:                x = is_backward?width() - 1 - X:X,
CImg.h:                y = is_backward?height() - 1 - Y:Y,
CImg.h:                z = is_backward?depth() - 1 - Z:Z;
CImg.h:              if (score(x,y,z)<=1e-5 || (constraint && guide(x,y,z,constraint)!=0)) continue;
CImg.h:                cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),  cx2 = psizew - cx1 - 1,
CImg.h:                cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()), cy2 = psizeh - cy1 - 1,
CImg.h:                cz1 = z<=psized1?z:(z<depth()  - psized2?psized1:psized + z - depth()),  cz2 = psized - cz1 - 1,
CImg.h:                xp = x - cx1,
CImg.h:                yp = y - cy1,
CImg.h:                zp = z - cz1;
CImg.h:              if (is_forward && x>0 && (is_updated(x - 1,y,z)&cmask)) { // Compare with left neighbor
CImg.h:                u = a_map(x - 1,y,z,0);
CImg.h:                v = a_map(x - 1,y,z,1);
CImg.h:                w = a_map(x - 1,y,z,2);
CImg.h:                if (u>=cx1 - 1 && u<patch_image.width() - 1 - cx2 &&
CImg.h:                    v>=cy1 && v<patch_image.height() - cy2 &&
CImg.h:                    w>=cz1 && w<patch_image.depth() - cz2) {
CImg.h:                                  xp,yp,zp,u + 1 - cx1,v - cy1,w - cz1,
CImg.h:              if (is_forward && y>0 && (is_updated(x,y - 1,z)&cmask)) { // Compare with up neighbor
CImg.h:                u = a_map(x,y - 1,z,0);
CImg.h:                v = a_map(x,y - 1,z,1);
CImg.h:                w = a_map(x,y - 1,z,2);
CImg.h:                if (u>=cx1 && u<patch_image.width() - cx2 &&
CImg.h:                    v>=cy1 - 1 && v<patch_image.height() - 1 - cy2 &&
CImg.h:                    w>=cz1 && w<patch_image.depth() - cz2) {
CImg.h:                                  xp,yp,zp,u - cx1,v + 1 - cy1,w - cz1,
CImg.h:              if (is_forward && z>0 && (is_updated(x,y,z - 1)&cmask)) { // Compare with backward neighbor
CImg.h:                u = a_map(x,y,z - 1,0);
CImg.h:                v = a_map(x,y,z - 1,1);
CImg.h:                w = a_map(x,y,z - 1,2);
CImg.h:                if (u>=cx1 && u<patch_image.width() - cx2 &&
CImg.h:                    v>=cy1 && v<patch_image.height() - cy2 &&
CImg.h:                    w>=cz1 - 1 && w<patch_image.depth() - 1 - cz2) {
CImg.h:                                  xp,yp,zp,u - cx1,v - cy1,w + 1 - cz1,
CImg.h:              if (is_backward && x<width() - 1 && (is_updated(x + 1,y,z)&cmask)) { // Compare with right neighbor
CImg.h:                if (u>=cx1 + 1 && u<patch_image.width() + 1 - cx2 &&
CImg.h:                    v>=cy1 && v<patch_image.height() - cy2 &&
CImg.h:                    w>=cz1 && w<patch_image.depth() - cz2) {
CImg.h:                                  xp,yp,zp,u - 1 - cx1,v - cy1,w - cz1,
CImg.h:                  if (s<best_score) { best_u = u - 1; best_v = v; best_w = w; best_score = s; }
CImg.h:              if (is_backward && y<height() - 1 && (is_updated(x,y + 1,z)&cmask)) { // Compare with bottom neighbor
CImg.h:                if (u>=cx1 && u<patch_image.width() - cx2 &&
CImg.h:                    v>=cy1 + 1 && v<patch_image.height() + 1 - cy2 &&
CImg.h:                    w>=cz1 && w<patch_image.depth() - cz2) {
CImg.h:                                  xp,yp,zp,u - cx1,v - 1 - cy1,w - cz1,
CImg.h:                  if (s<best_score) { best_u = u; best_v = v - 1; best_w = w; best_score = s; }
CImg.h:              if (is_backward && z<depth() - 1 && (is_updated(x,y,z + 1)&cmask)) { // Compare with forward neighbor
CImg.h:                if (u>=cx1 && u<patch_image.width() - cx2 &&
CImg.h:                    v>=cy1 && v<patch_image.height() - cy2 &&
CImg.h:                    w>=cz1 + 1 && w<patch_image.depth() + 1 - cz2) {
CImg.h:                                  xp,yp,zp,u - cx1,v - cy1,w - 1 - cz1,
CImg.h:                  if (s<best_score) { best_u = u; best_v = v; best_w = w - 1; best_score = s; }
CImg.h:                u = (int)cimg::round(cimg::rand(std::max((float)cx1,best_u - dw),
CImg.h:                                                std::min(patch_image.width() - 1.f - cx2,best_u + dw),&rng));
CImg.h:                v = (int)cimg::round(cimg::rand(std::max((float)cy1,best_v - dh),
CImg.h:                                                std::min(patch_image.height() - 1.f - cy2,best_v + dh),&rng));
CImg.h:                w = (int)cimg::round(cimg::rand(std::max((float)cz1,best_w - dd),
CImg.h:                                                std::min(patch_image.depth() - 1.f - cz2,best_w + dd),&rng));
CImg.h:                                  xp,yp,zp,u - cx1,v - cy1,w - cz1,
CImg.h:                  if (p_penalty) cimg_pragma_openmp(atomic) --p_penalty;
CImg.h:                cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),
CImg.h:                cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()),
CImg.h:                cz1 = z<=psized1?z:(z<depth()  - psized2?psized1:psized + z - depth()),
CImg.h:                xp = x - cx1,
CImg.h:                yp = y - cy1,
CImg.h:                zp = z - cz1,
CImg.h:                                                xp,yp,zp,u - cx1,v - cy1,w - cz1,
CImg.h:            cimg_forXY(*this,x,y) { // User-defined initialization
CImg.h:              cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),  cx2 = psizew - cx1 - 1,
CImg.h:              cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()), cy2 = psizeh - cy1 - 1,
CImg.h:              u = cimg::cut((int)guide(x,y,0),cx1,patch_image.width() - 1 - cx2),
CImg.h:              v = cimg::cut((int)guide(x,y,1),cy1,patch_image.height() - 1 - cy2);
CImg.h:                                     x - cx1,y - cy1,u - cx1,v - cy1,
CImg.h:                cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),  cx2 = psizew - cx1 - 1,
CImg.h:                cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()), cy2 = psizeh - cy1 - 1,
CImg.h:                u = (int)cimg::round(cimg::rand(cx1,patch_image.width() - 1 - cx2,&rng)),
CImg.h:                v = (int)cimg::round(cimg::rand(cy1,patch_image.height() - 1 - cy2,&rng));
CImg.h:                                       x - cx1,y - cy1,u - cx1,v - cy1,
CImg.h:          const unsigned int cmask = is_backward?1:2, nmask = 3 - cmask;
CImg.h:                x = is_backward?width() - 1 - X:X,
CImg.h:                y = is_backward?height() - 1 - Y:Y;
CImg.h:              if (score(x,y)<=1e-5 || (constraint && guide(x,y,constraint)!=0)) continue;
CImg.h:                cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),  cx2 = psizew - cx1 - 1,
CImg.h:                cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()), cy2 = psizeh - cy1 - 1,
CImg.h:                xp = x - cx1,
CImg.h:                yp = y - cy1;
CImg.h:              if (is_forward && x>0 && (is_updated(x - 1,y)&cmask)) { // Compare with left neighbor
CImg.h:                u = a_map(x - 1,y,0);
CImg.h:                v = a_map(x - 1,y,1);
CImg.h:                if (u>=cx1 - 1 && u<patch_image.width() - 1 - cx2 &&
CImg.h:                    v>=cy1 && v<patch_image.height() - cy2) {
CImg.h:                                  xp,yp,u + 1 - cx1,v - cy1,
CImg.h:              if (is_forward && y>0 && (is_updated(x,y - 1)&cmask)) { // Compare with up neighbor
CImg.h:                u = a_map(x,y - 1,0);
CImg.h:                v = a_map(x,y - 1,1);
CImg.h:                if (u>=cx1 && u<patch_image.width() - cx2 &&
CImg.h:                    v>=cy1 - 1 && v<patch_image.height() - 1 - cy2) {
CImg.h:                                  xp,yp,u - cx1,v + 1 - cy1,
CImg.h:              if (is_backward && x<width() - 1 && (is_updated(x + 1,y)&cmask)) { // Compare with right neighbor
CImg.h:                if (u>=cx1 + 1 && u<patch_image.width() + 1 - cx2 &&
CImg.h:                    v>=cy1 && v<patch_image.height() - cy2) {
CImg.h:                                  xp,yp,u - 1 - cx1,v - cy1,
CImg.h:                  if (s<best_score) { best_u = u - 1; best_v = v; best_score = s; }
CImg.h:              if (is_backward && y<height() - 1 && (is_updated(x,y + 1)&cmask)) { // Compare with bottom neighbor
CImg.h:                if (u>=cx1 && u<patch_image.width() - cx2 &&
CImg.h:                    v>=cy1 + 1 && v<patch_image.height() + 1 - cy2) {
CImg.h:                                  xp,yp,u - cx1,v - 1 - cy1,
CImg.h:                  if (s<best_score) { best_u = u; best_v = v - 1; best_score = s; }
CImg.h:                u = (int)cimg::round(cimg::rand(std::max((float)cx1,best_u - dw),
CImg.h:                                                std::min(patch_image.width() - 1.f - cx2,best_u + dw),&rng));
CImg.h:                v = (int)cimg::round(cimg::rand(std::max((float)cy1,best_v - dh),
CImg.h:                                                std::min(patch_image.height() - 1.f - cy2,best_v + dh),&rng));
CImg.h:                                  xp,yp,u - cx1,v - cy1,
CImg.h:                  if (p_penalty) cimg_pragma_openmp(atomic) --p_penalty;
CImg.h:                cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),
CImg.h:                cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()),
CImg.h:                xp = x - cx1,
CImg.h:                yp = y - cy1,
CImg.h:                                                xp,yp,u - cx1,v - cy1,
CImg.h:      if (!allow_identity && cimg::hypot((float)x1 - x2,(float)y1 - y2,(float)z1 - z2)<patch_penalization)
CImg.h:        offx1 = (ulongT)img1._width - psizewc,
CImg.h:        offx2 = (ulongT)img2._width - psizewc,
CImg.h:        offy1 = (ulongT)img1._width*img1._height - (ulongT)psizeh*img1._width,
CImg.h:        offy2 = (ulongT)img2._width*img2._height - (ulongT)psizeh*img2._width;
CImg.h:            ssd += cimg::sqr((Tfloat)*(p1++) - *(p2++));
CImg.h:      if (!allow_identity && cimg::hypot((float)x1-x2,(float)y1-y2)<patch_penalization)
CImg.h:        offx1 = (ulongT)img1._width - psizewc,
CImg.h:        offx2 = (ulongT)img2._width - psizewc;
CImg.h:          ssd += cimg::sqr((Tfloat)*(p1++) - *(p2++));
CImg.h:        \param metric Type of metric. Can be <tt>{ 0=Chebyshev | 1=Manhattan | 2=Euclidean | 3=Squared-euclidean }</tt>.
CImg.h:                     J. Goutsias, L. Vincent, and D.S. Bloomberg (eds.), Kluwer, 2000, pp. 331-340.'
CImg.h:      return (u*u - i*i + g[u] - g[i])/(2*(u - i));
CImg.h:      return (x - i)*(x - i) + g[i];
CImg.h:      return (u - i<=g[u] - g[i]?999999999:(g[u] - g[i] + u + i)/2);
CImg.h:      return (x<i?i - x:x - i) + g[i];
CImg.h:      return h<u - g[i]?h:u - g[i];
CImg.h:      const longT d = x<i?i - x:x - i;
CImg.h:        while ((q>=0) && f(t[q],s[q],g)>f(t[q],u,g)) { --q; }
CImg.h:      for (int u = (int)len - 1; u>=0; --u) { dt[u] = f(u,s[q],g); if (u==t[q]) --q; } // Backward scan
CImg.h:        cimg_forYZ(*this,y,z) { // Over X-direction
CImg.h:          cimg_forXZ(*this,x,z) { // Over Y-direction
CImg.h:          cimg_forXY(*this,x,y) { // Over Z-direction
CImg.h:            for (int z = depth() - 1 - dz, nz = depth() - 1; z>=0; --z,--nz) { // Backward scan
CImg.h:              for (int y = height() - 1 - dy, ny = height() - 1; y>=0; --y,--ny) {
CImg.h:                for (int x = width() - 1 - dx, nx = width() - 1; x>=0; --x,--nx) {
CImg.h:          const td P = (td)-Q(0,0);
CImg.h:          if (x - 1>=0 && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x - 1,y,z) + P),x - 1,y,z)) {
CImg.h:            res(x - 1,y,z) = npot; if (path) path(x - 1,y,z) = (to)2;
CImg.h:          if (x + 1<width() && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x + 1,y,z) + P),x + 1,y,z)) {
CImg.h:          if (y - 1>=0 && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x,y - 1,z) + P),x,y - 1,z)) {
CImg.h:            res(x,y - 1,z) = npot; if (path) path(x,y - 1,z) = (to)8;
CImg.h:          if (y + 1<height() && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x,y + 1,z) + P),x,y + 1,z)) {
CImg.h:          if (z - 1>=0 && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x,y,z - 1) + P),x,y,z - 1)) {
CImg.h:            res(x,y,z - 1) = npot; if (path) path(x,y,z - 1) = (to)32;
CImg.h:          if (z + 1<depth() && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x,y,z + 1) + P),x,y,z + 1)) {
CImg.h:            if (x - 1>=0 && y - 1>=0 &&
CImg.h:                Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x - 1,y - 1,z) + P)),x - 1,y - 1,z)) {
CImg.h:              res(x - 1,y - 1,z) = npot; if (path) path(x - 1,y - 1,z) = (to)10;
CImg.h:            if (x + 1<width() && y - 1>=0 &&
CImg.h:                Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x + 1,y - 1,z) + P)),x + 1,y - 1,z)) {
CImg.h:              res(x + 1,y - 1,z) = npot; if (path) path(x + 1,y - 1,z) = (to)9;
CImg.h:            if (x - 1>=0 && y + 1<height() &&
CImg.h:                Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x - 1,y + 1,z) + P)),x - 1,y + 1,z)) {
CImg.h:              res(x - 1,y + 1,z) = npot; if (path) path(x - 1,y + 1,z) = (to)6;
CImg.h:                Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x + 1,y + 1,z) + P)),x + 1,y + 1,z)) {
CImg.h:            if (z - 1>=0) { // Diagonal neighbors on slice z - 1
CImg.h:              if (x - 1>=0 &&
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x - 1,y,z - 1) + P)),x - 1,y,z - 1)) {
CImg.h:                res(x - 1,y,z - 1) = npot; if (path) path(x - 1,y,z - 1) = (to)34;
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x + 1,y,z - 1) + P)),x + 1,y,z - 1)) {
CImg.h:                res(x + 1,y,z - 1) = npot; if (path) path(x + 1,y,z - 1) = (to)33;
CImg.h:              if (y - 1>=0 &&
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x,y - 1,z - 1) + P)),x,y - 1,z - 1)) {
CImg.h:                res(x,y - 1,z - 1) = npot; if (path) path(x,y - 1,z - 1) = (to)40;
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x,y + 1,z - 1) + P)),x,y + 1,z - 1)) {
CImg.h:                res(x,y + 1,z - 1) = npot; if (path) path(x,y + 1,z - 1) = (to)36;
CImg.h:              if (x - 1>=0 && y - 1>=0 &&
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x - 1,y - 1,z - 1) + P)),
CImg.h:                                           x - 1,y - 1,z - 1)) {
CImg.h:                res(x - 1,y - 1,z - 1) = npot; if (path) path(x - 1,y - 1,z - 1) = (to)42;
CImg.h:              if (x + 1<width() && y - 1>=0 &&
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x + 1,y - 1,z - 1) + P)),
CImg.h:                                           x + 1,y - 1,z - 1)) {
CImg.h:                res(x + 1,y - 1,z - 1) = npot; if (path) path(x + 1,y - 1,z - 1) = (to)41;
CImg.h:              if (x - 1>=0 && y + 1<height() &&
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x - 1,y + 1,z - 1) + P)),
CImg.h:                                           x - 1,y + 1,z - 1)) {
CImg.h:                res(x - 1,y + 1,z - 1) = npot; if (path) path(x - 1,y + 1,z - 1) = (to)38;
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x + 1,y + 1,z - 1) + P)),
CImg.h:                                           x + 1,y + 1,z - 1)) {
CImg.h:                res(x + 1,y + 1,z - 1) = npot; if (path) path(x + 1,y + 1,z - 1) = (to)37;
CImg.h:              if (x - 1>=0 &&
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x - 1,y,z + 1) + P)),x - 1,y,z + 1)) {
CImg.h:                res(x - 1,y,z + 1) = npot; if (path) path(x - 1,y,z + 1) = (to)18;
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x + 1,y,z + 1) + P)),x + 1,y,z + 1)) {
CImg.h:              if (y - 1>=0 &&
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x,y - 1,z + 1) + P)),x,y - 1,z + 1)) {
CImg.h:                res(x,y - 1,z + 1) = npot; if (path) path(x,y - 1,z + 1) = (to)24;
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x,y + 1,z + 1) + P)),x,y + 1,z + 1)) {
CImg.h:              if (x - 1>=0 && y - 1>=0 &&
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x - 1,y - 1,z + 1) + P)),
CImg.h:                                           x - 1,y - 1,z + 1)) {
CImg.h:                res(x - 1,y - 1,z + 1) = npot; if (path) path(x - 1,y - 1,z + 1) = (to)26;
CImg.h:              if (x + 1<width() && y - 1>=0 &&
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x + 1,y - 1,z + 1) + P)),
CImg.h:                                           x + 1,y - 1,z + 1)) {
CImg.h:                res(x + 1,y - 1,z + 1) = npot; if (path) path(x + 1,y - 1,z + 1) = (to)25;
CImg.h:              if (x - 1>=0 && y + 1<height() &&
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x - 1,y + 1,z + 1) + P)),
CImg.h:                                           x - 1,y + 1,z + 1)) {
CImg.h:                res(x - 1,y + 1,z + 1) = npot; if (path) path(x - 1,y + 1,z + 1) = (to)22;
CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x + 1,y + 1,z + 1) + P)),
CImg.h:      CImg<charT> state(_width,_height,_depth); // -1=far away, 0=narrow, 1=frozen
CImg.h:        state.fill(-1);
CImg.h:          if (x - 1>=0 && state(x - 1,y,z)==-1) {
CImg.h:            const Tfloat dist = res(x - 1,y,z) = __distance_eikonal(res,met(x - 1,y,z),x - 1,y,z);
CImg.h:            Q._eik_priority_queue_insert(state,sizeQ,-dist,x - 1,y,z);
CImg.h:          if (x + 1<width() && state(x + 1,y,z)==-1) {
CImg.h:            Q._eik_priority_queue_insert(state,sizeQ,-dist,x + 1,y,z);
CImg.h:          if (y - 1>=0 && state(x,y - 1,z)==-1) {
CImg.h:            const Tfloat dist = res(x,y - 1,z) = __distance_eikonal(res,met(x,y - 1,z),x,y - 1,z);
CImg.h:            Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y - 1,z);
CImg.h:          if (y + 1<height() && state(x,y + 1,z)==-1) {
CImg.h:            Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y + 1,z);
CImg.h:          if (z - 1>=0 && state(x,y,z - 1)==-1) {
CImg.h:            const Tfloat dist = res(x,y,z - 1) = __distance_eikonal(res,met(x,y,z - 1),x,y,z - 1);
CImg.h:            Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y,z - 1);
CImg.h:          if (z + 1<depth() && state(x,y,z + 1)==-1) {
CImg.h:            Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y,z + 1);
CImg.h:          int x = -1, y = -1, z = -1;
CImg.h:            if (state(x,y,z)==1) x = -1; else state(x,y,z) = 1;
CImg.h:            if (x - 1>=0 && state(x - 1,y,z)!=1) {
CImg.h:              const Tfloat dist = __distance_eikonal(res,met(x - 1,y,z),x - 1,y,z);
CImg.h:              if (dist<res(x - 1,y,z)) {
CImg.h:                res(x - 1,y,z) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x - 1,y,z);
CImg.h:                res(x + 1,y,z) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x + 1,y,z);
CImg.h:            if (y - 1>=0 && state(x,y - 1,z)!=1) {
CImg.h:              const Tfloat dist = __distance_eikonal(res,met(x,y - 1,z),x,y - 1,z);
CImg.h:              if (dist<res(x,y - 1,z)) {
CImg.h:                res(x,y - 1,z) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y - 1,z);
CImg.h:                res(x,y + 1,z) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y + 1,z);
CImg.h:            if (z - 1>=0 && state(x,y,z - 1)!=1) {
CImg.h:              const Tfloat dist = __distance_eikonal(res,met(x,y,z - 1),x,y,z - 1);
CImg.h:              if (dist<res(x,y,z - 1)) {
CImg.h:                res(x,y,z - 1) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y,z - 1);
CImg.h:                res(x,y,z + 1) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y,z + 1);
CImg.h:      T T1 = (T)std::min(x - 1>=0?res(x - 1,y,z):M,x + 1<width()?res(x + 1,y,z):M);
CImg.h:          T2 = (T)std::min(y - 1>=0?res(x,y - 1,z):M,y + 1<height()?res(x,y + 1,z):M),
CImg.h:          T3 = (T)std::min(z - 1>=0?res(x,y,z - 1):M,z + 1<depth()?res(x,y,z + 1):M);
CImg.h:        if (T3<M && ___distance_eikonal(3,-2*(T1 + T2 + T3),T1*T1 + T2*T2 + T3*T3 - P*P,root))
CImg.h:        if (T2<M && ___distance_eikonal(2,-2*(T1 + T2),T1*T1 + T2*T2 - P*P,root))
CImg.h:        T T2 = (T)std::min(y - 1>=0?res(x,y - 1,z):M,y + 1<height()?res(x,y + 1,z):M);
CImg.h:        if (T2<M && ___distance_eikonal(2,-2*(T1 + T2),T1*T1 + T2*T2 - P*P,root))
CImg.h:    // Find max root of a 2nd-order polynomial.
CImg.h:      const Tfloat delta = b*b - 4*a*c;
CImg.h:      root = 0.5f*(-b + std::sqrt(delta))/a;
CImg.h:      (*this)(siz - 1,0) = (T)value; (*this)(siz - 1,1) = (T)x; (*this)(siz - 1,2) = (T)y; (*this)(siz - 1,3) = (T)z;
CImg.h:      for (unsigned int pos = siz - 1, par = 0; pos && value>(t)(*this)(par=(pos + 1)/2 - 1,0); pos = par) {
CImg.h:    //! Compute distance function to 0-valued isophotes, using the Eikonal PDE.
CImg.h:              gx = (Incc - Ipcc)/2,
CImg.h:              gy = (Icnc - Icpc)/2,
CImg.h:              gz = (Iccn - Iccp)/2,
CImg.h:              sgn = -cimg::sign(Iccc),
CImg.h:              ix = gx*sgn>0?(Incc - Iccc):(Iccc - Ipcc),
CImg.h:              iy = gy*sgn>0?(Icnc - Iccc):(Iccc - Icpc),
CImg.h:              iz = gz*sgn>0?(Iccn - Iccc):(Iccc - Iccp),
CImg.h:              ng = 1e-5f + cimg::hypot(gx,gy,gz),
CImg.h:              veloc = sgn*(ngx*ix + ngy*iy + ngz*iz - 1);
CImg.h:            if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
CImg.h:              gx = (Inc - Ipc)/2,
CImg.h:              gy = (Icn - Icp)/2,
CImg.h:              sgn = -cimg::sign(Icc),
CImg.h:              ix = gx*sgn>0?(Inc - Icc):(Icc - Ipc),
CImg.h:              iy = gy*sgn>0?(Icn - Icc):(Icc - Icp),
CImg.h:              ng = std::max((Tfloat)1e-5,cimg::hypot(gx,gy)),
CImg.h:              veloc = sgn*(ngx*ix + ngy*iy - 1);
CImg.h:            if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
CImg.h:    //! Compute distance function to 0-valued isophotes, using the Eikonal PDE \newinstance.
CImg.h:                                          "haar(): Sub-image width %u is not even.",
CImg.h:                res(x2++,y,z,c) = (val0 - val1)/sqrt2;
CImg.h:                res(xw,y,z,c) = (val1 - val0)/sqrt2;
CImg.h:                                          "haar(): Sub-image height %u is not even.",
CImg.h:                res(x,y2++,z,c) = (val0 - val1)/sqrt2;
CImg.h:                res(x,yh,z,c) = (val1 - val0)/sqrt2;
CImg.h:                                          "haar(): Sub-image depth %u is not even.",
CImg.h:                res(x,y,z2++,c) = (val0 - val1)/sqrt2;
CImg.h:                res(x,y,zd,c) = (val1 - val0)/sqrt2;
CImg.h:      } else { // Multi-scale version
CImg.h:            for (w = w?w:1; w<=_width; w*=2) res.draw_image(res.get_crop(0,w - 1).get_haar('x',true,1));
CImg.h:            for (h = h?h:1; h<=_height; h*=2) res.draw_image(res.get_crop(0,0,_width - 1,h - 1).get_haar('y',true,1));
CImg.h:              res.draw_image(res.get_crop(0,0,0,_width - 1,_height - 1,d - 1).get_haar('z',true,1));
CImg.h:              res.draw_image(res.get_crop(0,w - 1).get_haar('x',false,1));
CImg.h:              res.draw_image(res.get_crop(0,0,_width - 1,h - 1).get_haar('y',false,1));
CImg.h:              res.draw_image(res.get_crop(0,0,0,_width - 1,_height - 1,d - 1).get_haar('z',false,1));
CImg.h:      } else { // Multi-scale transform
CImg.h:                  res.draw_image(res.get_crop(0,0,0,w - 1,h - 1,d - 1).get_haar(true,1));
CImg.h:                  res.draw_image(res.get_crop(0,0,0,w - 1,h - 1,0).get_haar(true,1));
CImg.h:                  res.draw_image(res.get_crop(0,0,0,w - 1,0,d - 1).get_haar(true,1));
CImg.h:                  res.draw_image(res.get_crop(0,0,0,w - 1,0,0).get_haar(true,1));
CImg.h:                  res.draw_image(res.get_crop(0,0,0,0,h - 1,d - 1).get_haar(true,1));
CImg.h:                  res.draw_image(res.get_crop(0,0,0,0,h - 1,0).get_haar(true,1));
CImg.h:                  res.draw_image(res.get_crop(0,0,0,0,0,d - 1).get_haar(true,1));
CImg.h:                  res.draw_image(res.get_crop(0,0,0,w - 1,h - 1,d - 1).haar(false,1));
CImg.h:                     res.draw_image(res.get_crop(0,0,0,w - 1,h - 1,0).haar(false,1));
CImg.h:                              res.draw_image(res.get_crop(0,0,0,w - 1,0,d - 1).haar(false,1));
CImg.h:                     res.draw_image(res.get_crop(0,0,0,w - 1,0,0).haar(false,1));
CImg.h:                  res.draw_image(res.get_crop(0,0,0,0,h - 1,d - 1).haar(false,1));
CImg.h:                     res.draw_image(res.get_crop(0,0,0,0,h - 1,0).haar(false,1));
CImg.h:                              res.draw_image(res.get_crop(0,0,0,0,0,d - 1).haar(false,1));
CImg.h:    //! Compute n-D Fast Fourier Transform.
CImg.h:                                    "for computing FFT of image (%u,%u,%u,%u) along the X-axis.",
CImg.h:      case 'x' : { // Fourier along X, using built-in functions
CImg.h:        if (((N - 1)&N) && N!=1)
CImg.h:                                      "have non 2^N dimension along the X-axis.",
CImg.h:                const unsigned int ri = N - 1 - i, rj = N - 1 - j;
CImg.h:          for (unsigned int m = N, n = N2; (j+=n)>=m; j-=m, m = n, n>>=1) {}
CImg.h:              angle = (float)((is_inverse?+1:-1)*2*cimg::PI/delta),
CImg.h:                const float tmpr = (float)(wr*nir - wi*nii), tmpi = (float)(wr*nii + wi*nir);
CImg.h:                nir = (T)(ir - tmpr);
CImg.h:                nii = (T)(ii - tmpi);
CImg.h:              const float nwr = wr*ca-wi*sa;
CImg.h:      case 'y' : { // Fourier along Y, using built-in functions
CImg.h:        if (((N - 1)&N) && N!=1)
CImg.h:                                      "have non 2^N dimension along the Y-axis.",
CImg.h:                const unsigned int ri = N - 1 - i, rj = N - 1 - j;
CImg.h:          for (unsigned int m = N, n = N2; (j+=n)>=m; j-=m, m = n, n>>=1) {}
CImg.h:              angle = (float)((is_inverse?+1:-1)*2*cimg::PI/delta),
CImg.h:                const float tmpr = (float)(wr*nir - wi*nii), tmpi = (float)(wr*nii + wi*nir);
CImg.h:                nir = (T)(ir - tmpr);
CImg.h:                nii = (T)(ii - tmpi);
CImg.h:              const float nwr = wr*ca-wi*sa;
CImg.h:      default : { // Fourier along Z, using built-in functions
CImg.h:        if (((N - 1)&N) && N!=1)
CImg.h:                                      "have non 2^N dimension along the Z-axis.",
CImg.h:                const unsigned int ri = N - 1 - i, rj = N - 1 - j;
CImg.h:          for (unsigned int m = N, n = N2; (j+=n)>=m; j-=m, m = n, n>>=1) {}
CImg.h:              angle = (float)((is_inverse?+1:-1)*2*cimg::PI/delta),
CImg.h:                const float tmpr = (float)(wr*nir - wi*nii), tmpi = (float)(wr*nii + wi*nir);
CImg.h:                nir = (T)(ir - tmpr);
CImg.h:                nii = (T)(ii - tmpi);
CImg.h:              const float nwr = wr*ca-wi*sa;
CImg.h:    //! Compute n-D Fast Fourier Transform.
CImg.h:    //-------------------------------------
CImg.h:    //-------------------------------------
CImg.h:       \param x X-coordinate of the rotation axis, or first quaternion coordinate.
CImg.h:       \param y Y-coordinate of the rotation axis, or second quaternion coordinate.
CImg.h:       \param z Z-coordinate of the rotation axis, or second quaternion coordinate.
CImg.h:       \param tx X-coordinate of the 3D displacement vector.
CImg.h:       \param ty Y-coordinate of the 3D displacement vector.
CImg.h:       \param tz Z-coordinate of the 3D displacement vector.
CImg.h:      xcoords-=(xm + xM)/2; ycoords-=(ym + yM)/2; zcoords-=(zm + zM)/2;
CImg.h:    CImg<T>& resize_object3d(const float sx, const float sy=-100, const float sz=-100) {
CImg.h:      if (xm<xM) { if (sx>0) xcoords*=sx/(xM-xm); else xcoords*=-sx/100; }
CImg.h:      if (ym<yM) { if (sy>0) ycoords*=sy/(yM-ym); else ycoords*=-sy/100; }
CImg.h:      if (zm<zM) { if (sz>0) zcoords*=sz/(zM-zm); else zcoords*=-sz/100; }
CImg.h:    CImg<Tfloat> get_resize_object3d(const float sx, const float sy=-100, const float sz=-100) const {
CImg.h:      const float dx = xM - xm, dy = yM - ym, dz = zM - zm, dmax = cimg::max(dx,dy,dz);
CImg.h:       \param coords Texture-mapping coordinates.
CImg.h:      if (!coords) { // If no texture coordinates specified, do a default XY-projection
CImg.h:          dx = xmax>xmin?xmax-xmin:1,
CImg.h:          dy = ymax>ymin?ymax-ymin:1;
CImg.h:          _coords(p,0) = (int)(((*this)(p,0) - xmin)*texture._width/dx);
CImg.h:          _coords(p,1) = (int)(((*this)(p,1) - ymin)*texture._height/dy);
CImg.h:      int texture_ind = -1;
CImg.h:          texture.get_vector_at(x0<=0?0:x0>=texture.width()?texture.width() - 1:x0,
CImg.h:                                y0<=0?0:y0>=texture.height()?texture.height() - 1:y0).move_to(colors[l]);
CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
CImg.h:      const unsigned int size_x1 = _width - 1, size_y1 = _height - 1;
CImg.h:            r = (unsigned char)(((*this)(x,y,0) - m)*255/(M-m)),
CImg.h:            g = (unsigned char)(_spectrum>1?((*this)(x,y,1) - m)*255/(M-m):r),
CImg.h:            b = (unsigned char)(_spectrum>2?((*this)(x,y,2) - m)*255/(M-m):_spectrum>1?0:r);
CImg.h:      return elevation3d(primitives,func,0,0,_width - 1.f,_height - 1.f,_width,_height);
CImg.h:       \param x0 X-coordinate of the projection point.
CImg.h:       \param y0 Y-coordinate of the projection point.
CImg.h:       \param z0 Z-coordinate of the projection point.
CImg.h:      if (normalize_colors) { m = (float)min_max(M); delta = 255/(m==M?1:M-m); }
CImg.h:        _x0 = (x0>=_width)?_width - 1:x0,
CImg.h:        _y0 = (y0>=_height)?_height - 1:y0,
CImg.h:        _z0 = (z0>=_depth)?_depth - 1:z0;
CImg.h:        ((get_crop(0,0,_z0,0,_width - 1,_height - 1,_z0,_spectrum - 1)-=m)*=delta).move_to(img_xy);
CImg.h:        ((get_crop(0,_y0,0,0,_width - 1,_y0,_depth - 1,_spectrum - 1)-=m)*=delta).resize(_width,_depth,1,-100,-1).
CImg.h:        ((get_crop(_x0,0,0,0,_x0,_height - 1,_depth - 1,_spectrum - 1)-=m)*=delta).resize(_height,_depth,1,-100,-1).
CImg.h:        get_crop(0,0,_z0,0,_width - 1,_height - 1,_z0,_spectrum - 1).move_to(img_xy);
CImg.h:        get_crop(0,_y0,0,0,_width - 1,_y0,_depth - 1,_spectrum - 1).resize(_width,_depth,1,-100,-1).move_to(img_xz);
CImg.h:        get_crop(_x0,0,0,0,_x0,_height - 1,_depth - 1,_spectrum - 1).resize(_height,_depth,1,-100,-1).move_to(img_yz);
CImg.h:                          0,_width - 1,_width - 1,0,   0,_width - 1,_width - 1,0, _x0,_x0,_x0,_x0,
CImg.h:                          0,0,_height - 1,_height - 1, _y0,_y0,_y0,_y0,       0,_height - 1,_height - 1,0,
CImg.h:                          _z0,_z0,_z0,_z0,         0,0,_depth - 1,_depth - 1, 0,0,_depth - 1,_depth - 1);
CImg.h:      CImg<tf>::vector(0,1,2,3,0,0,img_xy._width - 1,0,img_xy._width - 1,img_xy._height - 1,0,img_xy._height - 1).
CImg.h:      CImg<tf>::vector(4,5,6,7,0,0,img_xz._width - 1,0,img_xz._width - 1,img_xz._height - 1,0,img_xz._height - 1).
CImg.h:      CImg<tf>::vector(8,9,10,11,0,0,img_yz._width - 1,0,img_yz._width - 1,img_yz._height - 1,0,img_yz._height - 1).
CImg.h:       \param size_x The number of subdivisions along the X-axis.
CImg.h:       \param size_y The number of subdisivions along the Y-axis.
CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
CImg.h:                               const int size_x=-100, const int size_y=-100) const {
CImg.h:      if ((size_x==-100 && size_y==-100) || (size_x==width() && size_y==height())) {
CImg.h:        vertices = isoline3d(primitives,func,isovalue,0,0,width() - 1.f,height() - 1.f,width(),height());
CImg.h:        vertices = isoline3d(primitives,func,isovalue,0,0,width() - 1.f,height() - 1.f,size_x,size_y);
CImg.h:       \param x0 X-coordinate of the starting point.
CImg.h:       \param y0 Y-coordinate of the starting point.
CImg.h:       \param x1 X-coordinate of the ending point.
CImg.h:       \param y1 Y-coordinate of the ending point.
CImg.h:       \param size_x Resolution of the function along the X-axis.
CImg.h:       \param size_y Resolution of the function along the Y-axis.
CImg.h:       \param x0 X-coordinate of the starting point.
CImg.h:       \param y0 Y-coordinate of the starting point.
CImg.h:       \param x1 X-coordinate of the ending point.
CImg.h:       \param y1 Y-coordinate of the ending point.
CImg.h:       \param size_x Resolution of the function along the X-axis.
CImg.h:       \param size_y Resolution of the function along the Y-axis.
CImg.h:      static const int segments[16][4] = { { -1,-1,-1,-1 }, { 0,3,-1,-1 }, { 0,1,-1,-1 }, { 1,3,-1,-1 },
CImg.h:                                           { 1,2,-1,-1 },   { 0,1,2,3 },   { 0,2,-1,-1 }, { 2,3,-1,-1 },
CImg.h:                                           { 2,3,-1,-1 },   { 0,2,-1,-1},  { 0,3,1,2 },   { 1,2,-1,-1 },
CImg.h:                                           { 1,3,-1,-1 },   { 0,1,-1,-1},  { 0,3,-1,-1},  { -1,-1,-1,-1 } };
CImg.h:        _nx = (unsigned int)(size_x>=0?size_x:cimg::round((x1-x0)*-size_x/100 + 1)),
CImg.h:        _ny = (unsigned int)(size_y>=0?size_y:cimg::round((y1-y0)*-size_y/100 + 1)),
CImg.h:        nxm1 = nx - 1,
CImg.h:        nym1 = ny - 1;
CImg.h:      const float dx = (x1 - x0)/nxm1, dy = (y1 - y0)/nym1;
CImg.h:      CImg<intT> indices1(nx,1,1,2,-1), indices2(nx,1,1,2);
CImg.h:        indices2.fill(-1);
CImg.h:              const float Xi = X + (isovalue-val0)*dx/(val1-val0);
CImg.h:              const float Yi = Y + (isovalue-val1)*dy/(val2-val1);
CImg.h:              const float Xi = X + (isovalue-val3)*dx/(val2-val3);
CImg.h:              const float Yi = Y + (isovalue-val0)*dy/(val3-val0);
CImg.h:            for (const int *segment = segments[configuration]; *segment!=-1; ) {
CImg.h:       \param size_x Number of subdivisions along the X-axis.
CImg.h:       \param size_y Number of subdisivions along the Y-axis.
CImg.h:       \param size_z Number of subdisivions along the Z-axis.
CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
CImg.h:       const CImg<float> img = CImg<unsigned char>("reference.jpg").resize(-100,-100,20);
CImg.h:                                  const int size_x=-100, const int size_y=-100, const int size_z=-100) const {
CImg.h:      if ((size_x==-100 && size_y==-100 && size_z==-100) || (size_x==width() && size_y==height() && size_z==depth())) {
CImg.h:        vertices = isosurface3d(primitives,func,isovalue,0,0,0,width() - 1.f,height() - 1.f,depth() - 1.f,
CImg.h:        vertices = isosurface3d(primitives,func,isovalue,0,0,0,width() - 1.f,height() - 1.f,depth() - 1.f,
CImg.h:       \param x0 X-coordinate of the starting point.
CImg.h:       \param y0 Y-coordinate of the starting point.
CImg.h:       \param z0 Z-coordinate of the starting point.
CImg.h:       \param x1 X-coordinate of the ending point.
CImg.h:       \param y1 Y-coordinate of the ending point.
CImg.h:       \param z1 Z-coordinate of the ending point.
CImg.h:       \param size_x Resolution of the elevation function along the X-axis.
CImg.h:       \param size_y Resolution of the elevation function along the Y-axis.
CImg.h:       \param size_z Resolution of the elevation function along the Z-axis.
CImg.h:       \param x0 X-coordinate of the starting point.
CImg.h:       \param y0 Y-coordinate of the starting point.
CImg.h:       \param z0 Z-coordinate of the starting point.
CImg.h:       \param x1 X-coordinate of the ending point.
CImg.h:       \param y1 Y-coordinate of the ending point.
CImg.h:       \param z1 Z-coordinate of the ending point.
CImg.h:       \param size_x Resolution of the elevation function along the X-axis.
CImg.h:       \param size_y Resolution of the elevation function along the Y-axis.
CImg.h:       \param size_z Resolution of the elevation function along the Z-axis.
CImg.h:        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1 },
CImg.h:        { 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1 },
CImg.h:        { 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1 },
CImg.h:        { 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1 },
CImg.h:        { 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1 },
CImg.h:        { 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1 },
CImg.h:        { 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1 },
CImg.h:        { 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1 },
CImg.h:        { 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1 },
CImg.h:        { 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1 },
CImg.h:        { 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1 },
CImg.h:        { 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1 },
CImg.h:        { 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1 },
CImg.h:        { 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1 },
CImg.h:        { 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1 },
CImg.h:        { 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1 },
CImg.h:        { 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1 },
CImg.h:        { 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1 },
CImg.h:        { 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1 },
CImg.h:        { 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1 },
CImg.h:        { 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1 },
CImg.h:        { 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1 },
CImg.h:        { 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1 },
CImg.h:        { 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1 },
CImg.h:        { 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1 },
CImg.h:        { 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1 },
CImg.h:        { 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1 },
CImg.h:        { 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1 },
CImg.h:        { 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1 },
CImg.h:        { 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1 },
CImg.h:        { 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1 },
CImg.h:        { 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1 },
CImg.h:        { 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1 },
CImg.h:        { 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1 },
CImg.h:        { 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1 },
CImg.h:        { 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1 },
CImg.h:        { 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1 },
CImg.h:        { 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1 },
CImg.h:        { 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1 },
CImg.h:        { 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1 },
CImg.h:        { 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1 },
CImg.h:        { 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1 },
CImg.h:        { 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1 },
CImg.h:        { 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1 },
CImg.h:        { 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1 },
CImg.h:        { 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1 },
CImg.h:        { 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1 },
CImg.h:        { 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1 },
CImg.h:        { 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1 },
CImg.h:        { 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1 },
CImg.h:        { 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1 },
CImg.h:        { 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1 },
CImg.h:        { 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1 },
CImg.h:        { 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1 },
CImg.h:        { 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1 },
CImg.h:        { 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1 },
CImg.h:        { 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1 },
CImg.h:        { 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1 },
CImg.h:        { 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1 },
CImg.h:        { 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1 },
CImg.h:        { 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1 },
CImg.h:        { 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1 },
CImg.h:        { 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1 },
CImg.h:        { 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1 },
CImg.h:        { 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1 },
CImg.h:        { 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1 },
CImg.h:        { 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1 },
CImg.h:        { 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1 },
CImg.h:        { 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1 },
CImg.h:        { 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1 },
CImg.h:        { 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1 },
CImg.h:        { 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1 },
CImg.h:        { 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1 },
CImg.h:        { 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1 },
CImg.h:        { 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1 },
CImg.h:        { 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1 },
CImg.h:        { 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1 },
CImg.h:        { 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1 },
CImg.h:        { 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1 },
CImg.h:        { 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1 },
CImg.h:        { 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1 },
CImg.h:        { 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1 },
CImg.h:        { 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1 },
CImg.h:        { 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1 },
CImg.h:        { 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1 },
CImg.h:        { 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1 },
CImg.h:        { 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1 },
CImg.h:        { 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1 },
CImg.h:        { 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1 },
CImg.h:        { 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1 },
CImg.h:        { 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1 },
CImg.h:        { 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1 },
CImg.h:        { 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1 },
CImg.h:        { 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1 },
CImg.h:        { 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1 },
CImg.h:        { 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1 },
CImg.h:        { 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1 },
CImg.h:        { 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1 },
CImg.h:        { 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1 },
CImg.h:        { 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1 },
CImg.h:        { 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1 },
CImg.h:        { 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1 },
CImg.h:        { 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1 },
CImg.h:        { 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1 },
CImg.h:        { 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1 },
CImg.h:        { 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1 },
CImg.h:        { 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1 },
CImg.h:        { 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1 },
CImg.h:        { 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
CImg.h:        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }
CImg.h:        _nx = (unsigned int)(size_x>=0?size_x:cimg::round((x1-x0)*-size_x/100 + 1)),
CImg.h:        _ny = (unsigned int)(size_y>=0?size_y:cimg::round((y1-y0)*-size_y/100 + 1)),
CImg.h:        _nz = (unsigned int)(size_z>=0?size_z:cimg::round((z1-z0)*-size_z/100 + 1)),
CImg.h:        nxm1 = nx - 1,
CImg.h:        nym1 = ny - 1,
CImg.h:        nzm1 = nz - 1;
CImg.h:      const float dx = (x1 - x0)/nxm1, dy = (y1 - y0)/nym1, dz = (z1 - z0)/nzm1;
CImg.h:      CImg<intT> indices1(nx,ny,1,3,-1), indices2(indices1);
CImg.h:        indices2.fill(-1);
CImg.h:                const float Xi = X + (isovalue-val0)*dx/(val1-val0);
CImg.h:                const float Yi = Y + (isovalue-val1)*dy/(val2-val1);
CImg.h:                const float Xi = X + (isovalue-val3)*dx/(val2-val3);
CImg.h:                const float Yi = Y + (isovalue-val0)*dy/(val3-val0);
CImg.h:                const float Xi = X + (isovalue-val4)*dx/(val5-val4);
CImg.h:                const float Yi = Y + (isovalue-val5)*dy/(val6-val5);
CImg.h:                const float Xi = X + (isovalue-val7)*dx/(val6-val7);
CImg.h:                const float Yi = Y + (isovalue-val4)*dy/(val7-val4);
CImg.h:                const float Zi = Z+ (isovalue-val0)*dz/(val4-val0);
CImg.h:                const float Zi = Z + (isovalue-val1)*dz/(val5-val1);
CImg.h:                const float Zi = Z + (isovalue-val2)*dz/(val6-val2);
CImg.h:                const float Zi = Z + (isovalue-val3)*dz/(val7-val3);
CImg.h:              for (const int *triangle = triangles[configuration]; *triangle!=-1; ) {
CImg.h:      ~_functor2d_expr() { mp->end(); delete mp; }
CImg.h:      ~_functor3d_expr() { mp->end(); delete mp; }
CImg.h:       \param x0 X-coordinate of the starting point.
CImg.h:       \param y0 Y-coordinate of the starting point.
CImg.h:       \param x1 X-coordinate of the ending point.
CImg.h:       \param y1 Y-coordinate of the ending point.
CImg.h:       \param size_x Resolution of the function along the X-axis.
CImg.h:       \param size_y Resolution of the function along the Y-axis.
CImg.h:        _nsize_x = (unsigned int)(size_x>=0?size_x:(nx1-nx0)*-size_x/100),
CImg.h:        nsize_x = _nsize_x?_nsize_x:1, nsize_x1 = nsize_x - 1,
CImg.h:        _nsize_y = (unsigned int)(size_y>=0?size_y:(ny1-ny0)*-size_y/100),
CImg.h:        nsize_y = _nsize_y?_nsize_y:1, nsize_y1 = nsize_y - 1;
CImg.h:        const float Y = ny0 + y*(ny1-ny0)/nsize_y1;
CImg.h:          const float X = nx0 + x*(nx1-nx0)/nsize_x1;
CImg.h:       \param size_x The width of the box (dimension along the X-axis).
CImg.h:       \param size_y The height of the box (dimension along the Y-axis).
CImg.h:       \param size_z The depth of the box (dimension along the Z-axis).
CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
CImg.h:      const unsigned int nbr = vertices._width - 2;
CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
CImg.h:      const unsigned int nbr = (vertices._width - 2)/2;
CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
CImg.h:    //! Generate a 3D XY-plane.
CImg.h:       \param size_x The width of the plane (dimension along the X-axis).
CImg.h:       \param size_y The height of the plane (dimensions along the Y-axis).
CImg.h:       \param subdivisions_x The number of planar subdivisions along the X-axis.
CImg.h:       \param subdivisions_y The number of planar subdivisions along the Y-axis.
CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
CImg.h:       \param radius The radius of the sphere (dimension along the X-axis).
CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
CImg.h:      CImgList<floatT> vertices(12,1,3,1,1, b,a,0., -b,a,0., -b,-a,0., b,-a,0., a,0.,b, a,0.,-b,
CImg.h:                                -a,0.,-b, -a,0.,b, 0.,b,a, 0.,-b,a, 0.,-b,-a, 0.,b,-a);
CImg.h:      // edge - length/2
CImg.h:          int i0 = -1, i1 = -1, i2 = -1;
CImg.h:            if (cimg::sqr(x-nx0) + cimg::sqr(y-ny0) + cimg::sqr(z-nz0)<he2) i0 = p;
CImg.h:            if (cimg::sqr(x-nx1) + cimg::sqr(y-ny1) + cimg::sqr(z-nz1)<he2) i1 = p;
CImg.h:            if (cimg::sqr(x-nx2) + cimg::sqr(y-ny2) + cimg::sqr(z-nz2)<he2) i2 = p;
CImg.h:          if (i0<0) { CImg<floatT>::vector(nx0,ny0,nz0).move_to(vertices); i0 = vertices.width() - 1; }
CImg.h:          if (i1<0) { CImg<floatT>::vector(nx1,ny1,nz1).move_to(vertices); i1 = vertices.width() - 1; }
CImg.h:          if (i2<0) { CImg<floatT>::vector(nx2,ny2,nz2).move_to(vertices); i2 = vertices.width() - 1; }
CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
CImg.h:        (V(0,1)*V(1,2) - V(0,2)*V(1,1))*V(2,0) +
CImg.h:        (V(0,2)*V(1,0) - V(0,0)*V(1,2))*V(2,1) +
CImg.h:        (V(0,0)*V(1,1) - V(0,1)*V(1,0))*V(2,2);
CImg.h:      if (orient<0) { V(2,0) = -V(2,0); V(2,1) = -V(2,1); V(2,2) = -V(2,2); }
CImg.h:          *(ptrd++) = -128.f;
CImg.h:          int shared_ind = -1;
CImg.h:      const int csiz2 = primitives.width() - colors.width();
CImg.h:          *(ptrd++) = -128.f;
CImg.h:          int shared_ind = -1;
CImg.h:      for (int c = std::min(primitives.width(),colors.width()) - 1; c>=0; --c) {
CImg.h:      if (colors._width<primitives._width) siz+=3*(primitives._width - colors._width);
CImg.h:      siz+=primitives._width - opacities._width;
CImg.h:      for (int c = std::min(primitives.width(),colors.width()) - 1; c>=0; --c) {
CImg.h:      if (colors._width<primitives._width) siz+=3*(primitives._width - colors._width);
CImg.h:        if (*ptrs==(T)-128) {
CImg.h:        if (*ptrs==(T)-128) {
CImg.h:    //---------------------------
CImg.h:    //---------------------------
CImg.h:    const float _sc_nopacity = cimg::abs((float)opacity), _sc_copacity = 1 - std::max((float)opacity,0.f); \
CImg.h:    // [internal] The following _draw_scanline() routines are *non user-friendly functions*,
CImg.h:    // Pre-requisites: x0<=x1, y-coordinate is valid, col is valid.
CImg.h:      const int nx0 = x0>0?x0:0, nx1 = x1<width()?x1:width() - 1, dx = nx1 - nx0;
CImg.h:        const ulongT off = whd - dx - 1;
CImg.h:                for (int x = dx; x>=0; --x) *(ptrd++) = val;
CImg.h:                for (int x = dx; x>=0; --x) *(ptrd++) = val;
CImg.h:                const T val = (T)((2-brightness)**(col++) + (brightness - 1)*_sc_maxval);
CImg.h:                for (int x = dx; x>=0; --x) *(ptrd++) = val;
CImg.h:                const T val = (T)((2-brightness)**(col++) + (brightness - 1)*_sc_maxval);
CImg.h:              for (int x = dx; x>=0; --x) { *ptrd = (T)(val + *ptrd*copacity); ++ptrd; }
CImg.h:              for (int x = dx; x>=0; --x) { *ptrd = (T)(val + *ptrd*copacity); ++ptrd; }
CImg.h:              const Tfloat val = ((2-brightness)**(col++) + (brightness - 1)*_sc_maxval)*nopacity;
CImg.h:              for (int x = dx; x>=0; --x) { *ptrd = (T)(val + *ptrd*copacity); ++ptrd; }
CImg.h:       \param x0 X-coordinate of the point.
CImg.h:       \param y0 Y-coordinate of the point.
CImg.h:       \param z0 Z-coordinate of the point.
CImg.h:       - To set pixel values without clipping needs, you should use the faster CImg::operator()() function.
CImg.h:        const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
CImg.h:       \param x0 X-coordinate of the starting line point.
CImg.h:       \param y0 Y-coordinate of the starting line point.
CImg.h:       \param x1 X-coordinate of the ending line point.
CImg.h:       \param y1 Y-coordinate of the ending line point.
CImg.h:       - Line routine uses Bresenham's algorithm.
CImg.h:       - Set \p init_hatch = false to draw consecutive hatched segments without breaking the line pattern.
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dy01 = y1 - y0;
CImg.h:        dx01*=-1; dy01*=-1;
CImg.h:      static unsigned int hatch = ~0U - (~0U>>1);
CImg.h:      if (init_hatch) hatch = ~0U - (~0U>>1);
CImg.h:        step = y0<=y1?1:-1,hdy01 = dy01*cimg::sign(dx01)/2,
CImg.h:          yy0 = y - y0,
CImg.h:        if (!(hatch>>=1)) hatch = ~0U - (~0U>>1);
CImg.h:    //! Draw a 2D line, with z-buffering.
CImg.h:       \param x0 X-coordinate of the starting point.
CImg.h:       \param y0 Y-coordinate of the starting point.
CImg.h:       \param z0 Z-coordinate of the starting point
CImg.h:       \param x1 X-coordinate of the ending point.
CImg.h:       \param y1 Y-coordinate of the ending point.
CImg.h:       \param z1 Z-coordinate of the ending point.
CImg.h:                                    "draw_line(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dy01 = y1 - y0;
CImg.h:      float diz01 = iz1 - iz0;
CImg.h:        dx01*=-1; dy01*=-1; diz01*=-1;
CImg.h:      static unsigned int hatch = ~0U - (~0U>>1);
CImg.h:      if (init_hatch) hatch = ~0U - (~0U>>1);
CImg.h:        step = y0<=y1?1:-1, hdy01 = dy01*cimg::sign(dx01)/2,
CImg.h:          yy0 = y - y0,
CImg.h:        if (!(hatch>>=1)) hatch = ~0U - (~0U>>1);
CImg.h:       \param x0 X-coordinate of the starting line point.
CImg.h:       \param y0 Y-coordinate of the starting line point.
CImg.h:       \param x1 X-coordinate of the ending line point.
CImg.h:       \param y1 Y-coordinate of the ending line point.
CImg.h:       \param tx0 X-coordinate of the starting texture point.
CImg.h:       \param ty0 Y-coordinate of the starting texture point.
CImg.h:       \param tx1 X-coordinate of the ending texture point.
CImg.h:       \param ty1 Y-coordinate of the ending texture point.
CImg.h:       - Line routine uses the well known Bresenham's algorithm.
CImg.h:      int w1 = width() - 1, h1 = height() - 1;
CImg.h:        dx01 = (longT)x1 - x0, dy01 = (longT)y1 - y0,
CImg.h:        dtx01 = (longT)tx1 - tx0, dty01 = (longT)ty1 - ty0;
CImg.h:        dx01*=-1; dy01*=-1; dtx01*=-1; dty01*=-1;
CImg.h:      static unsigned int hatch = ~0U - (~0U>>1);
CImg.h:      if (init_hatch) hatch = ~0U - (~0U>>1);
CImg.h:      const int step = y0<=y1?1:-1, cy0 = cimg::cut(y0,0,h1), cy1 = cimg::cut(y1,0,h1) + step;
CImg.h:          yy0 = (longT)y - y0,
CImg.h:        if (!(hatch>>=1)) hatch = ~0U - (~0U>>1);
CImg.h:       \param x0 X-coordinate of the starting point.
CImg.h:       \param y0 Y-coordinate of the starting point.
CImg.h:       \param z0 Z-coordinate of the starting point
CImg.h:       \param x1 X-coordinate of the ending point.
CImg.h:       \param y1 Y-coordinate of the ending point.
CImg.h:       \param z1 Z-coordinate of the ending point.
CImg.h:       \param tx0 X-coordinate of the starting texture point.
CImg.h:       \param ty0 Y-coordinate of the starting texture point.
CImg.h:       \param tx1 X-coordinate of the ending texture point.
CImg.h:       \param ty1 Y-coordinate of the ending texture point.
CImg.h:      int w1 = width() - 1, h1 = height() - 1;
CImg.h:      longT dx01 = (longT)x1 - x0, dy01 = (longT)y1 - y0;
CImg.h:        diz01 = iz1 - iz0,
CImg.h:        dtxz01 = txz1 - txz0, dtyz01 = tyz1 - tyz0;
CImg.h:        dx01*=-1; dy01*=-1; diz01*=-1; dtxz01*=-1; dtyz01*=-1;
CImg.h:      static unsigned int hatch = ~0U - (~0U>>1);
CImg.h:      if (init_hatch) hatch = ~0U - (~0U>>1);
CImg.h:      const int step = y0<=y1?1:-1, cy0 = cimg::cut(y0,0,h1), cy1 = cimg::cut(y1,0,h1) + step;
CImg.h:          yy0 = (longT)y - y0,
CImg.h:        if (!(hatch>>=1)) hatch = ~0U - (~0U>>1);
CImg.h:    //! Draw a textured 2D line, with perspective correction and z-buffering.
CImg.h:       \param zbuffer Z-buffer image.
CImg.h:       \param x0 X-coordinate of the starting point.
CImg.h:       \param y0 Y-coordinate of the starting point.
CImg.h:       \param z0 Z-coordinate of the starting point
CImg.h:       \param x1 X-coordinate of the ending point.
CImg.h:       \param y1 Y-coordinate of the ending point.
CImg.h:       \param z1 Z-coordinate of the ending point.
CImg.h:       \param tx0 X-coordinate of the starting texture point.
CImg.h:       \param ty0 Y-coordinate of the starting texture point.
CImg.h:       \param tx1 X-coordinate of the ending texture point.
CImg.h:       \param ty1 Y-coordinate of the ending texture point.
CImg.h:                                    "draw_line(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
CImg.h:      int w1 = width() - 1, h1 = height() - 1;
CImg.h:      longT dx01 = (longT)x1 - x0, dy01 = (longT)y1 - y0;
CImg.h:        diz01 = iz1 - iz0,
CImg.h:        dtxz01 = txz1 - txz0, dtyz01 = tyz1 - tyz0;
CImg.h:        dx01*=-1; dy01*=-1; diz01*=-1; dtxz01*=-1; dtyz01*=-1;
CImg.h:      static unsigned int hatch = ~0U - (~0U>>1);
CImg.h:      if (init_hatch) hatch = ~0U - (~0U>>1);
CImg.h:      const int step = y0<=y1?1:-1, cy0 = cimg::cut(y0,0,h1), cy1 = cimg::cut(y1,0,h1) + step;
CImg.h:          yy0 = (longT)y - y0,
CImg.h:        if (!(hatch>>=1)) hatch = ~0U - (~0U>>1);
CImg.h:       - This function uses several call to the single CImg::draw_line() procedure,
CImg.h:       \param x0 X-coordinate of the starting arrow point (tail).
CImg.h:       \param y0 Y-coordinate of the starting arrow point (tail).
CImg.h:       \param x1 X-coordinate of the ending arrow point (head).
CImg.h:       \param y1 Y-coordinate of the ending arrow point (head).
CImg.h:                        const float angle=30, const float length=-10,
CImg.h:      const float u = (float)(x0 - x1), v = (float)(y0 - y1), sq = u*u + v*v,
CImg.h:        l = (length>=0)?length:-length*(float)std::sqrt(sq)/100;
CImg.h:            cl = (float)std::cos(ang - deg), sl = (float)std::sin(ang - deg),
CImg.h:       \param x0 X-coordinate of the starting curve point
CImg.h:       \param y0 Y-coordinate of the starting curve point
CImg.h:       \param u0 X-coordinate of the starting velocity
CImg.h:       \param v0 Y-coordinate of the starting velocity
CImg.h:       \param x1 X-coordinate of the ending curve point
CImg.h:       \param y1 Y-coordinate of the ending curve point
CImg.h:       \param u1 X-coordinate of the ending velocity
CImg.h:       \param v1 Y-coordinate of the ending velocity
CImg.h:       - The curve is a 2D cubic Bezier spline, from the set of specified starting/ending points
CImg.h:       - The spline is drawn as a sequence of connected segments. The \p precision parameter sets the
CImg.h:       - A cubic Bezier curve is sometimes defined by a set of 4 points { (\p x0,\p y0), (\p xa,\p ya),
CImg.h:       \p u0 = (\p xa - \p x0), \p v0 = (\p ya - \p y0), \p u1 = (\p x1 - \p xb) and \p v1 = (\p y1 - \p yb).
CImg.h:       img.draw_spline(30,30,0,100,90,40,0,-100,color);
CImg.h:        ax = u0 + u1 + 2*(x0 - x1),
CImg.h:        bx = 3*(x1 - x0) - 2*u0 - u1,
CImg.h:        ay = v0 + v1 + 2*(y0 - y1),
CImg.h:        by = 3*(y1 - y0) - 2*v0 - v1,
CImg.h:        _precision = 1/(cimg::hypot((float)x0 - x1,(float)y0 - y1)*(precision>0?precision:1));
CImg.h:       \param x0 X-coordinate of the starting curve point
CImg.h:       \param y0 Y-coordinate of the starting curve point
CImg.h:       \param u0 X-coordinate of the starting velocity
CImg.h:       \param v0 Y-coordinate of the starting velocity
CImg.h:       \param x1 X-coordinate of the ending curve point
CImg.h:       \param y1 Y-coordinate of the ending curve point
CImg.h:       \param u1 X-coordinate of the ending velocity
CImg.h:       \param v1 Y-coordinate of the ending velocity
CImg.h:       \param tx0 X-coordinate of the starting texture point.
CImg.h:       \param ty0 Y-coordinate of the starting texture point.
CImg.h:       \param tx1 X-coordinate of the ending texture point.
CImg.h:       \param ty1 Y-coordinate of the ending texture point.
CImg.h:        return draw_point(x0,y0,texture.get_vector_at(x0<=0?0:x0>=texture.width()?texture.width() - 1:x0,
CImg.h:                                                      y0<=0?0:y0>=texture.height()?texture.height() - 1:y0).data(),
CImg.h:        ax = u0 + u1 + 2*(x0 - x1),
CImg.h:        bx = 3*(x1 - x0) - 2*u0 - u1,
CImg.h:        ay = v0 + v1 + 2*(y0 - y1),
CImg.h:        by = 3*(y1 - y0) - 2*v0 - v1,
CImg.h:        _precision = 1/(cimg::hypot((float)x0 - x1,(float)y0 - y1)*(precision>0?precision:1));
CImg.h:          ntx = tx0 + (int)((tx1 - tx0)*t1),
CImg.h:          nty = ty0 + (int)((ty1 - ty0)*t1);
CImg.h:            p0 = is_closed_set?(p + points.width() - 1)%points.width():(p?p - 1:0),
CImg.h:            u0 = x - x0,
CImg.h:            v0 = y - y0,
CImg.h:            n0 = 1e-8f + cimg::hypot(u0,v0),
CImg.h:            u1 = x1 - x,
CImg.h:            v1 = y1 - y,
CImg.h:            n1 = 1e-8f + cimg::hypot(u1,v1),
CImg.h:            n = 1e-8f + cimg::hypot(u,v),
CImg.h:            p0 = is_closed_set?(p + points.width() - 1)%points.width():(p?p - 1:0),
CImg.h:            u0 = x - x0,
CImg.h:            v0 = y - y0,
CImg.h:            w0 = z - z0,
CImg.h:            n0 = 1e-8f + cimg::hypot(u0,v0,w0),
CImg.h:            u1 = x1 - x,
CImg.h:            v1 = y1 - y,
CImg.h:            w1 = z1 - z,
CImg.h:            n1 = 1e-8f + cimg::hypot(u1,v1,w1),
CImg.h:            n = 1e-8f + cimg::hypot(u,v,w),
CImg.h:        h1 = height() - 1,
CImg.h:        dx01 = (longT)x1 - x0, dx02 = (longT)x2 - x0, dx12 = (longT)x2 - x1,
CImg.h:        dy01 = std::max((longT)1,(longT)y1 - y0),
CImg.h:        dy02 = std::max((longT)1,(longT)y2 - y0),
CImg.h:        dy12 = std::max((longT)1,(longT)y2 - y1),
CImg.h:        const longT yy0 = (longT)y - y0, yy1 = (longT)y - y1;
CImg.h:       \param x0 X-coordinate of the first vertex.
CImg.h:       \param y0 Y-coordinate of the first vertex.
CImg.h:       \param x1 X-coordinate of the second vertex.
CImg.h:       \param y1 Y-coordinate of the second vertex.
CImg.h:       \param x2 X-coordinate of the third vertex.
CImg.h:       \param y2 Y-coordinate of the third vertex.
CImg.h:       \param x0 X-coordinate of the first vertex.
CImg.h:       \param y0 Y-coordinate of the first vertex.
CImg.h:       \param x1 X-coordinate of the second vertex.
CImg.h:       \param y1 Y-coordinate of the second vertex.
CImg.h:       \param x2 X-coordinate of the third vertex.
CImg.h:       \param y2 Y-coordinate of the third vertex.
CImg.h:    //! Draw a filled 2D triangle, with z-buffering.
CImg.h:       \param zbuffer Z-buffer image.
CImg.h:       \param x0 X-coordinate of the first vertex.
CImg.h:       \param y0 Y-coordinate of the first vertex.
CImg.h:       \param z0 Z-coordinate of the first vertex.
CImg.h:       \param x1 X-coordinate of the second vertex.
CImg.h:       \param y1 Y-coordinate of the second vertex.
CImg.h:       \param z1 Z-coordinate of the second vertex.
CImg.h:       \param x2 X-coordinate of the third vertex.
CImg.h:       \param y2 Y-coordinate of the third vertex.
CImg.h:       \param z2 Z-coordinate of the third vertex.
CImg.h:                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
CImg.h:      const int w1 = width() - 1, h1 = height() - 1, cy0 = cimg::cut(y0,0,h1), cy2 = cimg::cut(y2,0,h1);
CImg.h:        dx01 = (longT)x1 - x0, dx02 = (longT)x2 - x0, dx12 = (longT)x2 - x1,
CImg.h:        dy01 = std::max((longT)1,(longT)y1 - y0),
CImg.h:        dy02 = std::max((longT)1,(longT)y2 - y0),
CImg.h:        dy12 = std::max((longT)1,(longT)y2 - y1),
CImg.h:      const float diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1;
CImg.h:        const longT yy0 = (longT)y - y0, yy1 = (longT)y - y1;
CImg.h:          const longT dxmM = std::max((longT)1,xM - xm);
CImg.h:          const float dizmM = izM - izm;
CImg.h:            const longT xxm = x - xm;
CImg.h:                const Tfloat val = cbs<=1?color[c]*cbs:(2 - cbs)*color[c] + (cbs - 1)*_sc_maxval;
CImg.h:    //! Draw a Gouraud-shaded 2D triangle.
CImg.h:       \param x0 X-coordinate of the first vertex in the image instance.
CImg.h:       \param y0 Y-coordinate of the first vertex in the image instance.
CImg.h:       \param x1 X-coordinate of the second vertex in the image instance.
CImg.h:       \param y1 Y-coordinate of the second vertex in the image instance.
CImg.h:       \param x2 X-coordinate of the third vertex in the image instance.
CImg.h:       \param y2 Y-coordinate of the third vertex in the image instance.
CImg.h:      const int w1 = width() - 1, h1 = height() - 1, cy0 = cimg::cut(y0,0,h1), cy2 = cimg::cut(y2,0,h1);
CImg.h:        dx01 = (longT)x1 - x0, dx02 = (longT)x2 - x0, dx12 = (longT)x2 - x1,
CImg.h:        dy01 = std::max((longT)1,(longT)y1 - y0),
CImg.h:        dy02 = std::max((longT)1,(longT)y2 - y0),
CImg.h:        dy12 = std::max((longT)1,(longT)y2 - y1),
CImg.h:      const float dbs01 = bs1 - bs0, dbs02 = bs2 - bs0, dbs12 = bs2 - bs1;
CImg.h:        const longT yy0 = (longT)y - y0, yy1 = (longT)y - y1;
CImg.h:          const longT dxmM = std::max((longT)1,xM - xm);
CImg.h:          const float dbsmM = bsM - bsm;
CImg.h:            const longT xxm = (longT)x - xm;
CImg.h:              const Tfloat val = cbs<=1?color[c]*cbs:(2 - cbs)*color[c] + (cbs - 1)*_sc_maxval;
CImg.h:    //! Draw a Gouraud-shaded 2D triangle, with z-buffering \overloading.
CImg.h:                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
CImg.h:        dbs01 = bs1 - bs0, dbs02 = bs2 - bs0, dbs12 = bs2 - bs1;
CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
CImg.h:          const int dxmM = std::max(1,xM - xm);
CImg.h:          const float dizmM = izM - izm, dbsmM = bsM - bsm;
CImg.h:            const int xxm = x - xm;
CImg.h:                const Tfloat val = cbs<=1?color[c]*cbs:(2 - cbs)*color[c] + (cbs - 1)*_sc_maxval;
CImg.h:    //! Draw a color-interpolated 2D triangle.
CImg.h:       \param x0 X-coordinate of the first vertex in the image instance.
CImg.h:       \param y0 Y-coordinate of the first vertex in the image instance.
CImg.h:       \param x1 X-coordinate of the second vertex in the image instance.
CImg.h:       \param y1 Y-coordinate of the second vertex in the image instance.
CImg.h:       \param x2 X-coordinate of the third vertex in the image instance.
CImg.h:       \param y2 Y-coordinate of the third vertex in the image instance.
CImg.h:      const int w1 = width() - 1, h1 = height() - 1, cy0 = cimg::cut(y0,0,h1), cy2 = cimg::cut(y2,0,h1);
CImg.h:        dx01 = (longT)x1 - x0, dx02 = (longT)x2 - x0, dx12 = (longT)x2 - x1,
CImg.h:        dy01 = std::max((longT)1,(longT)y1 - y0),
CImg.h:        dy02 = std::max((longT)1,(longT)y2 - y0),
CImg.h:        dy12 = std::max((longT)1,(longT)y2 - y1),
CImg.h:        const stc dcolor01 = color1[c] - color0[c], dcolor02 = color2[c] - color0[c], dcolor12 = color2[c] - color1[c];
CImg.h:          const longT yy0 = (longT)y - y0, yy1 = (longT)y - y1;
CImg.h:            const longT dxmM = std::max((longT)1,xM - xm);
CImg.h:            const stc dcolormM = colorM - colorm;
CImg.h:              const longT xxm = (longT)x - xm;
CImg.h:       \param x0 X-coordinate of the first vertex in the image instance.
CImg.h:       \param y0 Y-coordinate of the first vertex in the image instance.
CImg.h:       \param x1 X-coordinate of the second vertex in the image instance.
CImg.h:       \param y1 Y-coordinate of the second vertex in the image instance.
CImg.h:       \param x2 X-coordinate of the third vertex in the image instance.
CImg.h:       \param y2 Y-coordinate of the third vertex in the image instance.
CImg.h:       \param tx0 X-coordinate of the first vertex in the texture image.
CImg.h:       \param ty0 Y-coordinate of the first vertex in the texture image.
CImg.h:       \param tx1 X-coordinate of the second vertex in the texture image.
CImg.h:       \param ty1 Y-coordinate of the second vertex in the texture image.
CImg.h:       \param tx2 X-coordinate of the third vertex in the texture image.
CImg.h:       \param ty2 Y-coordinate of the third vertex in the texture image.
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
CImg.h:        dtx01 = tx1 - tx0, dtx02 = tx2 - tx0, dtx12 = tx2 - tx1,
CImg.h:        dty01 = ty1 - ty0, dty02 = ty2 - ty0, dty12 = ty2 - ty1,
CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
CImg.h:            dxmM = std::max(1,xM - xm), hdxmM = dxmM/2,
CImg.h:            dtxmM = txM - txm, dtymM = tyM - tym;
CImg.h:              xxm = x - xm,
CImg.h:              const Tfloat val = cbs<=1?color[c*twhd]*cbs:(2 - cbs)*color[c*twhd] + (cbs - 1)*_sc_maxval;
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
CImg.h:        dtxz01 = txz1 - txz0, dtxz02 = txz2 - txz0, dtxz12 = txz2 - txz1,
CImg.h:        dtyz01 = tyz1 - tyz0, dtyz02 = tyz2 - tyz0, dtyz12 = tyz2 - tyz1;
CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
CImg.h:          const int dxmM = std::max(1,xM - xm);
CImg.h:          const float dizmM = izM - izm, dtxzmM = txzM - txzm, dtyzmM = tyzM - tyzm;
CImg.h:            const int xxm = x - xm;
CImg.h:              const Tfloat val = cbs<=1?color[c*twhd]*cbs:(2 - cbs)*color[c*twhd] + (cbs - 1)*_sc_maxval;
CImg.h:    //! Draw a textured 2D triangle, with perspective correction and z-buffering.
CImg.h:                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
CImg.h:        dtxz01 = txz1 - txz0, dtxz02 = txz2 - txz0, dtxz12 = txz2 - txz1,
CImg.h:        dtyz01 = tyz1 - tyz0, dtyz02 = tyz2 - tyz0, dtyz12 = tyz2 - tyz1;
CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
CImg.h:          const int dxmM = std::max(1,xM - xm);
CImg.h:          const float dizmM = izM - izm, dtxzmM = txzM - txzm, dtyzmM = tyzM - tyzm;
CImg.h:            const int xxm = x - xm;
CImg.h:                const Tfloat val = cbs<=1?color[c*twhd]*cbs:(2 - cbs)*color[c*twhd] + (cbs - 1)*_sc_maxval;
CImg.h:    //! Draw a Phong-shaded 2D triangle.
CImg.h:       \param x0 X-coordinate of the first vertex in the image instance.
CImg.h:       \param y0 Y-coordinate of the first vertex in the image instance.
CImg.h:       \param x1 X-coordinate of the second vertex in the image instance.
CImg.h:       \param y1 Y-coordinate of the second vertex in the image instance.
CImg.h:       \param x2 X-coordinate of the third vertex in the image instance.
CImg.h:       \param y2 Y-coordinate of the third vertex in the image instance.
CImg.h:       \param lx0 X-coordinate of the first vertex in the light image.
CImg.h:       \param ly0 Y-coordinate of the first vertex in the light image.
CImg.h:       \param lx1 X-coordinate of the second vertex in the light image.
CImg.h:       \param ly1 Y-coordinate of the second vertex in the light image.
CImg.h:       \param lx2 X-coordinate of the third vertex in the light image.
CImg.h:       \param ly2 Y-coordinate of the third vertex in the light image.
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
CImg.h:        dlx01 = lx1 - lx0, dlx02 = lx2 - lx0, dlx12 = lx2 - lx1,
CImg.h:        dly01 = ly1 - ly0, dly02 = ly2 - ly0, dly12 = ly2 - ly1,
CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
CImg.h:            dxmM = std::max(1,xM - xm), hdxmM = dxmM/2,
CImg.h:            dlxmM = lxM - lxm, dlymM = lyM - lym;
CImg.h:              xxm = x - xm,
CImg.h:              const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
CImg.h:    //! Draw a Phong-shaded 2D triangle, with z-buffering.
CImg.h:                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
CImg.h:        dlx01 = lx1 - lx0, dlx02 = lx2 - lx0, dlx12 = lx2 - lx1,
CImg.h:        dly01 = ly1 - ly0, dly02 = ly2 - ly0, dly12 = ly2 - ly1,
CImg.h:      const float diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1;
CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
CImg.h:            dxmM = std::max(1,xM - xm), hdxmM = dxmM/2,
CImg.h:            dlxmM = lxM - lxm, dlymM = lyM - lym;
CImg.h:          const float dizmM = izM - izm;
CImg.h:            const int xxm = x - xm;
CImg.h:                const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
CImg.h:    //! Draw a textured Gouraud-shaded 2D triangle.
CImg.h:       \param x0 X-coordinate of the first vertex in the image instance.
CImg.h:       \param y0 Y-coordinate of the first vertex in the image instance.
CImg.h:       \param x1 X-coordinate of the second vertex in the image instance.
CImg.h:       \param y1 Y-coordinate of the second vertex in the image instance.
CImg.h:       \param x2 X-coordinate of the third vertex in the image instance.
CImg.h:       \param y2 Y-coordinate of the third vertex in the image instance.
CImg.h:       \param tx0 X-coordinate of the first vertex in the texture image.
CImg.h:       \param ty0 Y-coordinate of the first vertex in the texture image.
CImg.h:       \param tx1 X-coordinate of the second vertex in the texture image.
CImg.h:       \param ty1 Y-coordinate of the second vertex in the texture image.
CImg.h:       \param tx2 X-coordinate of the third vertex in the texture image.
CImg.h:       \param ty2 Y-coordinate of the third vertex in the texture image.
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
CImg.h:        dtx01 = tx1 - tx0, dtx02 = tx2 - tx0, dtx12 = tx2 - tx1,
CImg.h:        dty01 = ty1 - ty0, dty02 = ty2 - ty0, dty12 = ty2 - ty1,
CImg.h:      const float dbs01 = bs1 - bs0, dbs02 = bs2 - bs0, dbs12 = bs2 - bs1;
CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
CImg.h:            dxmM = std::max(1,xM - xm), hdxmM = dxmM/2,
CImg.h:            dtxmM = txM - txm, dtymM = tyM - tym;
CImg.h:          const float dbsmM = bsM - bsm;
CImg.h:              xxm = x - xm,
CImg.h:              const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
CImg.h:    //! Draw a textured Gouraud-shaded 2D triangle, with perspective correction \overloading.
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
CImg.h:        dtxz01 = txz1 - txz0, dtxz02 = txz2 - txz0, dtxz12 = txz2 - txz1,
CImg.h:        dtyz01 = tyz1 - tyz0, dtyz02 = tyz2 - tyz0, dtyz12 = tyz2 - tyz1,
CImg.h:        dbs01 = bs1 - bs0, dbs02 = bs2 - bs0, dbs12 = bs2 - bs1;
CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
CImg.h:          const int dxmM = std::max(1,xM - xm);
CImg.h:          const float dizmM = izM - izm, dtxzmM = txzM - txzm, dtyzmM = tyzM - tyzm, dbsmM = bsM - bsm;
CImg.h:            const int xxm = x - xm;
CImg.h:              const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
CImg.h:    //! Draw a textured Gouraud-shaded 2D triangle, with perspective correction and z-buffering \overloading.
CImg.h:                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
CImg.h:        dtxz01 = txz1 - txz0, dtxz02 = txz2 - txz0, dtxz12 = txz2 - txz1,
CImg.h:        dtyz01 = tyz1 - tyz0, dtyz02 = tyz2 - tyz0, dtyz12 = tyz2 - tyz1,
CImg.h:        dbs01 = bs1 - bs0, dbs02 = bs2 - bs0, dbs12 = bs2 - bs1;
CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
CImg.h:          const int dxmM = std::max(1,xM - xm);
CImg.h:          const float dizmM = izM - izm, dtxzmM = txzM - txzm, dtyzmM = tyzM - tyzm, dbsmM = bsM - bsm;
CImg.h:            const int xxm = x - xm;
CImg.h:                const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
CImg.h:    //! Draw a textured Phong-shaded 2D triangle.
CImg.h:       \param x0 X-coordinate of the first vertex in the image instance.
CImg.h:       \param y0 Y-coordinate of the first vertex in the image instance.
CImg.h:       \param x1 X-coordinate of the second vertex in the image instance.
CImg.h:       \param y1 Y-coordinate of the second vertex in the image instance.
CImg.h:       \param x2 X-coordinate of the third vertex in the image instance.
CImg.h:       \param y2 Y-coordinate of the third vertex in the image instance.
CImg.h:       \param tx0 X-coordinate of the first vertex in the texture image.
CImg.h:       \param ty0 Y-coordinate of the first vertex in the texture image.
CImg.h:       \param tx1 X-coordinate of the second vertex in the texture image.
CImg.h:       \param ty1 Y-coordinate of the second vertex in the texture image.
CImg.h:       \param tx2 X-coordinate of the third vertex in the texture image.
CImg.h:       \param ty2 Y-coordinate of the third vertex in the texture image.
CImg.h:       \param lx0 X-coordinate of the first vertex in the light image.
CImg.h:       \param ly0 Y-coordinate of the first vertex in the light image.
CImg.h:       \param lx1 X-coordinate of the second vertex in the light image.
CImg.h:       \param ly1 Y-coordinate of the second vertex in the light image.
CImg.h:       \param lx2 X-coordinate of the third vertex in the light image.
CImg.h:       \param ly2 Y-coordinate of the third vertex in the light image.
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
CImg.h:        dtx01 = tx1 - tx0, dtx02 = tx2 - tx0, dtx12 = tx2 - tx1,
CImg.h:        dty01 = ty1 - ty0, dty02 = ty2 - ty0, dty12 = ty2 - ty1,
CImg.h:        dlx01 = lx1 - lx0, dlx02 = lx2 - lx0, dlx12 = lx2 - lx1,
CImg.h:        dly01 = ly1 - ly0, dly02 = ly2 - ly0, dly12 = ly2 - ly1,
CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
CImg.h:            dxmM = std::max(1,xM - xm), hdxmM = dxmM/2,
CImg.h:            dtxmM = txM - txm, dtymM = tyM - tym,
CImg.h:            dlxmM = lxM - lxm, dlymM = lyM - lym;
CImg.h:              xxm = x - xm,
CImg.h:              const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
CImg.h:    //! Draw a textured Phong-shaded 2D triangle, with perspective correction.
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
CImg.h:        dtxz01 = txz1 - txz0, dtxz02 = txz2 - txz0, dtxz12 = txz2 - txz1,
CImg.h:        dtyz01 = tyz1 - tyz0, dtyz02 = tyz2 - tyz0, dtyz12 = tyz2 - tyz1,
CImg.h:        dlxz01 = lxz1 - lxz0, dlxz02 = lxz2 - lxz0, dlxz12 = lxz2 - lxz1,
CImg.h:        dlyz01 = lyz1 - lyz0, dlyz02 = lyz2 - lyz0, dlyz12 = lyz2 - lyz1;
CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
CImg.h:          const int dxmM = std::max(1,xM - xm);
CImg.h:            dizmM = izM - izm,
CImg.h:            dtxzmM = txzM - txzm, dtyzmM = tyzM - tyzm,
CImg.h:            dlxzmM = lxzM - lxzm, dlyzmM = lyzM - lyzm;
CImg.h:            const int xxm = x - xm;
CImg.h:              const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
CImg.h:    //! Draw a textured Phong-shaded 2D triangle, with perspective correction and z-buffering.
CImg.h:                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
CImg.h:        w1 = width() - 1, h1 = height() - 1,
CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
CImg.h:        dtxz01 = txz1 - txz0, dtxz02 = txz2 - txz0, dtxz12 = txz2 - txz1,
CImg.h:        dtyz01 = tyz1 - tyz0, dtyz02 = tyz2 - tyz0, dtyz12 = tyz2 - tyz1,
CImg.h:        dlxz01 = lxz1 - lxz0, dlxz02 = lxz2 - lxz0, dlxz12 = lxz2 - lxz1,
CImg.h:        dlyz01 = lyz1 - lyz0, dlyz02 = lyz2 - lyz0, dlyz12 = lyz2 - lyz1;
CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
CImg.h:          const int dxmM = std::max(1,xM - xm);
CImg.h:            dizmM = izM - izm,
CImg.h:            dtxzmM = txzM - txzm, dtyzmM = tyzM - tyzm,
CImg.h:            dlxzmM = lxzM - lxzm, dlyzmM = lyzM - lyzm;
CImg.h:            const int xxm = x - xm;
CImg.h:                const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
CImg.h:       \param x0 X-coordinate of the upper-left rectangle corner.
CImg.h:       \param y0 Y-coordinate of the upper-left rectangle corner.
CImg.h:       \param z0 Z-coordinate of the upper-left rectangle corner.
CImg.h:       \param c0 C-coordinate of the upper-left rectangle corner.
CImg.h:       \param x1 X-coordinate of the lower-right rectangle corner.
CImg.h:       \param y1 Y-coordinate of the lower-right rectangle corner.
CImg.h:       \param z1 Z-coordinate of the lower-right rectangle corner.
CImg.h:       \param c1 C-coordinate of the lower-right rectangle corner.
CImg.h:        lx = (1 + nx1 - nx0) + (nx1>=width()?width() - 1 - nx1:0) + (nx0<0?nx0:0),
CImg.h:        ly = (1 + ny1 - ny0) + (ny1>=height()?height() - 1 - ny1:0) + (ny0<0?ny0:0),
CImg.h:        lz = (1 + nz1 - nz0) + (nz1>=depth()?depth() - 1 - nz1:0) + (nz0<0?nz0:0),
CImg.h:        lc = (1 + nc1 - nc0) + (nc1>=spectrum()?spectrum() - 1 - nc1:0) + (nc0<0?nc0:0);
CImg.h:        offX = (ulongT)_width - lx,
CImg.h:        offY = (ulongT)_width*(_height - ly),
CImg.h:        offZ = (ulongT)_width*_height*(_depth - lz);
CImg.h:      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
CImg.h:       \param x0 X-coordinate of the upper-left rectangle corner.
CImg.h:       \param y0 Y-coordinate of the upper-left rectangle corner.
CImg.h:       \param z0 Z-coordinate of the upper-left rectangle corner.
CImg.h:       \param x1 X-coordinate of the lower-right rectangle corner.
CImg.h:       \param y1 Y-coordinate of the lower-right rectangle corner.
CImg.h:       \param z1 Z-coordinate of the lower-right rectangle corner.
CImg.h:       \param x0 X-coordinate of the upper-left rectangle corner.
CImg.h:       \param y0 Y-coordinate of the upper-left rectangle corner.
CImg.h:       \param x1 X-coordinate of the lower-right rectangle corner.
CImg.h:       \param y1 Y-coordinate of the lower-right rectangle corner.
CImg.h:      return draw_rectangle(x0,y0,0,x1,y1,_depth - 1,color,opacity);
CImg.h:        draw_line(nx1,ny0 + 1,nx1,ny1 - 1,color,opacity,pattern,false).
CImg.h:        draw_line(nx0,ny1 - 1,nx0,ny0 + 1,color,opacity,pattern,false);
CImg.h:      ymax = std::min(height() - 1,ymax);
CImg.h:      CImg<intT> Xs(points._width,ymax - ymin + 1);
CImg.h:            x01 = x1 - x0, y01 = y1 - y0, y12 = y2 - y1,
CImg.h:            tend = tmax - (step==cimg::sign(y12));
CImg.h:          unsigned int y = (unsigned int)y0 - ymin;
CImg.h:        const CImg<intT> Xsy = Xs.get_shared_points(0,count[y] - 1,y).sort();
CImg.h:       \param x0 X-coordinate of the ellipse center.
CImg.h:       \param y0 Y-coordinate of the ellipse center.
CImg.h:       \param x0 X-coordinate of the ellipse center.
CImg.h:       \param y0 Y-coordinate of the ellipse center.
CImg.h:       \param x0 X-coordinate of the ellipse center.
CImg.h:       \param y0 Y-coordinate of the ellipse center.
CImg.h:       \param x0 X-coordinate of the ellipse center.
CImg.h:       \param y0 Y-coordinate of the ellipse center.
CImg.h:      if (radius1<0 || radius2<0 || x0 - radiusM>=width() || y0 + radiusM<0 || y0 - radiusM>=height()) return *this;
CImg.h:          points(k,0) = (int)cimg::round(x0 + (X*ca - Y*sa));
CImg.h:          sa = -std::sin(ang),
CImg.h:          t2 = (i2 - i1)*casa,
CImg.h:          _ymin = (int)std::floor(y0 - radiusM),
CImg.h:          ymax = _ymax>=height()?height() - 1:_ymax;
CImg.h:            Y = y - y0 + 0.5f,
CImg.h:            C = t3*Y*Y - 1,
CImg.h:            D = B*B - 4*t1*C;
CImg.h:              xmin = (int)(x0 + cimg::round((-B - sD)/t12)),
CImg.h:              xmax = (int)(x0 + cimg::round((-B + sD)/t12));
CImg.h:       \param x0 X-coordinate of the circle center.
CImg.h:       \param y0 Y-coordinate of the circle center.
CImg.h:       - Circle version of the Bresenham's algorithm is used.
CImg.h:      if (radius<0 || x0 - radius>=width() || y0 + radius<0 || y0 - radius>=height()) return *this;
CImg.h:      if (y0>=0 && y0<height()) cimg_draw_scanline(x0 - radius,x0 + radius,y0,color,opacity,1);
CImg.h:      for (int f = 1 - radius, ddFx = 0, ddFy = -(radius<<1), x = 0, y = radius; x<y; ) {
CImg.h:          const int x1 = x0 - x, x2 = x0 + x, y1 = y0 - y, y2 = y0 + y;
CImg.h:          f+=(ddFy+=2); --y;
CImg.h:        const int x1 = x0 - y, x2 = x0 + y, y1 = y0 - x, y2 = y0 + x;
CImg.h:       \param x0 X-coordinate of the circle center.
CImg.h:       \param y0 Y-coordinate of the circle center.
CImg.h:      if (radius<0 || x0 - radius>=width() || y0 + radius<0 || y0 - radius>=height()) return *this;
CImg.h:      draw_point(x0 - radius,y0,color,opacity).draw_point(x0 + radius,y0,color,opacity).
CImg.h:        draw_point(x0,y0 - radius,color,opacity).draw_point(x0,y0 + radius,color,opacity);
CImg.h:      for (int f = 1 - radius, ddFx = 0, ddFy = -(radius<<1), x = 0, y = radius; x<y; ) {
CImg.h:        if (f>=0) { f+=(ddFy+=2); --y; }
CImg.h:          const int x1 = x0 - y, x2 = x0 + y, y1 = y0 - x, y2 = y0 + x,
CImg.h:            x3 = x0 - x, x4 = x0 + x, y3 = y0 - y, y4 = y0 + y;
CImg.h:       \param x0 X-coordinate of the sprite position.
CImg.h:       \param y0 Y-coordinate of the sprite position.
CImg.h:       \param z0 Z-coordinate of the sprite position.
CImg.h:       \param c0 C-coordinate of the sprite position.
CImg.h:        sx0 = dx0 - x0,  sy0 = dy0 - y0, sz0 = dz0 - z0, sc0 = dc0 - c0,
CImg.h:        lx = sprite.width() - sx0 - (x0 + sprite.width()>width()?x0 + sprite.width() - width():0),
CImg.h:        ly = sprite.height() - sy0 - (y0 + sprite.height()>height()?y0 + sprite.height() - height():0),
CImg.h:        lz = sprite.depth() - sz0 - (z0 + sprite.depth()>depth()?z0 + sprite.depth() - depth():0),
CImg.h:        lc = sprite.spectrum() - sc0 - (c0 + sprite.spectrum()>spectrum()?c0 + sprite.spectrum() - spectrum():0);
CImg.h:      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
CImg.h:        sx0 = dx0 - x0,  sy0 = dy0 - y0, sz0 = dz0 - z0, sc0 = dc0 - c0,
CImg.h:        lx = sprite.width() - sx0 - (x0 + sprite.width()>width()?x0 + sprite.width() - width():0),
CImg.h:        ly = sprite.height() - sy0 - (y0 + sprite.height()>height()?y0 + sprite.height() - height():0),
CImg.h:        lz = sprite.depth() - sz0 - (z0 + sprite.depth()>depth()?z0 + sprite.depth() - depth():0),
CImg.h:        lc = sprite.spectrum() - sc0 - (c0 + sprite.spectrum()>spectrum()?c0 + sprite.spectrum() - spectrum():0);
CImg.h:      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
CImg.h:       \param x0 X-coordinate of the sprite position in the image instance.
CImg.h:       \param y0 Y-coordinate of the sprite position in the image instance.
CImg.h:       \param z0 Z-coordinate of the sprite position in the image instance.
CImg.h:       \param c0 C-coordinate of the sprite position in the image instance.
CImg.h:       - Pixel values of \c mask set the opacity of the corresponding pixels in \c sprite.
CImg.h:       - Dimensions along x,y and z of \p sprite and \p mask must be the same.
CImg.h:        sx0 = dx0 - x0,  sy0 = dy0 - y0, sz0 = dz0 - z0, sc0 = dc0 - c0,
CImg.h:        lx = sprite.width() - sx0 - (x0 + sprite.width()>width()?x0 + sprite.width() - width():0),
CImg.h:        ly = sprite.height() - sy0 - (y0 + sprite.height()>height()?y0 + sprite.height() - height():0),
CImg.h:        lz = sprite.depth() - sz0 - (z0 + sprite.depth()>depth()?z0 + sprite.depth() - depth():0),
CImg.h:        lc = sprite.spectrum() - sc0 - (c0 + sprite.spectrum()>spectrum()?c0 + sprite.spectrum() - spectrum():0);
CImg.h:                  nopacity = cimg::abs(mopacity), copacity = mask_max_value - std::max(mopacity,0.f);
CImg.h:       \param x0 X-coordinate of the text in the image instance.
CImg.h:       \param y0 Y-coordinate of the text in the image instance.
CImg.h:       \param text Format of the text ('printf'-style format string).
CImg.h:       \param x0 X-coordinate of the text in the image instance.
CImg.h:       \param y0 Y-coordinate of the text in the image instance.
CImg.h:       \param text Format of the text ('printf'-style format string).
CImg.h:        // Pre-compute necessary size of the image as well as left paddings of each character.
CImg.h:                else if ((o_ch<'0' || o_ch>'9') && ch!='-') {
CImg.h:                      const int w1 = mask.width()>0?o_mask.width() - 1:0, w2 = w1>1?w1 - 1:0, w3 = w2>1?w2 - 1:0;
CImg.h:                      left_padding = -10;
CImg.h:                                 o_mask._width<=2 || o_mask(w2,k)>=8?-1:
CImg.h:                                 o_mask._width<=3 || o_mask(w3,k)>=8?-2:-3,
CImg.h:                                 mask._width<=2 || mask(1,k)>=8?-1:
CImg.h:                                 mask._width<=3 || mask(2,k)>=8?-2:-3;
CImg.h:          if (background_color) draw_rectangle(x,y,x + lw - 1,y + lh - 1,background_color,opacity);
CImg.h:                letter.assign(letter.get_resize(-100,-100,1,_spectrum,0,2),false);
CImg.h:                    draw_rectangle(x,y,0,c,posx + letter._width - 1,y + letter._height - 1,0,c,
CImg.h:      a_label+=(255 - a_label.get_dilate(3)).normalize(0,80);
CImg.h:      a_label.resize(-100,-100,1,3,1);
CImg.h:      return draw_image(0,is_down?height() - a_label.height():0,a_label,0.85f);
CImg.h:                         const unsigned int sampling=25, const float factor=-20,
CImg.h:       \param color Image of spectrum()-D vectors corresponding to the color of each arrow.
CImg.h:                         const unsigned int sampling=25, const float factor=-20,
CImg.h:        fact = -factor;
CImg.h:              draw_line((int)(x - 0.5*u),(int)(y - 0.5*v),(int)(x + 0.5*u),(int)(y + 0.5*v),
CImg.h:            else draw_line((int)(x - 0.5*u),(int)(y - 0.5*v),(int)(x + 0.5*u),(int)(y + 0.5*v),
CImg.h:       \param y Y-coordinate of the horizontal axis in the image instance.
CImg.h:      const int yt = (y + 3 + font_height)<_height?y + 3:y - 2 - (int)font_height;
CImg.h:      const int siz = (int)values_x.size() - 1;
CImg.h:        draw_line(0,y,_width - 1,y,color,opacity,pattern);
CImg.h:            _xt = (width() - a_label.width())/2,
CImg.h:            xt = _xt<3?3:_xt + a_label.width()>=width() - 2?width() - 3 - a_label.width():_xt;
CImg.h:          draw_point(width()/2,y - 1,color,opacity).draw_point(width()/2,y + 1,color,opacity);
CImg.h:        if (values_x[0]<values_x[siz]) draw_arrow(0,y,_width - 1,y,color,opacity,30,5,pattern);
CImg.h:        else draw_arrow(_width - 1,y,0,y,color,opacity,30,5,pattern);
CImg.h:            xi = (int)(x*(_width - 1)/siz),
CImg.h:            _xt = xi - a_label.width()/2,
CImg.h:            xt = _xt<3?3:_xt + a_label.width()>=width() - 2?width() - 3 - a_label.width():_xt;
CImg.h:          draw_point(xi,y - 1,color,opacity).draw_point(xi,y + 1,color,opacity);
CImg.h:       \param x X-coordinate of the vertical axis in the image instance.
CImg.h:       \param values_y Values along the Y-axis.
CImg.h:      int siz = (int)values_y.size() - 1;
CImg.h:        draw_line(x,0,x,_height - 1,color,opacity,pattern);
CImg.h:            _yt = (height() - a_label.height())/2,
CImg.h:            yt = _yt<0?0:_yt + a_label.height()>=height()?height() - 1 - a_label.height():_yt,
CImg.h:            _xt = x - 2 - a_label.width(),
CImg.h:          draw_point(x - 1,height()/2,color,opacity).draw_point(x + 1,height()/2,color,opacity);
CImg.h:        if (values_y[0]<values_y[siz]) draw_arrow(x,0,x,_height - 1,color,opacity,30,5,pattern);
CImg.h:        else draw_arrow(x,_height - 1,x,0,color,opacity,30,5,pattern);
CImg.h:            yi = (int)(y*(_height - 1)/siz),
CImg.h:            _yt = yi - a_label.height()/2,
CImg.h:            yt = _yt<0?0:_yt + a_label.height()>=height()?height() - 1 - a_label.height():_yt,
CImg.h:            _xt = x - 2 - a_label.width(),
CImg.h:          draw_point(x - 1,yi,color,opacity).draw_point(x + 1,yi,color,opacity);
CImg.h:       \param values_x Values along the X-axis.
CImg.h:       \param values_y Values along the Y-axis.
CImg.h:       \param pattern_x Drawing pattern for the X-axis.
CImg.h:       \param pattern_y Drawing pattern for the Y-axis.
CImg.h:      const int sizx = (int)values_x.size() - 1, wm1 = width() - 1;
CImg.h:            draw_axis(nx==0?x:x - 1,values_y,color,opacity,pattern_y,font_height,allow_zero,round_y);
CImg.h:      const int sizy = (int)values_y.size() - 1, hm1 = height() - 1;
CImg.h:            draw_axis(values_x,ny==0?y:y - 1,color,opacity,pattern_x,font_height,allow_zero,round_x);
CImg.h:                       const int subdivisionx=-60, const int subdivisiony=-60,
CImg.h:        dx = cimg::abs(x1 - x0), dy = cimg::abs(y1 - y0),
CImg.h:        px = dx<=0?1:precisionx==0?(float)std::pow(10.,(int)std::log10(dx) - 2.):precisionx,
CImg.h:        py = dy<=0?1:precisiony==0?(float)std::pow(10.,(int)std::log10(dy) - 2.):precisiony;
CImg.h:        draw_axes(CImg<floatT>::sequence(subdivisionx>0?subdivisionx:1-width()/subdivisionx,x0,x1),
CImg.h:                  CImg<floatT>::sequence(subdivisiony>0?subdivisiony:1-height()/subdivisiony,y0,y1),
CImg.h:        draw_axis((int)x0,CImg<floatT>::sequence(subdivisiony>0?subdivisiony:1-height()/subdivisiony,y0,y1),
CImg.h:        draw_axis(CImg<floatT>::sequence(subdivisionx>0?subdivisionx:1-width()/subdivisionx,x0,x1),(int)y0,
CImg.h:       \param values_x X-coordinates of the vertical lines.
CImg.h:       \param values_y Y-coordinates of the horizontal lines.
CImg.h:          if (xi>=0 && xi<width()) draw_line(xi,0,xi,_height - 1,color,opacity,pattern_x);
CImg.h:          if (yi>=0 && yi<height()) draw_line(0,yi,_width - 1,yi,color,opacity,pattern_y);
CImg.h:        const float dx = delta_x>0?delta_x:_width*-delta_x/100;
CImg.h:        if (invertx) cimg_foroff(seqx,x) seqx(x) = _width - 1 - seqx(x);
CImg.h:        const float dy = delta_y>0?delta_y:_height*-delta_y/100;
CImg.h:        if (inverty) cimg_foroff(seqy,y) seqy(y) = _height - 1 - seqy(y);
CImg.h:                      - 0 = No plot.
CImg.h:                      - 1 = Plot using segments.
CImg.h:                      - 2 = Plot using cubic splines.
CImg.h:                      - 3 = Plot with bars.
CImg.h:                      - 0 = No points.
CImg.h:                      - 1 = Point.
CImg.h:                      - 2 = Straight cross.
CImg.h:                      - 3 = Diagonal cross.
CImg.h:                      - 4 = Filled circle.
CImg.h:                      - 5 = Outlined circle.
CImg.h:                      - 6 = Square.
CImg.h:                      - 7 = Diamond.
CImg.h:       \param ymin Lower bound of the y-range.
CImg.h:       \param ymax Upper bound of the y-range.
CImg.h:         - if \c ymin==ymax==0, the y-range is computed automatically from the input samples.
CImg.h:        _siz1 = siz - (plot_type!=3),
CImg.h:        _width1 = _width - (plot_type!=3),
CImg.h:      if (m==M) { --m; ++M; }
CImg.h:      const float ca = (float)(M-m)/(_height - 1);
CImg.h:        int oX = 0, oY = (int)cimg::round((data[0] - m)/ca);
CImg.h:          const int Y = (int)cimg::round((*data - m)/ca);
CImg.h:          draw_line(0,Y,width() - 1,Y,color,opacity,pattern);
CImg.h:              X = (int)cimg::round(off*fx) - 1,
CImg.h:              Y = (int)cimg::round((data[off]-m)/ca);
CImg.h:        int oY = (int)cimg::round((data[0] - m)/ca);
CImg.h:          const int Y = (int)cimg::round((ndata._cubic_atX((float)x*siz1/width1)-m)/ca);
CImg.h:        const int Y0 = (int)cimg::round(-m/ca);
CImg.h:            X = (int)cimg::round((off + 1)*fx) - 1,
CImg.h:            Y = (int)cimg::round((data[off] - m)/ca);
CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
CImg.h:          draw_line(X - 3,Y,X + 3,Y,color,opacity).draw_line(X,Y - 3,X,Y + 3,color,opacity);
CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
CImg.h:          draw_line(X - 3,Y - 3,X + 3,Y + 3,color,opacity).draw_line(X - 3,Y + 3,X + 3,Y - 3,color,opacity);
CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
CImg.h:          draw_rectangle(X - 3,Y - 3,X + 3,Y + 3,color,opacity,~0U);
CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
CImg.h:          draw_line(X,Y - 4,X + 4,Y,color,opacity).
CImg.h:            draw_line(X,Y + 4,X - 4,Y,color,opacity).
CImg.h:            draw_line(X - 4,Y,X,Y - 4,color,opacity);
CImg.h:      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }
CImg.h:       \param x0 X-coordinate of the starting point of the region to fill.
CImg.h:       \param y0 Y-coordinate of the starting point of the region to fill.
CImg.h:       \param z0 Z-coordinate of the starting point of the region to fill.
CImg.h:       \param is_high_connectivity Tells if 8-connexity must be used.
CImg.h:#define _draw_fill_pop(x,y,z) x = stack[--N]; y = stack(N,1); z = stack(N,2)
CImg.h:      const float nopacity = cimg::abs((float)opacity), copacity = 1 - std::max((float)opacity,0.f);
CImg.h:          const int yp = y - 1, yn = y + 1, zp = z - 1, zn = z + 1;
CImg.h:          for (int step = -1; step<2; step+=2) {
CImg.h:                const int xp = x - 1, xn = x + 1;
CImg.h:            else xr = --x;
CImg.h:          std::memset(_region.data(xl,y,z),1,xr - xl + 1);
CImg.h:              const int dx = xr - xl + 1;
CImg.h:       \param alpha Alpha-parameter.
CImg.h:       \param beta Beta-parameter.
CImg.h:       \param scale Scale-parameter.
CImg.h:       \note Use the mid-point algorithm to render.
CImg.h:                                          r*cimg::rand(-1,1,&rng));
CImg.h:          for (int y = -delta2; y<h; y+=delta)
CImg.h:                                          r*cimg::rand(-1,1,&rng));
CImg.h:            for (int x = -delta2; x<w; x+=delta) {
CImg.h:                                          r*cimg::rand(-1,1,&rng));
CImg.h:          for (int y = -delta2; y<h; y+=delta)
CImg.h:            for (int x = -delta2; x<w; x+=delta) {
CImg.h:                                          r*cimg::rand(-1,1,&rng));
CImg.h:       \param x0 X-coordinate of the upper-left pixel.
CImg.h:       \param y0 Y-coordinate of the upper-left pixel.
CImg.h:       \param x1 X-coordinate of the lower-right pixel.
CImg.h:       \param y1 Y-coordinate of the lower-right pixel.
CImg.h:       \param z0r Real part of the upper-left fractal vertex.
CImg.h:       \param z0i Imaginary part of the upper-left fractal vertex.
CImg.h:       \param z1r Real part of the lower-right fractal vertex.
CImg.h:       \param z1i Imaginary part of the lower-right fractal vertex.
CImg.h:                             const double z0r=-2, const double z0i=-2, const double z1r=2, const double z1i=2,
CImg.h:      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f), ln2 = (float)std::log(2.);
CImg.h:        _x0 = cimg::cut(x0,0,width() - 1),
CImg.h:        _y0 = cimg::cut(y0,0,height() - 1),
CImg.h:        _x1 = cimg::cut(x1,0,width() - 1),
CImg.h:        _y1 = cimg::cut(y1,0,height() - 1);
CImg.h:                         cimg_openmp_if((1 + _x1 - _x0)*(1 + _y1 - _y0)>=(cimg_openmp_sizefactor)*2048))
CImg.h:          const double x = z0r + p*(z1r-z0r)/_width, y = z0i + q*(z1i-z0i)/_height;
CImg.h:            const double temp = zr*zr - zi*zi + cr;
CImg.h:              niteration = (float)(iteration + 1 - std::log(std::log(normz))/ln2);
CImg.h:                             const double z0r=-2, const double z0i=-2, const double z1r=2, const double z1i=2,
CImg.h:      return draw_mandelbrot(0,0,_width - 1,_height - 1,colormap,opacity,
CImg.h:       \param xc X-coordinate of the gaussian center.
CImg.h:      const float sigma2 = 2*sigma*sigma, nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
CImg.h:        const float dx = (x - xc), val = (float)std::exp(-dx*dx/sigma2);
CImg.h:        col-=_spectrum;
CImg.h:       \param xc X-coordinate of the gaussian center.
CImg.h:       \param yc Y-coordinate of the gaussian center.
CImg.h:      const CImg<tfloat> invT = tensor.get_invert(), invT2 = (invT*invT)/=-2.;
CImg.h:      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
CImg.h:      float dy = -yc;
CImg.h:        float dx = -xc;
CImg.h:          col-=_spectrum;
CImg.h:        b = (r1-r2)*ru*rv,
CImg.h:      const CImg<tfloat> invT = tensor.get_invert(), invT2 = (invT*invT)/=-2.;
CImg.h:      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
CImg.h:          dx = (x - xc), dy = (y - yc), dz = (z - zc),
CImg.h:        col-=_spectrum;
CImg.h:       \param x0 X-coordinate of the 3D object position
CImg.h:       \param y0 Y-coordinate of the 3D object position
CImg.h:       \param z0 Z-coordinate of the 3D object position
CImg.h:       \param lightx X-coordinate of the light
CImg.h:       \param lighty Y-coordinate of the light
CImg.h:       \param lightz Z-coordinate of the light
CImg.h:                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
CImg.h:                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
CImg.h:                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
CImg.h:                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
CImg.h:                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
CImg.h:                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
CImg.h:      if (render_type==5) cimg::mutex(10); // Static variable used in this case, breaks thread-safety
CImg.h:        nspec = 1 - (specular_lightness<0.f?0.f:(specular_lightness>1.f?1.f:specular_lightness)),
CImg.h:        nsl1 = (nspec2 - 1)/cimg::sqr(nspec - 1),
CImg.h:        nsl2 = 1 - 2*nsl1*nspec,
CImg.h:        nsl3 = nspec2 - nsl1 - nsl2;
CImg.h:      // Create light texture for phong-like rendering.
CImg.h:            (default_light_texture.assign(img,false)/=255).resize(-100,-100,1,_spectrum);
CImg.h:              dlx = lightx - X,
CImg.h:              dly = lighty - Y,
CImg.h:              dlz = lightz - Z,
CImg.h:              nlx = (default_light_texture._width - 1)/2*(1 + dlx/nl),
CImg.h:              nly = (default_light_texture._height - 1)/2*(1 + dly/nl),
CImg.h:            default_light_texture.resize(-100,-100,1,_spectrum);
CImg.h:      const float _focale = absfocale?absfocale:(1e5f-parallzmin);
CImg.h:      const tpfloat zmin = absfocale?(tpfloat)(1.5f - absfocale):cimg::type<tpfloat>::min();
CImg.h:            radius = 0.5f*cimg::hypot(vertices(i1,0) - vertices(i0,0),
CImg.h:                                      vertices(i1,1) - vertices(i0,1),
CImg.h:                                      vertices(i1,2) - vertices(i0,2))*(absfocale?absfocale/zc:1),
CImg.h:            xm = xc - radius,
CImg.h:            ym = yc - radius,
CImg.h:            const tpfloat d = (x1-x0)*(y2-y0) - (x2-x0)*(y1-y0);
CImg.h:            const float d = (x1 - x0)*(y2 - y0) - (x2 - x0)*(y1 - y0);
CImg.h:          if (___draw_object3d(opacities,l)!=1) zrange(l) = 2*zmax - zrange(l);
CImg.h:      const unsigned int nb_visibles = (unsigned int)(p_zrange - zrange._data);
CImg.h:              dx1 = x1 - x0, dy1 = y1 - y0, dz1 = z1 - z0,
CImg.h:              dx2 = x2 - x0, dy2 = y2 - y0, dz2 = z2 - z0,
CImg.h:              nx = dy1*dz2 - dz1*dy2,
CImg.h:              ny = dz1*dx2 - dx1*dz2,
CImg.h:              nz = dx1*dy2 - dy1*dx2,
CImg.h:              norm = 1e-5f + cimg::hypot(nx,ny,nz),
CImg.h:              lx = X + (x0 + x1 + x2)/3 - lightx,
CImg.h:              ly = Y + (y0 + y1 + y2)/3 - lighty,
CImg.h:              lz = Z + (z0 + z1 + z2)/3 - lightz,
CImg.h:              nl = 1e-5f + cimg::hypot(lx,ly,lz),
CImg.h:              factor = std::max(cimg::abs(-lx*nx - ly*ny - lz*nz)/(norm*nl),(tpfloat)0);
CImg.h:      case 5 : { // Phong-Shading
CImg.h:              dx1 = x1 - x0, dy1 = y1 - y0, dz1 = z1 - z0,
CImg.h:              dx2 = x2 - x0, dy2 = y2 - y0, dz2 = z2 - z0,
CImg.h:              nnx = dy1*dz2 - dz1*dy2,
CImg.h:              nny = dz1*dx2 - dx1*dz2,
CImg.h:              nnz = dx1*dy2 - dy1*dx2,
CImg.h:              norm = 1e-5f + cimg::hypot(nnx,nny,nnz),
CImg.h:              vertices_normals(p,0) = -nx1;
CImg.h:              vertices_normals(p,1) = -ny1;
CImg.h:              vertices_normals(p,2) = -nz1;
CImg.h:              norm = 1e-5f + cimg::hypot(nx,ny,nz),
CImg.h:              lx = X + vertices(l,0) - lightx,
CImg.h:              ly = Y + vertices(l,1) - lighty,
CImg.h:              lz = Z + vertices(l,2) - lightz,
CImg.h:              nl = 1e-5f + cimg::hypot(lx,ly,lz),
CImg.h:              factor = std::max((-lx*nx - ly*ny - lz*nz)/(norm*nl),(tpfloat)0);
CImg.h:            lw2 = light_texture._width/2 - 1,
CImg.h:            lh2 = light_texture._height/2 - 1;
CImg.h:              norm = 1e-5f + cimg::hypot(nx,ny,nz),
CImg.h:            __color.get_resize(-100,-100,-100,_spectrum,0):CImg<tc>(),
CImg.h:                board.drawDot((float)x0,height()-(float)y0);
CImg.h:              const int nx0 = x0 - (int)sw/2, ny0 = y0 - (int)sh/2;
CImg.h:                  (nx0 + (int)sw/2>=0 || nx0 - (int)sw/2<width() || ny0 + (int)sh/2>=0 || ny0 - (int)sh/2<height())) {
CImg.h:                    color.get_resize(sw,sh,1,-100,render_type<=3?1:3):CImg<tc>(),
CImg.h:                  board.drawRectangle((float)nx0,height() - (float)ny0,sw,sh);
CImg.h:            const int nx0 = x0 - (int)sw/2, ny0 = y0 - (int)sh/2;
CImg.h:                (nx0 + (int)sw/2>=0 || nx0 - (int)sw/2<width() || ny0 + (int)sh/2>=0 || ny0 - (int)sh/2<height())) {
CImg.h:                  color.get_resize(sw,sh,1,-100,render_type<=3?1:3):CImg<tc>(),
CImg.h:                  _opacity.get_resize(sw,sh,1,-100,render_type<=3?1:3):CImg<_to>(),
CImg.h:                board.drawRectangle((float)nx0,height() - (float)ny0,sw,sh);
CImg.h:              board.drawLine((float)x0,height() - (float)y0,x1,height() - (float)y1);
CImg.h:              board.drawDot((float)x0,height() - (float)y0);
CImg.h:              board.drawDot((float)x1,height() - (float)y1);
CImg.h:            radius = cimg::hypot(vertices(n1,0) - vertices(n0,0),
CImg.h:                                 vertices(n1,1) - vertices(n0,1),
CImg.h:                                 vertices(n1,2) - vertices(n0,2));
CImg.h:            radius = 0.5f*cimg::hypot(vertices(n1,0) - vertices(n0,0),
CImg.h:                                      vertices(n1,1) - vertices(n0,1),
CImg.h:                                      vertices(n1,2) - vertices(n0,2));
CImg.h:              board.drawDot(xc,height() - yc);
CImg.h:              board.drawCircle(xc,height() - yc,radius);
CImg.h:              if (!is_wireframe) board.fillCircle(xc,height() - yc,radius);
CImg.h:                board.drawCircle(xc,height() - yc,radius);
CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x1,height() - (float)y1);
CImg.h:            draw_point(x0,y0,color.get_vector_at(tx0<=0?0:tx0>=color.width()?color.width() - 1:tx0,
CImg.h:                                                 ty0<=0?0:ty0>=color.height()?color.height() - 1:ty0)._data,opacity).
CImg.h:              draw_point(x1,y1,color.get_vector_at(tx1<=0?0:tx1>=color.width()?color.width() - 1:tx1,
CImg.h:                                                   ty1<=0?0:ty1>=color.height()?color.height() - 1:ty1)._data,opacity);
CImg.h:              board.drawDot((float)x0,height() - (float)y0);
CImg.h:              board.drawDot((float)x1,height() - (float)y1);
CImg.h:              board.drawDot((float)x0,height() - (float)y0);
CImg.h:              board.drawDot((float)x1,height() - (float)y1);
CImg.h:              board.drawDot((float)x2,height() - (float)y2);
CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x1,height() - (float)y1);
CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x2,height() - (float)y2);
CImg.h:              board.drawLine((float)x1,height() - (float)y1,(float)x2,height() - (float)y2);
CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
CImg.h:                                 (float)x1,height() - (float)y1,
CImg.h:                                 (float)x2,height() - (float)y2);
CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
CImg.h:                                 (float)x1,height() - (float)y1,
CImg.h:                                 (float)x2,height() - (float)y2);
CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,lightprops(n0),
CImg.h:                                         (float)x1,height() - (float)y1,lightprops(n1),
CImg.h:                                         (float)x2,height() - (float)y2,lightprops(n2));
CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,l0,
CImg.h:                                         (float)x1,height() - (float)y1,l1,
CImg.h:                                         (float)x2,height() - (float)y2,l2);
CImg.h:              board.drawDot((float)x0,height() - (float)y0);
CImg.h:              board.drawDot((float)x1,height() - (float)y1);
CImg.h:              board.drawDot((float)x2,height() - (float)y2);
CImg.h:              board.drawDot((float)x3,height() - (float)y3);
CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x1,height() - (float)y1);
CImg.h:              board.drawLine((float)x1,height() - (float)y1,(float)x2,height() - (float)y2);
CImg.h:              board.drawLine((float)x2,height() - (float)y2,(float)x3,height() - (float)y3);
CImg.h:              board.drawLine((float)x3,height() - (float)y3,(float)x0,height() - (float)y0);
CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
CImg.h:                                 (float)x1,height() - (float)y1,
CImg.h:                                 (float)x2,height() - (float)y2);
CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
CImg.h:                                 (float)x2,height() - (float)y2,
CImg.h:                                 (float)x3,height() - (float)y3);
CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
CImg.h:                                 (float)x1,height() - (float)y1,
CImg.h:                                 (float)x2,height() - (float)y2);
CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
CImg.h:                                 (float)x2,height() - (float)y2,
CImg.h:                                 (float)x3,height() - (float)y3);
CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,lightprop0,
CImg.h:                                         (float)x1,height() - (float)y1,lightprop1,
CImg.h:                                         (float)x2,height() - (float)y2,lightprop2);
CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,lightprop0,
CImg.h:                                         (float)x2,height() - (float)y2,lightprop2,
CImg.h:                                         (float)x3,height() - (float)y3,lightprop3);
CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,l0,
CImg.h:                                         (float)x1,height() - (float)y1,l1,
CImg.h:                                         (float)x2,height() - (float)y2,l2);
CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,l0,
CImg.h:                                         (float)x2,height() - (float)y2,l2,
CImg.h:                                         (float)x3,height() - (float)y3,l3);
CImg.h:            draw_point(x0,y0,color.get_vector_at(tx0<=0?0:tx0>=color.width()?color.width() - 1:tx0,
CImg.h:                                                 ty0<=0?0:ty0>=color.height()?color.height() - 1:ty0)._data,opacity).
CImg.h:              draw_point(x1,y1,color.get_vector_at(tx1<=0?0:tx1>=color.width()?color.width() - 1:tx1,
CImg.h:                                                   ty1<=0?0:ty1>=color.height()?color.height() - 1:ty1)._data,opacity).
CImg.h:              draw_point(x2,y2,color.get_vector_at(tx2<=0?0:tx2>=color.width()?color.width() - 1:tx2,
CImg.h:                                                   ty2<=0?0:ty2>=color.height()?color.height() - 1:ty2)._data,opacity);
CImg.h:              board.drawDot((float)x0,height() - (float)y0);
CImg.h:              board.drawDot((float)x1,height() - (float)y1);
CImg.h:              board.drawDot((float)x2,height() - (float)y2);
CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x1,height() - (float)y1);
CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x2,height() - (float)y2);
CImg.h:              board.drawLine((float)x1,height() - (float)y1,(float)x2,height() - (float)y2);
CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
CImg.h:                                 (float)x1,height() - (float)y1,
CImg.h:                                 (float)x2,height() - (float)y2);
CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
CImg.h:                                 (float)x1,height() - (float)y1,
CImg.h:                                 (float)x2,height() - (float)y2);
CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,lightprops(n0),
CImg.h:                                        (float)x1,height() - (float)y1,lightprops(n1),
CImg.h:                                        (float)x2,height() - (float)y2,lightprops(n2));
CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,l0,
CImg.h:                                        (float)x1,height() - (float)y1,l1,
CImg.h:                                        (float)x2,height() - (float)y2,l2);
CImg.h:            draw_point(x0,y0,color.get_vector_at(tx0<=0?0:tx0>=color.width()?color.width() - 1:tx0,
CImg.h:                                                 ty0<=0?0:ty0>=color.height()?color.height() - 1:ty0)._data,opacity).
CImg.h:              draw_point(x1,y1,color.get_vector_at(tx1<=0?0:tx1>=color.width()?color.width() - 1:tx1,
CImg.h:                                                   ty1<=0?0:ty1>=color.height()?color.height() - 1:ty1)._data,opacity).
CImg.h:              draw_point(x2,y2,color.get_vector_at(tx2<=0?0:tx2>=color.width()?color.width() - 1:tx2,
CImg.h:                                                   ty2<=0?0:ty2>=color.height()?color.height() - 1:ty2)._data,opacity).
CImg.h:              draw_point(x3,y3,color.get_vector_at(tx3<=0?0:tx3>=color.width()?color.width() - 1:tx3,
CImg.h:                                                   ty3<=0?0:ty3>=color.height()?color.height() - 1:ty3)._data,opacity);
CImg.h:              board.drawDot((float)x0,height() - (float)y0);
CImg.h:              board.drawDot((float)x1,height() - (float)y1);
CImg.h:              board.drawDot((float)x2,height() - (float)y2);
CImg.h:              board.drawDot((float)x3,height() - (float)y3);
CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x1,height() - (float)y1);
CImg.h:              board.drawLine((float)x1,height() - (float)y1,(float)x2,height() - (float)y2);
CImg.h:              board.drawLine((float)x2,height() - (float)y2,(float)x3,height() - (float)y3);
CImg.h:              board.drawLine((float)x3,height() - (float)y3,(float)x0,height() - (float)y0);
CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
CImg.h:                                 (float)x1,height() - (float)y1,
CImg.h:                                 (float)x2,height() - (float)y2);
CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
CImg.h:                                 (float)x2,height() - (float)y2,
CImg.h:                                 (float)x3,height() - (float)y3);
CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
CImg.h:                                 (float)x1,height() - (float)y1,
CImg.h:                                 (float)x2,height() - (float)y2);
CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
CImg.h:                                 (float)x2,height() - (float)y2,
CImg.h:                                 (float)x3,height() - (float)y3);
CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,lightprop0,
CImg.h:                                         (float)x1,height() - (float)y1,lightprop1,
CImg.h:                                         (float)x2,height() - (float)y2,lightprop2);
CImg.h:              board.fillGouraudTriangle((float)x0,height()  -(float)y0,lightprop0,
CImg.h:                                         (float)x2,height() - (float)y2,lightprop2,
CImg.h:                                         (float)x3,height() - (float)y3,lightprop3);
CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,l0,
CImg.h:                                         (float)x1,height() - (float)y1,l1,
CImg.h:                                         (float)x2,height() - (float)y2,l2);
CImg.h:              board.fillGouraudTriangle((float)x0,height()  -(float)y0,l0,
CImg.h:                                         (float)x2,height() - (float)y2,l2,
CImg.h:                                         (float)x3,height() - (float)y3,l3);
CImg.h:    //---------------------------
CImg.h:    //---------------------------
CImg.h:      if (is_empty()) return CImg<intT>(1,feature_type==0?3:6,1,1,-1);
CImg.h:        get_resize(cimg_fitscreen(width(),height(),depth()),depth(),-100).move_to(thumb);
CImg.h:        X1 =-1, Y1 = -1, Z1 = -1,
CImg.h:        X3d = -1, Y3d = -1,
CImg.h:        oX3d = X3d, oY3d = -1,
CImg.h:        omx = -1, omy = -1;
CImg.h:      float X = -1, Y = -1, Z = -1;
CImg.h:          mX = mx<0?-1.f:(float)mx*(width() + (depth()>1?depth():0))/disp.width(),
CImg.h:          mY = my<0?-1.f:(float)my*(height() + (depth()>1?depth():0))/disp.height();
CImg.h:        if (mX>=0 && mX<width() && mY>=height()) { area = 2; X = mX; Z = mY - _height; Y = (float)(phase?Y1:Y0); }
CImg.h:        if (mY>=0 && mX>=width() && mY<height()) { area = 3; Y = mY; Z = mX - _width; X = (float)(phase?X1:X0); }
CImg.h:          if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) { disp.set_wheel(-1); key = 0; } break;
CImg.h:              resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
CImg.h:                     CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false).
CImg.h:          mx = my = -1; X = Y = Z = -1;
CImg.h:            X3d = mx - width()*disp.width()/(width() + (depth()>1?depth():0));
CImg.h:            Y3d = my - height()*disp.height()/(height() + (depth()>1?depth():0));
CImg.h:            if ((disp.button()&3)==3) { pose3d.assign(); view3d.assign(); oX3d = oY3d = X3d = Y3d = -1; }
CImg.h:                u0 = (float)(oX3d - view3d.width()/2),
CImg.h:                v0 = (float)(oY3d - view3d.height()/2),
CImg.h:                u1 = (float)(X3d - view3d.width()/2),
CImg.h:                v1 = (float)(Y3d - view3d.height()/2),
CImg.h:                nw0 = (float)std::sqrt(std::max(0.f,R2 - nu0*nu0 - nv0*nv0)),
CImg.h:                nw1 = (float)std::sqrt(std::max(0.f,R2 - nu1*nu1 - nv1*nv1)),
CImg.h:                u = nv0*nw1 - nw0*nv1,
CImg.h:                v = nw0*nu1 - nu0*nw1,
CImg.h:                w = nv0*nu1 - nu0*nv1,
CImg.h:              pose3d.draw_image(CImg<floatT>::rotation_matrix(u,v,w,-alpha)*pose3d.get_crop(0,0,2,2));
CImg.h:              pose3d(3,2)+=(Y3d - oY3d)*1.5f; view3d.assign();
CImg.h:              pose3d(3,2)-=disp.wheel()*15; view3d.assign(); disp.set_wheel();
CImg.h:              pose3d(3,0)-=oX3d - X3d; pose3d(3,1)-=oY3d - Y3d; view3d.assign();
CImg.h:          mx = my = -1; X = Y = Z = -1;
CImg.h:        if (X0>=width()) X0 = width() - 1;
CImg.h:        if (Y0>=height()) Y0 = height() - 1;
CImg.h:        if (Z0>=depth()) Z0 = depth() - 1;
CImg.h:        if (X1>=width()) X1 = width() - 1;
CImg.h:        if (Y1>=height()) Y1 = height() - 1;
CImg.h:        if (Z1>=depth()) Z1 = depth() - 1;
CImg.h:              x3d = _x3d>=visu0._width?visu0._width - 1:_x3d,
CImg.h:              y3d = _y3d>=visu0._height?visu0._height - 1:_y3d;
CImg.h:            CImg<ucharT>(1,2,1,1,64,128).resize(visu0._width - x3d,visu0._height - y3d,1,visu0._spectrum,3).
CImg.h:                                           0,_width - 1,_width - 1,0,0,_width - 1,_width - 1,0,
CImg.h:                                           0,0,_height - 1,_height - 1,0,0,_height - 1,_height - 1,
CImg.h:                                           0,0,0,0,_depth - 1,_depth - 1,_depth - 1,_depth - 1),'x');
CImg.h:              points3d.shift_object3d(-0.5f*(_width - 1),-0.5f*(_height - 1),-0.5f*(_depth - 1)).resize_object3d();
CImg.h:              _xn = (int)((_vX + 1.f)*w/W - 1), xn = _xn + ((int)((_xn + 1.f)*W/w)!=_vX + 1),
CImg.h:              _yn = (int)((_vY + 1.f)*h/H - 1), yn = _yn + ((int)((_yn + 1.f)*H/h)!=_vY + 1),
CImg.h:              _zxn = (int)((_vZ + width() + 1.f)*w/W - 1),
CImg.h:              _zyn = (int)((_vZ + height() + 1.f)*h/H - 1),
CImg.h:              _xM = (int)(width()*(float)w/W - 1), xM = _xM + ((int)((_xM + 1.f)*W/w)!=width()),
CImg.h:              _yM = (int)(height()*(float)h/H - 1), yM = _yM + ((int)((_yM + 1.f)*H/h)!=height()),
CImg.h:              visu.draw_line(0,yf,visu.width() - 1,yf,foreground_color,0.7f,0xFF00FF00).
CImg.h:                draw_line(0,yf,visu.width() - 1,yf,background_color,0.7f,0x00FF00FF).
CImg.h:                draw_line(xf,0,xf,visu.height() - 1,foreground_color,0.7f,0xFF00FF00).
CImg.h:                draw_line(xf,0,xf,visu.height() - 1,background_color,0.7f,0x00FF00FF);
CImg.h:            if (xn - xp>=4 && yn - yp>=4)
CImg.h:              if (yn - yp>=4 && zxn - zxp>=4)
CImg.h:              if (xn - xp>=4 && zyn - zyp>=4)
CImg.h:                _xn0 = (int)((X0 + 1.f)*w/W - 1), xn0 = _xn0 + ((int)((_xn0 + 1.f)*W/w)!=X0 + 1),
CImg.h:                _yn0 = (int)((Y0 + 1.f)*h/H - 1), yn0 = _yn0 + ((int)((_yn0 + 1.f)*H/h)!=Y0 + 1),
CImg.h:                _zxn0 = (int)((Z0 + width() + 1.f)*w/W - 1),
CImg.h:                _zyn0 = (int)((Z0 + height() + 1.f)*h/H - 1),
CImg.h:                                  (float)cimg::abs(xc - xc0),
CImg.h:                                  (float)cimg::abs(yc - yc0),0,background_color,0.2f).
CImg.h:                               (float)cimg::abs(xc - xc0),
CImg.h:                               (float)cimg::abs(yc - yc0),0,foreground_color,0.9f,~0U).
CImg.h:                  visu.draw_ellipse(zxc0,yc0,(float)cimg::abs(zxc - zxc0),(float)cimg::abs(yc - yc0),0,
CImg.h:                    draw_ellipse(zxc0,yc0,(float)cimg::abs(zxc - zxc0),(float)cimg::abs(yc - yc0),0,
CImg.h:                    draw_ellipse(xc0,zyc0,(float)cimg::abs(xc - xc0),(float)cimg::abs(zyc - zyc0),0,
CImg.h:                    draw_ellipse(xc0,zyc0,(float)cimg::abs(xc - xc0),(float)cimg::abs(zyc - zyc0),0,
CImg.h:            if (my>=0 && my<13) text_down = true; else if (my>=visu.height() - 13) text_down = false;
CImg.h:                  values.draw_image(0,4,values.get_rows(values._height - 4,values._height - 1)).resize(1,8,1,1,0);
CImg.h:                const double dX = (double)(X0 - X1), dY = (double)(Y0 - Y1), dZ = (double)(Z0 - Z1),
CImg.h:                  cimg_snprintf(text,text._width," Vect (%d,%d,%d)-(%d,%d,%d), Length = %g ",
CImg.h:                  cimg_snprintf(text,text._width," Vect (%d,%d)-(%d,%d), Length = %g, Angle = %g\260 ",
CImg.h:                                cimg::round(cimg::mod(180*std::atan2(-dY,-dX)/cimg::PI,360.),0.1));
CImg.h:                  cimg_snprintf(text,text._width," Vect (%d,%d)-(%d,%d), Length = %g ",
CImg.h:                const double dX = (double)(X0 - X1), dY = (double)(Y0 - Y1), dZ = (double)(Z0 - Z1),
CImg.h:                                " Box ( %d,%d,%d ) - ( %d,%d,%d )\n Size = ( %d,%d,%d ), Length = %g ",
CImg.h:                                1 + cimg::abs(X0 - X1),1 + cimg::abs(Y0 - Y1),1 + cimg::abs(Z0 - Z1),length);
CImg.h:                                " Box ( %d,%d ) - ( %d,%d )\n Size = ( %d,%d ), Length = %g \n Angle = %g\260 ",
CImg.h:                                1 + cimg::abs(X0 - X1),1 + cimg::abs(Y0 - Y1),length,
CImg.h:                                cimg::round(cimg::mod(180*std::atan2(-dY,-dX)/cimg::PI,360.),0.1));
CImg.h:                                " Box ( %d,%d ) - ( %d,%d )\n Size = (%d,%d), Length = %g ",
CImg.h:                                1 + cimg::abs(X0 - X1),1 + cimg::abs(Y0 - Y1),length);
CImg.h:                  cimg_snprintf(text,text._width," Ellipse ( %d,%d,%d ) - ( %d,%d,%d ), Radii = ( %d,%d,%d ) ",
CImg.h:                                1 + cimg::abs(X0 - X1),1 + cimg::abs(Y0 - Y1),1 + cimg::abs(Z0 - Z1));
CImg.h:                else cimg_snprintf(text,text._width," Ellipse ( %d,%d ) - ( %d,%d ), Radii = ( %d,%d ) ",
CImg.h:                                   1 + cimg::abs(X0 - X1),1 + cimg::abs(Y0 - Y1));
CImg.h:      CImg<intT> res(1,feature_type==0?3:6,1,1,-1);
CImg.h:            case 1 : Z0 = 0; Z1 = _depth - 1; break;
CImg.h:            case 2 : Y0 = 0; Y1 = _height - 1; break;
CImg.h:            case 3 : X0 = 0; X1 = _width - 1; break;
CImg.h:        if (X1<0 || Y1<0 || Z1<0) X0 = Y0 = Z0 = X1 = Y1 = Z1 = -1;
CImg.h:          res[3] = cimg::abs(X1 - X0); res[4] = cimg::abs(Y1 - Y0); res[5] = cimg::abs(Z1 - Z0);
CImg.h:      const CImg<T> crop = get_shared_channels(0,std::min(2,spectrum() - 1));
CImg.h:          crop.get_resize(-100,-100,mdisp,-100,0).move_to(img2d);
CImg.h:            val_minf = (T)(normalization==1 || normalization==3?m0 - cimg::abs(m0):m0),
CImg.h:              if (cimg::type<T>::is_inf(*ptr)) *ptr = (float)*ptr<0?val_minf:val_pinf; // Replace +-inf values
CImg.h:        (img2d-=m)*=255.f/(M - m>0?M - m:1);
CImg.h:          (img2d-=m)*=255.f/(M - m>0?M - m:1);
CImg.h:    //! Select sub-graph in a graph.
CImg.h:      if (nymin==nymax) { nymin = (Tfloat)min_max(nymax); const double dy = nymax - nymin; nymin-=dy/20; nymax+=dy/20; }
CImg.h:      if (nymin==nymax) { --nymin; ++nymax; }
CImg.h:      if (nxmin==nxmax && nxmin==0) { nxmin = 0; nxmax = siz - 1.; }
CImg.h:          cimg_for_inY(colormap,6,colormap.height()-1,k) {
CImg.h:            colormap(0,k) = (unsigned char)(120 + cimg::rand(-100.f,100.f,&rng));
CImg.h:            colormap(1,k) = (unsigned char)(120 + cimg::rand(-100.f,100.f,&rng));
CImg.h:            colormap(2,k) = (unsigned char)(120 + cimg::rand(-100.f,100.f,&rng));
CImg.h:      int x0 = -1, x1 = -1, y0 = -1, y1 = -1, omouse_x = -2, omouse_y = -2;
CImg.h:          const int gdimx = disp.width() - 32, gdimy = disp.height() - 32;
CImg.h:              if (siz>1) graph.draw_grid(gdimx/(float)(siz - one),gdimy/(float)(siz - one),0,0,
CImg.h:            } else graph.draw_grid(-10,-10,0,0,false,true,black,0.2f,0x33333333,0x33333333);
CImg.h:              dx = (float)cimg::abs(nxmax - nxmin), dy = (float)cimg::abs(nymax - nymin),
CImg.h:              px = (float)std::pow(10.,(int)std::log10(dx?dx:1) - 2.),
CImg.h:              py = (float)std::pow(10.,(int)std::log10(dy?dy:1) - 2.);
CImg.h:                CImg<Tdouble>::sequence(1 + gdimx/60,nxmin,one?nxmax:nxmin + (nxmax - nxmin)*(siz + 1)/siz),
CImg.h:            if (nymin>0) axes.draw_axis(seqx,gdimy - 1,gray,1,~0U,13,allow_zero,px);
CImg.h:            if (nxmax<0) axes.draw_axis(gdimx - 1,seqy,gray,1,~0U,13,allow_zero,py);
CImg.h:          text.assign().draw_text(0,0,labelx?labelx:"X-axis",white,ngray,1,13).resize(-100,-100,1,3);
CImg.h:          visu0.draw_image((visu0.width() - text.width())/2,visu0.height() - 14,~text);
CImg.h:          text.assign().draw_text(0,0,labely?labely:"Y-axis",white,ngray,1,13).rotate(-90).resize(-100,-100,1,3);
CImg.h:          visu0.draw_image(1,(visu0.height() - text.height())/2,~text);
CImg.h:              sx0 = (int)(16 + nx0*(visu.width() - 32)/std::max((ulongT)1,siz - one)),
CImg.h:              sx1 = (int)(15 + (nx1 + 1)*(visu.width() - 32)/std::max((ulongT)1,siz - one)),
CImg.h:            else visu.draw_rectangle(sx0,0,sx1,visu.height() - 17,gray,0.5f).
CImg.h:                   draw_line(sx0,16,sx0,visu.height() - 17,black,0.5f,0xCCCCCCCCU).
CImg.h:                   draw_line(sx1,16,sx1,visu.height() - 17,black,0.5f,0xCCCCCCCCU);
CImg.h:          if (mouse_x>=16 && mouse_y>=16 && mouse_x<visu.width() - 16 && mouse_y<visu.height() - 16) {
CImg.h:            if (graph) visu.draw_line(mouse_x,16,mouse_x,visu.height() - 17,black,0.5f,0x55555555U);
CImg.h:              x = (unsigned int)cimg::round((mouse_x - 16.f)*(siz - one)/(disp.width() - 32),1,one?0:-1);
CImg.h:            const double cx = nxmin + x*(nxmax - nxmin)/std::max((ulongT)1,siz - 1);
CImg.h:                            (double)(*this)(x,0,0,_spectrum - 4),(double)(*this)(x,0,0,_spectrum - 3),
CImg.h:                            (double)(*this)(x,0,0,_spectrum - 1));
CImg.h:                cx0 = nxmin + nx0*(nxmax - nxmin)/std::max((ulongT)1,siz - 1),
CImg.h:                cx1 = nxmin + (nx1 + one)*(nxmax - nxmin)/std::max((ulongT)1,siz - 1),
CImg.h:                cy0 = nymax - ny0*(nymax - nymin)/(visu._height - 32),
CImg.h:                cy1 = nymax - ny1*(nymax - nymin)/(visu._height - 32);
CImg.h:                cimg_sprintf(message._data + std::strlen(message)," - Range ( %u:%g, %g ) - ( %u:%g, %g )",
CImg.h:                cimg_sprintf(message._data + std::strlen(message)," - Range [ %u:%g - %u:%g ]",
CImg.h:            text.assign().draw_text(0,0,message,white,ngray,1,13).resize(-100,-100,1,3);
CImg.h:            visu.draw_image((visu.width() - text.width())/2,1,~text);
CImg.h:            resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
CImg.h:                   CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false).
CImg.h:              mx = (mouse_x - 16)*(int)(siz - one)/(disp.width() - 32),
CImg.h:              cx = cimg::cut(mx,0,(int)(siz - 1 - one)),
CImg.h:              my = mouse_y - 16,
CImg.h:              cy = cimg::cut(my,0,disp.height() - 32);
CImg.h:              if (!obutton) { x0 = cx; y0 = -1; } else { x1 = cx; y1 = -1; }
CImg.h:            else if (obutton) { x1 = x1>=0?cx:-1; y1 = y1>=0?cy:-1; selected = true; }
CImg.h:      return CImg<intT>(4,1,1,1,x0,y0,x1>=0?x1 + (int)one:-1,y1);
CImg.h:       \param filename Filename, as a C-string.
CImg.h:       \param filename Filename, as a C -string.
CImg.h:      err = std::fscanf(nfile,"%*[^0-9.eEinfa+-]");
CImg.h:        err = std::fscanf(nfile,"%lf%*[^0-9.eEinfa+-]",&val);
CImg.h:                   off - 1,siz,filename?filename:"(FILE*)");
CImg.h:      \param filename Filename, as a C-string.
CImg.h:      while ((err = std::fscanf(nfile,"%lf%255[^0-9eEinfa.+-]",&val,delimiter._data))>0) {
CImg.h:       \param filename Filename, as a C-string.
CImg.h:      if (header_size>40) cimg::fseek(nfile,header_size - 40,SEEK_CUR);
CImg.h:        align_bytes = (4 - dx_bytes%4)%4;
CImg.h:      const int xoffset = offset - 14 - header_size - 4*nb_colors;
CImg.h:        if (colormap._width>=2) for (int y = height() - 1; y>=0; --y) {
CImg.h:        if (colormap._width>=16) for (int y = height() - 1; y>=0; --y) {
CImg.h:        if (colormap._width>=256) for (int y = height() - 1; y>=0; --y) {
CImg.h:        for (int y = height() - 1; y>=0; --y) {
CImg.h:        for (int y = height() - 1; y>=0; --y) {
CImg.h:        for (int y = height() - 1; y>=0; --y) {
CImg.h:       \param filename Filename, as a C-string.
CImg.h:      _cimg_error_ptr c_err = (_cimg_error_ptr) cinfo->err;  // Return control to the setjmp point
CImg.h:      (*cinfo->err->format_message)(cinfo,c_err->message);
CImg.h:      longjmp(c_err->setjmp_buffer,1);
CImg.h:       \param filename Filename, as a C-string.
CImg.h:        for (ulongT off = (ulongT)W*H; off; --off) {
CImg.h:          *(ptr_r++) = (T)(pixels->red);
CImg.h:          *(ptr_g++) = (T)(pixels->green);
CImg.h:          *(ptr_b++) = (T)(pixels->blue);
CImg.h:          *(ptr_a++) = (T)(pixels->opacity);
CImg.h:        for (ulongT off = (ulongT)W*H; off; --off) {
CImg.h:          *(ptr_r++) = (T)(pixels->red);
CImg.h:          *(ptr_g++) = (T)(pixels->green);
CImg.h:          *(ptr_b++) = (T)(pixels->blue);
CImg.h:        for (ulongT off = (ulongT)W*H; off; --off) {
CImg.h:          *(ptr_r++) = (T)(pixels->red);
CImg.h:          *(ptr_a++) = (T)(pixels->opacity);
CImg.h:        for (ulongT off = (ulongT)W*H; off; --off) {
CImg.h:          *(ptr_r++) = (T)(pixels->red);
CImg.h:       \param filename Filename, as a C-string.
CImg.h:      \param filename Filename, as a C-string.
CImg.h:          to_read-=raw._width;
CImg.h:            if (!mask) { if (off--) val = *(ptrs++); mask = 128; }
CImg.h:            to_read-=raw._width;
CImg.h:            for (ulongT off = (ulongT)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++);
CImg.h:            to_read-=raw._width;
CImg.h:            for (ulongT off = (ulongT)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++);
CImg.h:            to_read-=raw._width;
CImg.h:            for (ulongT off = (ulongT)raw._width/3; off; --off) {
CImg.h:            to_read-=raw._width;
CImg.h:            for (ulongT off = (ulongT)raw._width/3; off; --off) {
CImg.h:          to_read-=raw._width;
CImg.h:          for (ulongT off = (ulongT)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++);
CImg.h:          to_read-=raw._width;
CImg.h:          for (ulongT off = (ulongT)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++);
CImg.h:      \param filename Filename, as a C-string.
CImg.h:      return mirror('y');  // Most of the .pfm files are flipped along the y-axis
CImg.h:      \param filename Filename, as a C-string.
CImg.h:        to_read-=raw._width;
CImg.h:        for (ulongT off = raw._width/3UL; off; --off) {
CImg.h:       \param filename Filename, as a C-string.
CImg.h:        to_read-=raw._width;
CImg.h:        for (ulongT off = raw._width/4UL; off; --off) {
CImg.h:       \param filename Filename, as a C-string.
CImg.h:       \param first_frame First frame to read (for multi-pages tiff).
CImg.h:       \param last_frame Last frame to read (for multi-pages tiff).
CImg.h:       - libtiff support is enabled by defining the precompilation
CImg.h:       - When libtiff is enabled, 2D and 3D (multipage) several
CImg.h:       - If \c cimg_use_tiff is not defined at compile time the
CImg.h:                                    "load_tiff(): Unable to read sub-images from file '%s' unless libtiff is enabled.",
CImg.h:        if (nlast_frame>=nb_images) nlast_frame = nb_images - 1;
CImg.h:            assign(frame._width,frame._height,1 + (nlast_frame - nfirst_frame)/nstep_frame,frame._spectrum);
CImg.h:                   std::max(frame._height,_height),-100,
CImg.h:          draw_image(0,0,(l - nfirst_frame)/nstep_frame,frame);
CImg.h:                  (*this)(cc,rr,vv) = (T)(ptr[(rr - row)*th*samplesperpixel + (cc - col)*samplesperpixel + vv]);
CImg.h:        cimg_uint32 row, rowsperstrip = (cimg_uint32)-1;
CImg.h:          cimg_uint32 nrow = (row + rowsperstrip>ny?ny - row:rowsperstrip);
CImg.h:          if ((TIFFReadEncodedStrip(tif,strip,buf,-1))<0) {
CImg.h:        cimg_uint32 row, rowsperstrip = (cimg_uint32)-1;
CImg.h:            cimg_uint32 nrow = (row + rowsperstrip>ny?ny - row:rowsperstrip);
CImg.h:            if ((TIFFReadEncodedStrip(tif,strip,buf,-1))<0) {
CImg.h:            (*this)(x,y,0) = (T)(float)TIFFGetR(raster[nx*(ny - 1 -y) + x]);
CImg.h:            (*this)(x,y,0) = (T)(float)TIFFGetR(raster[nx*(ny - 1 - y) + x]);
CImg.h:            (*this)(x,y,1) = (T)(float)TIFFGetG(raster[nx*(ny - 1 - y) + x]);
CImg.h:            (*this)(x,y,2) = (T)(float)TIFFGetB(raster[nx*(ny - 1 - y) + x]);
CImg.h:            (*this)(x,y,0) = (T)(float)TIFFGetR(raster[nx*(ny - 1 - y) + x]);
CImg.h:            (*this)(x,y,1) = (T)(float)TIFFGetG(raster[nx*(ny - 1 - y) + x]);
CImg.h:            (*this)(x,y,2) = (T)(float)TIFFGetB(raster[nx*(ny - 1 - y) + x]);
CImg.h:            (*this)(x,y,3) = (T)(float)TIFFGetA(raster[nx*(ny - 1 - y) + x]);
CImg.h:        \param filename Filename, as a C-string.
CImg.h:    // (Original code by Haz-Edine Assemlal).
CImg.h:      minc::load_standard_volume(rdr,this->_data);
CImg.h:       \param filename Filename, as a C-string.
CImg.h:                              "load_analyze(): Invalid zero-size header in file '%s'.",
CImg.h:      cimg::fread(header + 4,header_size - 4,nfile_header);
CImg.h:      \param filename Filename, as a C-string.
CImg.h:    //! Load sub-images of a .cimg file.
CImg.h:      \param filename Filename, as a C-string.
CImg.h:      \param x0 X-coordinate of the starting sub-image vertex.
CImg.h:      \param y0 Y-coordinate of the starting sub-image vertex.
CImg.h:      \param z0 Z-coordinate of the starting sub-image vertex.
CImg.h:      \param c0 C-coordinate of the starting sub-image vertex.
CImg.h:      \param x1 X-coordinate of the ending sub-image vertex (~0U for max).
CImg.h:      \param y1 Y-coordinate of the ending sub-image vertex (~0U for max).
CImg.h:      \param z1 Z-coordinate of the ending sub-image vertex (~0U for max).
CImg.h:      \param c1 C-coordinate of the ending sub-image vertex (~0U for max).
CImg.h:    //! Load sub-images of a .cimg file \newinstance.
CImg.h:    //! Load sub-images of a .cimg file \overloading.
CImg.h:    //! Load sub-images of a .cimg file \newinstance.
CImg.h:    //! Load image from an INRIMAGE-4 file.
CImg.h:       \param filename Filename, as a C-string.
CImg.h:    //! Load image from an INRIMAGE-4 file \newinstance.
CImg.h:    //! Load image from an INRIMAGE-4 file \overloading.
CImg.h:    //! Load image from an INRIMAGE-4 file \newinstance.
CImg.h:      out[0] = out[1] = out[2] = out[3] = out[5] = 1; out[4] = out[6] = out[7] = -1;
CImg.h:      if (cimg::strncasecmp(item,"#INRIMAGE-4#{",13)!=0)
CImg.h:        throw CImgIOException("CImg<%s>::load_inr(): INRIMAGE-4 header not found.",
CImg.h:        cimg_sscanf(item," XDIM%*[^0-9]%d",out);
CImg.h:        cimg_sscanf(item," YDIM%*[^0-9]%d",out + 1);
CImg.h:        cimg_sscanf(item," ZDIM%*[^0-9]%d",out + 2);
CImg.h:        cimg_sscanf(item," VDIM%*[^0-9]%d",out + 3);
CImg.h:        cimg_sscanf(item," PIXSIZE%*[^0-9]%d",out + 6);
CImg.h:          cimg_sscanf(item," VX%*[^0-9.+-]%f",voxel_size);
CImg.h:          cimg_sscanf(item," VY%*[^0-9.+-]%f",voxel_size + 1);
CImg.h:          cimg_sscanf(item," VZ%*[^0-9.+-]%f",voxel_size + 2);
CImg.h:          std::strncpy(tmp1,tmp2,tmp1._width - 1); // fallthrough
CImg.h:      \param filename Filename, as a C-string.
CImg.h:        inwidth = dw.max.x - dw.min.x + 1,
CImg.h:        inheight = dw.max.y - dw.min.y + 1;
CImg.h:      file.setFrameBuffer(&pixels[0][0] - dw.min.x - dw.min.y*inwidth, 1, inwidth);
CImg.h:    //! Load image from a PANDORE-5 file.
CImg.h:      \param filename Filename, as a C-string.
CImg.h:    //! Load image from a PANDORE-5 file \newinstance.
CImg.h:    //! Load image from a PANDORE-5 file \overloading.
CImg.h:    //! Load image from a PANDORE-5 file \newinstance.
CImg.h:        buffer-=siz; \
CImg.h:          buffer-=siz;
CImg.h:            buffer-=siz;
CImg.h:            buffer-=siz;
CImg.h:          buffer-=siz;
CImg.h:            buffer-=siz;
CImg.h:            buffer-=siz;
CImg.h:          buffer-=siz;
CImg.h:            buffer-=siz;
CImg.h:            buffer-=siz;
CImg.h:    //! Load image from a PAR-REC (Philips) file.
CImg.h:      \param filename Filename, as a C-string.
CImg.h:    //! Load image from a PAR-REC (Philips) file \newinstance.
CImg.h:      \param filename Filename, as a C-string.
CImg.h:      \param is_multiplexed Tells if the image values are multiplexed along the C-axis.
CImg.h:      } else { // Non-boolean data
CImg.h:        if (siz && (!is_multiplexed || size_c==1)) { // Non-multiplexed
CImg.h:      \param filename Filename, as a C-string.
CImg.h:        \param filename Filename, as a C-string.
CImg.h:      \param filename Filename, as a C-string.
CImg.h:      \param filename Filename, as a C-string.
CImg.h:      \param filename Filename, as a C-string.
CImg.h:       \param filename Filename, as a C-string.
CImg.h:       \param filename Filename, as a C-string.
CImg.h:        cimg_snprintf(command,command._width,"%s convert \"%s\" %s:-",
CImg.h:       \param filename Filename, as a C-string.
CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -c \"%s\" > \"%s\"",
CImg.h:       \param filename Filename, as a C-string.
CImg.h:        cimg_snprintf(command,command._width,"%s%s \"%s\" %s:-",
CImg.h:                      !cimg::strcasecmp(cimg::split_filename(filename),"pdf")?" -density 400x400":"",
CImg.h:                    !cimg::strcasecmp(cimg::split_filename(filename),"pdf")?" -density 400x400":"",
CImg.h:       \param filename Filename, as a C-string.
CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -w -c anlz -o \"%s\" -f \"%s\"",
CImg.h:        cimg_snprintf(command,command._width,"m000-%s.hdr",body._data);
CImg.h:       \param filename Filename, as a C-string.
CImg.h:      cimg_snprintf(command,command._width,"gs -q -dNOPAUSE -sDEVICE=ppmraw -o - -r%u \"%s\"",
CImg.h:      cimg_snprintf(command,command._width,"gs -q -dNOPAUSE -sDEVICE=ppmraw -o \"%s\" -r%u \"%s\"",
CImg.h:       \param filename Filename, as a C-string.
CImg.h:      cimg_snprintf(command,command._width,"%s -w -4 -c \"%s\"",
CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -w -4 -c \"%s\" > \"%s\"",
CImg.h:      int mat_type = -1;
CImg.h:          channels[c] = cv::Mat(_height,_width,mat_type,_data + _width*_height*(_spectrum - 1 - c));
CImg.h:        if (captures[camera_index]) captures[camera_index]->release();
CImg.h:        if (!captures[camera_index]->isOpened()) {
CImg.h:        captures[camera_index]->set(_cimg_cap_prop_frame_width,capture_width);
CImg.h:        captures[camera_index]->set(_cimg_cap_prop_frame_height,capture_height);
CImg.h:      for (unsigned int i = 0; i<skip_frames; ++i) captures[camera_index]->grab();
CImg.h:      captures[camera_index]->read(cvimg);
CImg.h:                            "('-Dcimg_use_opencv' must be defined).",
CImg.h:    //! Load image using various non-native ways.
CImg.h:       \param filename Filename, as a C-string.
CImg.h:    //! Load image using various non-native ways \newinstance.
CImg.h:    //---------------------------
CImg.h:    //---------------------------
CImg.h:      const ulongT siz = size(), msiz = siz*sizeof(T), siz1 = siz - 1,
CImg.h:        mdisp = msiz<8*1024?0U:msiz<8*1024*1024?1U:2U, width1 = _width - 1;
CImg.h:        std::fprintf(cimg::output(),"..%p (%s) = [ ",(void*)((char*)end() - 1),_is_shared?"shared":"non-shared");
CImg.h:      else std::fprintf(cimg::output()," (%s) = [ ",_is_shared?"shared":"non-shared");
CImg.h:        if (off==7 && siz>16) { off = siz1 - 8; std::fprintf(cimg::output(),"... "); }
CImg.h:      int x0 = 0, y0 = 0, z0 = 0, x1 = width() - 1, y1 = height() - 1, z1 = depth() - 1,
CImg.h:        old_mouse_x = -1, old_mouse_y = -1;
CImg.h:          x0 = 0; y0 = 0; z0 = 0; x1 = width() - 1; y1 = height() - 1; z1 = depth() - 1;
CImg.h:        if (!x0 && !y0 && !z0 && x1==width() - 1 && y1==height() - 1 && z1==depth() - 1) {
CImg.h:          dx = 1U + x1 - x0, dy = 1U + y1 - y0, dz = 1U + z1 - z0,
CImg.h:                if (disp.wheel()) { frame_timing-=disp.wheel()/3.f; disp.set_wheel(); }
CImg.h:                case cimg::keyPAGEUP : frame_timing-=0.3f; key = 0; break;
CImg.h:                  (_XYZ[2]+=visu._depth - 2)%=visu._depth; timer = 0; key = 0; break;
CImg.h:                      resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
CImg.h:                             CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false);
CImg.h:            X = x0 + mX*(1 + x1 - x0)/width(); Y = y0 + mY*(1 + y1 - y0)/height();
CImg.h:            X = x0 + mX*(1 + x1 - x0)/width(); Z = z0 + (mY - height())*(1 + z1 - z0)/depth();
CImg.h:            Y = y0 + mY*(1 + y1 - y0)/height(); Z = z0 + (mX - width())*(1 + z1 - z0)/depth();
CImg.h:          if (x1 - x0>4) { x0 = X - 3*(X - x0)/4; x1 = X + 3*(x1 - X)/4; }
CImg.h:          if (y1 - y0>4) { y0 = Y - 3*(Y - y0)/4; y1 = Y + 3*(y1 - Y)/4; }
CImg.h:          if (z1 - z0>4) { z0 = Z - 3*(Z - z0)/4; z1 = Z + 3*(z1 - Z)/4; }
CImg.h:            delta_x = (x1 - x0)/8, delta_y = (y1 - y0)/8, delta_z = (z1 - z0)/8,
CImg.h:          x0-=ndelta_x; y0-=ndelta_y; z0-=ndelta_z;
CImg.h:          if (x0<0) { x1-=x0; x0 = 0; if (x1>=width()) x1 = width() - 1; }
CImg.h:          if (y0<0) { y1-=y0; y0 = 0; if (y1>=height()) y1 = height() - 1; }
CImg.h:          if (z0<0) { z1-=z0; z0 = 0; if (z1>=depth()) z1 = depth() - 1; }
CImg.h:          if (x1>=width()) { x0-=(x1 - width() + 1); x1 = width() - 1; if (x0<0) x0 = 0; }
CImg.h:          if (y1>=height()) { y0-=(y1 - height() + 1); y1 = height() - 1; if (y0<0) y0 = 0; }
CImg.h:          if (z1>=depth()) { z0-=(z1 - depth() + 1); z1 = depth() - 1; if (z0<0) z0 = 0; }
CImg.h:            ratio = (float)(x1-x0)/(y1-y0),
CImg.h:            sub = std::min(cimg::abs(ratio - ratiow),cimg::abs(1/ratio-1/ratiow));
CImg.h:          const int delta = (x1 - x0)/4, ndelta = delta?delta:(_width>1);
CImg.h:          if (x0 - ndelta>=0) { x0-=ndelta; x1-=ndelta; }
CImg.h:          else { x1-=x0; x0 = 0; }
CImg.h:          const int delta = (x1 - x0)/4, ndelta = delta?delta:(_width>1);
CImg.h:          else { x0+=(width() - 1 - x1); x1 = width() - 1; }
CImg.h:          const int delta = (y1 - y0)/4, ndelta = delta?delta:(_height>1);
CImg.h:          if (y0 - ndelta>=0) { y0-=ndelta; y1-=ndelta; }
CImg.h:          else { y1-=y0; y0 = 0; }
CImg.h:          const int delta = (y1 - y0)/4, ndelta = delta?delta:(_height>1);
CImg.h:          else { y0+=(height() - 1 - y1); y1 = height() - 1; }
CImg.h:          const int delta = (z1 - z0)/4, ndelta = delta?delta:(_depth>1);
CImg.h:          if (z0 - ndelta>=0) { z0-=ndelta; z1-=ndelta; }
CImg.h:          else { z1-=z0; z0 = 0; }
CImg.h:          const int delta = (z1 - z0)/4, ndelta = delta?delta:(_depth>1);
CImg.h:          else { z0+=(depth() - 1 - z1); z1 = depth() - 1; }
CImg.h:       \param is_double_sided Tells if the object primitives are double-sided.
CImg.h:       \param light_x X-coordinate of the light source.
CImg.h:       \param light_y Y-coordinate of the light source.
CImg.h:       \param light_z Z-coordinate of the light source.
CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
CImg.h:        if (disp) background.resize(disp.width(),disp.height(),1,-100,3);
CImg.h:                                              CImgDisplay::screen_height()/2,1),1,-100,3);
CImg.h:      const float delta = cimg::max(xM - xm,yM - ym,zM - zm);
CImg.h:                                                   0,20,0,0,22,-6,-6,
CImg.h:                                                   0,0,20,0,-6,22,-6,
CImg.h:            CImg<floatT>(4,3,1,1, ratio,0.,0.,-ratio*dx, 0.,ratio,0.,-ratio*dy, 0.,0.,ratio,-ratio*dz).move_to(pose);
CImg.h:              n = 1e-8f + cimg::hypot(r00,r01,r02),
CImg.h:              Xaxes = 25, Yaxes = visu._height - 38.f;
CImg.h:              u0 = (float)(x0 - disp.width()/2),
CImg.h:              v0 = (float)(y0 - disp.height()/2),
CImg.h:              u1 = (float)(x1 - disp.width()/2),
CImg.h:              v1 = (float)(y1 - disp.height()/2),
CImg.h:              nw0 = (float)std::sqrt(std::max(0.f,R2 - nu0*nu0 - nv0*nv0)),
CImg.h:              nw1 = (float)std::sqrt(std::max(0.f,R2 - nu1*nu1 - nv1*nv1)),
CImg.h:              u = nv0*nw1 - nw0*nv1,
CImg.h:              v = nw0*nu1 - nu0*nw1,
CImg.h:              w = nv0*nu1 - nu0*nv1,
CImg.h:            (CImg<floatT>::rotation_matrix(u,v,w,-alpha)*pose).move_to(pose);
CImg.h:            if (focale>0) Zoff-=(y0 - y1)*focale/400;
CImg.h:            else { const float s = std::exp((y0 - y1)/400.f); pose*=s; sprite_scale*=s; }
CImg.h:            if (focale>0) Zoff-=disp.wheel()*focale/20;
CImg.h:            Xoff+=(x1 - x0); Yoff+=(y1 - y0); x0 = x1; y0 = y1;
CImg.h:              resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
CImg.h:                     CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false).
CImg.h:            // Switch single/double-sided primitives.
CImg.h:            if (--_is_double_sided==-2) _is_double_sided = 1;
CImg.h:        case cimg::keyZ : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) { // Enable/disable Z-buffer
CImg.h:            nrender_motion = (nrender_static==0 && nrender_motion!=0)?0:-1; nrender_static = 0;
CImg.h:            nrender_motion = (nrender_static==1 && nrender_motion!=1)?1:-1; nrender_static = 1;
CImg.h:            nrender_motion = (nrender_static==2 && nrender_motion!=2)?2:-1; nrender_static = 2;
CImg.h:        case cimg::keyF4 : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) { // Set rendering mode to flat-shaded
CImg.h:            nrender_motion = (nrender_static==3 && nrender_motion!=3)?3:-1; nrender_static = 3;
CImg.h:            // Set rendering mode to gouraud-shaded.
CImg.h:            nrender_motion = (nrender_static==4 && nrender_motion!=4)?4:-1; nrender_static = 4;
CImg.h:        case cimg::keyF6 : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) { // Set rendering mode to phong-shaded
CImg.h:            nrender_motion = (nrender_static==5 && nrender_motion!=5)?5:-1; nrender_static = 5;
CImg.h:       \param labelx Title for the horizontal axis, as a C-string.
CImg.h:       \param xmin Minimum value along the X-axis.
CImg.h:       \param xmax Maximum value along the X-axis.
CImg.h:       \param labely Title for the vertical axis, as a C-string.
CImg.h:       \param ymin Minimum value along the X-axis.
CImg.h:       \param ymax Maximum value along the X-axis.
CImg.h:      const ulongT siz = (ulongT)_width*_height*_depth, siz1 = std::max((ulongT)1,siz - 1);
CImg.h:      int x0 = 0, x1 = width()*height()*depth() - 1, key = 0;
CImg.h:        if (reset_view) { x0 = 0; x1 = width()*height()*depth() - 1; y0 = ymin; y1 = ymax; reset_view = false; }
CImg.h:        CImg<T> zoom(x1 - x0 + 1,1,1,spectrum());
CImg.h:        cimg_forC(*this,c) zoom.get_shared_channel(c) = CImg<T>(data(x0,0,0,c),x1 - x0 + 1,1,1,1,true);
CImg.h:        if (y0==y1) { y0 = zoom.min_max(y1); const double dy = y1 - y0; y0-=dy/20; y1+=dy/20; }
CImg.h:        if (y0==y1) { --y0; ++y1; }
CImg.h:                                                           nxmin + x0*(nxmax - nxmin)/siz1,
CImg.h:                                                           nxmin + x1*(nxmax - nxmin)/siz1,
CImg.h:              y0 = y1 - selection[3]*(y1 - y0)/(disp.height() - 32);
CImg.h:              y1-=selection[1]*(y1 - y0)/(disp.height() - 32);
CImg.h:              xsiz = x1 - x0,
CImg.h:              mx = (mouse_x - 16)*xsiz/(disp.width() - 32),
CImg.h:            if (x1 - x0>4) {
CImg.h:              x0 = cx - 7*(cx - x0)/8; x1 = cx + 7*(x1 - cx)/8;
CImg.h:                  ysiz = y1 - y0,
CImg.h:                  my = (mouse_y - 16)*ysiz/(disp.height() - 32),
CImg.h:                  cy = y1 - cimg::cut(my,0.,ysiz);
CImg.h:                y0 = cy - 7*(cy - y0)/8; y1 = cy + 7*(y1 - cy)/8;
CImg.h:              const int delta_x = (x1 - x0)/8, ndelta_x = delta_x?delta_x:(siz>1);
CImg.h:              const double ndelta_y = (y1 - y0)/8;
CImg.h:              x0-=ndelta_x; x1+=ndelta_x;
CImg.h:              y0-=ndelta_y; y1+=ndelta_y;
CImg.h:              if (x0<0) { x1-=x0; x0 = 0; if (x1>=(int)siz) x1 = (int)siz1; }
CImg.h:              if (x1>=(int)siz) { x0-=(x1 - siz1); x1 = (int)siz1; if (x0<0) x0 = 0; }
CImg.h:            const int delta = (x1 - x0)/5, ndelta = delta?delta:1;
CImg.h:            if (x0 - ndelta>=0) { x0-=ndelta; x1-=ndelta; }
CImg.h:            else { x1-=x0; x0 = 0; }
CImg.h:            const int delta = (x1 - x0)/5, ndelta = delta?delta:1;
CImg.h:            else { x0+=(siz1 - x1); x1 = (int)siz1; }
CImg.h:            const double delta = (y1 - y0)/10, ndelta = delta?delta:1;
CImg.h:            const double delta = (y1 - y0)/10, ndelta = delta?delta:1;
CImg.h:            y0-=ndelta; y1-=ndelta;
CImg.h:       \param filename Filename, as a C-string.
CImg.h:       - The used file format is defined by the file extension in the filename \p filename.
CImg.h:       - Parameter \p number can be used to add a 6-digit number to the filename before saving.
CImg.h:    const CImg<T>& save(const char *const filename, const int number=-1, const unsigned int digits=6) const {
CImg.h:      const bool is_stdout = *filename=='-' && (!filename[1] || filename[1]=='.');
CImg.h:      \param filename Filename, as a C-string.
CImg.h:      \param filename Filename, as a C-string.
CImg.h:      if (filename) cimg_sscanf(cimg::basename(filename),"%1023[a-zA-Z0-9_]",varname._data);
CImg.h:      if (!is_empty()) for (ulongT off = 0, siz = size() - 1; off<=siz; ++off) {
CImg.h:       \param filename Filename, as a C-string.
CImg.h:        cimg_forX(*this,x) std::fprintf(nfile,"%.17g%s",(double)*(ptrs++),(x==width() - 1)?"":",");
CImg.h:      \param filename Filename, as a C-string.
CImg.h:        align = (4 - (3*_width)%4)%4,
CImg.h:        *ptr_r = data(0,_height - 1,0,0),
CImg.h:        *ptr_g = (_spectrum>=2)?data(0,_height - 1,0,1):0,
CImg.h:        *ptr_b = (_spectrum>=3)?data(0,_height - 1,0,2):0;
CImg.h:          ptr_r-=2*_width;
CImg.h:          ptr_r-=2*_width; ptr_g-=2*_width;
CImg.h:          ptr_r-=2*_width; ptr_g-=2*_width; ptr_b-=2*_width;
CImg.h:      \param filename Filename, as a C-string.
CImg.h:    //! Save image, using built-in ImageMagick++ library.
CImg.h:      \param filename Filename, as a C-string.
CImg.h:        for (ulongT off = (ulongT)_width*_height; off; --off) {
CImg.h:          pixels->red = pixels->green = pixels->blue = (Magick::Quantum)*(ptr_r++);
CImg.h:        for (ulongT off = (ulongT)_width*_height; off; --off) {
CImg.h:          pixels->red = (Magick::Quantum)*(ptr_r++);
CImg.h:          pixels->green = (Magick::Quantum)*(ptr_g++);
CImg.h:          pixels->blue = 0; ++pixels;
CImg.h:        for (ulongT off = (ulongT)_width*_height; off; --off) {
CImg.h:          pixels->red = (Magick::Quantum)*(ptr_r++);
CImg.h:          pixels->green = (Magick::Quantum)*(ptr_g++);
CImg.h:          pixels->blue = (Magick::Quantum)*(ptr_b++);
CImg.h:       \param filename Filename, as a C-string.
CImg.h:      const int pixel_bit_depth_flag = numChan * (bit_depth - 1);
CImg.h:      case 7 :  { // Gray 8-bit
CImg.h:      case 14 : { // Gray w/ Alpha 8-bit
CImg.h:      case 21 :  { // RGB 8-bit
CImg.h:      case 28 : { // RGB x/ Alpha 8-bit
CImg.h:      case 15 : { // Gray 16-bit
CImg.h:      case 30 : { // Gray w/ Alpha 16-bit
CImg.h:      case 45 : { // RGB 16-bit
CImg.h:      case 60 : { // RGB w/ Alpha 16-bit
CImg.h:      \param filename Filename, as a C-string.
CImg.h:            for (ulongT i = N; i>0; --i) *(ptrd++) = (unsigned char)*(ptr_r++);
CImg.h:            to_write-=N;
CImg.h:            for (ulongT i = N; i>0; --i) *(ptrd++) = (unsigned short)*(ptr_r++);
CImg.h:            to_write-=N;
CImg.h:            for (ulongT i = N; i>0; --i) {
CImg.h:            to_write-=N;
CImg.h:            for (ulongT i = N; i>0; --i) {
CImg.h:            to_write-=N;
CImg.h:            for (ulongT i = N; i>0; --i) {
CImg.h:            to_write-=N;
CImg.h:            for (ulongT i = N; i>0; --i) {
CImg.h:            to_write-=N;
CImg.h:      \param filename Filename, as a C-string.
CImg.h:      else if (!cimg::type<T>::is_float() && sizeof(T)==1) { // Save as extended P5 file: Binary byte-valued 3D
CImg.h:          for (ulongT i = N; i>0; --i) *(ptrd++) = (unsigned char)*(ptr++);
CImg.h:          to_write-=N;
CImg.h:      } else if (!cimg::type<T>::is_float()) { // Save as P8: Binary int32-valued 3D
CImg.h:          for (ulongT i = N; i>0; --i) *(ptrd++) = (int)*(ptr++);
CImg.h:          to_write-=N;
CImg.h:      } else { // Save as P9: Binary float-valued 3D
CImg.h:          for (ulongT i = N; i>0; --i) *(ptrd++) = (float)*(ptr++);
CImg.h:          to_write-=N;
CImg.h:      \param filename Filename, as a C-string.
CImg.h:          for (ulongT i = N; i>0; --i) *(ptrd++) = (float)*(ptr_r++);
CImg.h:          to_write-=N;
CImg.h:          for (ulongT i = N; i>0; --i) {
CImg.h:          to_write-=N;
CImg.h:          for (ulongT i = N; i>0; --i) {
CImg.h:          to_write-=N;
CImg.h:      \param filename Filename, as a C-string.
CImg.h:       \param filename Filename, as a C-string.
CImg.h:       \param filename Filename, as a C-string.
CImg.h:       - libtiff support is enabled by defining the precompilation
CImg.h:       - When libtiff is enabled, 2D and 3D (multipage) several
CImg.h:       - If \c cimg_use_tiff is not defined at compile time the
CImg.h:      cimg_uint32 rowsperstrip = (cimg_uint32)-1;
CImg.h:          cimg_uint32 nrow = (row + rowsperstrip>_height?_height - row:rowsperstrip);
CImg.h:       \param filename Filename, as a C-string.
CImg.h:       \param imitate_file If non-zero, reference filename, as a C-string, to borrow header from.
CImg.h:       if (width()) di.push_back(minc::dim_info(width(),width()*0.5,-1,minc::dim_info::DIM_X));
CImg.h:       if (height()) di.push_back(minc::dim_info(height(),height()*0.5,-1,minc::dim_info::DIM_Y));
CImg.h:       if (depth()) di.push_back(minc::dim_info(depth(),depth()*0.5,-1,minc::dim_info::DIM_Z));
CImg.h:       if (spectrum()) di.push_back(minc::dim_info(spectrum(),spectrum()*0.5,-1,minc::dim_info::DIM_TIME));
CImg.h:     minc::save_standard_volume(wtr, this->_data);
CImg.h:      \param filename Filename, as a C-string.
CImg.h:      short datatype = -1;
CImg.h:        std::strncpy(iname,filename,iname._width - 1);
CImg.h:        cimg_sprintf(iname._data + std::strlen(iname) - 3,"img");
CImg.h:        std::strncpy(iname,filename,iname._width - 1);
CImg.h:        cimg_sprintf(hname._data + std::strlen(iname) - 3,"hdr");
CImg.h:        std::strncpy(hname,filename,hname._width - 1); *iname = 0;
CImg.h:      \param filename Filename, as a C-string.
CImg.h:    //! Save image as a sub-image into an existing .cimg file.
CImg.h:      \param filename Filename, as a C-string.
CImg.h:      \param x0 X-coordinate of the sub-image location.
CImg.h:      \param y0 Y-coordinate of the sub-image location.
CImg.h:      \param z0 Z-coordinate of the sub-image location.
CImg.h:      \param c0 C-coordinate of the sub-image location.
CImg.h:    //! Save image as a sub-image into an existing .cimg file \overloading.
CImg.h:        \param filename Filename, as a C-string.
CImg.h:        - All pixel values of the saved image are set to \c 0.
CImg.h:        - Use this method to save large images without having to instantiate and allocate them.
CImg.h:    //! Save image as an INRIMAGE-4 file.
CImg.h:      \param filename Filename, as a C-string.
CImg.h:    //! Save image as an INRIMAGE-4 file \overloading.
CImg.h:      int inrpixsize = -1;
CImg.h:      int err = cimg_snprintf(header,header._width,"#INRIMAGE-4#{\nXDIM=%u\nYDIM=%u\nZDIM=%u\nVDIM=%u\n",
CImg.h:      std::memset(header._data + err,'\n',252 - err);
CImg.h:       \param filename Filename, as a C-string.
CImg.h:    //! Save image as a Pandore-5 file.
CImg.h:       \param filename Filename, as a C-string.
CImg.h:    //! Save image as a Pandore-5 file \overloading.
CImg.h:       buffer-=size(); \
CImg.h:       \param filename Filename, as a C-string.
CImg.h:    // mco-
CImg.h:        if (!is_multiplexed || _spectrum==1) cimg::fwrite(_data,size(),nfile); // Non-multiplexed
CImg.h:      if (!is_multiplexed || _spectrum==1) // Non-multiplexed
CImg.h:      if (S && (!is_multiplexed || _spectrum==1)) // Non-multiplexed
CImg.h:       \param filename Filename, as a C-string.
CImg.h:       \param is_rgb Tells if pixel values of the instance image are RGB-coded (\c true) or YUV-coded (\c false).
CImg.h:       \param filename Filename, as a C-string.
CImg.h:       - Instance image contains the vertices data of the 3D object.
CImg.h:       - Textured, transparent or sphere-shaped primitives cannot be managed by the .off file format.
CImg.h:       - The .off file format is <a href="http://people.sc.fsu.edu/~jburkardt/html/off_format.html">described here</a>.
CImg.h:       \param filename Filename, as a C-string.
CImg.h:       \param codec Video codec, as a C-string.
CImg.h:       - Each slice of the instance image is considered to be a single frame of the output video file.
CImg.h:       - This method uses \c ffmpeg, an external executable binary provided by
CImg.h:       \param filename Filename, as a C-string.
CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -c \"%s\" > \"%s\"",
CImg.h:       \param filename Filename, as a C-string.
CImg.h:      cimg_snprintf(command,command._width,"\"%s\" convert -quality %u \"%s\" \"%s\"",
CImg.h:       \param filename Filename, as a C-string.
CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -quality %u \"%s\" \"%s\"",
CImg.h:       \param filename Filename, as a C-string.
CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -w -c dicom -o \"%s\" -f \"%s\"",
CImg.h:        cimg_snprintf(command,command._width,"m000-%s",filename);
CImg.h:       \param filename Filename, as a C-string.
CImg.h:       - The filename extension tells about the desired file format.
CImg.h:       - This method tries to save the instance image as a file, using external tools from
CImg.h:       - It is recommended to use the generic method save(const char*, int) const instead,
CImg.h:   #-----------------------------------------
CImg.h:   #------------------------------------------
CImg.h:       - The \c CImgList<T>::iterator type is defined as a <tt>CImg<T>*</tt>.
CImg.h:       - You may use it like this:
CImg.h:       - Using the loop macro \c cimglist_for is another (more concise) alternative:
CImg.h:       - The \c CImgList<T>::const_iterator type is defined to be a <tt>const CImg<T>*</tt>.
CImg.h:       - Similar to CImgList<T>::iterator, but for constant list instances.
CImg.h:       - The \c CImgList<T>::value_type type of a \c CImgList<T> is defined to be a \c T.
CImg.h:       - \c CImgList<T>::value_type is actually not used in %CImg methods. It has been mainly defined for
CImg.h:    //---------------------------
CImg.h:    //---------------------------
CImg.h:    //--------------------------------------------------------
CImg.h:    //--------------------------------------------------------
CImg.h:       - Any allocated buffer is deallocated.
CImg.h:       - Destroying an empty list does nothing actually.
CImg.h:       - An empty list has no pixel data and its dimension width() is set to \c 0, as well as its
CImg.h:       - An empty list may be reassigned afterwards, with the family of the assign() methods.
CImg.h:        T *ptrd = _data->_data; \
CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of \c img.
CImg.h:       \param is_shared Tells if the element of the list is a shared or non-shared copy of \c img.
CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
CImg.h:       \param filename Filename, as a C-string.
CImg.h:    //------------------------------------------
CImg.h:    //------------------------------------------
CImg.h:      return const_cast<CImgList<T>*>(this)->operator()(pos);
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:    //! Return a non-shared copy of a list.
CImg.h:          It forces the copy to have non-shared elements.
CImg.h:    //-------------------------------------
CImg.h:    //-------------------------------------
CImg.h:       - The returned string does not contain any spaces.
CImg.h:       - If the pixel type \c T does not correspond to a registered type, the string <tt>"unknown"</tt> is returned.
CImg.h:    //! Return pointer to the pos-th image of the list.
CImg.h:      return const_cast<CImgList<T>*>(this)->data(l);
CImg.h:    //! Return pointer to the pos-th image of the list \const.
CImg.h:      return *(_data + _width - 1);
CImg.h:      return *(_data + _width - 1);
CImg.h:    //! Return pos-th image of the list.
CImg.h:      return _data[cimg::cut(pos,0,width() - 1)];
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atXYZC(x,y,z,c);
CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atXYZC(x,y,z,c);
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atXYZ(x,y,z,c);
CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atXYZ(x,y,z,c);
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atXY(x,y,z,c);
CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atXY(x,y,z,c);
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atX(x,y,z,c);
CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atX(x,y,z,c);
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:       \param x X-coordinate of the pixel value.
CImg.h:       \param y Y-coordinate of the pixel value.
CImg.h:       \param z Z-coordinate of the pixel value.
CImg.h:       \param c C-coordinate of the pixel value.
CImg.h:      return _data[cimg::cut(pos,0,width() - 1)](x,y,z,c);
CImg.h:      return _data[cimg::cut(pos,0,width() - 1)](x,y,z,c);
CImg.h:    //-------------------------------------
CImg.h:    //-------------------------------------
CImg.h:    // (cannot be documented because macro-generated).
CImg.h:       \param x X-coordinate of the checked pixel value.
CImg.h:       \param y Y-coordinate of the checked pixel value.
CImg.h:       \param z Z-coordinate of the checked pixel value.
CImg.h:       \param c C-coordinate of the checked pixel value.
CImg.h:       \param[out] x X-coordinate of the pixel value, if test succeeds.
CImg.h:       \param[out] y Y-coordinate of the pixel value, if test succeeds.
CImg.h:       \param[out] z Z-coordinate of the pixel value, if test succeeds.
CImg.h:       \param[out] c C-coordinate of the pixel value, if test succeeds.
CImg.h:       \param[out] x X-coordinate of the pixel value, if test succeeds.
CImg.h:       \param[out] y Y-coordinate of the pixel value, if test succeeds.
CImg.h:       \param[out] z Z-coordinate of the pixel value, if test succeeds.
CImg.h:       \param[out] x X-coordinate of the pixel value, if test succeeds.
CImg.h:       \param[out] y Y-coordinate of the pixel value, if test succeeds.
CImg.h:       \param[out] x X-coordinate of the pixel value, if test succeeds.
CImg.h:    //-------------------------------------
CImg.h:    //-------------------------------------
CImg.h:    //---------------------------
CImg.h:    //---------------------------
CImg.h:        if (new_data) { // Insert with re-allocation
CImg.h:          if (npos!=_width - 1)
CImg.h:            std::memcpy((void*)(new_data + npos + 1),(void*)(_data + npos),sizeof(CImg<T>)*(_width - 1 - npos));
CImg.h:          std::memset((void*)_data,0,sizeof(CImg<T>)*(_width - 1));
CImg.h:        } else if (npos!=_width - 1) // Insert without re-allocation
CImg.h:          std::memmove((void*)(_data + npos + 1),(void*)(_data + npos),sizeof(CImg<T>)*(_width - 1 - npos));
CImg.h:          _data->_width = img._width;
CImg.h:          _data->_height = img._height;
CImg.h:          _data->_depth = img._depth;
CImg.h:          _data->_spectrum = img._spectrum;
CImg.h:          _data->_is_shared = true;
CImg.h:          _data->_data = img._data;
CImg.h:        if (new_data) { // Insert with re-allocation
CImg.h:          if (npos!=_width - 1)
CImg.h:            std::memcpy((void*)(new_data + npos + 1),(void*)(_data + npos),sizeof(CImg<T>)*(_width - 1 - npos));
CImg.h:          std::memset((void*)_data,0,sizeof(CImg<T>)*(_width - 1));
CImg.h:        } else { // Insert without re-allocation
CImg.h:          if (npos!=_width - 1)
CImg.h:            std::memmove((void*)(_data + npos + 1),(void*)(_data + npos),sizeof(CImg<T>)*(_width - 1 - npos));
CImg.h:        npos2 = tpos2<_width?tpos2:_width - 1;
CImg.h:                                    "remove(): Invalid remove request at positions %u->%u.",
CImg.h:                                      "remove(): Invalid remove request at positions %u->%u.",
CImg.h:        const unsigned int nb = 1 + npos2 - npos1;
CImg.h:        if (!(_width-=nb)) return assign();
CImg.h:            std::memmove((void*)(_data + npos1),(void*)(_data + npos2 + 1),sizeof(CImg<T>)*(_width - npos1));
CImg.h:            std::memcpy((void*)(new_data + npos1),(void*)(_data + npos2 + 1),sizeof(CImg<T>)*(_width - npos1));
CImg.h:            std::memset((void*)(new_data + _width),0,sizeof(CImg<T>)*(_allocated_width - _width));
CImg.h:      return remove(_width - 1);
CImg.h:      for (unsigned int l = 0; l<_width/2; ++l) (*this)[l].swap((*this)[_width - 1 - l]);
CImg.h:                                    "images(): Specified sub-list indices (%u->%u) are out of bounds.",
CImg.h:      CImgList<T> res(pos1 - pos0 + 1);
CImg.h:                                    "get_shared_images(): Specified sub-list indices (%u->%u) are out of bounds.",
CImg.h:      CImgList<T> res(pos1 - pos0 + 1);
CImg.h:                                    "get_shared_images(): Specified sub-list indices (%u->%u) are out of bounds.",
CImg.h:      CImgList<T> res(pos1 - pos0 + 1);
CImg.h:      case 'x' : { // Along the X-axis
CImg.h:                               (int)(align*(dy - img._height)),
CImg.h:                               (int)(align*(dz - img._depth)),
CImg.h:                               (int)(align*(dc - img._spectrum)),
CImg.h:      case 'y' : { // Along the Y-axis
CImg.h:                res.draw_image((int)(align*(dx - img._width)),
CImg.h:                               (int)(align*(dz - img._depth)),
CImg.h:                               (int)(align*(dc - img._spectrum)),
CImg.h:      case 'z' : { // Along the Z-axis
CImg.h:                res.draw_image((int)(align*(dx - img._width)),
CImg.h:                               (int)(align*(dy - img._height)),
CImg.h:                               (int)(align*(dc - img._spectrum)),
CImg.h:      default : { // Along the C-axis
CImg.h:                res.draw_image((int)(align*(dx - img._width)),
CImg.h:                               (int)(align*(dy - img._height)),
CImg.h:                               (int)(align*(dz - img._depth)),
CImg.h:    CImgList<T>& split(const char axis, const int nb=-1) {
CImg.h:    CImgList<T> get_split(const char axis, const int nb=-1) const {
CImg.h:      return remove(_width - 1);
CImg.h:      return remove(iter - _data);
CImg.h:    //----------------------------------
CImg.h:    //----------------------------------
CImg.h:       \return A one-column vector containing the selected image indexes.
CImg.h:       \return A one-column vector containing the selected image indexes.
CImg.h:          w = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,false),
CImg.h:          h = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,true);
CImg.h:      CImg<intT> positions(_width,4,1,1,-1);
CImg.h:      int oindex0 = -1, oindex1 = -1, index0 = -1, index1 = -1;
CImg.h:              const unsigned int h = CImgDisplay::_fitscreen(res._width,res._height,1,128,-85,true);
CImg.h:              res.resize(x1 - x0,std::max(32U,h*disp._height/max_height),1,res._spectrum==1?3:-100);
CImg.h:              positions(ind,1) = positions(ind,3) = (int)(align*(visu0.height() - res.height()));
CImg.h:              positions(ind,3)+=res._height - 1;
CImg.h:              src._get_select(disp,old_normalization,(src._width - 1)/2,(src._height - 1)/2,(src._depth - 1)/2).
CImg.h:              const unsigned int w = CImgDisplay::_fitscreen(res._width,res._height,1,128,-85,false);
CImg.h:              res.resize(std::max(32U,w*disp._width/max_width),y1 - y0,1,res._spectrum==1?3:-100);
CImg.h:              positions(ind,0) = positions(ind,2) = (int)(align*(visu0.width() - res.width()));
CImg.h:              positions(ind,2)+=res._width - 1;
CImg.h:          if (axis=='x') --positions(_ind,2); else --positions(_ind,3);
CImg.h:                if ((axis=='x' && positions(ind,2) - positions(ind,0)>=8) ||
CImg.h:                    (axis!='x' && positions(ind,3) - positions(ind,1)>=8))
CImg.h:            if (is_clicked) visu.__draw_text(" Images #%u - #%u, Size = %u ",font_size,(int)text_down,
CImg.h:                                             orig + indm,orig + indM,indM - indm + 1);
CImg.h:        int index = -1;
CImg.h:            if (!(disp.button()&1)) { is_clicked = is_selected = false; index0 = index1 = -1; }
CImg.h:            else index1 = -1;
CImg.h:          } else index0 = index1 = -1;
CImg.h:        if (disp.button()&4) { is_clicked = is_selected = false; index0 = index1 = -1; }
CImg.h:        if (disp.button()&2 && exit_on_rightbutton) { is_selected = true; index1 = index0 = -1; }
CImg.h:              resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
CImg.h:                     CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false).
CImg.h:        else if (ym>=visu.height() - 13) { if (text_down) { visu.assign(); text_down = false; }}
CImg.h:      CImg<intT> res(1,2,1,1,-1);
CImg.h:      const bool is_stdin = *filename=='-' && (!filename[1] || filename[1]=='.');
CImg.h:          _data->load(filename);
CImg.h:                  CImg<T>(ptrd,std::min(8*raw._width,(unsigned int)(img.end() - ptrd)),1,1,1,true).\
CImg.h:                  to_read-=raw._width; \
CImg.h:                  for (ulongT off = (ulongT)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); \
CImg.h:                  to_read-=raw._width; \
CImg.h:      err = cimg_sscanf(tmp,"%u%*c%255[A-Za-z123468_]%*c%255[sA-Za-z_ ]",
CImg.h:      \param x0 Starting X-coordinates of image regions to read.
CImg.h:      \param y0 Starting Y-coordinates of image regions to read.
CImg.h:      \param z0 Starting Z-coordinates of image regions to read.
CImg.h:      \param c0 Starting C-coordinates of image regions to read.
CImg.h:      \param x1 Ending X-coordinates of image regions to read (~0U for max).
CImg.h:      \param y1 Ending Y-coordinates of image regions to read (~0U for max).
CImg.h:      \param z1 Ending Z-coordinates of image regions to read (~0U for max).
CImg.h:      \param c1 Ending C-coordinates of image regions to read (~0U for max).
CImg.h:    //! Load a sub-image list from a (non compressed) .cimg file \overloading.
CImg.h:    //! Load a sub-image list from a (non compressed) .cimg file \newinstance.
CImg.h:                _nx1 = nx1==~0U?W - 1:nx1, \
CImg.h:                _ny1 = ny1==~0U?H - 1:ny1, \
CImg.h:                _nz1 = nz1==~0U?D - 1:nz1, \
CImg.h:                _nc1 = nc1==~0U?C - 1:nc1; \
CImg.h:                                            "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " \
CImg.h:              CImg<Tss> raw(1 + _nx1 - nx0); \
CImg.h:              CImg<T> &img = _data[l - nn0]; \
CImg.h:              img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); \
CImg.h:              for (unsigned int c = 1 + _nc1 - nc0; c; --c) { \
CImg.h:                for (unsigned int z = 1 + _nz1 - nz0; z; --z) { \
CImg.h:                  for (unsigned int y = 1 + _ny1 - ny0; y; --y) { \
CImg.h:                    for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); \
CImg.h:                    const ulongT skipxe = (W - 1 - _nx1)*sizeof(Tss); \
CImg.h:                  const ulongT skipye = (H - 1 - _ny1)*W*sizeof(Tss); \
CImg.h:                const ulongT skipze = (D - 1 - _nz1)*W*H*sizeof(Tss); \
CImg.h:              const ulongT skipve = (C - 1 - _nc1)*W*H*D*sizeof(Tss); \
CImg.h:      err = cimg_sscanf(tmp,"%u%*c%255[A-Za-z123468_]%*c%255[sA-Za-z_ ]",
CImg.h:      nn1 = n1==~0U?N - 1:n1;
CImg.h:                                    "load_cimg(): Invalid specified coordinates [%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) "
CImg.h:      assign(1 + nn1 - n0);
CImg.h:        std::strncpy(filenamepar,filename,filenamepar._width - 1);
CImg.h:        std::strncpy(filenamepar,filename,filenamepar._width - 1);
CImg.h:        std::strncpy(filenamerec,filename,filenamerec._width - 1);
CImg.h:        std::strncpy(filenamerec,filename,filenamerec._width - 1);
CImg.h:          st_slices[st_slices._width - 1][7] = (float)i;
CImg.h:          sn = (unsigned int)vec[0] - 1,
CImg.h:                                "load_parrec(): Unsupported %d-bits pixel type for file '%s'.",
CImg.h:                              "load_parrec(): Failed to recognize valid PAR-REC data in file '%s'.",
CImg.h:            if (nstep_frame>1) cimg::fseek(nfile,(uint64T)(nstep_frame - 1)*(size_x*size_y + size_x*size_y/2),SEEK_CUR);
CImg.h:                   nlast_frame,frame - 1,filename?filename:"(FILE*)");
CImg.h:      \param filename Filename, as a C-string.
CImg.h:                                    "('-Dcimg_use_opencv' must be defined).",
CImg.h:      static int last_used_index = -1;
CImg.h:      int index = -1;
CImg.h:          captures[index]->release();
CImg.h:          if (last_used_index==index) last_used_index = -1;
CImg.h:          index = -1;
CImg.h:                                      "non-(null) filename argument for the first call.",
CImg.h:        if (!captures[index]->isOpened()) {
CImg.h:      const unsigned int nb_frames = (unsigned int)std::max(0.,captures[index]->get(_cimg_cap_prop_frame_count));
CImg.h:        if (!captures[index]->grab()) { cimg::mutex(9,0); go_on = false; break; }
CImg.h:      const unsigned int _last_frame = std::min(nb_frames?nb_frames - 1:~0U,last_frame);
CImg.h:        if (captures[index]->read(cvimg)) { CImg<T>::_cvmat2cimg(cvimg).move_to(*this); ++pos; }
CImg.h:            if (!captures[index]->grab()) go_on = false;
CImg.h:        captures[index]->release();
CImg.h:        index = -1;
CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -v -8 -i \"%s\" \"%s\"",
CImg.h:        else cimg_snprintf(filename_tmp2,filename_tmp2._width,"%s-0.png",filename_tmp._data);
CImg.h:      else cimg_snprintf(command,command._width,"\"%s\" -coalesce \"%s\" \"%s.png\"",
CImg.h:          else cimg_snprintf(filename_tmp2,filename_tmp2._width,"%s-%u.png",filename_tmp._data,i);
CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -c \"%s\" > \"%s\"",
CImg.h:                                    "load_tiff(): Unable to load sub-images from file '%s' unless libtiff is enabled.",
CImg.h:        if (nlast_frame>=nb_images) nlast_frame = nb_images - 1;
CImg.h:        assign(1 + (nlast_frame - nfirst_frame)/nstep_frame);
CImg.h:    //! Load a multi-page TIFF file \newinstance.
CImg.h:    //----------------------------------
CImg.h:    //----------------------------------
CImg.h:      if (_data) std::fprintf(cimg::output(),"..%p.\n",(void*)((char*)end() - 1));
CImg.h:        if (ll==3 && width()>8) { ll = width() - 5; std::fprintf(cimg::output(),"  ...\n"); }
CImg.h:              w = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,false),
CImg.h:              h = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,true);
CImg.h:          disp.assign(cimg_fitscreen(sum_width,max_height,1),title?title:titles?titles->__display()._data:0,1);
CImg.h:              w = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,false),
CImg.h:              h = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,true);
CImg.h:          disp.assign(cimg_fitscreen(max_width,sum_height,1),title?title:titles?titles->__display()._data:0,1);
CImg.h:      else if (titles) disp.set_title("%s",titles->__display()._data);
CImg.h:                ind0 = (unsigned int)std::max(0,s[0] - (int)delta),
CImg.h:                ind1 = (unsigned int)std::min(width() - 1,s[0] + (int)delta);
CImg.h:              if ((ind0!=0 || ind1!=_width - 1) && ind1 - ind0>=3) {
CImg.h:                if (titles) t_sublist = titles->get_shared_images(ind0,ind1);
CImg.h:          } else if (s[0]!=0 || s[1]!=width() - 1) {
CImg.h:            if (titles) t_sublist = titles->get_shared_images(s[0],s[1]);
CImg.h:        if (l!=width() - 1) {
CImg.h:          str[str._width - 2] = ',';
CImg.h:          str[str._width - 1] = ' ';
CImg.h:    const CImgList<T>& save(const char *const filename, const int number=-1, const unsigned int digits=6) const {
CImg.h:      const bool is_stdout = *filename=='-' && (!filename[1] || filename[1]=='.');
CImg.h:        if (_width==1) _data[0].save(fn,-1);
CImg.h:        else cimglist_for(*this,l) { _data[l].save(fn,is_stdout?-1:l); if (is_stdout) std::fputc(EOF,cimg::_stdout()); }
CImg.h:       \param filename Filename, as a C-string.
CImg.h:        if (_data[l]._depth>1 || _data[l]._spectrum!=3) _data[l].get_resize(-100,-100,1,3).save(filename_tmp2);
CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -delay %u -loop %u",
CImg.h:      cimglist_for_in(*this,1,filenames._width - 1,l) std::remove(filenames[l]);
CImg.h:            if (YUV._width!=width0 || YUV._height!=height0) YUV.resize(width0,height0,1,-100,0);
CImg.h:            if (YUV._spectrum!=3) YUV.resize(-100,-100,1,3,YUV._spectrum==1?1:0);
CImg.h:            } else { // Non-boolean data
CImg.h:          if (failed_to_compress) { // Write non-compressed
CImg.h:            } else cimg::fwrite(ref._data,ref.size(),nfile); // Non-boolean data
CImg.h:              const CImg<T>& img = (*this)[l - n0]; \
CImg.h:                x1 = x0 + img._width - 1, \
CImg.h:                y1 = y0 + img._height - 1, \
CImg.h:                z1 = z0 + img._depth - 1, \
CImg.h:                c1 = c0 + img._spectrum - 1, \
CImg.h:                nx1 = x1>=W?W - 1:x1, \
CImg.h:                ny1 = y1>=H?H - 1:y1, \
CImg.h:                nz1 = z1>=D?D - 1:z1, \
CImg.h:                nc1 = c1>=C?C - 1:c1; \
CImg.h:              CImg<Tss> raw(1 + nx1 - x0); \
CImg.h:              for (unsigned int v = 1 + nc1 - c0; v; --v) { \
CImg.h:                for (unsigned int z = 1 + nz1 - z0; z; --z) { \
CImg.h:                  for (unsigned int y = 1 + ny1 - y0; y; --y) { \
CImg.h:                    const unsigned int skipxe = (W - 1 - nx1)*sizeof(Tss); \
CImg.h:                  const unsigned int skipye = (H - 1 - ny1)*W*sizeof(Tss); \
CImg.h:                const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(Tss); \
CImg.h:              const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(Tss); \
CImg.h:      err = cimg_sscanf(tmp,"%u%*c%255[A-Za-z123468_]%*c%255[sA-Za-z_ ]",&N,str_pixeltype._data,str_endian._data);
CImg.h:      \param x0 Starting X-coordinates of image regions to write.
CImg.h:      \param y0 Starting Y-coordinates of image regions to write.
CImg.h:      \param z0 Starting Z-coordinates of image regions to write.
CImg.h:      \param c0 Starting C-coordinates of image regions to write.
CImg.h:      \param x0 Starting X-coordinates of image regions to write.
CImg.h:      \param y0 Starting Y-coordinates of image regions to write.
CImg.h:      \param z0 Starting Z-coordinates of image regions to write.
CImg.h:      \param c0 Starting C-coordinates of image regions to write.
CImg.h:      for (unsigned int i=nb; i; --i) {
CImg.h:        for (ulongT off = siz; off; --off) std::fputc(0,nfile);
CImg.h:    //! Save empty (non-compressed) .cimg file with specified dimensions.
CImg.h:        cimg_snprintf(command,command._width,"\"%s\" -c \"%s\" > \"%s\"",
CImg.h:        static int last_used_index = -1;
CImg.h:        int index = -1;
CImg.h:                                        "non-(null) filename argument for the first call.",
CImg.h:          if (!writers[index]->isOpened()) {
CImg.h:                writers[index]->write(CImg<ucharT>(_src)._cimg2cvmat());
CImg.h:                __src.channels(0,std::min(__src._spectrum - 1,2U)).resize(W,H);
CImg.h:                writers[index]->write(__src._cimg2cvmat());
CImg.h:          last_used_index = -1;
CImg.h:            _src.assign(_src.get_resize(_src._width + (_src._width%2),_src._height + (_src._height%2),1,-100,0),false);
CImg.h:            _src.assign(_src.get_resize(-100,-100,1,3),false);
CImg.h:                    "\"%s\" -v -8 -y -i \"%s_%%6d.ppm\" -pix_fmt yuv420p -vcodec %s -b %uk -r %u \"%s\"",
CImg.h:          if (failed_to_compress) { // Write in a non-compressed way
CImg.h:      err = cimg_sscanf(tmp,"%u%*c%255[A-Za-z123468_]%*c%255[sA-Za-z_ ]",
CImg.h:    //----------------------------------
CImg.h:    //----------------------------------
CImg.h:    //! Return a CImg pre-defined font with requested height.
CImg.h:          dataf.append(CImg<char>::string(font_data[ind][k],k==font_chunk[ind] - 1,true),'x');
CImg.h:            const int _n = (int)(*ptrs - M - 32), v = _n>=0?255:0, n = _n>=0?_n:-_n;
CImg.h:            else { std::memset(ptrd,v,ptrde - ptrd); break; }
CImg.h:            int n = (int)*ptrs - M - 32, v = 0;
CImg.h:              n = -n;
CImg.h:              v = (int)*(++ptrs) - M - 32;
CImg.h:              if (v<0) { v = 0; --ptrs; } else v*=85;
CImg.h:            else { std::memset(ptrd,v,ptrde - ptrd); break; }
CImg.h:        fonts->assign();
CImg.h:            font[l].resize(std::max(1U,font[l]._width*requested_height/font[l]._height),requested_height,-100,-100,5);
CImg.h:            if (xmin<=xmax) letter.crop(xmin,0,xmax,letter._height - 1);
CImg.h:          font[(int)' '].resize(font[(int)'f']._width,-100,-100,-100,0);
CImg.h:          if (' ' + 256<font.size()) font[' ' + 256].resize(font[(int)'f']._width,-100,-100,-100,0);
CImg.h:    //! Compute a 1-D Fast Fourier Transform, along specified axis \newinstance.
CImg.h:    //! Compute n-D Fast Fourier Transform.
CImg.h:    //! Compute n-D Fast Fourier Transform \newinstance.
CImg.h:  //--------------------------------------------
CImg.h:      // Try alternative method, with wide-character string.
CImg.h:      int err = MultiByteToWideChar(CP_UTF8,0,path,-1,0,0);
CImg.h:        err = MultiByteToWideChar(CP_UTF8,0,path,-1,wpath,err);
CImg.h:        if (err) { // Convert 'mode' to a wide-character string
CImg.h:          err = MultiByteToWideChar(CP_UTF8,0,mode,-1,0,0);
CImg.h:            if (MultiByteToWideChar(CP_UTF8,0,mode,-1,wmode,err))
CImg.h:    //! Get the file or directory attributes with support for UTF-8 paths (Windows only).
CImg.h:        // Try alternative method, with wide-character string.
CImg.h:        int err = MultiByteToWideChar(CP_UTF8,0,path,-1,0,0);
CImg.h:          if (MultiByteToWideChar(CP_UTF8,0,path,-1,wpath,err)) res = GetFileAttributesW(wpath);
CImg.h:          if (pfPath) std::strncpy(s_path,pfPath,MAX_PATH - 1);
CImg.h:        for (int k = 32; k>=10 && !path_found; --k) {
CImg.h:          cimg_snprintf(s_path,s_path._width,"%s\\GRAPHI~1.%.2d-\\gm.exe",pf_path,k);
CImg.h:        for (int k = 9; k>=0 && !path_found; --k) {
CImg.h:          cimg_snprintf(s_path,s_path._width,"%s\\GRAPHI~1.%d-Q\\gm.exe",pf_path,k);
CImg.h:        for (int k = 32; k>=0 && !path_found; --k) {
CImg.h:        for (int k = 32; k>=10 && !path_found; --k) {
CImg.h:          cimg_snprintf(s_path,s_path._width,"%s\\GRAPHI~1.%.2d-\\VISUA~1\\BIN\\gm.exe",pf_path,k);
CImg.h:        for (int k = 9; k>=0 && !path_found; --k) {
CImg.h:          cimg_snprintf(s_path,s_path._width,"%s\\GRAPHI~1.%d-Q\\VISUA~1\\BIN\\gm.exe",pf_path,k);
CImg.h:        for (int k = 32; k>=0 && !path_found; --k) {
CImg.h:        for (int k = 32; k>=10 && !path_found; --k) {
CImg.h:          cimg_snprintf(s_path,s_path._width,"C:\\GRAPHI~1.%.2d-\\gm.exe",k);
CImg.h:        for (int k = 9; k>=0 && !path_found; --k) {
CImg.h:          cimg_snprintf(s_path,s_path._width,"C:\\GRAPHI~1.%d-Q\\gm.exe",k);
CImg.h:        for (int k = 32; k>=0 && !path_found; --k) {
CImg.h:        for (int k = 32; k>=10 && !path_found; --k) {
CImg.h:          cimg_snprintf(s_path,s_path._width,"C:\\GRAPHI~1.%.2d-\\VISUA~1\\BIN\\gm.exe",k);
CImg.h:        for (int k = 9; k>=0 && !path_found; --k) {
CImg.h:          cimg_snprintf(s_path,s_path._width,"C:\\GRAPHI~1.%d-Q\\VISUA~1\\BIN\\gm.exe",k);
CImg.h:        for (int k = 32; k>=0 && !path_found; --k) {
CImg.h:        for (int k = 32; k>=10 && !path_found; --k) {
CImg.h:          cimg_snprintf(s_path,s_path._width,"D:\\GRAPHI~1.%.2d-\\gm.exe",k);
CImg.h:        for (int k = 9; k>=0 && !path_found; --k) {
CImg.h:          cimg_snprintf(s_path,s_path._width,"D:\\GRAPHI~1.%d-Q\\gm.exe",k);
CImg.h:        for (int k = 32; k>=0 && !path_found; --k) {
CImg.h:        for (int k = 32; k>=10 && !path_found; --k) {
CImg.h:          cimg_snprintf(s_path,s_path._width,"D:\\GRAPHI~1.%.2d-\\VISUA~1\\BIN\\gm.exe",k);
CImg.h:        for (int k = 9; k>=0 && !path_found; --k) {
CImg.h:          cimg_snprintf(s_path,s_path._width,"D:\\GRAPHI~1.%d-Q\\VISUA~1\\BIN\\gm.exe",k);
CImg.h:        for (int k = 32; k>=0 && !path_found; --k) {
CImg.h:          for (int k = 32; k>=10 && !path_found; --k) {
CImg.h:            cimg_snprintf(s_path,s_path._width,"%s\\IMAGEM~1.%.2d-\\%s.exe",pf_path,k,s_exe);
CImg.h:          for (int k = 9; k>=0 && !path_found; --k) {
CImg.h:            cimg_snprintf(s_path,s_path._width,"%s\\IMAGEM~1.%d-Q\\%s.exe",pf_path,k,s_exe);
CImg.h:          for (int k = 32; k>=0 && !path_found; --k) {
CImg.h:          for (int k = 32; k>=10 && !path_found; --k) {
CImg.h:            cimg_snprintf(s_path,s_path._width,"%s\\IMAGEM~1.%.2d-\\VISUA~1\\BIN\\%s.exe",pf_path,k,s_exe);
CImg.h:          for (int k = 9; k>=0 && !path_found; --k) {
CImg.h:            cimg_snprintf(s_path,s_path._width,"%s\\IMAGEM~1.%d-Q\\VISUA~1\\BIN\\%s.exe",pf_path,k,s_exe);
CImg.h:          for (int k = 32; k>=0 && !path_found; --k) {
CImg.h:          for (int k = 32; k>=10 && !path_found; --k) {
CImg.h:            cimg_snprintf(s_path,s_path._width,"C:\\IMAGEM~1.%.2d-\\%s.exe",k,s_exe);
CImg.h:          for (int k = 9; k>=0 && !path_found; --k) {
CImg.h:            cimg_snprintf(s_path,s_path._width,"C:\\IMAGEM~1.%d-Q\\%s.exe",k,s_exe);
CImg.h:          for (int k = 32; k>=0 && !path_found; --k) {
CImg.h:          for (int k = 32; k>=10 && !path_found; --k) {
CImg.h:            cimg_snprintf(s_path,s_path._width,"C:\\IMAGEM~1.%.2d-\\VISUA~1\\BIN\\%s.exe",k,s_exe);
CImg.h:          for (int k = 9; k>=0 && !path_found; --k) {
CImg.h:            cimg_snprintf(s_path,s_path._width,"C:\\IMAGEM~1.%d-Q\\VISUA~1\\BIN\\%s.exe",k,s_exe);
CImg.h:          for (int k = 32; k>=0 && !path_found; --k) {
CImg.h:          for (int k = 32; k>=10 && !path_found; --k) {
CImg.h:            cimg_snprintf(s_path,s_path._width,"D:\\IMAGEM~1.%.2d-\\%s.exe",k,s_exe);
CImg.h:          for (int k = 9; k>=0 && !path_found; --k) {
CImg.h:            cimg_snprintf(s_path,s_path._width,"D:\\IMAGEM~1.%d-Q\\%s.exe",k,s_exe);
CImg.h:          for (int k = 32; k>=0 && !path_found; --k) {
CImg.h:          for (int k = 32; k>=10 && !path_found; --k) {
CImg.h:            cimg_snprintf(s_path,s_path._width,"D:\\IMAGEM~1.%.2d-\\VISUA~1\\BIN\\%s.exe",k,s_exe);
CImg.h:          for (int k = 9; k>=0 && !path_found; --k) {
CImg.h:            cimg_snprintf(s_path,s_path._width,"D:\\IMAGEM~1.%d-Q\\VISUA~1\\BIN\\%s.exe",k,s_exe);
CImg.h:          for (int k = 32; k>=0 && !path_found; --k) {
CImg.h:          std::strncpy(tmp,filename_tmp,tmp._width - 1);
CImg.h:      if (!_is_pattern && lp && _path[lp - 1]=='/') {
CImg.h:        _path[lp - 1] = 0; --lp;
CImg.h:        const unsigned int bpos = (unsigned int)(cimg::basename(_path,'/') - _path.data());
CImg.h:          _path[bpos - 1] = 0; // End 'path' at last slash
CImg.h:        const char *const filename = ent->d_name;
CImg.h:          if (stat(full_filename,&st)==-1) continue;
CImg.h:       \param filename Filename, as a C-string (can be \c 0 if \c file is set).
CImg.h:       \return C-string containing the guessed file format, or \c 0 if nothing has been guessed.
CImg.h:       \param url URL of the filename, as a C-string.
CImg.h:       \param[out] filename_local C-string containing the path to a local copy of \c filename.
CImg.h:       \param referer Referer used, as a C-string.
CImg.h:      const char *const __ext = cimg::split_filename(url), *const _ext = (*__ext && __ext>url)?__ext - 1:__ext;
CImg.h:          cimg_snprintf(command,command._width,"\"%s\" -e %s -m %u -f --silent --compressed -o \"%s\" \"%s\"",
CImg.h:          cimg_snprintf(command,command._width,"\"%s\" -m %u -f --silent --compressed -o \"%s\" \"%s\"",
CImg.h:          cimg_snprintf(command,command._width,"\"%s\" -e %s -f --silent --compressed -o \"%s\" \"%s\"",
CImg.h:          cimg_snprintf(command,command._width,"\"%s\" -f --silent --compressed -o \"%s\" \"%s\"",
CImg.h:                          "\"%s\" -NonInteractive -Command Invoke-WebRequest -Headers @{'Referer'='%s'} "
CImg.h:                          "-TimeoutSec %u -OutFile \"%s\" -Uri \"%s\"",
CImg.h:                          "\"%s\" -NonInteractive -Command Invoke-WebRequest "
CImg.h:                          "-TimeoutSec %u -OutFile \"%s\" -Uri \"%s\"",
CImg.h:            cimg_snprintf(command,command._width,"\"%s\" -NonInteractive -Command Invoke-WebRequest "
CImg.h:                          "-Headers @{'Referer'='%s'} -OutFile \"%s\" -Uri \"%s\"",
CImg.h:            cimg_snprintf(command,command._width,"\"%s\" -NonInteractive -Command Invoke-WebRequest "
CImg.h:                          "-OutFile \"%s\" -Uri \"%s\"",
CImg.h:            cimg_snprintf(command,command._width,"\"%s\" --referer=%s -T %u -q -r -l 0 --no-cache -O \"%s\" \"%s\"",
CImg.h:            cimg_snprintf(command,command._width,"\"%s\" -T %u -q -r -l 0 --no-cache -O \"%s\" \"%s\"",
CImg.h:            cimg_snprintf(command,command._width,"\"%s\" --referer=%s -q -r -l 0 --no-cache -O \"%s\" \"%s\"",
CImg.h:            cimg_snprintf(command,command._width,"\"%s\" -q -r -l 0 --no-cache -O \"%s\" \"%s\"",
CImg.h:        cimg_snprintf(command,command._width,"\"%s\" --quiet \"%s.gz\"",
CImg.h:        t0 = times[--pos],
CImg.h:        dt = t1>=t0?(t1 - t0):cimg::type<cimg_uint64>::max();
CImg.h:        ehours = (unsigned int)((dt - edays*86400000.)/3600000.),
CImg.h:        emin = (unsigned int)((dt - edays*86400000. - ehours*3600000.)/60000.),
CImg.h:        esec = (unsigned int)((dt - edays*86400000. - ehours*3600000. - emin*60000.)/1000.),
CImg.h:        ems = (unsigned int)(dt - edays*86400000. - ehours*3600000. - emin*60000. - esec*1000.);
CImg.h:       \return Index of clicked button (from \c 0 to \c 5), or \c -1 if the dialog window has been closed by the user.
CImg.h:       - Up to 6 buttons can be defined in the dialog window.
CImg.h:       - The function returns when a user clicked one of the button or closed the dialog window.
CImg.h:       - If a button text is set to 0, the corresponding button (and the following) will not appear in the dialog box.
CImg.h:      cimglist_for(buttons,l) buttons[l].resize(-100,-100,1,3);
CImg.h:      button.draw_rectangle(0,0,bw - 1,bh - 1,gray);
CImg.h:      button.draw_line(0,0,bw - 1,0,white).draw_line(0,bh - 1,0,0,white);
CImg.h:      button.draw_line(bw - 1,0,bw - 1,bh - 1,black).draw_line(bw - 1,bh - 1,0,bh - 1,black);
CImg.h:      button.draw_line(1,bh - 2,bw - 2,bh - 2,gray2).draw_line(bw - 2,bh - 2,bw - 2,1,gray2);
CImg.h:      sbutton.draw_rectangle(0,0,bw - 1,bh - 1,gray);
CImg.h:      sbutton.draw_line(0,0,bw - 1,0,black).draw_line(bw - 1,0,bw - 1,bh - 1,black);
CImg.h:      sbutton.draw_line(bw - 1,bh - 1,0,bh - 1,black).draw_line(0,bh - 1,0,0,black);
CImg.h:      sbutton.draw_line(1,1,bw - 2,1,white).draw_line(1,bh - 2,1,1,white);
CImg.h:      sbutton.draw_line(bw - 2,1,bw - 2,bh - 2,black).draw_line(bw - 2,bh - 2,1,bh - 2,black);
CImg.h:      sbutton.draw_line(2,bh - 3,bw - 3,bh - 3,gray2).draw_line(bw - 3,bh - 3,bw - 3,2,gray2);
CImg.h:      sbutton.draw_line(4,4,bw - 5,4,black,1,0xAAAAAAAA,true).
CImg.h:        draw_line(bw - 5,4,bw - 5,bh - 5,black,1,0xAAAAAAAA,false);
CImg.h:      sbutton.draw_line(bw - 5,bh - 5,4,bh - 5,black,1,0xAAAAAAAA,false).
CImg.h:        draw_line(4,bh - 5,4,4,black,1,0xAAAAAAAA,false);
CImg.h:      cbutton.draw_rectangle(0,0,bw - 1,bh - 1,black).draw_rectangle(1,1,bw - 2,bh - 2,gray2).
CImg.h:        draw_rectangle(2,2,bw - 3,bh - 3,gray);
CImg.h:      cbutton.draw_line(4,4,bw - 5,4,black,1,0xAAAAAAAA,true).
CImg.h:        draw_line(bw - 5,4,bw - 5,bh - 5,black,1,0xAAAAAAAA,false);
CImg.h:      cbutton.draw_line(bw - 5,bh - 5,4,bh - 5,black,1,0xAAAAAAAA,false).
CImg.h:        draw_line(4,bh - 5,4,4,black,1,0xAAAAAAAA,false);
CImg.h:          draw_image(1 + (bw  -buttons[ll].width())/2,1 + (bh - buttons[ll].height())/2,buttons[ll]).
CImg.h:          draw_image((bw - buttons[ll].width())/2,(bh - buttons[ll].height())/2,buttons[ll]).
CImg.h:          draw_image((bw - buttons[ll].width())/2,(bh - buttons[ll].height())/2,buttons[ll]).
CImg.h:        ((CImg<unsigned char>().draw_text(0,0,"%s",gray,0,1,13,msg)*=-1)+=200).resize(-100,-100,1,3).move_to(canvas);
CImg.h:        bwall = (buttons._width - 1)*(12 + bw) + bw,
CImg.h:        lx = 12 + (canvas._data?0:((w - 24 - logo._width)/2)),
CImg.h:        ly = (h - 12 - bh - logo._height)/2,
CImg.h:        ty = (h - 12 - bh - canvas._height)/2,
CImg.h:        bx = (w - bwall)/2,
CImg.h:        by = h - 12 - bh;
CImg.h:          draw_rectangle(0,0,w - 1,h - 1,gray).
CImg.h:          draw_line(0,0,w - 1,0,white).draw_line(0,h - 1,0,0,white).
CImg.h:          draw_line(w - 1,0,w - 1,h - 1,black).draw_line(w - 1,h - 1,0,h - 1,black).
CImg.h:          draw_rectangle(0,0,w - 1,h - 1,gray).
CImg.h:          draw_line(0,0,w - 1,0,white).draw_line(0,h - 1,0,0,white).
CImg.h:          draw_line(w - 1,0,w - 1,h - 1,black).draw_line(w - 1,h - 1,0,h - 1,black);
CImg.h:      if (is_centered) disp.move((CImgDisplay::screen_width() - disp.width())/2,
CImg.h:                                 (CImgDisplay::screen_height() - disp.height())/2);
CImg.h:      int oselected = -1, oclicked = -1, selected = -1, clicked = -1;
CImg.h:          clicked = -1;
CImg.h:          case cimg::keyESC : selected = -1; stop_flag = true; break;
CImg.h:          case cimg::keyARROWUP : selected = (selected + buttons.width() - 1)%buttons.width(); break;
CImg.h:      if (!disp) selected = -1;
CImg.h:       \param expression C-string describing the formula to evaluate.
CImg.h:       \param x Value of the pre-defined variable \c x.
CImg.h:       \param y Value of the pre-defined variable \c y.
CImg.h:       \param z Value of the pre-defined variable \c z.
CImg.h:       \param c Value of the pre-defined variable \c c.
jpeg_buffer.h: #                ( C++ header file - CImg plug-in )
jpeg_buffer.h: #  Description : This CImg plug-in provide functions to load and save jpeg images
jpeg_buffer.h: #                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
jpeg_buffer.h: #  professionals having in-depth computer knowledge. Users are therefore
jpeg_buffer.h:/*-----------------------------------------------------------------------------------
jpeg_buffer.h:------------------------------------------------------------------------------------*/
jpeg_buffer.h:  my_src_mptr src = (my_src_mptr) cinfo->src;
jpeg_buffer.h:  if (src->indexinmem + INPUT_BUF_SIZE>src->lenght) nbytes=src->lenght - src->indexinmem;
jpeg_buffer.h:  std::memcpy(src->buffer,src->inmem,nbytes);
jpeg_buffer.h:  src->inmem += nbytes;
jpeg_buffer.h:  src->indexinmem += (int)nbytes;
jpeg_buffer.h:  src->pub.next_input_byte = src->buffer;
jpeg_buffer.h:  src->pub.bytes_in_buffer = INPUT_BUF_SIZE;
jpeg_buffer.h:  src->start_of_file = FALSE;
jpeg_buffer.h:  my_src_ptr src = (my_src_ptr)cinfo->src;
jpeg_buffer.h:    while (num_bytes > (long) src->pub.bytes_in_buffer) {
jpeg_buffer.h:      num_bytes -= (long) src->pub.bytes_in_buffer;
jpeg_buffer.h:    src->pub.next_input_byte += (size_t) num_bytes;
jpeg_buffer.h:    src->pub.bytes_in_buffer -= (size_t) num_bytes;
jpeg_buffer.h:  my_src_mptr src = (my_src_mptr)cinfo->src;
jpeg_buffer.h:  src->start_of_file = TRUE;
jpeg_buffer.h:  if (cinfo->src == NULL) {
jpeg_buffer.h:    cinfo->src = (struct jpeg_source_mgr*)(*cinfo->mem->alloc_small)((j_common_ptr) cinfo,
jpeg_buffer.h:    src = (my_src_mptr) cinfo->src;
jpeg_buffer.h:    src->buffer = (JOCTET *)(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo,
jpeg_buffer.h:  src = (my_src_mptr) cinfo->src;
jpeg_buffer.h:  src->pub.init_source = init_msource;
jpeg_buffer.h:  src->pub.fill_input_buffer = fill_minput_buffer;
jpeg_buffer.h:  src->pub.skip_input_data = skip_minput_data;
jpeg_buffer.h:  //src->pub.resync_to_restart = jpeg_resync_to_restart; // use default method
jpeg_buffer.h:  src->pub.term_source = term_source;
jpeg_buffer.h:  src->inmem = memptr;
jpeg_buffer.h:  src->indexinmem = 0;
jpeg_buffer.h:  src->lenght = lenght;
jpeg_buffer.h:  src->pub.bytes_in_buffer = 0; // forces fill_input_buffer on first read
jpeg_buffer.h:  src->pub.next_input_byte = NULL; // until buffer loaded
jpeg_buffer.h:  mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
jpeg_buffer.h:  dest->pub.next_output_byte = dest->buf;
jpeg_buffer.h:  dest->pub.free_in_buffer = dest->bufsize;
jpeg_buffer.h:  dest->jpegsize = 0;
jpeg_buffer.h:  mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
jpeg_buffer.h:  dest->pub.next_output_byte = dest->buf;
jpeg_buffer.h:  dest->pub.free_in_buffer = dest->bufsize;
jpeg_buffer.h:  mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
jpeg_buffer.h:  dest->jpegsize = dest->bufsize - dest->pub.free_in_buffer;
jpeg_buffer.h:  if (cinfo->dest == NULL) {
jpeg_buffer.h:    cinfo->dest = (struct jpeg_destination_mgr *)
jpeg_buffer.h:      (*cinfo->mem->alloc_small)((j_common_ptr)cinfo,JPOOL_PERMANENT,sizeof(mem_destination_mgr));
jpeg_buffer.h:  dest = (mem_dest_ptr) cinfo->dest;
jpeg_buffer.h:  dest->pub.init_destination = init_destination;
jpeg_buffer.h:  dest->pub.empty_output_buffer = empty_output_buffer;
jpeg_buffer.h:  dest->pub.term_destination = term_destination;
jpeg_buffer.h:  dest->buf = buf;
jpeg_buffer.h:  dest->bufsize = bufsize;
jpeg_buffer.h:  dest->jpegsize = 0;
jpeg_buffer.h:  mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
jpeg_buffer.h:  return dest->jpegsize;
jpeg_buffer.h://! Load image from a jpeg-coded memory buffer.
jpeg_buffer.h:   \param buffer Memory buffer containing the jpeg-coded image data.
jpeg_buffer.h://! Load image from a jpeg-coded memory buffer (in-place version)
jpeg_buffer.h:   \param buffer Memory buffer containing the jpeg-coded image data.
jpeg_buffer.h://! Save image in a memory buffer, directly as a jpeg-coded file
jpeg_buffer.h:   \param buffer Memory buffer that will be written with the jpeg-coded image data.
jpeg_buffer.h:// End of the plug-in
jpeg_buffer.h://-------------------
out.txt:==77287== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
out.txt:==77287== Using Valgrind-3.15.0-608cb11914-20190413 and LibVEX; rerun with -h for copyright info
out.txt:--77287-- Valgrind options:
out.txt:--77287--    --tool=memcheck
out.txt:--77287--    -v
out.txt:--77287--    --leak-check=full
out.txt:--77287--    --track-origins=yes
out.txt:--77287--    --show-reachable=yes
out.txt:--77287-- Contents of /proc/version:
out.txt:--77287--   Linux version 5.4.0-105-generic (buildd@lcy02-amd64-066) (gcc version 9.4.0 (Ubuntu 9.4.0-1ubuntu1~20.04)) #119-Ubuntu SMP Mon Mar 7 18:49:24 UTC 2022
out.txt:--77287-- 
out.txt:--77287-- Arch and hwcaps: AMD64, LittleEndian, amd64-cx16-lzcnt-rdtscp-sse3-ssse3-avx-avx2-bmi-f16c-rdrand
out.txt:--77287-- Page sizes: currently 4096, max supported 4096
out.txt:--77287-- Valgrind library directory: /usr/lib/x86_64-linux-gnu/valgrind
out.txt:--77287-- Reading syms from /sdaone/GIT_HUB/liveimage/liveimage
out.txt:--77287-- Reading syms from /lib/x86_64-linux-gnu/ld-2.31.so
out.txt:--77287--   Considering /lib/x86_64-linux-gnu/ld-2.31.so ..
out.txt:--77287--   .. CRC mismatch (computed 0306b78c wanted 8d362b37)
out.txt:--77287--   Considering /lib/x86_64-linux-gnu/ld-2.31.so ..
out.txt:--77287--   .. CRC mismatch (computed 0306b78c wanted 8d362b37)
out.txt:--77287--   Considering /usr/lib/debug/lib/x86_64-linux-gnu/ld-2.31.so ..
out.txt:--77287--   .. CRC is valid
out.txt:--77287-- Reading syms from /usr/lib/x86_64-linux-gnu/valgrind/memcheck-amd64-linux
out.txt:--77287--    object doesn't have a symbol table
out.txt:--77287--    object doesn't have a dynamic symbol table
out.txt:--77287-- Scheduler: using generic scheduler lock implementation.
out.txt:--77287-- Reading suppressions file: /usr/lib/x86_64-linux-gnu/valgrind/default.supp
out.txt:==77287== embedded gdbserver: reading from /tmp/vgdb-pipe-from-vgdb-to-77287-by-marius-on-???
out.txt:==77287== embedded gdbserver: writing to   /tmp/vgdb-pipe-to-vgdb-from-77287-by-marius-on-???
out.txt:==77287== embedded gdbserver: shared mem   /tmp/vgdb-pipe-shared-mem-vgdb-77287-by-marius-on-???
out.txt:==77287==   /usr/lib/x86_64-linux-gnu/valgrind/../../bin/vgdb --pid=77287 ...command...
out.txt:==77287==   target remote | /usr/lib/x86_64-linux-gnu/valgrind/../../bin/vgdb --pid=77287
out.txt:==77287== --pid is optional if only one valgrind process is running
out.txt:--77287-- REDIR: 0x4022e10 (ld-linux-x86-64.so.2:strlen) redirected to 0x580c9ce2 (???)
out.txt:--77287-- REDIR: 0x4022be0 (ld-linux-x86-64.so.2:index) redirected to 0x580c9cfc (???)
out.txt:--77287-- Reading syms from /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_core-amd64-linux.so
out.txt:--77287--    object doesn't have a symbol table
out.txt:--77287-- Reading syms from /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so
out.txt:--77287--    object doesn't have a symbol table
out.txt:==77287== WARNING: new redirection conflicts with existing -- ignoring it
out.txt:--77287--     old: 0x04022e10 (strlen              ) R-> (0000.0) 0x580c9ce2 ???
out.txt:--77287--     new: 0x04022e10 (strlen              ) R-> (2007.0) 0x0483f060 strlen
out.txt:--77287-- REDIR: 0x401f5f0 (ld-linux-x86-64.so.2:strcmp) redirected to 0x483ffd0 (strcmp)
out.txt:--77287-- REDIR: 0x4023370 (ld-linux-x86-64.so.2:mempcpy) redirected to 0x4843a20 (mempcpy)
out.txt:--77287-- Reading syms from /lib/x86_64-linux-gnu/libpthread-2.31.so
out.txt:--77287--   Considering /usr/lib/debug/.build-id/f0/983025f0e0f327a6da752ff4ffa675e0be393f.debug ..
out.txt:--77287--   .. build-id is valid
out.txt:--77287-- Reading syms from /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2
out.txt:--77287--    object doesn't have a symbol table
out.txt:--77287-- Reading syms from /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0
out.txt:--77287--    object doesn't have a symbol table
out.txt:--77287-- Reading syms from /usr/lib/x86_64-linux-gnu/libstdc++.so.6.0.28
out.txt:--77287--    object doesn't have a symbol table
out.txt:--77287-- Reading syms from /lib/x86_64-linux-gnu/libm-2.31.so
out.txt:--77287--   Considering /lib/x86_64-linux-gnu/libm-2.31.so ..
out.txt:--77287--   .. CRC mismatch (computed 3cfca93f wanted 658b15c9)
out.txt:--77287--   Considering /lib/x86_64-linux-gnu/libm-2.31.so ..
out.txt:--77287--   .. CRC mismatch (computed 3cfca93f wanted 658b15c9)
out.txt:--77287--   Considering /usr/lib/debug/lib/x86_64-linux-gnu/libm-2.31.so ..
out.txt:--77287--   .. CRC is valid
out.txt:--77287-- Reading syms from /lib/x86_64-linux-gnu/libgcc_s.so.1
out.txt:--77287--    object doesn't have a symbol table
out.txt:--77287-- Reading syms from /lib/x86_64-linux-gnu/libc-2.31.so
out.txt:--77287--   Considering /lib/x86_64-linux-gnu/libc-2.31.so ..
out.txt:--77287--   .. CRC mismatch (computed ef41b1a0 wanted f854b801)
out.txt:--77287--   Considering /lib/x86_64-linux-gnu/libc-2.31.so ..
out.txt:--77287--   .. CRC mismatch (computed ef41b1a0 wanted f854b801)
out.txt:--77287--   Considering /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.31.so ..
out.txt:--77287--   .. CRC is valid
out.txt:--77287-- Reading syms from /lib/x86_64-linux-gnu/libdl-2.31.so
out.txt:--77287--   Considering /lib/x86_64-linux-gnu/libdl-2.31.so ..
out.txt:--77287--   .. CRC mismatch (computed 2bb25318 wanted f334bb32)
out.txt:--77287--   Considering /lib/x86_64-linux-gnu/libdl-2.31.so ..
out.txt:--77287--   .. CRC mismatch (computed 2bb25318 wanted f334bb32)
out.txt:--77287--   Considering /usr/lib/debug/lib/x86_64-linux-gnu/libdl-2.31.so ..
out.txt:--77287--   .. CRC is valid
out.txt:--77287-- Reading syms from /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0
out.txt:--77287--    object doesn't have a symbol table
out.txt:--77287-- Reading syms from /lib/x86_64-linux-gnu/librt-2.31.so
out.txt:--77287--   Considering /lib/x86_64-linux-gnu/librt-2.31.so ..
out.txt:--77287--   .. CRC mismatch (computed a25149bb wanted cf42d776)
out.txt:--77287--   Considering /lib/x86_64-linux-gnu/librt-2.31.so ..
out.txt:--77287--   .. CRC mismatch (computed a25149bb wanted cf42d776)
out.txt:--77287--   Considering /usr/lib/debug/lib/x86_64-linux-gnu/librt-2.31.so ..
out.txt:--77287--   .. CRC is valid
out.txt:--77287-- REDIR: 0x4d2d4b0 (libc.so.6:memmove) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2c7b0 (libc.so.6:strncpy) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2d7e0 (libc.so.6:strcasecmp) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2c0d0 (libc.so.6:strcat) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2c810 (libc.so.6:rindex) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2ec80 (libc.so.6:rawmemchr) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d49d10 (libc.so.6:wmemchr) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d49850 (libc.so.6:wcscmp) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2d610 (libc.so.6:mempcpy) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2d440 (libc.so.6:bcmp) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2c740 (libc.so.6:strncmp) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2c180 (libc.so.6:strcmp) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2d570 (libc.so.6:memset) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d49810 (libc.so.6:wcschr) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2c6a0 (libc.so.6:strnlen) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2c260 (libc.so.6:strcspn) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2d830 (libc.so.6:strncasecmp) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2c200 (libc.so.6:strcpy) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2d980 (libc.so.6:memcpy@@GLIBC_2.14) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d4af80 (libc.so.6:wcsnlen) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d49890 (libc.so.6:wcscpy) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2c850 (libc.so.6:strpbrk) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2c130 (libc.so.6:index) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2c660 (libc.so.6:strlen) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d35bd0 (libc.so.6:memrchr) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2d880 (libc.so.6:strcasecmp_l) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2d400 (libc.so.6:memchr) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d49960 (libc.so.6:wcslen) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2cb10 (libc.so.6:strspn) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2d780 (libc.so.6:stpncpy) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2d720 (libc.so.6:stpcpy) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2ecc0 (libc.so.6:strchrnul) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2d8d0 (libc.so.6:strncasecmp_l) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4dba880 (libc.so.6:__memcpy_chk) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4d2d320 (libc.so.6:strstr) redirected to 0x48311d0 (_vgnU_ifunc_wrapper)
out.txt:--77287-- REDIR: 0x4e15410 (libc.so.6:__strrchr_avx2) redirected to 0x483ea10 (rindex)
out.txt:--77287-- REDIR: 0x4d27110 (libc.so.6:malloc) redirected to 0x483b780 (malloc)
out.txt:--77287-- REDIR: 0x4e155e0 (libc.so.6:__strlen_avx2) redirected to 0x483ef40 (strlen)
out.txt:--77287-- REDIR: 0x4e11bd0 (libc.so.6:__memcmp_avx2_movbe) redirected to 0x48421e0 (bcmp)
out.txt:--77287-- REDIR: 0x4e10ae0 (libc.so.6:__strcmp_avx2) redirected to 0x483fed0 (strcmp)
out.txt:--77287-- REDIR: 0x4e185f0 (libc.so.6:__memcpy_avx_unaligned_erms) redirected to 0x48429f0 (memmove)
out.txt:--77287-- REDIR: 0x4d2cfd0 (libc.so.6:__GI_strstr) redirected to 0x4843ca0 (__strstr_sse2)
out.txt:--77287-- REDIR: 0x4e11440 (libc.so.6:__memchr_avx2) redirected to 0x4840050 (memchr)
out.txt:--77287-- REDIR: 0x4e14ff0 (libc.so.6:__strchr_avx2) redirected to 0x483ebf0 (index)
out.txt:--77287-- REDIR: 0x4e16b20 (libc.so.6:__strcpy_avx2) redirected to 0x483f090 (strcpy)
out.txt:--77287-- REDIR: 0x49e9b20 (libstdc++.so.6:operator new(unsigned long)) redirected to 0x483bdf0 (operator new(unsigned long))
out.txt:--77287-- REDIR: 0x4d27700 (libc.so.6:free) redirected to 0x483c9d0 (free)
out.txt:--77287-- REDIR: 0x4e11710 (libc.so.6:__rawmemchr_avx2) redirected to 0x4843580 (rawmemchr)
out.txt:--77287-- REDIR: 0x4e15220 (libc.so.6:__strchrnul_avx2) redirected to 0x4843540 (strchrnul)
out.txt:--77287-- REDIR: 0x4e185d0 (libc.so.6:__mempcpy_avx_unaligned_erms) redirected to 0x4843660 (mempcpy)
out.txt:--77287-- REDIR: 0x4d27eb0 (libc.so.6:realloc) redirected to 0x483df30 (realloc)
out.txt:--77287-- REDIR: 0x4d28b40 (libc.so.6:calloc) redirected to 0x483dce0 (calloc)
out.txt:--77287-- Reading syms from /usr/lib/x86_64-linux-gnu/libv4l/plugins/libv4l-mplane.so
out.txt:--77287--    object doesn't have a symbol table
out.txt:--77287-- Discarding syms at 0x484b120-0x484bc22 in /usr/lib/x86_64-linux-gnu/libv4l/plugins/libv4l-mplane.so (have_dinfo 1)
out.txt:--77287-- REDIR: 0x4e15780 (libc.so.6:__strnlen_avx2) redirected to 0x483eee0 (strnlen)
out.txt:--77287-- REDIR: 0x4e18a70 (libc.so.6:__memset_avx2_unaligned_erms) redirected to 0x48428e0 (memset)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49326B9: ??? (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x49340BA: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x493455D: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49347FC: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49345E3: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49345E3: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:--77287-- REDIR: 0x49e9b80 (libstdc++.so.6:operator new[](unsigned long)) redirected to 0x483c510 (operator new[](unsigned long))
out.txt:--77287-- REDIR: 0x4d48410 (libc.so.6:__strstr_sse2_unaligned) redirected to 0x4843c20 (strstr)
out.txt:==77287==    at 0x483BE63: operator new(unsigned long) (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x4932C84: ??? (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4934E21: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x4932C84: ??? (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4934E21: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49345E3: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49345E3: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49345E3: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    at 0x48E10C2: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1636: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1646: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1651: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E165A: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E17C2: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E17C6: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E17D8: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1809: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1755: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1774: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1793: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E17B2: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E11D0: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E11EF: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E120E: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E122D: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E124C: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E126B: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E10F4: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1113: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1151: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1132: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1170: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E118F: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E183A: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1859: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1897: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E18D5: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1878: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E18B6: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48B1A31: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48B1BB8: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BC6FD: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AE8DE: jpeg_finish_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48B1A4F: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48B1BB8: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BC6FD: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AE8DE: jpeg_finish_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:--77287-- memcheck GC: 1000 nodes, 991 survivors (99.1%)
out.txt:--77287-- memcheck GC: 1414 new table size (stepup)
out.txt:--77287-- memcheck GC: 1414 nodes, 1414 survivors (100.0%)
out.txt:--77287-- memcheck GC: 1999 new table size (stepup)
out.txt:--77287-- REDIR: 0x49e7d70 (libstdc++.so.6:operator delete(void*)) redirected to 0x483cf50 (operator delete(void*))
out.txt:--77287-- REDIR: 0x49e7da0 (libstdc++.so.6:operator delete[](void*)) redirected to 0x483d6e0 (operator delete[](void*))
out.txt:Motion-JPEG
out.txt:==77287== Searching for pointers to 1 not-freed blocks
out.txt:==77287==    at 0x483C583: operator new[](unsigned long) (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    at 0x48B1A31: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48B1BB8: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BC6FD: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AE8DE: jpeg_finish_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49345E3: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49345E3: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49345E3: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x4932C84: ??? (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4934E21: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x4932C84: ??? (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4934E21: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    at 0x483BE63: operator new(unsigned long) (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49345E3: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49345E3: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49347FC: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x493455D: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x4E88973: ??? (in /usr/lib/x86_64-linux-gnu/libv4lconvert.so.0.0.0)
out.txt:==77287==    by 0x49326B9: ??? (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    by 0x49340BA: v4l2_ioctl (in /usr/lib/x86_64-linux-gnu/libv4l2.so.0.0.0)
out.txt:==77287==    at 0x48B1A4F: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48B1BB8: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BC6FD: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AE8DE: jpeg_finish_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E18B6: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1878: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1859: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E183A: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E18D5: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1897: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E126B: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1170: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E118F: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1151: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1132: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E10F4: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1113: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E124C: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E122D: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E11EF: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E11D0: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E120E: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E17B2: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1793: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1755: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1774: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1809: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E10C2: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E17D8: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E17C6: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E17C2: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E165A: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1651: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1646: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x48E1636: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    at 0x483B7F3: malloc (in /usr/lib/x86_64-linux-gnu/valgrind/vgpreload_memcheck-amd64-linux.so)
out.txt:==77287==    by 0x48D9DEC: ??? (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BCCC1: jinit_c_master_control (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48BB31E: jinit_compress_master (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
out.txt:==77287==    by 0x48AEAF4: jpeg_start_compress (in /usr/lib/x86_64-linux-gnu/libjpeg.so.8.2.2)
jencoder.cpp:    _jpgenc->init(d);
jencoder.cpp:        return _jpgenc->cam_to_jpg(img, name);
jencoder.cpp:    return _jpgenc->cam_to_bw_for_motion(img);
Binary file xxx.txt matches
mainn.cpp:    First Release: September 16 - 29 2016
mainn.cpp:sudo apt-get install libv4l-dev libjpeg-dev
mainn.cpp:        pCFG->parse("./liveimage.konf");
mainn.cpp:        if(!pserver->init(img_size))
mainn.cpp:            if(url.find("rtsp")!=(size_t)-1)
mainn.cpp:                if(url.find("http")!=(size_t)-1)
mainn.cpp:                ps->init(img_size);
mainn.cpp:                pc->set_peer(ps);
mainn.cpp:            pc->init(img_size);
mainn.cpp:                pserver->reg_cam(pc->name());
mainn.cpp:            pserver->spin(cameras);
mainn.cpp:            p->get_frame(image);
mainn.cpp:                    encode.cam_to_jpg(image, p->name());
mainn.cpp:                loopevent = p->proc_events(image);
mainn.cpp:                if(p->peer())
mainn.cpp:                    p->peer()->stream(image._jpgp,
mainn.cpp:                                        p->name(),
mainn.cpp:                if(pserver && pserver->has_clients(p->name()))
mainn.cpp:                    int wants = pserver->anyone_needs();
mainn.cpp:                        pserver->stream_on(image._jpgp, image._jpgl, image._jpgf, wants, p);
mainn.cpp:                        const uint8_t*  mot = p->getm(w, h, sz);
mainn.cpp:                                pserver->stream_on(imly._jpgp, imly._jpgl, imly._jpgf, wants, p);
mainn.cpp:                            pserver->stream_on(nullptr, 0, eFJPG, wants, p);
mainn.cpp:                p->clean_events();
sock.cpp:# Copyright (C) 2007-2014 Chincisan Octavian-Marius(mariuschincisan@gmail.com) - coinscode.com - N/A
sock.cpp:# http://www.apache.org/licenses/LICENSE-2.0
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:bio_unblock::bio_unblock(sock* sock, int bl):_sk(sock),_bl(_sk->_blocking){
sock.cpp:    sock->set_blocking(bl);
sock.cpp:    _sk->set_blocking(_bl);
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:        ::memcpy((char*)&(sin.sin_addr), hostent->h_addr, hostent->h_length);
sock.cpp:        strcpy(out, h->h_name);
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    _thesock     = -1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:        if (flags == -1) return false;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    return (SOCKET)-1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    return (SOCKET)-1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    if(-1 == gethostname((char*)szBuf, (int)dwSize))
sock.cpp:    ::memcpy((char*)&(locSin.sin_addr), pHe->h_addr,pHe->h_length);
sock.cpp:        if (ifAddrStruct->ifa_addr->sa_family==AF_INET && strcmp(ifAddrStruct->ifa_name, "lo0")!=0)
sock.cpp:            tmpAddrPtr = (void*)&((SADDR_46 *)ifAddrStruct->ifa_addr)->sin_addr;
sock.cpp:            inet_ntop(AF_INET, tmpAddrPtr, tmp, (sizeof(tmp)-1));
sock.cpp:            if(strlen(localip) + strlen(tmp) < (sizeof(localip)-1) )
sock.cpp:        ifAddrStruct = ifAddrStruct->ifa_next;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    return -1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    return -1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    int      bytes = -1;
sock.cpp:    return -1; // no data this time
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:        toreceive -= shot;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    while(length > 0 &&  tout-->0)
sock.cpp:        if(shot==-1){
sock.cpp:            length -= shot;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:            return -1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:            return -1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:        while(-1==::close(_thesock) && --k>0)
sock.cpp:    _thesock = -1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    if((int)-1 == rv)
sock.cpp:        return -1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:        return (SOCKET)-1;
sock.cpp:        return (SOCKET)-1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:        return (SOCKET)-1;
sock.cpp:        return (SOCKET)-1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:        return -1;
sock.cpp://as send -1 continue, 0 closed -cannot 1 ok
sock.cpp:    ::memcpy((char*)&(_remote_sin.sin_addr), _hostent->h_addr, _hostent->h_length);
sock.cpp:    this->set_blocking(1);
sock.cpp:    if(-1 == ::connect(_thesock, (const struct sockaddr*)&_remote_sin, _remote_sin.rsz()))
sock.cpp:    ::memcpy((char*)&(locSin.sin_addr), _hostent->h_addr, _hostent->h_length);
sock.cpp:// 0 no connection, >0 OK, -1 in progress
sock.cpp:    if(-1 == rv)
sock.cpp:                while(time(0) - t < tout)
sock.cpp:            return -1;
sock.cpp:    if(-1 == rv)
sock.cpp:            return -1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    if((int)_thesock != (int)-1)
sock.cpp:    if(err==-1 )
sock.cpp:        while(cbCall(pUser, time(0)-ti))
sock.cpp:    if(err==-1)
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    if((int)_thesock != (int)-1)
sock.cpp:    if(err==-1)
sock.cpp:        if(pUser==(void*)-1)
sock.cpp:            return -1;
sock.cpp:        int tdiff = time(0)-ti;
sock.cpp:            tdiff = time(0)-ti;
sock.cpp:    if(err==-1)
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:        ::memcpy((char*)&(locSin.sin_addr), _hostent->h_addr, _hostent->h_length);
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    if((int)-1 == (int)_thesock)
sock.cpp:        return -1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    if((int)-1 == (int)_thesock)
sock.cpp:        return -1;
sock.cpp:        printf("udp-sock-bind-error\n");
sock.cpp:        return -1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    int snd = -1;
sock.cpp:        ////printf("<-to %s : %d\n", IP2STR(_remote_sin.sin_addr.s_addr), htons(_remote_sin.sin_port));
sock.cpp:        ////printf("<-to %s : %d\n", IP2STR(_remote_sin.sin_addr.s_addr), htons(_remote_sin.sin_port));
sock.cpp:    if(-1 == snd)
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:        ////printf("<-to %s : %d\n", IP2STR(rsin.sin_addr.s_addr), htons(rsin.sin_port));
sock.cpp:    if(-1 == snd)
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    if(rcv==-1)
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    if(rcv==-1)
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    while(cbCall(pUser, time(0)-ti))
sock.cpp:    return -1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:              sizeof (_local_sin)) == -1)
sock.cpp:        return -1;
sock.cpp:                    (char  *)&iOptVal, sizeof (int)) == -1)
sock.cpp:        return -1;
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    if(i==-1)
sock.cpp://-----------------------------------------------------------------------------
sock.cpp://-----------------------------------------------------------------------------
sock.cpp:    if(_thesock != -1)
sock.cpp:        return -1;
sock.cpp:    if (bnd == -1)
sock.cpp:    if (bnd == -1)
liveimage_srv/pool.cpp:        DELETE_PTR(a.second->_cam);
liveimage_srv/pool.cpp:        if(pr->_clis.size())
liveimage_srv/pool.cpp:            for(auto& csc: pr->_clis)
liveimage_srv/pool.cpp:            pr->_clis.clear();
liveimage_srv/pool.cpp:                    (*it).second->_cam;
liveimage_srv/pool.cpp:        for(const auto& css : pr->_clis)
liveimage_srv/pool.cpp:            if(css->Rsin().c_str() == sin.Rsin().c_str())
liveimage_srv/pool.cpp:    hret += "<head><meta http-equiv='refresh' content='5'></head>\r\n";
liveimage_srv/pool.cpp:            const TcpCamCli* pc = a.second->_cam;
liveimage_srv/pool.cpp:            lis[pc->name()] += " and is streaming.\r\n";
liveimage_srv/pool.cpp: * @return   [FIRST=CHANNEL-CAM,SECOND CLI-CONN]
liveimage_srv/pool.cpp:        if(a.second->_cam->name()==channel)
liveimage_srv/pool.cpp:            return a.second->_cam->header();
liveimage_srv/pool.cpp:        if(a.second->_cam!=nullptr)
liveimage_srv/pool.cpp:            _kill_conn(a.second->_cam);
liveimage_srv/pool.cpp:        for(const auto& css : pr->_clis)
liveimage_srv/pool.cpp:        FD_SET(a.second->_cam->socket(),&fdr);
liveimage_srv/pool.cpp:        FD_SET(a.second->_cam->socket(),&fdw);
liveimage_srv/pool.cpp:        FD_SET(a.second->_cam->socket(),&fdx);
liveimage_srv/pool.cpp:        ndfs = std::max(ndfs,a.second->_cam->socket());
liveimage_srv/pool.cpp:        for(const auto& css : pr->_clis)
liveimage_srv/pool.cpp:            if(css && css->isopen())
liveimage_srv/pool.cpp:                FD_SET(css->socket(),&fdr);
liveimage_srv/pool.cpp:                // FD_SET(css->socket(),&fdw);
liveimage_srv/pool.cpp:                // FD_SET(css->socket(),&fdx);
liveimage_srv/pool.cpp:                ndfs = std::max(ndfs,css->socket());
liveimage_srv/pool.cpp:    if(sel==-1){
liveimage_srv/pool.cpp:        if(!a.second->_cam->isopen()) {
liveimage_srv/pool.cpp:        if(FD_ISSET(a.second->_cam->socket(),&fdx))
liveimage_srv/pool.cpp:            _kill_conn(a.second->_cam);
liveimage_srv/pool.cpp:        if(FD_ISSET(a.second->_cam->socket(),&fdw))
liveimage_srv/pool.cpp:            a.second->_cam->can_send();
liveimage_srv/pool.cpp:        if(FD_ISSET(a.second->_cam->socket(),&fdr))
liveimage_srv/pool.cpp:                a.second->_cam->transfer(a.second->_clis);
liveimage_srv/pool.cpp:                if(SECS()-nowt>CHECK_CLIENTS_TOUT)
liveimage_srv/pool.cpp:                    _check_activity(a.second->_cam,a.second->_clis.size());
liveimage_srv/pool.cpp:    this->record_cam(cam->name());
liveimage_srv/pool.cpp:        this->record_cli(cam->name());
liveimage_srv/pool.cpp:        if(this->client_was_here(cam->name())==false)
liveimage_srv/pool.cpp:            time_t lt = SECS() - cam->last_time();
liveimage_srv/pool.cpp:        pcs->bind(&_tm);
liveimage_srv/pool.cpp:        Pool::Pair* pexistentCam = _has(pcs->name());     /* a camera conn */
liveimage_srv/pool.cpp:            if(pcs->type()==RawSock::CAM) // is camera socket
liveimage_srv/pool.cpp:            if(pcs->type()==RawSock::CLIENT||
liveimage_srv/pool.cpp:                    pcs->type()==RawSock::CLIJPEG||
liveimage_srv/pool.cpp:                    pcs->type()==RawSock::CLIRTSP) // check if is a Client socket
liveimage_srv/pool.cpp:        if(pr->_cam->isopen()==false)
liveimage_srv/pool.cpp:            for(auto& client : pr->_clis)
liveimage_srv/pool.cpp:            pr->_clis.clear();
liveimage_srv/pool.cpp:            _del_camera(pr->_cam);
liveimage_srv/pool.cpp:            DELETE_PTR (pr->_cam);
liveimage_srv/pool.cpp:        if(pr->_clis.size())
liveimage_srv/pool.cpp:            std::vector<RawSock*>::iterator it = pr->_clis.begin();
liveimage_srv/pool.cpp:            for(;it!=pr->_clis.end();it++)
liveimage_srv/pool.cpp:                if((*it)->isopen()==false)
liveimage_srv/pool.cpp:                    if(pr->_cam)
liveimage_srv/pool.cpp:                        pr->_cam->bind((TcpWebSock*)*it,false);
liveimage_srv/pool.cpp:                    pr->_clis.erase(it);
liveimage_srv/pool.cpp:    if(pr->_cam && pr->_cam->isopen())
liveimage_srv/pool.cpp:        pr->_cam->sendall("client_off",7);
liveimage_srv/pool.cpp:    pcamerain->_clis.push_back(pcs);
liveimage_srv/pool.cpp:    pcamerain->_cam->bind((TcpWebSock*)pcs,true);
liveimage_srv/pool.cpp:    //pcamerain->_cam->sendall("client_on",6);
liveimage_srv/pool.cpp:    p->_cam = (TcpCamCli*)(pcs);
liveimage_srv/pool.cpp:    p->_cam->bind(nullptr,false);
liveimage_srv/pool.cpp:    p->_clis.clear();
liveimage_srv/pool.cpp:    if(_pool.find(pcs->name())!=_pool.end())
liveimage_srv/pool.cpp:        _kill_conn(_pool[pcs->name()]->_cam);
liveimage_srv/pool.cpp:        delete _pool[pcs->name()];
liveimage_srv/pool.cpp:    GLOGI("ADDINF KEEP CAM " << pcs->name());
liveimage_srv/pool.cpp:    _pool[pcs->name()] = p;
liveimage_srv/pool.cpp:    size_t seq = _seqs[pcs->name()];
liveimage_srv/pool.cpp:    pcs->seq(seq);
liveimage_srv/pool.cpp:            pp->_cam->set_letal();
liveimage_srv/pool.cpp:            _kill_conn(pp->_cam);
liveimage_srv/pool.cpp:        time_t d = SECS() - _times[cam].cli;
liveimage_srv/pool.cpp:        Times& tt = fi->second;
liveimage_srv/pool.cpp:        return d - tt.cam < KILL_TIME;
liveimage_srv/pool.cpp:        if(now - pt.cam > KILL_TIME)
liveimage_srv/pool.cpp:    ps->destroy();
liveimage_srv/pool.cpp:    _seqs[ps->name()] = ps->seq();
liveimage_srv/pool.cpp:    GLOGD(" KILLING CAM CONN  file saving seq at " << ps->seq());
liveimage_srv/pool.cpp:        throw ps->type();
liveimage_srv/fpipe.cpp:    split(file,'-',fn);
liveimage_srv/fpipe.cpp:            rv =  ::write(_fd,buff+sent,maxsz-sent);
liveimage_srv/fpipe.cpp:                GLOGI ("mplayer " << _fn << " -cache 200 -cache-min 80  # has "<<maxsz<<" bytes ");
liveimage_srv/tcpsrv.h:            bool r = SECS()-a->second < LAST_CONTIME;
liveimage_srv/tcpsrv.h:            a->second = SECS();
liveimage_srv/tcpsrv.h:            if(a.second - now > LAST_CONTIME){
liveimage_srv/rawsock.h:        size_t   room(){return cap-rec_off;}
liveimage_srv/rawsock.h:        size_t   left(){return rec_off-prc_off;}
liveimage_srv/rawsock.h:                  " inbuff="<<left() << " to-Fill=" << int(vfl-left()) << " vfl="<<vfl << " room="<<room()<<
liveimage_srv/rawsock.h:                  " diff " << (int)inbytes-outbytes);
liveimage_srv/encrypter.h:            loco[i] = pc[i] - _key[i%_key.length()];
Binary file liveimage_srv/def.jpg matches
liveimage_srv/liveimage_srv.conf_example:# only if /usr/lib/x86_64-linux-gnu/lib_av.so  is provided.
liveimage_srv/liveimage_srv.conf_example:#AV_CODEC_ID_MPEG2VIDEO  2 ///< preferred ID for MPEG-1/2 video decoding
liveimage_srv/liveimage_srv.conf_example:        lib_av           {/usr/lib/x86_64-linux-gnu/lib_av.so}   # if the img format is !=0 TODO
liveimage_srv/liveimage_srv.conf_example:        lib_curl         {/usr/lib/x86_64-linux-gnu/libcurl.so}  # if there are any rtsp cameras
liveimage_srv/liveimage_srv.conf_example:        noise_div        {8}                # lower -> higher noise, (2...32)
liveimage_srv/liveimage_srv.conf_example:#           name            {rpirpi}                        # a R-PI rtsp camera for tsting. experimental.
liveimage_srv/liveimage_srv.conf_example:#           on_event        {webcast,record,force,save}     #  force->save no mater of events
liveimage_srv/tcpsrv.cpp:#define SECRET_CONTENT        "marius-marius:secret"
liveimage_srv/tcpsrv.cpp:                    "Cache-Control: no-store, no-cache, must-revalidate, pre-check=0, post-check=0, max-age=0\r\n"
liveimage_srv/tcpsrv.cpp:                    "Pragma: no-cache\r\n"
liveimage_srv/tcpsrv.cpp:                    "Content-Type: text/html\r\n"
liveimage_srv/tcpsrv.cpp:                    "Content-length: %d\r\n"
liveimage_srv/tcpsrv.cpp:                    "X-Timestamp: %d.%06d\r\n\r\n";
liveimage_srv/tcpsrv.cpp:static const char* SRV = "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 3.2 Final//EN\""
liveimage_srv/tcpsrv.cpp:    if(is ==-1) {
liveimage_srv/tcpsrv.cpp:        if(--_fatals==0){
liveimage_srv/tcpsrv.cpp:                    const char*         end = p + sizeof(hdr)-1;
liveimage_srv/tcpsrv.cpp:                    p[sizeof(hdr)-1] = '\0';
liveimage_srv/tcpsrv.cpp:            if(pENC->decrypt(hdr.challange) != hdr.random)
liveimage_srv/tcpsrv.cpp:                --checks;
liveimage_srv/tcpsrv.cpp:                                                         sizeof(hdr)-1,
liveimage_srv/tcpsrv.cpp:        ::strncpy(empty.camname, pcs->name().c_str(), sizeof(empty.camname));
liveimage_srv/tcpsrv.cpp:        if(pcs->header()->format==0)
liveimage_srv/tcpsrv.cpp:        else if(pcs->header()->format==0)
liveimage_srv/tcpsrv.cpp:    else if(time(0) - _zoomah < 20){
liveimage_srv/tcpsrv.cpp:        ::strncpy(empty.camname, pcs->name().c_str(), sizeof(empty.camname));
liveimage_srv/CMakeLists.txt:SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0")
liveimage_srv/CMakeLists.txt:add_definitions(-Dcimg_display=0 -Dcimg_use_jpeg  -Dcimg_display=0 -DDEBUG)
liveimage_srv/CMakeLists.txt:#add_definitions( -DDEBUG )
liveimage_srv/Testing/Temporary/LastTest.log:----------------------------------------------------------
liveimage_srv/config.h:            paka->_parent = this;
liveimage_srv/config.h:            this->_values.push_back(paka);
liveimage_srv/config.h:            this->_type = Node::eNODE;
liveimage_srv/config.h:            this->_values.push_back(pn);
liveimage_srv/config.h:                if(a->_name==key){
liveimage_srv/config.h:                    assert(this->_name!=key);
liveimage_srv/config.h:                        pn=pn->_parent;
liveimage_srv/config.h:                            pn=pn->_root();
liveimage_srv/config.h:                            pn=pn->_at(ev);
liveimage_srv/config.h:            pn = pn->_at(ev);
liveimage_srv/config.h:                    v = _values[index]->_name;
liveimage_srv/config.h:                    v = _values[0]->_name;
liveimage_srv/config.h:                    if(pn->_values.size()>dx)
liveimage_srv/config.h:                        return pn->_values[dx]->_name;
liveimage_srv/config.h:            while(pn->_parent)
liveimage_srv/config.h:                pn=pn->_parent;
liveimage_srv/config.h:                if(a->_name==s){
liveimage_srv/config.h:        return _pnode->operator[](key);
liveimage_srv/config.h:                            root->add(curent);
liveimage_srv/config.h:                            curent->_parent = root;
liveimage_srv/config.h:                        paka->_name=_string;
liveimage_srv/config.h:                        paka->_parent = parent;
liveimage_srv/config.h:                            parent->_values.push_back(paka);
liveimage_srv/config.h:                            if(!paka->_name.empty())
liveimage_srv/config.h:                                if(paka->_name=="%include")
liveimage_srv/config.h:                                            Node* prent = paka->_parent ? paka->_parent : _pnode;
liveimage_srv/config.h:                                            prent->_del_node(paka);
liveimage_srv/config.h:                                            pn->_parent = prent;
liveimage_srv/config.h:                                            prent->add(pn);
liveimage_srv/config.h:                                        paka->store_it(_string);
liveimage_srv/config.h:                                    paka->store_it(_string);
liveimage_srv/config.h:                        paka = paka->_parent;
liveimage_srv/config.h:                        --oc;
liveimage_srv/config.h:                        paka->store_it(_string);
liveimage_srv/config.h:            throw(-1);
liveimage_srv/config.h:            _pnode->_parent = _pnode;
liveimage_srv/config.h:        OOO  << p->_name.c_str();
liveimage_srv/config.h:        if(p->_values.size())
liveimage_srv/config.h:            for(const auto& a : p->_values)
liveimage_srv/config.h:        --depth;
liveimage_srv/sheller.cpp:        if(!_pool->has(a.pcsname))
liveimage_srv/sheller.cpp:            cmd =  "kill -9 ";
liveimage_srv/sheller.cpp:                cmd += " | grep -v grep";
liveimage_srv/sheller.cpp:                    comand = "pkill -9 ";
liveimage_srv/sheller.cpp:                if (wpid == -1)
liveimage_srv/sheller.cpp:            } while (!WIFEXITED(status) && !WIFSIGNALED(status) && --timeout>0);
liveimage_srv/sheller.cpp:    cmd += " | grep -v grep";
liveimage_srv/sheller.cpp:                    if (wpid == -1)
liveimage_srv/sheller.cpp:                } while (!WIFEXITED(status) && !WIFSIGNALED(status) && --timeout>0);
liveimage_srv/sock.h://---------------------------------------------------------------------------------------
liveimage_srv/sock.h://---------------------------------------------------------------------------------------
liveimage_srv/sock.h://---------------------------------------------------------------------------------------
liveimage_srv/sock.h://---------------------------------------------------------------------------------------
liveimage_srv/sock.h://---------------------------------------------------------------------------------------
liveimage_srv/sock.h://---------------------------------------------------------------------------------------
liveimage_srv/sock.h:        ::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));
liveimage_srv/sock.h:        ::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));
liveimage_srv/sock.h:        ::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));
liveimage_srv/sock.h:    void commit(){::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));}
liveimage_srv/sock.h:            int msk = pow(2,atoi(pm))-1;
liveimage_srv/sock.h:        ::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));
liveimage_srv/sock.h:        ::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));
liveimage_srv/sock.h:            int msk = pow(2,bits)-1;
liveimage_srv/sock.h:        ::strcpy(_sip,inet_ntoa((struct in_addr)this->sin_addr));
liveimage_srv/sock.h://---------------------------------------------------------------------------------------
liveimage_srv/sock.h:    int             detach(){int s = _thesock; _thesock=-1; return s;}
liveimage_srv/sock.h://---------------------------------------------------------------------------------------
liveimage_srv/sock.h://---------------------------------------------------------------------------------------
liveimage_srv/sock.h://---------------------------------------------------------------------------------------
liveimage_srv/sock.h://---------------------------------------------------------------------------------------
liveimage_srv/sock.h://---------------------------------------------------------------------------------------
liveimage_srv/sock.h:    err_ == -1
liveimage_srv/CImg.h: #  Licenses        : This file is 'dual-licensed', you have to choose one
liveimage_srv/CImg.h: #                    CeCILL-C
liveimage_srv/CImg.h: #                    The CeCILL-C license is close to the GNU LGPL.
liveimage_srv/CImg.h: #                    ( http://cecill.info/licences/Licence_CeCILL-C_V1-en.html )
liveimage_srv/CImg.h: #                    ( http://cecill.info/licences/Licence_CeCILL_V2.1-en.html )
liveimage_srv/CImg.h: #  This software is governed either by the CeCILL or the CeCILL-C license
liveimage_srv/CImg.h: #  the CeCILL or CeCILL-C licenses as circulated by CEA, CNRS and INRIA
liveimage_srv/CImg.h: #  professionals having in-depth computer knowledge. Users are therefore
liveimage_srv/CImg.h: #  knowledge of the CeCILL and CeCILL-C licenses and that you accept its terms.
liveimage_srv/CImg.h:/*-----------------------------------------------------------
liveimage_srv/CImg.h: # Test and possibly auto-set CImg configuration variables
liveimage_srv/CImg.h: ------------------------------------------------------------*/
liveimage_srv/CImg.h:// This is the minimal set of required headers to make CImg-based codes compile.
liveimage_srv/CImg.h://                      '1' for a Unix-like OS (Linux, Solaris, BSD, MacOSX, Irix, ...).
liveimage_srv/CImg.h://                      (auto-detection is performed if 'cimg_OS' is not set by the user).
liveimage_srv/CImg.h:#error (correct values are '0 = unknown OS', '1 = Unix-like OS', '2 = Microsoft Windows').
liveimage_srv/CImg.h:// Include OS-specific headers.
liveimage_srv/CImg.h:// Define 'cimg_use_vt100' to allow output of color messages on VT100-compatible terminals.
liveimage_srv/CImg.h:// advantages of multi-core CPUs.
liveimage_srv/CImg.h://                           '1' to use the X-Window framework (X11).
liveimage_srv/CImg.h:#error (should be { 0=none | 1=X-Window (X11) | 2=Microsoft GDI32 }).
liveimage_srv/CImg.h:// Include display-specific headers.
liveimage_srv/CImg.h:// Board library may be used to draw 3D objects in vector-graphics canvas
liveimage_srv/CImg.h:#pragma GCC diagnostic ignored "-Wdeprecated"
liveimage_srv/CImg.h:#pragma GCC diagnostic ignored "-Wdeprecated-copy"
liveimage_srv/CImg.h:#pragma GCC diagnostic ignored "-Wshadow"
liveimage_srv/CImg.h:// TinyEXR is a small, single header-only library to load and save OpenEXR(.exr) images.
liveimage_srv/CImg.h:/*------------------------------------------------------------------------------
liveimage_srv/CImg.h:  # Define user-friendly macros.
liveimage_srv/CImg.h:  ------------------------------------------------------------------------------*/
liveimage_srv/CImg.h:  int _n1##x = x<(img).width() - 1?x + 1:(img).width() - 1, \
liveimage_srv/CImg.h:      _n1##y = y<(img).height() - 1?y + 1:(img).height() - 1
liveimage_srv/CImg.h:  int _p1##x = x>1?x - 1:0, \
liveimage_srv/CImg.h:      _p1##y = y>1?y - 1:0
liveimage_srv/CImg.h:  int _n2##x = x<(img).width() - 2?x + 2:(img).width() - 1, \
liveimage_srv/CImg.h:      _n2##y = y<(img).height() - 2?y + 2:(img).height() - 1
liveimage_srv/CImg.h:  int _p2##x = x>2?x - 2:0, \
liveimage_srv/CImg.h:      _p2##y = y>2?y - 2:0
liveimage_srv/CImg.h:  int _n3##x = x<(img).width() - 3?x + 3:(img).width() - 1, \
liveimage_srv/CImg.h:      _n3##y = y<(img).height() - 3?y + 3:(img).height() - 1
liveimage_srv/CImg.h:  int _p3##x = x>3?x - 3:0, \
liveimage_srv/CImg.h:      _p3##y = y>3?y - 3:0
liveimage_srv/CImg.h:  int _n4##x = x<(img).width() - 4?x + 4:(img).width() - 1, \
liveimage_srv/CImg.h:      _n4##y = y<(img).height() - 4?y + 4:(img).height() - 1
liveimage_srv/CImg.h:  int _p4##x = x>4?x - 4:0, \
liveimage_srv/CImg.h:      _p4##y = y>4?y - 4:0
liveimage_srv/CImg.h:  int _n1##z = z<(img).depth() - 1?z + 1:(img).depth() - 1
liveimage_srv/CImg.h:  int _p1##x = x>1?x - 1:0, \
liveimage_srv/CImg.h:      _p1##y = y>1?y - 1:0, \
liveimage_srv/CImg.h:      _p1##z = z>1?z - 1:0
liveimage_srv/CImg.h:#define cimg_rof(img,ptrs,T_ptrs) for (T_ptrs *ptrs = (img)._data + (img).size() - 1; ptrs>=(img)._data; --ptrs)
liveimage_srv/CImg.h:#define cimg_rofoff(img,off) for (cimg_long off = (cimg_long)((img).size() - 1); off>=0; --off)
liveimage_srv/CImg.h:#define cimg_rof1(bound,i) for (int i = (int)(bound) - 1; i>=0; --i)
liveimage_srv/CImg.h: for (int i = (int)(i0)<0?0:(int)(i0), _max##i = (int)(i1)<(int)(bound)?(int)(i1):(int)(bound) - 1; i<=_max##i; ++i)
liveimage_srv/CImg.h:#define cimg_for_insideX(img,x,n) cimg_for_inX(img,n,(img)._width - 1 - (n),x)
liveimage_srv/CImg.h:#define cimg_for_insideY(img,y,n) cimg_for_inY(img,n,(img)._height - 1 - (n),y)
liveimage_srv/CImg.h:#define cimg_for_insideZ(img,z,n) cimg_for_inZ(img,n,(img)._depth  - 1 - (n),z)
liveimage_srv/CImg.h:#define cimg_for_insideC(img,c,n) cimg_for_inC(img,n,(img)._spectrum - 1 - (n),c)
liveimage_srv/CImg.h:#define cimg_for_insideXY(img,x,y,n) cimg_for_inXY(img,n,n,(img)._width - 1 - (n),(img)._height - 1 - (n),x,y)
liveimage_srv/CImg.h:  cimg_for_inXYZ(img,n,n,n,(img)._width - 1 - (n),(img)._height - 1 - (n),(img)._depth - 1 - (n),x,y,z)
liveimage_srv/CImg.h:  cimg_for_inXYZ(img,n,n,n,(img)._width - 1 - (n),(img)._height - 1 - (n),(img)._depth - 1 - (n),x,y,z)
liveimage_srv/CImg.h:#define cimg_for_borderX(img,x,n) cimg_for_outX(img,n,(img)._width - 1 - (n),x)
liveimage_srv/CImg.h:#define cimg_for_borderY(img,y,n) cimg_for_outY(img,n,(img)._height - 1 - (n),y)
liveimage_srv/CImg.h:#define cimg_for_borderZ(img,z,n) cimg_for_outZ(img,n,(img)._depth - 1 - (n),z)
liveimage_srv/CImg.h:#define cimg_for_borderC(img,c,n) cimg_for_outC(img,n,(img)._spectrum - 1 - (n),c)
liveimage_srv/CImg.h:#define cimg_for_borderXY(img,x,y,n) cimg_for_outXY(img,n,n,(img)._width - 1 - (n),(img)._height - 1 - (n),x,y)
liveimage_srv/CImg.h:  cimg_for_outXYZ(img,n,n,n,(img)._width - 1 - (n),(img)._height - 1 - (n),(img)._depth - 1 - (n),x,y,z)
liveimage_srv/CImg.h: cimg_for_outXYZC(img,n,n,n,n,(img)._width - 1 - (n),(img)._height - 1 - (n), \
liveimage_srv/CImg.h:                  (img)._depth - 1 - (n),(img)._spectrum - 1 - (n),x,y,z,c)
liveimage_srv/CImg.h:      --_n1##y, _n1##x+=(_n1##x>>2) - ((!(_n1##x&3)?--y:((_n1##x&3)==1?(img)._width - 1 - ++x:\
liveimage_srv/CImg.h:      ((_n1##x&3)==2?(img)._height - 1 - ++y:--x))))?0:1)
liveimage_srv/CImg.h:      _dx=(x1)>(x0)?(int)(x1) - (int)(x0):(_sx=-1,(int)(x0) - (int)(x1)), \
liveimage_srv/CImg.h:      _dy=(y1)>(y0)?(int)(y1) - (int)(y0):(_sy=-1,(int)(y0) - (int)(y1)), \
liveimage_srv/CImg.h:      --_counter, x+=_steep? \
liveimage_srv/CImg.h:      (y+=_sy,(_err-=_dx)<0?_err+=_dy,_sx:0): \
liveimage_srv/CImg.h:      (y+=(_err-=_dy)<0?_err+=_dx,_sy:0,_sx))
liveimage_srv/CImg.h: for (int i = 0, _n1##i = 1>=(bound)?(int)(bound) - 1:1; \
liveimage_srv/CImg.h:      _n1##i<(int)(bound) || i==--_n1##i; \
liveimage_srv/CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1; \
liveimage_srv/CImg.h:      i<=(int)(i1) && (_n1##i<(int)(bound) || i==--_n1##i); \
liveimage_srv/CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1; \
liveimage_srv/CImg.h:      _n1##i<(int)(bound) || i==--_n1##i; \
liveimage_srv/CImg.h:      _p1##i = i - 1<0?0:i - 1, \
liveimage_srv/CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1; \
liveimage_srv/CImg.h:      i<=(int)(i1) && (_n1##i<(int)(bound) || i==--_n1##i); \
liveimage_srv/CImg.h: for (int i = 0, _p1##i = 0, _n1##i = 1>=(bound)?(int)(bound) - 1:1, \
liveimage_srv/CImg.h:      _n2##i = 2>=(bound)?(int)(bound) - 1:2; \
liveimage_srv/CImg.h:      _n2##i<(int)(bound) || _n1##i==--_n2##i || i==(_n2##i = --_n1##i); \
liveimage_srv/CImg.h:      _p1##i = i - 1<0?0:i - 1, \
liveimage_srv/CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1, \
liveimage_srv/CImg.h:      _n2##i = i + 2>=(int)(bound)?(int)(bound) - 1:i + 2; \
liveimage_srv/CImg.h:      i<=(int)(i1) && (_n2##i<(int)(bound) || _n1##i==--_n2##i || i==(_n2##i = --_n1##i)); \
liveimage_srv/CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1, \
liveimage_srv/CImg.h:      _n2##i = 2>=(bound)?(int)(bound) - 1:2; \
liveimage_srv/CImg.h:      _n2##i<(int)(bound) || _n1##i==--_n2##i || i==(_n2##i = --_n1##i); \
liveimage_srv/CImg.h:      _p2##i = i - 2<0?0:i - 2, \
liveimage_srv/CImg.h:      _p1##i = i - 1<0?0:i - 1, \
liveimage_srv/CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1, \
liveimage_srv/CImg.h:      _n2##i = i + 2>=(int)(bound)?(int)(bound) - 1:i + 2; \
liveimage_srv/CImg.h:      i<=(int)(i1) && (_n2##i<(int)(bound) || _n1##i==--_n2##i || i==(_n2##i = --_n1##i)); \
liveimage_srv/CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1, \
liveimage_srv/CImg.h:      _n2##i = 2>=(bound)?(int)(bound) - 1:2, \
liveimage_srv/CImg.h:      _n3##i = 3>=(bound)?(int)(bound) - 1:3; \
liveimage_srv/CImg.h:      _n3##i<(int)(bound) || _n2##i==--_n3##i || _n1##i==--_n2##i || i==(_n3##i = _n2##i = --_n1##i); \
liveimage_srv/CImg.h:      _p2##i = i - 2<0?0:i - 2, \
liveimage_srv/CImg.h:      _p1##i = i - 1<0?0:i - 1, \
liveimage_srv/CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1, \
liveimage_srv/CImg.h:      _n2##i = i + 2>=(int)(bound)?(int)(bound) - 1:i + 2, \
liveimage_srv/CImg.h:      _n3##i = i + 3>=(int)(bound)?(int)(bound) - 1:i + 3; \
liveimage_srv/CImg.h:      (_n3##i<(int)(bound) || _n2##i==--_n3##i || _n1##i==--_n2##i || i==(_n3##i = _n2##i = --_n1##i)); \
liveimage_srv/CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1, \
liveimage_srv/CImg.h:      _n2##i = 2>=(bound)?(int)(bound) - 1:2, \
liveimage_srv/CImg.h:      _n3##i = 3>=(bound)?(int)(bound) - 1:3; \
liveimage_srv/CImg.h:      _n3##i<(int)(bound) || _n2##i==--_n3##i || _n1##i==--_n2##i || i==(_n3##i = _n2##i = --_n1##i); \
liveimage_srv/CImg.h:      _p3##i = i - 3<0?0:i - 3, \
liveimage_srv/CImg.h:      _p2##i = i - 2<0?0:i - 2, \
liveimage_srv/CImg.h:      _p1##i = i - 1<0?0:i - 1, \
liveimage_srv/CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1, \
liveimage_srv/CImg.h:      _n2##i = i + 2>=(int)(bound)?(int)(bound) - 1:i + 2, \
liveimage_srv/CImg.h:      _n3##i = i + 3>=(int)(bound)?(int)(bound) - 1:i + 3; \
liveimage_srv/CImg.h:      (_n3##i<(int)(bound) || _n2##i==--_n3##i || _n1##i==--_n2##i || i==(_n3##i = _n2##i = --_n1##i)); \
liveimage_srv/CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1, \
liveimage_srv/CImg.h:      _n2##i = 2>=(bound)?(int)(bound) - 1:2, \
liveimage_srv/CImg.h:      _n3##i = 3>=(bound)?(int)(bound) - 1:3, \
liveimage_srv/CImg.h:      _n4##i = 4>=(bound)?(int)(bound) - 1:4; \
liveimage_srv/CImg.h:      _n4##i<(int)(bound) || _n3##i==--_n4##i || _n2##i==--_n3##i || _n1##i==--_n2##i || \
liveimage_srv/CImg.h:      i==(_n4##i = _n3##i = _n2##i = --_n1##i); \
liveimage_srv/CImg.h:      _p3##i = i - 3<0?0:i - 3, \
liveimage_srv/CImg.h:      _p2##i = i - 2<0?0:i - 2, \
liveimage_srv/CImg.h:      _p1##i = i - 1<0?0:i - 1, \
liveimage_srv/CImg.h:      _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1, \
liveimage_srv/CImg.h:      _n2##i = i + 2>=(int)(bound)?(int)(bound) - 1:i + 2, \
liveimage_srv/CImg.h:      _n3##i = i + 3>=(int)(bound)?(int)(bound) - 1:i + 3, \
liveimage_srv/CImg.h:      _n4##i = i + 4>=(int)(bound)?(int)(bound) - 1:i + 4; \
liveimage_srv/CImg.h:      i<=(int)(i1) && (_n4##i<(int)(bound) || _n3##i==--_n4##i || _n2##i==--_n3##i || _n1##i==--_n2##i || \
liveimage_srv/CImg.h:      i==(_n4##i = _n3##i = _n2##i = --_n1##i)); \
liveimage_srv/CImg.h:       _n1##i = 1>=(int)(bound)?(int)(bound) - 1:1, \
liveimage_srv/CImg.h:       _n2##i = 2>=(int)(bound)?(int)(bound) - 1:2, \
liveimage_srv/CImg.h:       _n3##i = 3>=(int)(bound)?(int)(bound) - 1:3, \
liveimage_srv/CImg.h:       _n4##i = 4>=(int)(bound)?(int)(bound) - 1:4; \
liveimage_srv/CImg.h:       _n4##i<(int)(bound) || _n3##i==--_n4##i || _n2##i==--_n3##i || _n1##i==--_n2##i || \
liveimage_srv/CImg.h:       i==(_n4##i = _n3##i = _n2##i = --_n1##i); \
liveimage_srv/CImg.h:       _p4##i = i - 4<0?0:i - 4, \
liveimage_srv/CImg.h:       _p3##i = i - 3<0?0:i - 3, \
liveimage_srv/CImg.h:       _p2##i = i - 2<0?0:i - 2, \
liveimage_srv/CImg.h:       _p1##i = i - 1<0?0:i - 1, \
liveimage_srv/CImg.h:       _n1##i = i + 1>=(int)(bound)?(int)(bound) - 1:i + 1, \
liveimage_srv/CImg.h:       _n2##i = i + 2>=(int)(bound)?(int)(bound) - 1:i + 2, \
liveimage_srv/CImg.h:       _n3##i = i + 3>=(int)(bound)?(int)(bound) - 1:i + 3, \
liveimage_srv/CImg.h:       _n4##i = i + 4>=(int)(bound)?(int)(bound) - 1:i + 4; \
liveimage_srv/CImg.h:       i<=(int)(i1) && (_n4##i<(int)(bound) || _n3##i==--_n4##i || _n2##i==--_n3##i || _n1##i==--_n2##i || \
liveimage_srv/CImg.h:       i==(_n4##i = _n3##i = _n2##i = --_n1##i)); \
liveimage_srv/CImg.h:   1>=(img)._width?(img).width() - 1:1);  \
liveimage_srv/CImg.h:   x==--_n1##x; \
liveimage_srv/CImg.h:   x + 1>=(int)(img)._width?(img).width() - 1:x + 1); \
liveimage_srv/CImg.h:   x==--_n1##x); \
liveimage_srv/CImg.h:   1>=(img)._width?(img).width() - 1:1); \
liveimage_srv/CImg.h:   x==--_n1##x; \
liveimage_srv/CImg.h:   _p1##x = x - 1<0?0:x - 1, \
liveimage_srv/CImg.h:   x + 1>=(int)(img)._width?(img).width() - 1:x + 1); \
liveimage_srv/CImg.h:   x==--_n1##x);            \
liveimage_srv/CImg.h:   _n1##x = 1>=(img)._width?(img).width() - 1:1, \
liveimage_srv/CImg.h:   2>=(img)._width?(img).width() - 1:2); \
liveimage_srv/CImg.h:   _n1##x==--_n2##x || x==(_n2##x = --_n1##x); \
liveimage_srv/CImg.h:   _p1##x = x - 1<0?0:x - 1, \
liveimage_srv/CImg.h:   _n1##x = x + 1>=(int)(img)._width?(img).width() - 1:x + 1, \
liveimage_srv/CImg.h:   x + 2>=(int)(img)._width?(img).width() - 1:x + 2); \
liveimage_srv/CImg.h:   _n1##x==--_n2##x || x==(_n2##x = --_n1##x)); \
liveimage_srv/CImg.h:   _n1##x = 1>=(img)._width?(img).width() - 1:1, \
liveimage_srv/CImg.h:   2>=(img)._width?(img).width() - 1:2); \
liveimage_srv/CImg.h:   _n1##x==--_n2##x || x==(_n2##x = --_n1##x); \
liveimage_srv/CImg.h:   _p2##x = x - 2<0?0:x - 2, \
liveimage_srv/CImg.h:   _p1##x = x - 1<0?0:x - 1, \
liveimage_srv/CImg.h:   _n1##x = x + 1>=(int)(img)._width?(img).width() - 1:x + 1, \
liveimage_srv/CImg.h:   x + 2>=(int)(img)._width?(img).width() - 1:x + 2); \
liveimage_srv/CImg.h:   _n1##x==--_n2##x || x==(_n2##x = --_n1##x)); \
liveimage_srv/CImg.h:   _n1##x = 1>=(img)._width?(img).width() - 1:1, \
liveimage_srv/CImg.h:   _n2##x = 2>=(img)._width?(img).width() - 1:2, \
liveimage_srv/CImg.h:   3>=(img)._width?(img).width() - 1:3); \
liveimage_srv/CImg.h:   _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n3## x = _n2##x = --_n1##x); \
liveimage_srv/CImg.h:   _p2##x = x - 2<0?0:x - 2, \
liveimage_srv/CImg.h:   _p1##x = x - 1<0?0:x - 1, \
liveimage_srv/CImg.h:   _n1##x = x + 1>=(int)(img)._width?(img).width() - 1:x + 1, \
liveimage_srv/CImg.h:   _n2##x = x + 2>=(int)(img)._width?(img).width() - 1:x + 2, \
liveimage_srv/CImg.h:   x + 3>=(int)(img)._width?(img).width() - 1:x + 3); \
liveimage_srv/CImg.h:   _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n3## x = _n2##x = --_n1##x)); \
liveimage_srv/CImg.h:   _n1##x = 1>=(img)._width?(img).width() - 1:1, \
liveimage_srv/CImg.h:   _n2##x = 2>=(img)._width?(img).width() - 1:2, \
liveimage_srv/CImg.h:   3>=(img)._width?(img).width() - 1:3); \
liveimage_srv/CImg.h:   _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n3##x = _n2##x = --_n1##x); \
liveimage_srv/CImg.h:   _p3##x = x - 3<0?0:x - 3, \
liveimage_srv/CImg.h:   _p2##x = x - 2<0?0:x - 2, \
liveimage_srv/CImg.h:   _p1##x = x - 1<0?0:x - 1, \
liveimage_srv/CImg.h:   _n1##x = x + 1>=(int)(img)._width?(img).width() - 1:x + 1, \
liveimage_srv/CImg.h:   _n2##x = x + 2>=(int)(img)._width?(img).width() - 1:x + 2, \
liveimage_srv/CImg.h:   x + 3>=(int)(img)._width?(img).width() - 1:x + 3); \
liveimage_srv/CImg.h:   _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n3##x = _n2##x = --_n1##x)); \
liveimage_srv/CImg.h:   _n1##x = 1>=((img)._width)?(img).width() - 1:1, \
liveimage_srv/CImg.h:   _n2##x = 2>=((img)._width)?(img).width() - 1:2, \
liveimage_srv/CImg.h:   _n3##x = 3>=((img)._width)?(img).width() - 1:3, \
liveimage_srv/CImg.h:   4>=((img)._width)?(img).width() - 1:4); \
liveimage_srv/CImg.h:   _n3##x==--_n4##x || _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n4##x = _n3##x = _n2##x = --_n1##x); \
liveimage_srv/CImg.h:   _p3##x = x - 3<0?0:x - 3, \
liveimage_srv/CImg.h:   _p2##x = x - 2<0?0:x - 2, \
liveimage_srv/CImg.h:   _p1##x = x - 1<0?0:x - 1, \
liveimage_srv/CImg.h:   _n1##x = x + 1>=(img).width()?(img).width() - 1:x + 1, \
liveimage_srv/CImg.h:   _n2##x = x + 2>=(img).width()?(img).width() - 1:x + 2, \
liveimage_srv/CImg.h:   _n3##x = x + 3>=(img).width()?(img).width() - 1:x + 3, \
liveimage_srv/CImg.h:   x + 4>=(img).width()?(img).width() - 1:x + 4); \
liveimage_srv/CImg.h:   _n3##x==--_n4##x || _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n4##x = _n3##x = _n2##x = --_n1##x)); \
liveimage_srv/CImg.h:   _n1##x = 1>=((img)._width)?(img).width() - 1:1, \
liveimage_srv/CImg.h:   _n2##x = 2>=((img)._width)?(img).width() - 1:2, \
liveimage_srv/CImg.h:   _n3##x = 3>=((img)._width)?(img).width() - 1:3, \
liveimage_srv/CImg.h:   4>=((img)._width)?(img).width() - 1:4); \
liveimage_srv/CImg.h:   _n3##x==--_n4##x || _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n4##x = _n3##x = _n2##x = --_n1##x); \
liveimage_srv/CImg.h:   _p4##x = x - 4<0?0:x - 4, \
liveimage_srv/CImg.h:   _p3##x = x - 3<0?0:x - 3, \
liveimage_srv/CImg.h:   _p2##x = x - 2<0?0:x - 2, \
liveimage_srv/CImg.h:   _p1##x = x - 1<0?0:x - 1, \
liveimage_srv/CImg.h:   _n1##x = x + 1>=(img).width()?(img).width() - 1:x + 1, \
liveimage_srv/CImg.h:   _n2##x = x + 2>=(img).width()?(img).width() - 1:x + 2, \
liveimage_srv/CImg.h:   _n3##x = x + 3>=(img).width()?(img).width() - 1:x + 3, \
liveimage_srv/CImg.h:   x + 4>=(img).width()?(img).width() - 1:x + 4); \
liveimage_srv/CImg.h:   _n3##x==--_n4##x || _n2##x==--_n3##x || _n1##x==--_n2##x || x==(_n4##x = _n3##x = _n2##x = --_n1##x)); \
liveimage_srv/CImg.h:   1>=(img)._width?(img).width() - 1:1); \
liveimage_srv/CImg.h:   x==--_n1##x; \
liveimage_srv/CImg.h:   x + 1>=(int)(img)._width?(img).width() - 1:x + 1); \
liveimage_srv/CImg.h:   x==--_n1##x); \
liveimage_srv/CImg.h:   1>=(img)._width?(img).width() - 1:1); \
liveimage_srv/CImg.h:   x==--_n1##x; \
liveimage_srv/CImg.h:   _p1##x = x - 1<0?0:x - 1, \
liveimage_srv/CImg.h:   x + 1>=(int)(img)._width?(img).width() - 1:x + 1); \
liveimage_srv/CImg.h:   x==--_n1##x); \
liveimage_srv/CImg.h:#define cimglist_rof(list,l) for (int l = (int)(list)._width - 1; l>=0; --l)
liveimage_srv/CImg.h:  for (int l = (int)(l0)<0?0:(int)(l0), _max##l = (unsigned int)l1<(list)._width?(int)(l1):(int)(list)._width - 1; \
liveimage_srv/CImg.h:#define cimg_instance _width,_height,_depth,_spectrum,_data,_is_shared?"":"non-",pixel_type()
liveimage_srv/CImg.h:/*------------------------------------------------
liveimage_srv/CImg.h: -------------------------------------------------*/
liveimage_srv/CImg.h:   \CImg-based programs with
liveimage_srv/CImg.h:      int result = -1;
liveimage_srv/CImg.h:      if (result==-1) result = _vscprintf(format,ap);
liveimage_srv/CImg.h:    // Mutex-protected version of sscanf, sprintf and snprintf.
liveimage_srv/CImg.h:    // Used only MacOSX, as it seems those functions are not re-entrant on MacOSX.
liveimage_srv/CImg.h:       - \c 0: Hide library messages (quiet mode).
liveimage_srv/CImg.h:       - \c 1: Print library messages on the console.
liveimage_srv/CImg.h:       - \c 2: Display library messages on a dialog window.
liveimage_srv/CImg.h:       - \c 3: Do as \c 1 + add extra debug warnings (slow down the code!).
liveimage_srv/CImg.h:       - \c 4: Do as \c 2 + add extra debug warnings (slow down the code!).
liveimage_srv/CImg.h:       The way openmp-based methods are handled by \CImg can be changed dynamically, using this function.
liveimage_srv/CImg.h:       - \c 0: Never parallelize.
liveimage_srv/CImg.h:       - \c 1: Always parallelize.
liveimage_srv/CImg.h:       - \c 2: Adaptive parallelization mode (default behavior).
liveimage_srv/CImg.h:  /*---------------------------------------
liveimage_srv/CImg.h:    --------------------------------------*/
liveimage_srv/CImg.h:      - \b CImgAbortException: Thrown when a computationally-intensive function is aborted by an external signal.
liveimage_srv/CImg.h:        This is the only \c non-derived exception class.
liveimage_srv/CImg.h:      - \b CImgArgumentException: Thrown when one argument of a called \CImg function is invalid.
liveimage_srv/CImg.h:      CImg<float> img(100,100,1,3); // Define a 100x100 color image with float-valued pixels
liveimage_srv/CImg.h:      img.mirror('e');              // Try to mirror image along the (non-existing) 'e'-axis
liveimage_srv/CImg.h:      - \b CImgDisplayException: Thrown when something went wrong during the display of images in CImgDisplay instances.
liveimage_srv/CImg.h:      - \b CImgInstanceException: Thrown when an instance associated to a called \CImg method does not fit
liveimage_srv/CImg.h:      - \b CImgIOException: Thrown when an error occurred when trying to load or save image files.
liveimage_srv/CImg.h:      - \b CImgWarningException: Thrown only if configuration macro \c cimg_strict_warnings is set, and
liveimage_srv/CImg.h:    //! Return a C-string containing the error message associated to the thrown exception.
liveimage_srv/CImg.h:  // a computationally-intensive function has been aborted by an external signal.
liveimage_srv/CImg.h:    //! Return a C-string containing the error message associated to the thrown exception.
liveimage_srv/CImg.h:  /*-------------------------------------
liveimage_srv/CImg.h:    -----------------------------------*/
liveimage_srv/CImg.h:  //! Contains \a low-level functions and variables of the \CImg Library.
liveimage_srv/CImg.h:     Most of the functions and variables within this namespace are used by the \CImg library for low-level operations.
liveimage_srv/CImg.h:      static T max() { return (T)1<<(8*sizeof(T) - 1); }
liveimage_srv/CImg.h:      static unsigned char max() { return (unsigned char)-1; }
liveimage_srv/CImg.h:      static char max() { return (char)-1; }
liveimage_srv/CImg.h:      static char max() { return (char)((unsigned char)-1>>1); }
liveimage_srv/CImg.h:      static signed char max() { return (signed char)((unsigned char)-1>>1); }
liveimage_srv/CImg.h:      static unsigned short max() { return (unsigned short)-1; }
liveimage_srv/CImg.h:      static short max() { return (short)((unsigned short)-1>>1); }
liveimage_srv/CImg.h:      static unsigned int max() { return (unsigned int)-1; }
liveimage_srv/CImg.h:      static cimg_uint64 max() { return (cimg_uint64)-1; }
liveimage_srv/CImg.h:      static cimg_int64 max() { return (cimg_int64)((cimg_uint64)-1>>1); }
liveimage_srv/CImg.h:      static bool is_nan(const double val) { // Custom version that works with '-ffast-math'
liveimage_srv/CImg.h:      static double min() { return -DBL_MAX; }
liveimage_srv/CImg.h:        const double val_nan = -std::sqrt(-1.); return val_nan;
liveimage_srv/CImg.h:      static bool is_nan(const float val) { // Custom version that works with '-ffast-math'
liveimage_srv/CImg.h:      static float min() { return -FLT_MAX; }
liveimage_srv/CImg.h:      static long double min() { return -LDBL_MAX; }
liveimage_srv/CImg.h:      static long double nan() { const long double val_nan = -std::sqrt(-1.L); return val_nan; }
liveimage_srv/CImg.h:      static bool is_nan(const half val) { // Custom version that works with '-ffast-math'
liveimage_srv/CImg.h:      static half min() { return (half)-65504; }
liveimage_srv/CImg.h:      static half nan() { const half val_nan = (half)-std::sqrt(-1.); return val_nan; }
liveimage_srv/CImg.h:    // Define keycodes for X11-based graphical systems.
liveimage_srv/CImg.h:    const unsigned int keyESC        = 1U;   //!< Keycode for the \c ESC key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF1         = 2U;   //!< Keycode for the \c F1 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF2         = 3U;   //!< Keycode for the \c F2 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF3         = 4U;   //!< Keycode for the \c F3 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF4         = 5U;   //!< Keycode for the \c F4 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF5         = 6U;   //!< Keycode for the \c F5 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF6         = 7U;   //!< Keycode for the \c F6 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF7         = 8U;   //!< Keycode for the \c F7 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF8         = 9U;   //!< Keycode for the \c F8 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF9         = 10U;  //!< Keycode for the \c F9 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF10        = 11U;  //!< Keycode for the \c F10 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF11        = 12U;  //!< Keycode for the \c F11 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF12        = 13U;  //!< Keycode for the \c F12 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAUSE      = 14U;  //!< Keycode for the \c PAUSE key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int key1          = 15U;  //!< Keycode for the \c 1 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int key2          = 16U;  //!< Keycode for the \c 2 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int key3          = 17U;  //!< Keycode for the \c 3 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int key4          = 18U;  //!< Keycode for the \c 4 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int key5          = 19U;  //!< Keycode for the \c 5 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int key6          = 20U;  //!< Keycode for the \c 6 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int key7          = 21U;  //!< Keycode for the \c 7 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int key8          = 22U;  //!< Keycode for the \c 8 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int key9          = 23U;  //!< Keycode for the \c 9 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int key0          = 24U;  //!< Keycode for the \c 0 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyBACKSPACE  = 25U;  //!< Keycode for the \c BACKSPACE key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyINSERT     = 26U;  //!< Keycode for the \c INSERT key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyHOME       = 27U;  //!< Keycode for the \c HOME key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAGEUP     = 28U;  //!< Keycode for the \c PAGEUP key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyTAB        = 29U;  //!< Keycode for the \c TAB key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyQ          = 30U;  //!< Keycode for the \c Q key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyW          = 31U;  //!< Keycode for the \c W key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyE          = 32U;  //!< Keycode for the \c E key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyR          = 33U;  //!< Keycode for the \c R key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyT          = 34U;  //!< Keycode for the \c T key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyY          = 35U;  //!< Keycode for the \c Y key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyU          = 36U;  //!< Keycode for the \c U key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyI          = 37U;  //!< Keycode for the \c I key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyO          = 38U;  //!< Keycode for the \c O key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyP          = 39U;  //!< Keycode for the \c P key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyDELETE     = 40U;  //!< Keycode for the \c DELETE key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyEND        = 41U;  //!< Keycode for the \c END key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAGEDOWN   = 42U;  //!< Keycode for the \c PAGEDOWN key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyCAPSLOCK   = 43U;  //!< Keycode for the \c CAPSLOCK key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyA          = 44U;  //!< Keycode for the \c A key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyS          = 45U;  //!< Keycode for the \c S key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyD          = 46U;  //!< Keycode for the \c D key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyF          = 47U;  //!< Keycode for the \c F key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyG          = 48U;  //!< Keycode for the \c G key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyH          = 49U;  //!< Keycode for the \c H key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyJ          = 50U;  //!< Keycode for the \c J key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyK          = 51U;  //!< Keycode for the \c K key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyL          = 52U;  //!< Keycode for the \c L key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyENTER      = 53U;  //!< Keycode for the \c ENTER key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keySHIFTLEFT  = 54U;  //!< Keycode for the \c SHIFTLEFT key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyZ          = 55U;  //!< Keycode for the \c Z key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyX          = 56U;  //!< Keycode for the \c X key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyC          = 57U;  //!< Keycode for the \c C key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyV          = 58U;  //!< Keycode for the \c V key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyB          = 59U;  //!< Keycode for the \c B key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyN          = 60U;  //!< Keycode for the \c N key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyM          = 61U;  //!< Keycode for the \c M key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keySHIFTRIGHT = 62U;  //!< Keycode for the \c SHIFTRIGHT key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyARROWUP    = 63U;  //!< Keycode for the \c ARROWUP key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyCTRLLEFT   = 64U;  //!< Keycode for the \c CTRLLEFT key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyAPPLEFT    = 65U;  //!< Keycode for the \c APPLEFT key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyALT        = 66U;  //!< Keycode for the \c ALT key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keySPACE      = 67U;  //!< Keycode for the \c SPACE key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyALTGR      = 68U;  //!< Keycode for the \c ALTGR key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyAPPRIGHT   = 69U;  //!< Keycode for the \c APPRIGHT key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyMENU       = 70U;  //!< Keycode for the \c MENU key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyCTRLRIGHT  = 71U;  //!< Keycode for the \c CTRLRIGHT key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyARROWLEFT  = 72U;  //!< Keycode for the \c ARROWLEFT key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyARROWDOWN  = 73U;  //!< Keycode for the \c ARROWDOWN key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyARROWRIGHT = 74U;  //!< Keycode for the \c ARROWRIGHT key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAD0       = 75U;  //!< Keycode for the \c PAD0 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAD1       = 76U;  //!< Keycode for the \c PAD1 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAD2       = 77U;  //!< Keycode for the \c PAD2 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAD3       = 78U;  //!< Keycode for the \c PAD3 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAD4       = 79U;  //!< Keycode for the \c PAD4 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAD5       = 80U;  //!< Keycode for the \c PAD5 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAD6       = 81U;  //!< Keycode for the \c PAD6 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAD7       = 82U;  //!< Keycode for the \c PAD7 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAD8       = 83U;  //!< Keycode for the \c PAD8 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPAD9       = 84U;  //!< Keycode for the \c PAD9 key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPADADD     = 85U;  //!< Keycode for the \c PADADD key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPADSUB     = 86U;  //!< Keycode for the \c PADSUB key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPADMUL     = 87U;  //!< Keycode for the \c PADMUL key (architecture-dependent)
liveimage_srv/CImg.h:    const unsigned int keyPADDIV     = 88U;  //!< Keycode for the \c PADDDIV key (architecture-dependent)
liveimage_srv/CImg.h:      "}|^{|}|g{|}| s{}~}_{|y~|gy~} Z{}~}_{|y~|gy~}    )y}|                       -{|y~                    Jy}|yy}|   "
liveimage_srv/CImg.h:      "}y~}  6{}~}_{}~}f{|y~|  -y~}6{|y~ A{}y~Z{}~}  j{|y~I{}y~d{}~}d{}~} \\{|y~a{|}y|*{}~}j{|y~|O{}~}F{|y~K{|}y~y|j{}"
liveimage_srv/CImg.h:      "|y~|O{}~}F{|y~J{|y~h{}y~     Ry~}b{~| r{}~}    i{}~}-x}y~ '{}x~w|y~|  e{}~|         qy~      i{|x~g{}y~b{|x~  f"
liveimage_srv/CImg.h:      "|y~|O{}~}F{|y~J{|y~h{}y~     Rx| W{}~}    i{}~}-{}y~}| &{}s~|  i{|~y}y~         t{|~y}y~      kv~|g{}y~dv~|  ex"
liveimage_srv/CImg.h:      "}                   s{|y~}|     '{|n~}  m{|y}w~}|6{|y~} ?{}y~Z{}~}  nx~}|-{}~} B{|y~ g{}~}j{|y~|O{}~}F{|y~J{|y~"
liveimage_srv/CImg.h:      "h{}y~           q{}~}  -{|}x~}|  f{}y~}|         t{|x~}|      kx~}|f{}y~dx~}|                                  "
liveimage_srv/CImg.h:      " -{|                                                                                                           "
liveimage_srv/CImg.h:      "}c~|_{}d~}^{|}p~}|R{|v~Y{}^~|iv~}r{|v~qv~}a{|}p~}| x{}x~} s{}w~ s{}w~|  f{|}r~}|-{}w~|i{|v~({|q~}|W{|v~vv~|Ty|u"
liveimage_srv/CImg.h:      "~}St~V{}c~|_{}d~}`{|}k~|T{|v~Y{}^~|iv~}r{|v~qv~}c{|k~}| {}v~} t{}w~ t{}u~|  i{|l~-v~i{}w~|Xw}|R{|l~X{|v~vv~|W{|"
liveimage_srv/CImg.h:      "~}a{}g~|V{|v~Y{}^~|iv~}r{|v~qv~}e{|g~}\"{}t~} u{}w~ u{}s~| >y~}P{|k~-{|w~}k{|w~}Ww~|S{|k~X{|v~vv~|Y{|}k~}|Z{|y~"
liveimage_srv/CImg.h:      "|w~|R{|x~}x{|x~}Uv~|w{}w~}Q{|w~|Ww~}Hv~}w{}w~}    Pw~}y{|x~}cY~  i{}y~|#{|w~}Qm~|`m~}w{|m~|\\{}v~|  ;{}`~}    -"
liveimage_srv/CImg.h:      "~|Rw~ {{}o~}w{|x~} H{}x~|T{|w~r{}x~}-{}x~|hw~|d{}x~|hw~|_{}x~|mw~|%{|r~|R{|r~|R{|r~|R{|r~|R{|r~|R{}r~|Y{|v~|y{|"
liveimage_srv/CImg.h:      "}|uy|s~a{|t~}|uy|s~a{|t~}|uy|s~a{|t~}|uy|s~-{|t~}|u{|}q~}f{|v~h{}w~}f{|v~h{}w~}f{|v~h{}w~}f{|v~h{}w~}dv~}l{}v~`"
liveimage_srv/CImg.h:      "~h{}v~}f{|r~y}v~}r~}d{}w~}hv~|iv~}r{|v~qv~}j{|v~}i{|u~-{}v~}{}w~{|v~} {}w~ {}v~}{}w~{|u~ Cy~}Rv~|S{}~}g{|y~|_v~"
liveimage_srv/CImg.h:      "-{}y~}r{}y~}R{}w~I{|w~Pt~}| L{}m~}w{|x~} H{}x~|U{|x~}p{|w~.{}x~|kw~|a{}x~|kw~|ct~}lw~|${|v~xv~U{|v~xv~U{|v~xv~U"
liveimage_srv/CImg.h:      "v~S{|v~}x{|}v~}|y{|v~}^{|w~}u{|w~}Rw~|S{|u~}${}y~|v{}v~}|wy|}y~u{|y~}c{|x~}r{|x~}Q{|q{| W{}y~|uw~vy|v~u{|y~}-w~"
liveimage_srv/CImg.h:      "~}g{|y~}dw~q{}x~}S{}~}s{}y~ X{}y~|tw~s{}x~}u{|y~}-{}p~}P{}w~M{|w~|F{|x~}({|w~|m{}w~|a{}m~}w{|x~} H{}x~|Tw~p{}x~"
liveimage_srv/CImg.h:      "v~|mv~|`v~}n{}w~|av~|n{|v~|av~|n{|v~|av~|n{|v~|av~|n{|v~|av~|n{|v~|-v~|r{|x~}v~`{|w~|m{}w~|a{|w~|m{}w~|a{|w~|m{"
liveimage_srv/CImg.h:      "{y|u~}T{|w~}Lw}|P{|}p~}-{|y~}u{}l~u{}y~|.{|v~|v{}w~}Dw~}6{|y~}uw~rw~}w{}y~| O{}w~  p{|w~|m{}w~|Ux~}w{|x~}  C{}w"
liveimage_srv/CImg.h:      "S{}v~}?{|v~c{|_~|Ov~|`v~|m{}w~}Y{|v~W{|v~k{}w~}O{|v~ J{|}p~}|d{|Z~}d{|}p~}|-w~s{|w~ov~|v{}x~|lv~|j{|v~c{}w~}k{}"
liveimage_srv/CImg.h:      "{|w~|D{}w~| q{|y~}K{|y~}L{}v~|N{}v~Ww~}kw~}^{|j~}\\v~|o{}w~}X{}s~W{|^~}    -s~}v|}v~}$v~}#{|w~t{|x~}X{}e~|^w~|o"
liveimage_srv/CImg.h:      "}\\{}h~}T{}x~}Ms~ K{|y~}C{|w~ p{}x~K{}x~Kw~|L{}x~|Ww~}kw~}]{|l~}\\{|v~n{|w~}X{|s~U{}`~}    -{|h~|$v~}#{}x~}t{}x"
liveimage_srv/CImg.h:      "  -{|k~}|    U{|r~}                  l{}r~}            Z{}r~|Rw~}L{}r~|    O{}t~                               "
liveimage_srv/CImg.h:      "       k{}t~}           -{|`}|    `{|}m~}| Jt~}   _w~}9{|w~|    `{}s~| :w~|   cv~  S{|w~}W{|w~|#{|w~| j{}w~ s{}"
liveimage_srv/CImg.h:      "                         )X  AX '\\ )XAV 7YDY -]      BY  BY '[ +YEY 2X  AY (\\ -YDY   'XAU 3Y  AY (\\ )XAV 8YD"
liveimage_srv/CImg.h:      "X  CY '] -ZEZ 2X  CY (^ .ZEZ   )[CU 2Y  CY (] *[CU 7ZEZ      LY  CY (] -ZEZ %Y                                 "
liveimage_srv/CImg.h:      "                                  =X  KX 'XJX 3WKd 5ZEY 3XGX      CX  JX 'WIW 1ZEZ .X  JX (XJX 2ZEZ   -WKd -X  "
liveimage_srv/CImg.h:      "W 3VHa 4ZEY 3WDW      CX  LX 'WGW 2ZEZ -X  LX 'WHW 2ZEZ   -VHa +X  KX (XHW 3VHa 5ZEZ      GX  KX (WGW 2ZEZ )X  "
liveimage_srv/CImg.h:      "X 'WFW 3ZEZ   -VF^ )X  MX 'WFW 4VF^ 4ZEZ      FX  MX 'WFW 3ZEZ *X                 ?d                           "
liveimage_srv/CImg.h:      "             ?W  X 'WDW 5UC[ 2ZEY 4VAV      AW  X &WDW 4ZEZ +W  NW 'WDW 4ZEZ   -UC[ 'W  MW 'WDW 5UC[ 3ZEZ      "
liveimage_srv/CImg.h:      "           NVAV                                          <P              -X +Y  =Y +] )[CU 7YDY 4V@V      KY  ="
liveimage_srv/CImg.h:      "CW                                          <R              4a .Y  >X *^ +]DU 7ZEZ 5U>U      JY  ?Y *^ -YEZ 4Y "
liveimage_srv/CImg.h:      "                                 7Y          -T 7W#W <Y    9X -W  DU             KY    HZ \"\\      4Z    M[ \""
liveimage_srv/CImg.h:      "    +g                 A[                      LY        8Z -ZEZ   \"Y          1o )V    FX  NZ  FY            "
liveimage_srv/CImg.h:      " FV             a   \"d -g      >d   (d +b            %b        4f        Bg                 Ie   \"e   \"h    "
liveimage_srv/CImg.h:      "      -n   $g        I`                   .j        >a        ;e    HU        .U        +b        Ac 2ZEZ   'b "
liveimage_srv/CImg.h:      "         5o -]    Na (c  KY          .Y #_   8Y!W'Y\"X.c$X              3XGX    Mf                       -e +d "
liveimage_srv/CImg.h:      "        +g    L\\ 8t (m Ks 2~R E} <o HZ(Z :Z \"Z 4Z,] LZ 2_'_(^-Z Ck :q 0k ?q *n J~d'Z(Z*Z LZ=Z.\\.Z7Z(Z([$Z'~^"
liveimage_srv/CImg.h:      " ,\\ ,h        7\\ -o .`   $f -h  NY    No     %_ %c   @_\"X-_\"W0h&W   .\\ $\\ \"\\ #\\ #\\ )g 5~a Lm D~S I~S "
liveimage_srv/CImg.h:      "         GX 5i 0d 2p ;u !^ ?y 2o F~S @n 4j            /l    N\\ 8x .r Nx 7~R E} >t KZ(Z :Z \"Z 4Z-] KZ 2_'_(^-Z"
liveimage_srv/CImg.h:      "                        Le /X 0e          1r   +r        c                   3o -\\ 5~S E~R Dn *Z :~]+[;Z;Z Ko "
liveimage_srv/CImg.h:      "   Y    EX    EY        2m   @Y)Y   6l 7ZEZ 0e 2k        >e 1o 0c   'j /i  X   !r     (b 'g   Eb\"W0c#X0i(W   -"
liveimage_srv/CImg.h:      "LY   )h   :Y  <Y  NX 0X  >Y                 >X               8f /X 0f          3t   -s        c                "
liveimage_srv/CImg.h:      "X   #u     (b (i   Fb#X0c#W/k+X   .^ %] $^ %] $^ (d 5~b\"v H~S I~S H~R H~R 6Z !Z !Z \"Z :{ A_-Y Gt :t ;t ;s ;t "
liveimage_srv/CImg.h:      "6p 7m        Eo 6o 2h   *l 1l %X   #v     (b )k   Gb$X/c$X/l,W   -^ &_ %^ &_ %^ 'b 4~b$z J~S I~S H~R H~R 6Z !Z "
liveimage_srv/CImg.h:      "!Z \"Z :~ D_-Y Hw =v >w >w >w   4wIX)Z(Z#Z(Z$Z(Z$Y'Y$[)[ KZ  Mt 1X  HX )WHW 2VHb 6ZEZ 4WDW      DX  GX )WHW 1YE"
liveimage_srv/CImg.h:      "X    H_      7U 'p   ?Y,Y 6X *o 7ZEZ 8t 9YH]        Ht 9o 3i   *XG[ 1VE[ &Y   %x     (b *[I[   Hb$W.c%X.VE[-X  "
liveimage_srv/CImg.h:      "J_ 2X  IX )WGW 2VG` 5ZEZ 4XFX      CX  IX )WFW 2YEZ .X  IX )WFW 3ZEZ /j 8VG` -X  HX *WFW 4VG` 4ZEZ      IX  IX "
liveimage_srv/CImg.h:      ")WGW 2ZEZ 'X 6Y  FYEZ                 ?XKX M~f        7T   )W 'i DiAi ;X          1~V                  (w   -Z "
liveimage_srv/CImg.h:      " A~R E} E~T$Z(Z :Z \"Z 4Z2] FZ 2a+a(`/Z K| C{ C} H| =|!~d'Z(Z(Z!Z9Z1^1Z2[0[!Z+[$~^ @X $X  ;Y -e    MX   'Y     "
liveimage_srv/CImg.h:      "        8Z@[ 2` 7~S E~R J{ 1Z :~]+[;Z;Z#}   +`    HX    Ia      8U (q   >Y-Y 6X +p 7ZEZ 9bMb ;U@Y        JbMb :"
liveimage_srv/CImg.h:      "n 3ZIZ   +T@Y 2R>Y 'X   %y     (XLV +ZEZ   IXMW%X.YMW%W-R>Y.W   -` '_ &` '_ &` '` 4~c'~R N~S I~S H~R H~R 6Z !Z "
liveimage_srv/CImg.h:      "W 2YEZ -X  KX (WFW 3ZEZ .f 5UE_ ,X  JX )WFW 4VF_ 4ZEZ      HX  KX )WEW 3ZEZ (X 5Y  FYEZ                 @YJW M~"
liveimage_srv/CImg.h:      "e        7U   *X (j EkCk =Y          3~X                  )x   -Z +XCX ,W?X 3T BYEY3X Ft (X  KX %X  JV         "
liveimage_srv/CImg.h:      "~P   -b    IX    Jc      9U )r   >Y.Y 5X ,]DX 7ZEZ ;\\>\\ <R;X        M]>\\   0XDX   ,R=Y  MX (X   %hEW     (SG"
liveimage_srv/CImg.h:      "V ,YAY   JSHW%W-SGW&X GX/W   ,` (a '` (a '` (a 5~d(~S N~S I~S H~R H~R 6Z !Z !Z \"Z :~T Ia/Y L~P F~P F~P F~P F~P"
liveimage_srv/CImg.h:      "   <~X&Z(Z#Z(Z$Z(Z$Y'Y\"[-[ IZ  \\>Z 1X  LX )VCW 4UD] 4ZEZ 2f      ?X  LX )WDW 3YEZ ,W  KX )WDW 4ZEZ -b 2UD] *W"
liveimage_srv/CImg.h:      "   6~Z                  *`C\\   -Z +XCX ,W?W 2T CYCY5X E]CZ (X  LX $X  JV           IX 9]E^ @m 7aGb B^Ec ,b ?y "
liveimage_srv/CImg.h:      "9aF[ F~R E_C_ B_E^            ;]E_ ={ 7b ;~R @cBb'~V D~R E} HeBc$Z(Z :Z \"Z 4Z4] DZ 2b-b(a0Z NbCb E} GbCb J~ Aa"
liveimage_srv/CImg.h:      "/d    JX    Ke      :U )]BW   =Y/Y 5X ,[?U   3Z8[ &W        NZ7Z   2XBW    EX  LW )X   %iEW      KV -Y?Y   @W&X"
liveimage_srv/CImg.h:      "!W&W EW0X   -b )a (b )a 'a )a 5~d)dCb N~S I~S H~R H~R 6Z !Z !Z \"Z :~V Kb0Y MbCb HbCb HbCb HbCb HbCb   >bCh%Z(Z"
liveimage_srv/CImg.h:      "   -Z +XCX -X@X 2U DXAX5W E\\=V (X  LX #X .R@V?Q          ,X :\\A\\ @m 7\\>_ CY<_ -c ?y :^=V F~Q E]>^ D]@]     "
liveimage_srv/CImg.h:      "       <Z@^ @~P 9b ;Z=d Aa;^'Z>j E~R E| Ha8^$Z(Z :Z \"Z 4Z5] CZ 2b-b(b1Z `<_ FZ@d I`=` K[@d C_:Z ~b&Z(Z'Z#Z8Z2`"
liveimage_srv/CImg.h:      "     ;U *\\=T   =Y0Y 4X ,Z;R   5Z3Y &W       !Y3Y   3W@W    EW  LX *W   %jEW      KV -X=X   @W'X W'X EX1W   ,b "
liveimage_srv/CImg.h:      " NW 2Y         N\\ #[ \"\\ #\\ #[  MXHW L~b        7U   +\\ ,n IoGp C_          ;~]                  ,]:X   -Z "
liveimage_srv/CImg.h:      "+XCX -X@X 8c LX@X7X E[:T (X  MX \"X /TAVAT          .X :\\?\\ Am 7Y9] CT4] .c ?Y  J]8S  Z E\\;\\ E]=[          "
liveimage_srv/CImg.h:      "  <W;\\ B~T ;b ;Z7_ C_5['Z7e GZ  MZ '`3[$Z(Z :Z \"Z 4Z6] BZ 2b-b(b1Z!_8^ GZ;` K_9_ LZ:` D]5W 3Y 9Z(Z&Z$Z7Z3`3Z."
liveimage_srv/CImg.h:      "U *[:R   <Y2Z 4X -Z8P   6Y/X 'W       #Y/Y   6W>V    EW  KW +W   %kEW      KV .X;W   @W'W NW(X CW2X   -c *c )b "
liveimage_srv/CImg.h:      "e +d +d ,e #XHW LZ#Z        7U   +] -o KqHp C_          <c                   2]7V   -Z +XCX -W?X <l#X?X7W E[7R "
liveimage_srv/CImg.h:      "E^1Y'Z3b HZ  MZ (_/Y$Z(Z :Z \"Z 4Z7] AZ 2c/c(c2Z!]4] HZ9^ L^5^ MZ8^ E\\0T 3Y 9Z(Z&Z%Z6Z3`3Z-Z6[ J[2Z  \\ >X #X "
liveimage_srv/CImg.h:      "        #Z                   =Y8Z 7d 7[  Z )_7_ Bp EZ(Z+[;Z;Z(^5^   5j    MX    Nk      =U +[7P   <Z3Y 3X -Y   "
liveimage_srv/CImg.h:      "       7U   +_ /p KrJr Ea          >`                   .\\5U   -Z +XCX -W?W =r'X>W8X EZ  ;X  NY !X 1XDVDX 2X  "
liveimage_srv/CImg.h:      "      &X ;[;[ BWDZ 7T2\\ \"\\ 1XMZ ?Y  L\\  2Z E[7[ G\\9[            >S5[ F`7` ?YNY <Z3\\ F]-W'Z0` IZ  MZ )^+W$"
liveimage_srv/CImg.h:      "Z(Z :Z \"Z 4Z8] @Z 2YNX/XNY(c2Z\"]2] IZ7] N]2] MZ6] G\\-R 3Y 9Z(Z&[&Z6Z4XNW3Z-[8[ HZ3[ !\\ =X #X  <Y 3\\H]    N"
liveimage_srv/CImg.h:      "                >Y6Y 7YNY 6[ !Z *^3] Dt GZ(Z+[;Z;Z)]2]   6l    NX    m      >U +Z   !Y4Z 3X -Y    NW(W (W      "
liveimage_srv/CImg.h:      " 7U   ,a 0q LrJr Fc          A_                   ,\\2S   -Z +XCX .X@X ?u(W=X:X DY  :X  NX  Y 2ZFVFZ 2X        "
liveimage_srv/CImg.h:      "LY   -Y   'Y      8X  >Y                 >Y               ;Y  X  Y          :Y6Y 7j :Y        \"Y              "
liveimage_srv/CImg.h:      "     >Y6Z 9YMY 5[ \"Z *]1] Hy IZ(Z+[;Z;Z)\\/\\   8n    X   !o      ?U ,[    Y5Y 2X -Y    W&W )W       'W%W   9V"
liveimage_srv/CImg.h:      "<V +X  DW  LW     )mEW      KV /X9X   BW)X MW)W BW3X   ,YMY ,YMY ,ZNZ -YMY +YNZ -YMY 9ZGZ 5]*U NZ !Z  Z !Z  >Z "
liveimage_srv/CImg.h:      "C^                   *[0R   -Z +XCX .X@X @v)X=X:W CY  :X  Y  NX 1[HVH[ 1X        'X ;Z7Z 0Z 7P,[ ![ 3XLZ ?Y  M["
liveimage_srv/CImg.h:      "  1Z EZ4[ I[5Z            ?P1Z I^-] BYLY =Z1[ H\\(T'Z-^ JZ  MZ *\\$S$Z(Z :Z \"Z 4Z:] >Z 2YMX1XMY(YNZ4Z$].\\ JZ5"
liveimage_srv/CImg.h:      "\\!\\-\\ Z4[ GZ  ;Y 9Z(Z%Z'Z4Z5XNX5Z*Z:[ F[6Z  [ ;X \"X  =Y 5\\C[       #Y     LY   -Y   'Y      8X  >Y        "
liveimage_srv/CImg.h:      "(Z+[;Z;Z*\\-\\   :p   !X   \"q      @U ,Z    NY6Y 1X -X    W#V *W       (W#W   :U;V +X  DW  LW     )mEW      KV"
liveimage_srv/CImg.h:      " /X9X   BW*X LW*X BW3W   +YLY -YMY ,YLY -YMY ,YLY -YMZ ;ZFZ 5\\'S NZ !Z  Z !Z  >Z !Z !Z \"Z :Z-^\"e3Y#\\.]#].\\"
liveimage_srv/CImg.h:      "#\\-\\#\\-\\#\\-\\   H\\.]$Z(Z#Z(Z$Z(Z$Y'Y L[6Z DZ \"Y5Y                                    /[G[               "
liveimage_srv/CImg.h:      "  -Z +XCX .W?X Bx)X=X;X DZ  :X  X  MY 0ZIVIZ /X        'X ;Z7[ 1Z  AZ ![ 4XKZ ?Y  MZ  0Z EZ3Z I[5Z             "
liveimage_srv/CImg.h:      "(Z4Z5WLW5Z*[<[ DZ7[ !\\ ;X \"X  =Y 6\\A[       $Y     LY   -Y   'Y      8X  >Y                 >Y              "
liveimage_srv/CImg.h:      "   #s      AU ,Z    MY7Y 1X -Y   \"W!V :f       (V!W   ;U;V +X  EX  MW     (mEW      KV /W7W   BW*W KW+X BW3X  "
liveimage_srv/CImg.h:      " +YLY .YKY -YLY .YKY -YLY .ZLY ;ZFZ 6\\%R NZ !Z  Z !Z  >Z !Z !Z \"Z :Z,^#YNZ3Y$\\,\\#\\,\\$\\,\\%\\+\\%\\,\\ MP"
liveimage_srv/CImg.h:      " NP N\\-]$Z(Z#Z(Z$Z(Z$Y'Y KZ7[ Dq :Z4X                                    /XC[                              EY "
liveimage_srv/CImg.h:      "       -x @x >x ?x @x -X :Z'Z      ?U  MU   -e 2q MtLt Ig          E[                   'Z,P   -Z +XCX .W?W By)"
liveimage_srv/CImg.h:      "X<W;W CZ  :X  X  MY .ZKVKZ -X        (Y <Z5Z 1Z  A[ !Z 4XKZ ?Y  N[  1Z DZ3Z IZ3Y             NY K\\%[ EYKZ >Z0Z"
liveimage_srv/CImg.h:      " !\\ :X !X  >Y 7[>[       %Y     LY   -Y   'Y      8X  >Y                 >Y               ;Y  X  Y          ;Y"
liveimage_srv/CImg.h:      "  BU ,Z  *P DY8Y 0X -Y   #W NV @k       )V NV   <V;V +X  EW  NY     )nEW      KV /W7W   BW+X KW+W CY4X   +YKZ /"
liveimage_srv/CImg.h:      "YKY .ZLZ /YKY .ZKY /YKY <ZEZ 7\\#Q NZ !Z  Z !Z  >Z !Z !Z \"Z :Z+]#YMZ4Y%\\*\\%\\*\\&\\*[%[)[%[*\\ R!R [-_%Z(Z#Z"
liveimage_srv/CImg.h:      "B{ Az B{ /X :Z'Y      >V  U   -g 4r NvNu Ji *\\ 5X.X 6\\ 7Z1Z M[                   '[    8Z +XCX /X@X C`MTL_)W;"
liveimage_srv/CImg.h:      "\\ 9X !X  >Y 8[<[       &Y     LY   -Y   'Y      8X  >Y                 >Y               ;Y  X  Y          ;Y5Y "
liveimage_srv/CImg.h:      "7RB] =\\        $Z                   BY2Y ;YJY 3[ &Z -[(\\!~U Z(Z+[;Z;Z,\\)\\   ?\\MXL[   $X   %\\LXM\\      CU"
liveimage_srv/CImg.h:      " ,Y *Q\"R DY9Y 0X -Y   #V=_?V Cm       *V LV   <U;V +X  FX \"[     (nEW      KV /W7W   BW+W JW,X F[3W   *YJY 0Z"
liveimage_srv/CImg.h:      "KZ /YJY /YKZ /YJY /YJY =ZEZ 7[!P NZ !Z  Z !Z  >Z !Z !Z \"Z :Z*]$YMZ4Y%[([%[(['\\)\\'\\)\\'\\)[!T#T\"\\-`&Z(Z#Z("
liveimage_srv/CImg.h:      "[ ![ 8X !X  >Y 9[:[       'Y     LY   -Y   'Y      8X  >Y                 >Y               ;Y  X  Y          ;Y"
liveimage_srv/CImg.h:      " DU -Z +S$T EY:Y /X -Z   %V?fBU Eo       +VEg=V   =V<V +X  GX *b     &nEW      KV /W7W   BW,X JW,W Nb2X   +ZJY "
liveimage_srv/CImg.h:      "0YIY /YJY 0YIY /YJZ 1YIY =ZEZ 8\\  NZ !Z  Z !Z  >Z !Z !Z \"Z :Z)\\$YLZ5Y&\\'['['\\(['['['['['[#V%V#[-a&Z(Z#Z(Z$"
liveimage_srv/CImg.h:      "K[ &Z(\\ MZ  MZ -[  Z(Z :Z \"Z 4Z?\\ 8Z 2YKX5XKY(YLZ6Z&[&[ MZ3[%[&\\#Z2[ JZ  :Y 9Z(Z#Z+Z1Z7WJW7Z&Z@Z >Z<Z ![ 7X"
liveimage_srv/CImg.h:      "X  Y        6Y /Y5Y $[ =`  G^ !Z    IZ             M\\     #Y2Z =YIZ 3\\ (Z .[%[%aIZI`\"Z(Z+[;Z;Z-[%[   B\\KXJ["
liveimage_srv/CImg.h:      "BW-X IW-X N`0W   *YIZ 1YIY 0YHY 1YIY 0ZIY 1YIZ ?ZDZ 8[  MZ !Z  Z !Z  >Z !Z !Z \"Z :Z(\\%YLZ5Y&[&['[&[)\\&[)[%[)"
liveimage_srv/CImg.h:      "[&[$X'X%[-b&Z(Z#Z(Z$Z(Z$Y'Y I[=[ Az CY;` 5\\ $] $\\ \"\\ #\\ $] 8\\/[ 3\\ '\\ #\\ \"[ \"[          \"[ &Z &[ !["
liveimage_srv/CImg.h:      "XHZ ?Y !Z  /Z CY1Y JZ1Z      2Y   Y  $Z Z HY JYHY ?Z/Y L[ %Z'\\ NZ  MZ -[  Z(Z :Z \"Z 4Z@\\ 7Z 2YKX5XKY(YKZ7Z'["
liveimage_srv/CImg.h:      "0X1Z 8Y FXD`9` YD` -c 9XD` /aEX :XD] 6g 7t BX0Y LY)Y+X6Z6X)Z/Z NX)Y I} 2Y  X  Y        9_>W KY5Y #[ =c  h >XD` "
liveimage_srv/CImg.h:      "AT#X 5Y 6X0X LY'Y ?RCW ?~Y!X?X?X ;d 'r!~W KZ1Y =YHY 2\\ )Z /[$[%_GZG_#Z(Z+[;Z;Z-[%[   C\\JXI[   'X   (\\IXJ\\  "
liveimage_srv/CImg.h:      " (Y  d 5Z -W(X FY<Y .X ,[   (UAmDV Iq       ,VDl@U   >V=W +X  HX )^   ,Y1Y HnEW      KV 0X7W   BW-W HW.X M^/X )"
liveimage_srv/CImg.h:      "Z(Z$Z(Z$Y'Y H[>Z @{ DY=b ;f -f -f ,e -f -f Ae7c ;e /b )c *c *c 'Y  NX  NX  X  E[ >XD` -c )c *b *c )c '\\ &bDX L"
liveimage_srv/CImg.h:      "2Z&[#Z#Z2[ JZ  :Y 9Z(Z\"Z,Z1Z8XJX8Z%[D[ <Z?[ \"\\ 6X  X  ?Y <[4[     -l :YGd ,k 9eGY :h 5r 8eGY GYGe +Y  NX 0X3"
liveimage_srv/CImg.h:      "Z $k 9Z .Y*Z FY=Y .X ,\\   *UAnCU J^CW       -VCmAV   ?W>V *X  IX (a   /Y1Y HnEW      KV 0X7W   BW.X HW.W La3X "
liveimage_srv/CImg.h:      "#[$Z2[ JZ  :Y 9Z(Z\"Z-Z/Z9XJX9Z#ZDZ :Z@Z \"\\ 5X  NX  @Y =[1Z     1q <YIh 0o =hHY <l 7r 9hIY GYHg ,Y  NX 0X4\\ "
liveimage_srv/CImg.h:      "7Y FYIg@g#YHh 6l =YIh 7hHX ;YHa ;q <t BY1Y KY+Y*Y8\\8Y([3[ MY+Y I~ 2Y  X  Y        =gCX KY6Z !Z <i -q CYHh F[*Y"
liveimage_srv/CImg.h:      " ;Z /[,[ FZ?Y -X +\\   +UBoBU LZ>W       -UBnAU   >W@W *X  JX 'c   1Y1Y HnEW      KV /W7W   BW.W GW/X Lc5W 'Y ,"
liveimage_srv/CImg.h:      "YFY 4ZGY 2YFY 3YGZ 3YFY 3YGZ AZCZ 9Z  KZ !Z  Z !Z  >Z !Z !Z \"Z :Z&[&YJZ7Y'[#[*Z\"Z+[#[+[#[+[#[&[-\\'[/YM[(Z(Z#"
liveimage_srv/CImg.h:      "BY2Z KZ0[      <b   a  -[\"Y BX MYFY @Z0Z M[ $Z%[ Z  MZ .Z  MZ(Z :Z \"Z 4ZD] 4Z 2YJX7XJY(YJZ8Z([\"[ Z2Z&Z\"[$Z2"
liveimage_srv/CImg.h:      "JiBi$YJk 8o ?YJj 9kJX ;YJc <r <t BY1Y KZ-Z)X8\\8Y'Z4[ LZ,Y I~ 2Y  X  Y        ?jDX KY6Y  Z ;k 1r CYIj G]-Z 5Z 7"
liveimage_srv/CImg.h:      " (q ;Z .[BVB[ DY@Z -X *]   .UC^EXBU LX<W       .VBWC[AU   ?WAW )X  KX %c   2Y1Y HnEW      KV /W7W   BW/X GW/W J"
liveimage_srv/CImg.h:      " -\\ ,nLW JY0X HY0X GX0X GX0Y KY,Y JYJj CY,Y     :ZBXBZ!Z+Z Z,Z Z,Z!Z+Z 6X 7Z-Z      BZ  U   0q 7o M~n s ;u BX."
liveimage_srv/CImg.h:      "Z2Z'[!Z$Z2[ JZ  :Y 9Z(Z!Z/[/Z:XHW9Z\"[H[ 8ZC[ \"[ 3X  NX  @Y ?[-Z     5v ?YKm 6r ?mKY ?q 9r <mKY GYKm /Y  NX 0X"
liveimage_srv/CImg.h:      "6[ 4Y FYKkEl%YKm ;r @YKl ;mKX ;YKd >t <t BY1Y JY-Y(Y9]9Y&Z5Z JY-Y H~ 2Y  X  Y        @lFX JY6Y  NY 9k 4s CYJl H"
liveimage_srv/CImg.h:      "EXFU   %Z )r ;Z -[G^G[ CZAY ,X )]   /UC[>TAU NX;W )P9P     =UAWAYAU   >XDX )X  LX  HY   3Y1Y HnEW      KV /W7W "
liveimage_srv/CImg.h:      "AP9P 9W0X FW0X ?Y8W &Y -YEZ 5YEY 4ZFZ 5YEY 4ZEY 5YEY BZBZ :[  KZ !Z  Z !Z  >Z !Z !Z \"Z :Z%['YIZ8Y([!Z+Z![,Z![-"
liveimage_srv/CImg.h:      "[![-[!Z$[1\\&[/XJZ(Z(Z#Z(Z$Z(Z$Y'Y EZCZ =Z;` HYA[ 8u <u =v <v =u <u!uGr Js =r 9r 9r 9r .Y  Y  NX  Y (o AXJl :q "
liveimage_srv/CImg.h:      "7q 9r 9q 7q .\\ -y IY0X HY0X GX0X GX0Y KZ-Y JYKl DY-Z     ;ZAXAZ\"Y)Y!Z*Z\"Z*Z\"Y)Y 6X 7Z-Y      BZ  NT   0s 8o"
liveimage_srv/CImg.h:      "GYLo 0Y  NX 0X7[ 3Y FYLmGn&YLo =t AYLo >oLX ;YLe ?u <t BY1Y JY-Y(Y9]9X%[7Z IZ.Y H~ 2Y  X  Y        AnGX JY7Z  N"
liveimage_srv/CImg.h:      "Z 9k 6t CYKn I^/Z 5\\ 8Y1Y Z$Z L\\Jg H~Y!Y@X@Y Br =~S\"~W LZ/Y @YDY /[ -Z 0Z NZ+\\@Z@\\'Z(Z*Z;Z;Z/[![ U  GSEXDS"
liveimage_srv/CImg.h:      "W      KV /W7W AQ:Q :W0W EW1X <X:X &Y -YDY 6ZEZ 5YDY 6ZEZ 5YDY 5YEZ CZBZ :Z  JZ !Z  Z !Z  >Z !Z !Z \"Z :Z%['YHZ"
liveimage_srv/CImg.h:      "9Y(Z Z+Z Z-[![-[![-Z [$[3\\%[0XI[)Z(Z#Z(Z$Z(Z$Y'Y E[E[ =Z9^ HYBZ 6v =v >w =w >v =v\"vIt Lt >t ;t ;t ;t /Y  Y  N"
liveimage_srv/CImg.h:      "Z(Z :Z \"Z 4ZG] 1Z 2YIX:YIY(YHZ:Z)[ [!Z2Z'Z [%Z2[ J[  ;Y 9Z(Z Z0Z-Z;XHX;Z NZJ[ 6[FZ \"\\ 2X  MX  AY AZ(Z     7x"
liveimage_srv/CImg.h:      "!Z !Z \"Z :Z$Z'YHZ9Y)[ [-[ [.[ Z-Z NZ-Z [#[5\\$Z0XH[)Z(Z#Z(Z$Z(Z$Y'Y D[FZ <Z7] IYBY 5w >w ?x >x ?w >w#wKv Nu ?v"
liveimage_srv/CImg.h:      "X :[  >X $Y  FY +f &X        +X ;Z/Z 4Z  AZ !Z ;YDZ ?YFP -Z?Q  BZ ?Z5Z JZ/Z 5Z \"[  Gj   Ii  ;[\"X1Q,W\"YCZ BZ1"
liveimage_srv/CImg.h:      "j J~Y!Y@X@Y D_I` A~U\"~W LY.Y AYCZ .[ /Z 1Z MZ,\\?Z?\\(Z(Z*Z;Z<[/Z NZ\"Y  ;X  ;Y 3X 3Y2Y 3X    EZ -hM[ ;Z *~Q >"
liveimage_srv/CImg.h:      "CY 6YBY 7YCY 6ZCY 7YCZ EZAZ ;[  JZ !Z  Z !Z  >Z !Z !Z \"Z :Z$Z'YGZ:Y)[ NZ-[ [.Z N[.Z NZ.[ NZ\"[7\\$[1XFZ)Z(Z#Z("
liveimage_srv/CImg.h:      "-j (X        +X ;Z/Z 4Z  AZ \"Z :XCZ ?YM_ 5ZE^  IZ >Y6Z IZ0[ 5Z \"[  Jj   Ci  ?\\\"X6\\2X#YBY BZ1Z MZ \"Z$[!Z  "
liveimage_srv/CImg.h:      " K~Y!Y@X@Y E]C^ CaHl\"~W LY.Z BYBY .\\ 0Z 1Z M[-[>Z>[(Z(Z*Z;Z<[0[ N[$[  <X  <[ 4X 4[4[ 4X    EZ ._KUHV ;Z )~ <Y"
liveimage_srv/CImg.h:      "Z 7YBY 8ZCZ 7YBY 8ZBY FZ@Z ;Z  IZ !Z  Z !Z  >Z !Z !Z \"Z :Z$[(YGZ:Y)[ NZ-Z MZ.Z N[/[ N[/[ NZ![9\\#[2YFZ)Z(Z#Z(Z"
liveimage_srv/CImg.h:      "$Z(Z$Y'Y C[I[ ;Z5\\ JYCY 4X=^ @X=] @Y=] ?Y>^ @X=^ @X=^%X=l@\\\"_?W A]@\\ @]@\\ @^A\\ @^A\\ 1Y  Y  NX  Y -w DXNY"
liveimage_srv/CImg.h:      "BZ 9YAY 8ZBZ 9YAY 8ZBZ 9YAY FZ@Z ;Z  IZ !Z  Z !Z  >Z !Z !Z \"Z :Z$[(YFZ;Y)Z MZ-Z MZ/[ MZ/[ N[/Z M[![;\\\"[3YE[*"
liveimage_srv/CImg.h:      "[ \"Z#Z!Z  MZ 0Z  KZ(Z :Z \"Z 4ZK] -Z 2YGX=XGY(YFZ<Z*[ MZ!Z3[(Z M[&Z3[ H^  ?Y 9Z(Z NZ3Z*Z=XFX=Z Kf 0[L[ #\\ /X "
liveimage_srv/CImg.h:      "X@Y FZ;[ E]>\\ 0Z 6Y.Z CYAZ -\\ 2Z 1Z LZ.[=Z=[)Z(Z*Z;Z<Z/Z LZ&\\  ;X  ;\\ 6X 6\\2\\ 6X    EZ /\\GUCQ ;Z 'z 9YGY"
liveimage_srv/CImg.h:      " )X -ZN_   ;TDX\"U\"W;Y 0W@W     ?T>W>X@T   ;a #X #X  =W   6Y1Y GmEW      KV .X;X @W@W @W3W BW4X 6W?X #Y /Y@Y :"
liveimage_srv/CImg.h:      " >Y  EY 2ZKVKZ -X        ,X :Z/Z 4Z  BZ &] :XAZ ?s =YJk #[ ;[=[ FZ1\\ 6Z \"[ #j L~d Ki  J\\!X:hKVAW%Y@Y CZ5\\ L"
liveimage_srv/CImg.h:      "  LX  BY        JQ1[ D_:[ B\\ ([9_ F[7Z 6Y 1[:_ G^9Z 3Y  NX 0X>\\ -Y F^;b;Z)_:Z D[:\\ F_:[ G[9^ ;_ /Y  EY .Y1Y "
liveimage_srv/CImg.h:      "Z9[ G\\;[ 0Y 5Y.Z DZ@Y ,\\ 3Z 1Z LZ.Z<Z=[)Z(Z*Z;Z<Z/Z LZ'\\  :X  :\\ 7X 7\\0\\ 7X    EZ 0\\FU -Z &x 8YHY (X -YK"
liveimage_srv/CImg.h:      " MZ 0Z  KZ(Z :Z \"Z 4ZM] +Z 2YGY?XFY(YEZ=Z*Z L[\"Z4['Z LZ&Z4[ Fc  EY 9Z(Z MZ5Z)Z>XDW=Z Ic .[NZ #\\ -X  KX  CY  "
liveimage_srv/CImg.h:      ".Z DZ@Z ,\\ 4Z 2[ LZ.Z<Z<Z)Z(Z*[<Z<Z/Z LZ(\\  9X  9\\ 8X 8\\.\\ 8X    EZ 1\\EU -Z %^E] EhIg 6X .YI_   ?UEX T!W="
liveimage_srv/CImg.h:      "Z 2YBY     @U>W>W?U   7W <~d BX  ;W   6Y1Y GmEW      KV -X=X ?YBY BW4W AW5X 5W@W !Y 0Y?Z ;Y?Y :Z@Z ;Y?Y :Z?Y ;Y"
liveimage_srv/CImg.h:      "Y GX.X ;YMZ 7Z;Z!X                   *~R   !Z    X@X BZDT BXCYDX 6`    ?Y  DY 7[HVH[ 1X        -X 9Z.Y 4Z  D[ 7"
liveimage_srv/CImg.h:      "G]7Z 4Y  NX 0X@[ *Y F]8^8Z*]7Z FZ6[ G]6Z I[7] ;] -X  DY .Y1Y GY3Y#Y=WNX=X L[CZ ?Y4Y &[ .X  NX  Y     $iGh Z:XNX"
liveimage_srv/CImg.h:      "ZIuIZ)\\  8X  8\\ 9X 9\\,\\ 9X    EZ 1[DU -Z $Z@[ EhJh 6X /YF_   ATDX U\"X?[ 3ZCZ     @U>W>W?U     K~d CX  ;X  "
liveimage_srv/CImg.h:      " 6Y1Y FlEW      KV -Y?Y ?ZCZ CW5X AW5W 5XAX !Y 0Y>Y <Z?Z ;Y>Y <Z?Z ;Y>Y ;Y?Z JZ>~Q3[  I~Q G~Q F~Q G~Q 5Z !Z !Z "
liveimage_srv/CImg.h:      "R   !Z    X@X BZDT BZGZCW 6b    @Y  DY 8ZFVFZ 2X        -X 9Z.Y 4Z  DZ 7l 8X?Z ?w BZMr ([ 7s C[3] 6Z \"[ +i C~d"
liveimage_srv/CImg.h:      "Z5\\ ;] -X  DY .Y1Y GZ5Z#Y>XMW>Y K[E[ ?Y5Y &[ .Y  NX  Y     $XIZHZIY!Z:XNX GYHf  GY DY6[ CY $\\5Y CX6Y 5c ;Y1Y#"
liveimage_srv/CImg.h:      "CU -Z %Z>Z EiKh 6X /XC^   BTDX U\"YA\\ 4ZCZ N~d  &U>W?X>T     K~d EY  :W   5Y1Y EkEW      KV ,YAY =ZCZ DW6X @W6"
liveimage_srv/CImg.h:      "   BZ  DY 8XDVDX 2X        -X 9Z.Y 4Z  E[ 7j 7Y?Z ?x CZNt )Z 5p @Z3] 6Z \"[ .i @~d @i *\\ MW<^Ib@W(Y=Z E| GZ !Z"
liveimage_srv/CImg.h:      "[5[ 3Y 6~W EY=Z *[ 6Z 2Z KZ/Z;Z<[*Z(Z)Z<Z=Z/[IuI[,\\  6X  6\\ ;X ;\\(\\ ;X      LZBU -Z %Y<Z FjMi 6X 0X@]   CTD"
liveimage_srv/CImg.h:      "4[   >Z9` IY0X HY0X GX0X GX0Y FY6Z F\\4Z GY6Y     ;W9X9W-X JX,WD[I\\DW,W1[DW-X JX =X 1Y6Z     <~d'RKY:U   5~U J"
liveimage_srv/CImg.h:      "8Z.Y 4Z  F[ 6h 5X>Z ?y DgF` *Z 2k >Z4^ 6Z \"[ 1j >~d =i -[ LW=\\C_?W)Y<Y Ez EZ !Z\"Z\"~Q Dy![  K~] :Z \"Z 4e &Z"
liveimage_srv/CImg.h:      " 3Y2[ G[4Y 4Y  NX 0XD\\ 'Y F[5[5Y*[4Y HZ2Z H[3Z KZ3[ ;[ ,Y  DY .Y1Y FY5Y!Y?WLX?Y J[GZ <Y7Z '[ -Y  NX  Z     'WC"
liveimage_srv/CImg.h:      "Z)[=Z=Z/[IuI[-\\  5X  5\\ <X <\\&\\ <X      LZBU -Z &Y:Y FjNj 6X 0X?]   EUEX NU!s 6ZCZ L~d  &T=WAY=T     K~d GX"
liveimage_srv/CImg.h:      "3Z GY6Y     ;W9X9W-W HW,WC[K\\CW,W2[CW-W HW =X 1Z7Z     <~d NX:U   5~V M~X%~e&~Y LX0Y HX.X =ZJY 6Y=Z W         "
liveimage_srv/CImg.h:      " =X      MZAU -Z &X8Y G~W 6X 0W<\\   FUEX MT iNW 8[D[ K~d  &T=WE\\<T     K~d HX  NQ<Y   4Y1Y CiEW 3Z    CV )k 7"
liveimage_srv/CImg.h:      "6Y  Y  NX  Y 3Z3Z HZ3Y IZ1Z IZ2Z IZ2Z JZ1Z IZ2Z   ?Z:b IY0X HY0X GX0X GX0Y EY8Z E[2Y GZ8Z     ;W9X9X.W HW-XB[M"
liveimage_srv/CImg.h:      "T >eBX<U\"[M\\4Y   ;Y  CZ 7Q?V?Q 0X        .X 8Y-Z 5Z  H\\ 5j 9Y=Z ?T9_ Ec>] ,Z 1j <[7_     7i 8~d 7i 5[ KW=Z="
liveimage_srv/CImg.h:      " IY@X@Y JY1Y LZ1Z 4Y 6~W FY;Z *[ 7Z 2Z KZ/Z;Z;Z*Z(Z(Z=Z>[/[IuI[/\\  3X  3\\ >X >\\\"\\ >X      MZAU -Z 'X6X 5c "
liveimage_srv/CImg.h:      "X<[+Z(Z#Z(Z$Z(Z$Y'Y <_ 4Z2Z KYD[  @X  NX  Y  NY  X  NX 3Z/Y-Z $Z/Y KZ/Y KZ/Y KZ/Y 6Y  Y  NX  Y 4Z2Z HZ3Y IZ1Z I"
liveimage_srv/CImg.h:      "Z1Z JY1Z JZ1Z IZ1Z   @Z;XNZ JY0X HY0X GX0X GX0Y EY8Y D[2Z GY8Y     ;X9X8W.W HW-W@hAW-X4[@W.W:[:W =X 0Z9Z      I"
liveimage_srv/CImg.h:      "X        /X 7Y-Z 5Z  H[ 4l ;X<Z ?Q4^ Fb<] .[ 3o ?[7_     :i    5j 9[ JW=Y;[?W+Z:Y F~ IZ !Z\"Z\"~Q Dy![2l'~] :Z "
liveimage_srv/CImg.h:      " 3Y.Y-Z $Y.Y KY.Y KY.Y KY.Y 6Y  Y  NX  Y 4Z1Y HY2Y IZ1Z IY0Z KZ0Z KZ1Z IY0Z   @Y;XMZ JY0X HY0X GX0X GX0Y DY9Y D"
liveimage_srv/CImg.h:      "Z0Y GY9Z     ;W8X8W.W HW-W?f?W.W4[?W.W:[:W =X 0Z9Y      HZ 5X<U   6~Z$~`'~a&~\\ NY/X HX.X =YHY 7Z?Z ~m         "
liveimage_srv/CImg.h:      "         4Z    3Y    W?W <i >_@XAa*[I\\6Y   ;Y  CZ %V  MX        /X 7Y-Z 5Z  I[ 3n >X;Z  ] G`9\\ .Z 4s @[9`    "
liveimage_srv/CImg.h:      "[ Ff GZ:X:[+Z(Z#Z(Z$Z(Z$Y'Y :\\ 3Z2Z KYC\\  BY  X  NX  NY  Y  X 3Y-X-Y #Y-X KY-X KY-X KY-X 6Y  Y  NX  Y 5Z0Y HY"
liveimage_srv/CImg.h:      "2Y IY/Y JZ0Z KZ0Z KY/Z KZ/Y   AZ;WKY JY0X HY0X GX0X GX0Y DY:Z DZ0Y FY:Y     :WK~KW.WK}KW-W>d>W.W5[>W.W:[:W =X /"
liveimage_srv/CImg.h:      "  CZ %V ;~c        LX 7Y-Z 5Z  J\\ 2n @Y;Z  N\\ G`8\\ /Z 5u A\\<b     ?i    *i ?Z IW=X8Z>V+Y8Y G~R LZ !Z\"Z\"~Q"
liveimage_srv/CImg.h:      "-[ 5Z 2[ LZ/Z;Z;Z*Z(Z'[?Z?[.[IuI[2~n BX B~n AX A~m AX      NZ@U 8y <X4X 4_ #X 1X7Z   IUEX MT J^HW <ZCZ F~d  &T="
liveimage_srv/CImg.h:      "g5T     -X ,o 5k   1Y1Y >dEW 3Z    Nl ._ ,ZCZ'lEX6\\>mEWDVCZBkAX6]   LY8Y BZ9Z AY8Y BZ9Z AY8Y BZ9Z!Z;~Q3Z  H~Q "
liveimage_srv/CImg.h:      "  NY  Y  Y 4Y-Y.Y #Y-X KY-X KY-Y LY-Y 7Y  Y  NX  Y 5Z0Z IY2Y JZ/Z KZ/Y KY/Z KY/Z KZ/Y#~d$Z<WJY JY0X HY0X GX0X G"
liveimage_srv/CImg.h:      "N~m                  4Z    3Y   !X@X :n 'WBg.ZE\\8X   :Y  CZ %V <~e        NX 6Y-Y 4Z  K\\ #a AX:Z  M\\ H_6[ 0Z"
liveimage_srv/CImg.h:      "3Y+Y1Y JY.Y IY/Z NY/Y ;Z *\\  HY .Y1Y DZ;Z LXBXIWBY Ce 6Y;Y )[ -\\  LX  L\\ >q:X  !U:[9U&Y5] DY?d =jLX FY/Z C[ "
liveimage_srv/CImg.h:      ")Y1Y AX=Z 6ZIY >Y1Y%Z IZ*YAYAY HY9Y IY@X@Y KY/Y NZ/Z 5Y 5Y-Y HZ8Y .[ 4Z 1Z LZ/Z;Z;Z*Z(Z'[?Z@[-[ L[3~o BX B~o BX"
liveimage_srv/CImg.h:      " B~o BX      NZ@U 8y <X4X 4^ \"X 1X6Y   IUEX MT GW *ZCZ E~d  &T=g5T     -X ,o 5i   /Y1Y <bEW 3Z    Nl *W 'ZCZ(l",
liveimage_srv/CImg.h:      "1[ L[1Z KZ Dc E[=Y9[+Z(Z#Z(Z$Z(Z$Y'Y 9Z 2Z2Z KYB^ &i 0i 1i /i 0i 0i Ej-Y/Z $Z-Y MZ-Y MZ-Y LY-Y 7Y  Y  NX  Y 5Y/"
liveimage_srv/CImg.h:      "/Z 5Y 5Y-Y HZ8Z 0\\ 4Z 1Z LZ/Z;Z;Z*Z(Z&[@Z@[-[ L[4~p BX B~o BX B~p CX      NY?U 8y <W2W 3] \"X 1Y7Y   IUEX MT  "
liveimage_srv/CImg.h:      " JZCZ  8X  &T=WIZ6T     -X ,o 3e   -Y1Y :`EW 3Z    Nl   (ZCZ)lFW5UNV>mFWCQ;XAe>X6UNW CY 4Y7Z DZ7Y BZ8Z CY7Z CZ7"
liveimage_srv/CImg.h:      "KYA^ /q 9r 9q 7q 8q 9r Mq,Y/Z $Y,Y MY,Y MY,Y MZ-Y 7Y  Y  NX  Y 5Y.Y IY1X JZ/Z KY.Z LY.Y LZ/Z KY.Z$~d$Y=XIZ KY0X"
liveimage_srv/CImg.h:      " ?ZFY 6YAZ N~m                  4Z    3Y   !W?W 6p -WCk1ZB\\;Y   :Y  CZ %V <~e        NX 6Z.Y 4Z  M\\  J] EY9Z "
liveimage_srv/CImg.h:      " L[ H^4[ 2[ 8\\<\\ BbKi     ?`     Ha @Z HV=X5X>W-Y6Y HZ2\\ Z !Z\"Z\"Z  MZ 1[2l'Z(Z :Z \"Z 4ZL] ,Z 2YBXGXBY(Y?Z"
liveimage_srv/CImg.h:      "XNX GZ.Y Ai 9Y1Y AY>Y 5YHZ ?Y1Y&[ IZ+ZAYAY HY9Y IY@X@Y KY/Y NZ.Y 5Y 5Y-Y IZ6Y 0[ 3Z 1Z LZ/Z;Z;Z*Z(Z&\\AZA[,[ L["
liveimage_srv/CImg.h:      "4~p BX B~o BX C~q CX      NY?U 8y <W2W 3\\   )Y6Y   JUEX NU   KZCZ  7X  &T=WGY7T     -X    J^   *Y1Y 7]EW 3Z   "
liveimage_srv/CImg.h:      "     8ZCZ 4X6UMV GX-X=^;W6UMW CY 4Y6Y DZ7Z CY6Y DZ7Z CY6Y DZ7Z#Z:Z <Z  HZ !Z  Z !Z  >Z !Z !Z \"Z :Z#[)Y>ZCY*Z K"
liveimage_srv/CImg.h:      " NX  Y 6Z.Y IX0X JY-Y KY.Z MZ.Y LZ.Y KY.Z$~d$Y>XHZ KY0X HY0X GX0X GX0Y BY=Y BY.Y FY=Z     9WK~KW/WJ}JW.W:\\:W.W"
liveimage_srv/CImg.h:      "Z IZ1[ Z !Z#[\"Z  MZ 1[2l'Z(Z :Z \"Z 4ZK] -Z 2YBXHYBY(Y>ZDZ*Z KZ\"v L[ LZ&z !c 4Y 9Z(Z HZ>Z\"ZDX>XDY Ge 'Z '[ "
liveimage_srv/CImg.h:      " KYDXGWDY @a 3Z>Y +[ 5d  IX  Ic L~d  !U8X7T'Z4[ CY5\\ AZCa GY-Y @h 9Y1Y @X?Z 6ZGY ?Y1Y&[9X9Z+ZAYAZ IY9Y IY@X@Y "
liveimage_srv/CImg.h:      "KY/Z Y-Y 5Y 5Y.Z IZ6Z 2[ 2Z 1Z M[/Z;Z<[*Z(Z%[AZB\\,[ LZ3~p BX B~o BX C~q CX      NY?U 8y <W2W 2[   (Y7Y   ITDW "
liveimage_srv/CImg.h:      "NU   M[CZ  6X  &T=WFY8T     -X        EY1Y 1WEW 3Z        7ZC[ 6W6ULV HX+W JX7ULW CY 5Z6Z EY5Y DZ6Z EY5Y DZ6Z E"
liveimage_srv/CImg.h:      "_ 8w ?x ?w =w >w >w$~u/Y #~W M~W M~W M~W 7Y  Y  NX  Y 6Z.Y IX0X JY-Y KY.Z MZ.Z MY-Y KY-Y$~d$Y?XFY KY0X HY0X GX0"
liveimage_srv/CImg.h:      "X GX0Y BY>Z BY.Y EY>Y     8WK~KW/WJ}JW.W;]:W.W:[9W/W9[9W >X -Y>Z      KZ .YAU   6~^*~g%~W L~T JX.Y IX.X ?YEZ 7Z"
liveimage_srv/CImg.h:      "2Z 2Z 8[7[ BqMZ     ?^     C^ @Y GV=W4X>V-Y5Z IZ0[!Z !Z#[\"Z  MZ 1[2l'Z(Z :Z \"Z 4ZJ] .Z 2YAXIXAY(Y=YDZ*Z L[\"s"
liveimage_srv/CImg.h:      " FY3Y2Y+Y1Y KZ.Z JY.Y Y.Y ;Y &h (Y .Y1Y BY=Y IXDXGWDY ?_ 1Y?Z ,[ 4b  GX  Ga L~c   T6V6T'Z4[ CY4\\ CZ@_ GY-Y >f "
liveimage_srv/CImg.h:      "9Y1Y @Y@Y 5YFZ @Y1Y&Z8X9[,ZAYAZ IY9Y IY@X@Y KX.Z Y-Y 5Y 5Y.Z IY5Z 3[ 1Z 1Z M[/[<Z<[*Z(Z%\\BZC\\+[ LZ3~p BX B~o "
liveimage_srv/CImg.h:      "BX C~q CX    DX 4Z?U -Z (W2W 2Z   'Z7X   ITDX U   MZCZ  5X  &U>WEY9T     -X        EY1Y 1WEW 3Z        6ZCZ 7X7"
liveimage_srv/CImg.h:      "-Y KY-Y MZ.Z MY-Y KY-Y$~d$Y?WEY KY0X HY0X GX0X GX0Y BZ?Y AY.Y EY>Y     8WK~KW/WJ}JW.W<_;W.W;[8W/W9[9W >X -Z?Z  "
liveimage_srv/CImg.h:      "    LZ -YBU   5~^*~h%~U J~R IX.Y IX.X @ZDY 6YCZ LW                   'y    JY   \"W?X ,j 3WCYCY4Y=\\>X   9Y  CZ"
liveimage_srv/CImg.h:      "Gz FY.Y KZ %Y-Y J~W :Y 5Y.Y GY1Y 5Y  NX 0c  IY FY3Y2Y+Y1Y KZ.Z JY.Y Y.Y ;Y %j +Y .Y1Y BY=Y IYEXGXEY >] 0Y?Y ,[ "
liveimage_srv/CImg.h:      "3`  EX  E_ L\\Cx   NT6V6T'Z4Z BY2Z CY>^ GY-Y ;c 9Y1Y @YAZ 6ZEY @Y1Y&Z8X9[,ZAYAZ IY9Y IY@X@Y KX.Z Y-Y 5Y 5Y.Z JZ"
liveimage_srv/CImg.h:      "4Y 4\\ 1Z 1[ NZ.[<Z<Z)Z(Z$\\CZD]*Z LZ3~p BX B~o BX C~q CX    DX 4Z?U -Z (W2W 2Z   'Z7X   ITDX U   MYBY  4X  &U>"
liveimage_srv/CImg.h:      "WDX:U     -X        EY1Y 1WEW 3Z        5YBY 7W6UKV IX*W KW6UKW CY 6Z4Y FZ5Z FZ4Z GZ4Y EY4Z GZ4Y%Y8Z <[  IZ !Z "
liveimage_srv/CImg.h:      "B{'~x/Y #~W M~W M~W M~W 7Y  Y  NX  Y 6Z.Y IX0X JY-Y LZ-Y MZ.Z MY-Y KY-Y$~d$Y@WDY KY0X HY0X GX0X GX0Y AY@Z AY.Y "
liveimage_srv/CImg.h:      "^ 6Y 9Z(Z GZAZ NZEW<WEZ IZL[ )Z *\\  X  FX  HY        H{ FY.Y KZ %Y-Y K~X :Y 5Y.Y GY1Y 5Y  NX 0c  IY FY3Y2Y+Y1Y"
liveimage_srv/CImg.h:      " KZ-Y JY.Y Y-X ;Y $l .Y .Y1Y AY?Y HYEWFXEX =\\ .Y@Y -[ 2b  GX  Ga LY=s   LT6W7T'Z4Z BY2Z DY=^ GY-Z =d 9Y1Y ?XAY"
liveimage_srv/CImg.h:      " 5YDZ AY1Y&Z8X9[,ZAYAZ IY9Y IY@X@Y KX.Z Y-Y 5Y 5Y.Z JZ4Z 5[ 0Z 0Z NZ-Z<Z<Z)Z(Z#\\DZD\\)Z LZ3~p BX B~o BX B~p CX"
liveimage_srv/CImg.h:      "    DX 4Z?U -Z (W2W 2Z   &[9X   IUEX T s AXAY  4X  &U>WCX;U     -X        EY1Y 1WEW 3Z      Is 0YAX 8W6UJV IW)W"
liveimage_srv/CImg.h:      "Ca CZBY4Z*Z(Z#Z(Z$Z(Z$Y'Y 9Z 2Z5\\ JY<` A| C| C{ A{ C| C|(~y/Y #~W M~W M~W M~W 7Y  Y  NX  Y 6Y-Z JX0X JY-Y LZ-Y"
liveimage_srv/CImg.h:      " MZ.Z MY-Y KY-Y$~d$YAWCY KY0X HY0X GX0X GX0Y AY@Y @Y.Y DY@Y     7WK~KW/XK}KX.W>c=W.W=[6W/X:[:X >X ,Y@Z      M[ "
liveimage_srv/CImg.h:      "Y KZ %Y-Y K~X :Y 5Y.Y GY1Y 5Y  NX 0d  JY FY3Y2Y+Y1Y KZ-Y JY.Y Y-X ;Y #m 0Y .Y1Y AY?Y HYFXEWFY =\\ .YAY ,[ 2d  I"
liveimage_srv/CImg.h:      "X  Ic LW8n   JU7W7T'Y2Y BY1Z EY<\\ FY-Z @g 9Y1Y ?YBY 6ZDZ AY1Y&Z8X8Z,Y@YAZ IY9Y IY@X@Y LY-Y Y-Y 5Y 5Y.Z JY3Z 6["
liveimage_srv/CImg.h:      " /Z 0Z [-[=Z=[)Z(Z#]EZE\\(Z LZ2~o BX B~n AX A~n BX    DX 4Z?U -Z (X4X H~W   <\\:W   HUDX!T s AZCZ  5X  %T>WBX<U"
liveimage_srv/CImg.h:      "     -X        EY1Y 1WEW       \"s 1ZCZ 9X7UIV JX)W LW7UIW CY 6Y2Y HZ3Z GY2Y HZ3Z GY2Y HZ3Z'Z8Z <[  IZ !Z  Z !Z"
liveimage_srv/CImg.h:      "/Y #~W M~W M~W M~W 7Y  Y  NX  Y 6Y-Z JX0X JY-Y LZ-Y MY-Z MY-Y LZ-Y$~d%ZBXCY KY0X HY0X GX0X GX0Y @YAY @Y.Y DYAZ "
liveimage_srv/CImg.h:      "    7W8X8W.W HW-W?e>W.W>[5W.W:[:W =W +ZAY      LZ *YDU   5~`,~i#~Q F} GX.Y IX.X AZBY 7ZEZ KX                   "
liveimage_srv/CImg.h:      "BZ MYFX<XGZ J[IZ *Z +[  MX  FX  HY        Jb>Y FY.Y KZ %Y-Y K~X :Y 5Y.Y GY1Y 5Y  NX 0e  KY FY3Y2Y+Y1Y KZ-Y JY.Y"
liveimage_srv/CImg.h:      " Y-X ;Y !m 2Y .Y1Y AZAZ GYGXEXGY >] .ZBY -[ 1e  JX  Ke LU4k   IU8Y8T'Y2X AY0Y EX:[ FY-Z Ah 9Y1Y >XCZ 6YBY AY1Y&"
liveimage_srv/CImg.h:      "Z8X8Z,Y@YAZ IY9Y IY@X@Y LY-Y Y-Y 5Y 5Z/Y JZ2Z 8[ .Z 0[!Z,[=Z=[)Z(Z\"]FZG]'Z M[1]  1X  1\\ @X @\\ L\\ AX    DX 4"
liveimage_srv/CImg.h:      "Z?U -Z (X4X H~W   ;\\;W   GTDX\"U s A[D[  6X  %T>WBX<T     ,X        EY1Y 1WEW       \"s 2[D[ 9W7UHV KX(W MX7UI"
liveimage_srv/CImg.h:      "X3[*Z(Z#Z(Z$Z(Z$Y(Z 9Z 2Z8^ IY9` Fb=Y Eb=Y Eb=X Cb>Y Eb=Y Eb=Y*b=~V/Y #~W M~W M~W M~W 7Y  Y  NX  Y 6Y-Z JX0X JY"
liveimage_srv/CImg.h:      "-Y LZ-Y MY-Z MY-Y LZ-Y   CZCXBY KY0X HY0X GX0X GX0Y @YBZ @Y.Y CYBY     6W8X8W.W HW-W@g@X.W?[4W.W:[:W =W *YBZ   "
liveimage_srv/CImg.h:      "  KX    Nl   !X 4Z/Z 4Z %\\  =Z LX4Z  IZ I[0Z 5Z 9Z0Z <bFY     ;i    1i =Z HW>X3W?W/~S KZ-Z\"Z \"Z#Z!Z  MZ 0[!Z"
liveimage_srv/CImg.h:      "]8Y FY.Y KZ %Y-Y K~X :Y 5Y.Y GY1Y 5Y  NX 0f  LY FY3Y2Y+Y1Y KZ-Y JY.Y Y-X ;Y  Mk 3Y .Y1Y @YAY FYGWDXGY >^ .YCZ ."
liveimage_srv/CImg.h:      "[ )_  KX  L_ ES/e   FU8Z9T'Z3X AY0Y FY:[ FY-Z Cj 9Y1Y >XCY 6ZBZ BY1Y&Z8X9[,Y@YAZ IY9Y IY@X@Y LY-Y Y-Y 5Y 5Z/Y J"
liveimage_srv/CImg.h:      "Z2Z 9\\ .Z /Z!Z,\\>Z>[(Z(Z!]GZH^'[ N[0\\  1X  2\\ ?X ?[ M\\ @X    DX 4Z?U -Z 'W4W G~W   :]>X   GTDY#U s @[D[  7"
liveimage_srv/CImg.h:      " !Z  >Z !Z !Z \"Z :Z$[(Y;ZFY)Z MZ-Z MZ/[ N[/[ N[/Z MZ Eg F[EX2[*Z(Z#Z(Z$Z(Z$Y(Z 9Z 2Z9^ HY7_ G]8Y F^8Y F^8X D]8"
liveimage_srv/CImg.h:      "Y E]8Y F^8Y+^8~V/Y #~W M~W M~W M~W 7Y  Y  NX  Y 6Y-Z JX0X JY-Y LZ-Y MY-Z MY-Y LZ-Y   BYDXAY KY0X HY0X GX0X GX0Y"
liveimage_srv/CImg.h:      " @ZCY ?Y.Y CYBY     5W9X8W.W HW-WAiAW,WA[3W.W9Y9W >X *ZCZ     6~d IYET   4~`,~i!| By EX.Y IX.X AYAZ 7ZFY IX    "
liveimage_srv/CImg.h:      "Y 8ZCZ     8i 6~d 5i ;Z HW>X3W?W0~T KZ-Z\"Z \"Z$[!Z  MZ 0[!Z'Z(Z :Z \"Z 4ZD] 4Z 2Y?XMX?Y(Y:ZHZ)Z N[!Z /[ NZ%Z6["
liveimage_srv/CImg.h:      "  J[ 7Y 9Z(Y DZDZ LZGW:WGZ K[GZ +Z -\\  LX  EX  IY        L\\6Y FY.Y KZ %Y-Y K~W 9Y 5Y.Y GY1Y 5Y  NX 0XM\\  MY "
liveimage_srv/CImg.h:      "FY3Y2Y+Y1Y KZ.Z JY.Y Y-X ;Y  Ji 4Y .Y1Y @YAY FYGWDXGX >` /YCY .[ $\\  LX  M\\ AR+`   CT9[:U'Z3X AY0Y FY9Z FY-Z "
liveimage_srv/CImg.h:      "D` .Y1Y >YEZ 6YAZ BY1Y&Z8X9[,ZAYAZ IY9Y IY@X@Y LY.Z Y-Y 5Y 5Z/Y KZ1Z 9[ -Z /Z\"[+[>Z>[(Z(Z ^IZJ_&[ NZ.\\  2X  3"
liveimage_srv/CImg.h:      "\\ >X >[ \\ ?X    DX 4Z?U -Z 'X6X G~W   9^@X   GUDY$T Ns ?[CZ  8X  %U?WAY?U     ,X        EY1Y 1WEW       \"s 4"
liveimage_srv/CImg.h:      "ZCZ 7W7UGV LX)X MW7UGW CY 8~T J~T I~S J~T I~T K~T*~ ;Z  IZ !Z  Z !Z  >Z !Z !Z \"Z :Z$[(Y:ZGY)[ NZ-Z N[.Z N[/[ N"
liveimage_srv/CImg.h:      "  Y 6Y-Z JX0X JY-Y LZ-Y MZ.Z MY-Y KY-Y   BYDW@Y KY0X HY0X GX0X GX0Y ?YDZ ?Y.Y BYDY     4W9X9X.W HW-XC\\L[BW,WB["
liveimage_srv/CImg.h:      "Z6\\GY   7Y  CY    JX    Nl   \"X 2Y/Z 4Z '\\  :Z M~Z %Z I[0Z 6Z 8Z/Z \"Z     5i 9~d 8i 8Z HW>X3W?W0~U LZ-Z\"[ "
liveimage_srv/CImg.h:      "HXCWHY ?b /YDY /[ ![  MX  M[ @Q%W   ?T9\\;U'Z3X AY0Z GX8Z FY-Z E\\ )Y1Y =XEY 6Z@Y BY1Y&Z9Y9[,ZAYAZ IY9Y IY@X@Y "
liveimage_srv/CImg.h:      "LY.Z Y-Y 5Y 4Y/Y KZ0Z ;[ ,Z /[#Z*\\?Z?\\(Z(Z N`LZL`$Z NZ-\\  3X  4\\ JPCXCP J[\"\\ >X    DX 4Z?U -Z 'X6X G~W   "
liveimage_srv/CImg.h:      "T J~U K~T*~ ;[  JZ !Z  Z !Z  >Z !Z !Z \"Z :Z$Z'Y9YGY)[ [-[ [.Z N[.Z NZ.[ NZ G\\L[ GZGX0Z)Z(Z#Z(Z$Z(Y#Z)Z 9Z 2~ "
liveimage_srv/CImg.h:      "GY4] J[4Y G[4Y G[4X EZ4Y FZ4Y G[4Y,[4X 1Y #Y  Y  Y  Y  9Y  Y  NX  Y 6Y-Z JX0X JY-Y LZ-Y MZ.Z MY-Y KY-Y   BYEW?Y"
liveimage_srv/CImg.h:      " KY0X HY0X GX0X GX0Y ?YDY >Y.Y BYDY     4W9X9W-X JX,WD\\J[CW,WC[2W-X JX >X )YDZ     5~d HXFU   4~_+~i z @w DX.Y"
liveimage_srv/CImg.h:      " M~Z %Z I[0Z 6Z 8Z/Z \"Z     2i <~d ;i 5Z HW>X3W@W/~U LZ-[#[ #Z$Z Z  MZ /Z!Z'Z(Z :Z \"Z 4ZB] 6Z 2Y>a>Y(Y9ZIZ)[ "
liveimage_srv/CImg.h:      "Z Z .Z [%Z4Z  JZ 7Y 9Z)Z DZEZ JYHX:XIZ KZD[ -Z /\\  JX  EX  IY        MZ3Y FY.Y JY %Z/Z JY  <Y 5Y.Y GY1Y 5Y  NX"
liveimage_srv/CImg.h:      " EY-Y E[ 'Y1Y =YFY 6Z@Z CY1Y&Z9Y9Z+ZAYAZ IY9Y IY@X@Y LZ/Z Y-Y 5Y 4Y0Z KZ0Z <[ +Z .Z$[)\\@Z@\\'Z(Z M~Q#Z [,\\  4"
liveimage_srv/CImg.h:      "X  5\\ JRDXDR J[$\\ KQCXDQ   #Y 4Z?U -Z &X8X F~W   7_EY   EUDY&U Ns <ZCZ  :X  $U@W?XAU     +X        EY1Y 1WEW "
liveimage_srv/CImg.h:      "      \"s 6ZCZ 7X8UEV MX)X MW7UFW DZ 8~U L~V K~U L~V K~U K~U+~ :Z  JZ !Z  Z !Z  >Z !Z !Z \"Z :Z%['Y9ZHY(Z [-[ Z"
liveimage_srv/CImg.h:      "-[ Z-Z [-Z [ H\\J[ HZHY1[)Z(Z#Z(Z$Z(Y#Z)Z 9Z 2} FY2\\ KZ3Y GZ3Y GY3Y FZ3Y GZ3Y GZ3Y,Z3X 1Y #Y  Y  Y  Y  9Y  Y  "
liveimage_srv/CImg.h:      "NX  Y 6Y-Z JX0X JY-Y KY.Z MZ.Z MY-Y KY-Y   BYFX?Y KY0X HY0X GX0X GX0Y >YEY >Y.Y BYEZ     4X:X9W,W JW+WE\\H[EX,X"
liveimage_srv/CImg.h:      "X8Z4\\JY   6Z  DY    JX        4X 1Z0Y 3Z )\\  8Z M~Z %Z I[0Z 7Z 7Z/Z \"Y     /i >~d >i 2Z GV>X3W@W0~V LZ-[\"Z "
liveimage_srv/CImg.h:      "#Z%[ Z  MZ /[\"Z'Z(Z :Z \"Z 4ZA] 7Z 2Y>a>Y(Y9ZIZ(Z Z Z .[![%Z4[  KZ 7Y 9Z)Z CZFZ JZIX:XIZ L[CZ -Z /[  IX  DX  J"
liveimage_srv/CImg.h:      "Y-Y 5Y 4Y0Z LZ.Y =[ *Z .[%Z(]AZA]'Z(Z L~\"[![+\\  5X  6\\ JTEXET J[&\\ KSDXES   $Y 3Y?U -Z &Y:Y F~W   5_GX   DU"
liveimage_srv/CImg.h:      ",~P :Z  JZ !Z  Z !Z  >Z !Z !Z \"Z :Z%['Y8ZIY(Z Z+Z Z-[![-[![-[![ I\\H[ I[JY0[(Y(Z#Z(Z$Z)Z#Z)Z 9Z 2| EY1\\ LY2Y "
liveimage_srv/CImg.h:      "HZ2Y HZ3Y FY2Y GY2Y GY2Y-Z2X 1Y #Y  Y  Y  Y  9Y  Y  NX  Y 6Z.Y IX0X JY-Y KY.Z MZ.Z MY-Y KY.Z   BYGX?Z KY1Y HY0X"
liveimage_srv/CImg.h:      "Z HZ0Z 7Z 7Y.Z #Z     ,i A~d Aj 0Z GV=W4X@W0~W MZ-[\"[ $Z%[ Z  MZ /[\"Z'Z(Z :Z \"Z 4Z@] 8Z 2Y>`=Y(Y8ZJZ([\"[ Z "
liveimage_srv/CImg.h:      " EZ.Y FZ %Y1Y <XGY 6Z>Y CY1Y&[:Z:Z+ZAYAY HY9Y IY@X@Y LZ/Y NZ.Y 5Y 4Y0Y KZ.Z ?\\ *Z -['['\\AZB]&Z(Z K|![!Z)\\  6"
liveimage_srv/CImg.h:      "X  7\\ JVFXFV J[(\\ KUEXFU   %Y 3Y?U -Z %Y<Y /Z    M`KY   BUC[=SAU   CZCZ  <X  #UAW>XCU     *X        EY1Y 1WEW"
liveimage_srv/CImg.h:      "          F[CZ 6X8UDV NW)X MX8UDW DY 8~W N~W L~W M~V L~W M~W-~P :[  KZ !Z  Z !Z  >Z !Z !Z \"Z :Z%['Y8ZIY([\"[+["
liveimage_srv/CImg.h:      "\"[,Z![-[!Z,[!Z I\\F[ J[KY/Z'Z)Z#Z)Z#Z)Z#Z)Z 9Z 2{ DY0[ MY1Y HY1Y HY2Y FY2Y HZ2Y HY1Y-Y2Y 1Z $Y  Y  Y  Z  :Y  Y"
liveimage_srv/CImg.h:      "BZ >W?W;W8Z2\\MY   4Y  DY    JX        4X 1Z1Z 3Z +\\  6Z M~Z %Z HZ0Z 8[ 7Y.Z #Z     )i D~d Ci -Z GV=W4XAW/~W M"
liveimage_srv/CImg.h:      "Z-[\"[ $Z&[ NZ  MZ .Z\"Z'Z(Z :Z \"Z 4Z?] 9Z 2Y=_=Y(Y8ZJZ([\"[ Z -Z\"[$Z3[  L[ 8Y 9Z)Z BZHZ IZJX8XJY LZ@[ /Z 1\\"
liveimage_srv/CImg.h:      "Y IY@X@Y LZ/Y NZ/Z 5Y 3Y1Y KY-Z ?[ )Z -[([%]CZC]%Z(Z Jy M[#[(\\  7X  8\\ JXGXGX J[*\\ KWFXGW   &Y 3Y?U -Z %Z>Z "
liveimage_srv/CImg.h:      " 9Z 2z CY/Z MY1Y HY2Z HY2Y GY1Y HY1Y HY1Y-Y2Z 2Z $Z !Z !Z !Z  :Y  Y  NX  Y 6Z.Y IX0X JZ/Z KY.Z LY.Y LZ/Z KY.Z  "
liveimage_srv/CImg.h:      "Y1Z 3Z ,\\  5Z M~Z %Z HZ0Z 8Z 6Y.Z #Z     &i G~d Fi )X FV=X5XAW0~Y NZ-[!Z $Z&[ NZ  MZ .[#Z'Z(Z :Z \"Z 4Z>] :Z 2"
liveimage_srv/CImg.h:      "Y=_=Y(Y7ZKZ'Z#[ NZ -[#[$Z2[  M[ 8Y 9Z)Z BZHZ HYJX8XKZ M[?Z /Z 2\\  GX  CX  KY        NY1Y FZ0Z JZ %Y/Z JZ  =Y 4"
liveimage_srv/CImg.h:      "%Z(Z Iw L[#['\\  8X  9\\ JZHXHZ J[,\\ KYGXHY   'Y 3Z@U -Z $[B[ .Z  NW $j   @UCpBU   @[D[  ?X  \"UBW=XEU     )X "
liveimage_srv/CImg.h:      "Y7ZJY'[#Z)Z#[+[#[+[#[+[#[ K\\B[ K[MX.['Z*Z!Z*Z#Z)Z#Z)Z 9Z 2x AY.Z NY2Z HY2Z IY1Y GY1Y HY1Y HY2Z-X1Z 2Z $Z !Z !Z"
liveimage_srv/CImg.h:      "    1W?X &TAY ?W>W;W8Z0e   3Y  EZ    JX        5X /Z2Y 2Z -\\  4Z M~Z %Z HZ0Z 8Z 6Z/Z $Z     #j J~d Ii   CW>X6Y"
liveimage_srv/CImg.h:      "BX0~Y NZ-[![ %Z'\\ NZ  MZ -Z#Z'Z(Z :Z \"Z 4Z=] ;Z 2Y<]<Y(Y7ZKZ'[$[ NZ -[$[#Z1Z  M[ 8Y 8Z*Z BZIZ GZKX8XKZ N[>[ 0"
liveimage_srv/CImg.h:      "HY9Y IY@X@Y LZ/Y MY/Z 4Y 4Y2Y KZ,Z B[ 'Z +[+[#_FZF_$Z(Z Gt JZ$[%\\  9X  :\\ J\\IXI[ I\\/\\ K[HXI[   (Y 3Z@U -Z "
liveimage_srv/CImg.h:      "  3Z M~Z &Z FY1Z 8[ 6Z/Z $Z      i L~d Li   @W>Y7YBW0Z*Y NZ-[![ %Z'[ MZ  MZ -[$Z'Z(Z :Z \"Z 4Z<] <Z 2Y<]<Y(Y6ZL"
liveimage_srv/CImg.h:      "[%[$\\  :X  ;\\ H\\JXJ\\ H\\1\\ J\\IXJ\\   (Y 3Z@U -Z &x 0Z  X  c   <UAmDV   =[CZ  AX  !VDW<YHU     (X        E"
liveimage_srv/CImg.h:      "Y6ZKY&[%[)\\&[)[%[)[%[)[%[ L\\>[ Ld.[&Z*Z!Z*Z\"Z+[\"Z+Z 8Z 2s <Y-Y NX1Z IY1Z IY2Z GY2Z HY2Z HX1Z.Y1Z 1Z $Y  Y  "
liveimage_srv/CImg.h:      "W/Z*Z Z-Z N[ &Z(\\ MZ  MZ -\\%Z'Z(Z :Z \"Z 4Z;] =Z 2Y<]<Y(Y6ZLZ&[&[ MZ ,\\'[\"Z0Z  NZ 7Y 8Z+Z @ZJY FZLX6XLY N[;"
liveimage_srv/CImg.h:      "Y GY9Y IY@XAZ L[1Y LZ1Z 3Y 3Y3Y LZ*Z D[ &Z *[-[ aJZJa\"Z(Z Cl F\\'[\"\\  ;X  <\\ F\\KXK\\ F\\3\\ H\\JXK\\   'Y "
liveimage_srv/CImg.h:      "2ZAU -Z 'z 1Z  X  Na   ;V@jDV   :ZCZ  BX   UDW;XIU     'X        EY2Z 1WEW          KZCZ 3X9U@V\"W*X LX9VAW H[ "
liveimage_srv/CImg.h:      "[,[\"Z+Z!Z+Z 8Z 2n 7Y-Y NX1Z IY2[ IY2Z GY2Z HY2Z IY2[.Y2\\ 2Z $Z !Z !Z !Z  ;Y  Y  NX  Y 5Z0Y HX0X IZ1Z IY0Z KZ0"
liveimage_srv/CImg.h:      "   -dIQId%kKRKk El 2j >X.Y HY2Y CY;Z 7ZMZ BZ                   #Z        3X@X %TAX @W<W;W7Z/a   0Y  FY    IX   "
liveimage_srv/CImg.h:      "     6X -Z4Z 2Z 0\\  2[ )Z  JZ FZ2Z 8Z 5Z/Z %Z      Hi   @j   :V=Y9ZDX/Z*Z Z-Z N\\ 'Z)\\ LZ  MZ ,[%Z'Z(Z :Z \"Z"
liveimage_srv/CImg.h:      "/[ MdNZNd!Z(Z Ag B['[!\\  <X  =\\ D\\LXL\\ D[4\\ F\\KXL\\   &Z 3ZAU -Z (| 2Z  X  L^   9V?fBU   8ZCZ  CX   V JV "
liveimage_srv/CImg.h:      " !Z \"Z :Z)\\$Y5ZLY%[(\\'\\(['\\(['['['[(\\ M\\:[ Ma-[$Z,Z NZ,Z![,Z!Z,[ 8Z 2Z #Y-Y NX2[ IY2[ IY2Z GY3[ HX2[ IY2"
liveimage_srv/CImg.h:      "         $[,P       )W?X %TBY AX<W;W7[/_   /Y  FY    IX        6X -Z5Z 1Z 1\\  1Z (Z  K[ EY2Z 9Z 4Z0[ &[      F"
liveimage_srv/CImg.h:      "j   Ei   7W=Y;[EX/Z(Z!Z.[ M[!P'Z*] LZ  MZ ,\\&Z'Z(Z :Z \"Z 4Z9] ?Z 2Y;[;Y(Y4YMZ%[)\\ LZ +\\)[!Z/Z  Z 7Y 7Z-[ ?Z"
liveimage_srv/CImg.h:      "XM\\   %Z 3ZAU -Z )~ 3Z  X  J]   9V>a@V   7YBY  CX   NV LV              BZ3Z 1WEW          LYBY 2W8U?V#W+X KX9U"
liveimage_srv/CImg.h:      "[ N`-[#Z,Z NZ,Z Z-[![-[ 8Z 2Z #Y-Y NX2[ IY2[ IY3[ GY3[ HY3[ HX2[.Y3^ 2Z $Z !Z !Z !Z  <Y  Y  NX  Y 4Z2Z HX0X HZ2"
liveimage_srv/CImg.h:      "$Z  HYNU   +aHSH`!hJRIg Bi /g <X.Y GY4Y CZ:Y 6YMY @[                   $Z-Q       )W?W $TBY AW;W<X6Z.]   .Y  GY"
liveimage_srv/CImg.h:      "    HX        6X -Z5Z 1Z 2\\  0Z (Z  L[ DZ4Z 8Z 4[1Z %Z      Bj   Ki   4W=Z=\\GY.Z(Z!Z.[ M\\#Q'Z+] KZ  MZ +\\'Z"
liveimage_srv/CImg.h:      "'Z(Z :Z \"Z 4Z8] @Z 2Y:Y:Y(Y4ZNZ%\\*[ KZ *\\+\\!Z/[ \"[ 7Y 7Z-Z >ZMZ DZMW4WMZ![7Z 3Z 7\\  BX  AX  MY        NY3"
liveimage_srv/CImg.h:      "[ F\\4Z FZ &Z3\\ HZ  ?Y 3Z4\\ GY1Y 5Y  NX 0X@[ *Y FY3Y2Y+Y1Y HZ3Z H\\4Z KZ3[ ;Y  5Y 9Y -Y4[ ;YKY >YNX=WNY D[D[ "
liveimage_srv/CImg.h:      "Y6Z LZ(Z H\\ $Z (\\3[ I~R MZ(Z :Z ;\\+\\ MY  ;X  ;X @\\NXN\\ @X1X B\\MXN\\   $Z 2ZBU -Z *~Q 4Z  X  I]   :W9U;V "
liveimage_srv/CImg.h:      "Z  Z !Z  >Z !Z !Z \"Z :Z+]#Y4ZMY$[*\\%\\*[%\\+\\%\\+\\%\\+\\ N\\6[ N^-\\#[.[ N[.[ [.Z NZ-Z 7Z 2Z #Y-Y NY4\\ IY3"
liveimage_srv/CImg.h:      " GZ5[ GZ5\\ :YMY :\\4Z ;XMZ     +Y@X@Y#Z)Z\"Y(Y\"Y(Y#Z)Z 9X %ZMZ     %Z  F_   )^GSG^ NfIRHe @g -e ;X.Y GZ6Z CY9"
liveimage_srv/CImg.h:      "Z 9[ 3Z2[ &Z      >i   i   2W<Z?]HZ.Y'Z!Z/\\ L\\&S'Z,] JZ  MZ *\\(Z'Z(Z :Z \"Z 4Z7] AZ 2Y JY(Y3e$\\,\\ KZ )\\-"
liveimage_srv/CImg.h:      "Y FY3Y2Y+Y1Y HZ4Z G\\4Z JZ5\\ ;Y  6Y 8Y -Y5\\ ;YKY =XNX=WNY E[B[ 3YNY 4[  BY  X  Y      N_=_ LZ:_ CZ2Y FX;Y >Z4"
liveimage_srv/CImg.h:      "Z EY #Y1Y 9XNZ 7Y6Z GZ4[$Z=]=['ZDYDZ FY9Y HZBXBZ K]5Z J[5[ 2Y 2Z7Y L[(Z H[ #Z '\\5[ F~ LZ(Z :Z :\\-\\ KW  :X  :"
liveimage_srv/CImg.h:      "V >r >V/V @s   #Z 2[CU -Z +[MeL[ 5Z  X  G\\   :W!V   3W@W     7V!W              AZ4[ 1WEW          LW@W 1W7s,X-"
liveimage_srv/CImg.h:      "Y JX8t$\\ 7Z'Z%Z'Z$Z'Y%Z'Z$Z'Y%Z'Z4Z1Z 6\\&S NZ !Z  Z !Z  >Z !Z !Z \"Z :Z,]\"Y3ZNY$\\,\\#\\,\\$\\,\\$\\-\\$\\,"
liveimage_srv/CImg.h:      "\\ N\\4[ ]-\\![/Z LZ/[ N[/[ N[/[ 7Z 2Z #Y-Y NY4\\ HY5] IY4\\ GY4\\ HY4\\ HY4\\.Z5` 2Z $Z !Z !Z !Z  =Y  Y  NX  Y "
liveimage_srv/CImg.h:      "X $YMY     %[  F^   '\\FSF\\ LcGRGc >f ,c :X.Y FZ7Y BY8Y 7e >[                   %[1S   -Y   'X@X ;Q:TCZ CX:X=X"
liveimage_srv/CImg.h:      "  AX  MY        NY5] F]6Z DZ &Z5] G[  AY 2[8^ GY1Y 5Y  NX 0X>[ ,Y FY3Y2Y+Y1Y H[6[ G]6Z IZ5\\ ;Y  6Y 8Y -Z6\\ ;Z"
liveimage_srv/CImg.h:      "IZ5Z 1Y 1Y8Z LZ&Z J[ \"Z &\\8] E| KZ(Z :Z :]/] JU  9X  9T <p <T-T >q   \"Z 1ZCU -Z ,[JaI[ 6Z  X  F\\   :W#V   1"
liveimage_srv/CImg.h:      "V?V     7W#W              @[5[ 1WEW          LV?V 1X7s,W-Y JX7t%\\ 6Z&Z&Z'Z%Z&Z&Z'Z%Z&Z&Z&Y4Y0Z 5\\(T NZ !Z  Z "
liveimage_srv/CImg.h:      "!Z  >Z !Z !Z \"Z :Z.^!Y3e#\\.\\!\\.\\#].\\#]/]#\\.\\ N\\2[ ]/]![0[ L[0[ M[0[ N\\1[ 6Z 2Z #Y-Y NY5] HY5] IZ6] GY"
liveimage_srv/CImg.h:      "5] HY5] HY5]-Y5a 3[ %[ \"[ \"[ \"[  >Y  Y  NX  Y 3Z5[ GX0X GZ5Z F[6[ G[6[ GZ5Z F[5Z 5\\ 4^9Z FY6\\ FY6\\ FY6\\ "
liveimage_srv/CImg.h:      "FY6] 9c 9]6Z :d     )[CXBZ Z-Z NZ-[ [-Z Z-Z 7X $YNZ     %Z  D]   $VCSDW G`FSG` ;d +c :X.Y F[9Z CZ8Y 6d =\\     "
liveimage_srv/CImg.h:      "              '\\3T   -Z   (W?X ;S<TDZ BW8W=W4\\1`   0Y  HY    HX  NZ    GZ 'X *Z9Z /Z 5\\  0\\ 'Z  N\\ B[8[ 8Z"
liveimage_srv/CImg.h:      " 2\\5[ '[ /Z \"[  >d   c  @Z EW<_Ks-Z&Z\"Z1] J^,V'Z/_ IZ  MZ )]*Z'Z(Z :Z \"Z 4Z5] CZ 2Y JY(Y2d#]0\\ IZ (]1] NZ-"
liveimage_srv/CImg.h:      "Z NS*\\ 6Y 6[1[ <e Bc4c\"[3Z 5Z 9\\  @X  AX  MY        NZ6] F^8[ D[ &Z7^ G[  AY 1[:_ GY1Y 5Y  NX 0X=[ -Y FY3Y2Y"
liveimage_srv/CImg.h:      "1[DU -Z -[F\\F[ 7Z  X  E\\   :W&W   /U>U     6W%W              ?[6\\ 1WEW          LU>U 0W6s-X.X HW6t&\\ 5Z&Z'Z"
liveimage_srv/CImg.h:      "2[ L[1[ 6Z 2Z #Y.Y MZ7^ HY6^ HY6] GZ6] HZ7^ HZ7^-Y6c 3[ %[ \"[ \"[ \"[  ?Y  Y  NX  Y 3[7[ FX0X G[7[ E[7[ FZ7[ F"
liveimage_srv/CImg.h:      "\\ 9b )a 9X.Y E[<[ BY7Z 7c ;\\                   '\\5U   -Z   (W?W :U>TE[ CX8X?X3\\3b   1Y  IY    GX  NZ    GZ ("
liveimage_srv/CImg.h:      "X )[;[ /Z 5[ %Q-\\ &Z BQ/] AZ9\\ 9Z 0[6\\ (\\ /Z \"[  ;a   `  =Z EX<nNd,Z$Y\"Z2] H^.W'Z2a HZ  MZ (^,Z'Z(Z :Z \""
liveimage_srv/CImg.h:      "Z 4Z4] DZ 2Y JY(Y2d\"]3^ IZ ']3] MZ-[ U-] 6Y 5\\4\\ ;d Bb2b#[2[ 6Z :\\  ?X  @X  NY        MZ8^ F^8Z B[ '[9_ F[,"
liveimage_srv/CImg.h:      "P 7Y 1\\<` GY1Y 5Y  NX 0X<[ .Y FY3Y2Y+Y1Y G[8[ F^9[ G[9^ ;Y *Q/Z 7Y -Z9^ :YMY <a;` F[>[ 4b 6[  ?Y  X  Y        "
liveimage_srv/CImg.h:      "(Z :Z 8]3] FQ  7X  7P 8l 8P)P :m    Z 0[EU -Z .[?P?[ 8Z  X  D[   9W(W   -T<S     5X)X              >\\8] 1WEW  "
liveimage_srv/CImg.h:      "        LS<T 0W5s-W.X HX6t'\\ 5Z$Y'Z%Z'[%Z(Z%Z&Z%Z(Z%Z6Z0Z 4^.W NZ !Z  Z !Z  >Z !Z !Z \"Z :Z2a Y2d\"^3] N]3^ ]3"
liveimage_srv/CImg.h:      "] N]3] N]3] \\.[!^3] M\\4\\ J\\4\\ K\\4\\ L\\4\\ 5Z 2Z #Y.Y MZ8_ HZ8_ HZ8^ FZ8^ HZ8_ HZ8_-Z8e-Q)\\ &\\-Q G\\-Q "
liveimage_srv/CImg.h:      "G\\-Q G\\-Q 5Y  Y  NX  Y 2[9\\ FX0X F[9[ D\\9[ E[8[ E[9[ D\\9[ 4\\ 3[9[ EZ9^ FZ9^ FZ9^ F[9^ 9b 8^9[ 8b     &[2["
liveimage_srv/CImg.h:      "-Z   )X@X :W@TF[ BW7X?X3]6e   1X  IY    GX  NZ    GZ (X ([=[ .Z 6[ $S1^ &Z BS3^ @\\<\\ 8Z 0]9] FR6] .Z \"[  8^ "
liveimage_srv/CImg.h:      "Y/Z LZ:` H[:` H[:_ FZ:` GZ:` GZ:`-[:YN\\0S(\\4Q C\\0S F\\0S F\\0S F\\0S 5Y  Y  NX  Y 1[:[ EX0X F\\;\\ C\\;[ C[:"
liveimage_srv/CImg.h:      "@[    @T  JT  _ %] 7X.Y D^D^ BZ6Y 6b 9_                   *];X   -Z   )X@X :ZCTH] CX7YAX1^:h   2Y  JY    GX  NZ"
liveimage_srv/CImg.h:      "    GZ (X (\\?\\ .Z 7\\ $W7_ %Z BV8` ?\\>] 9[ /];] ET9] -Z \"[  5[   [  8Z DX;jLb*Z$Z#Z7a E`7\\'Z9f FZ  MZ &`4^"
liveimage_srv/CImg.h:      "        -_?Z   -Z   )W?X :^GTK_ CX5XAX0_>k   3Y  JX    FX  NZ    GZ )Y ']C] ?} I~S IZ=b %Z BZ>a =]B^ 8Z ._?^ DX"
liveimage_srv/CImg.h:      "   ?U  KT  M\\ #[ 6X.Y Bu AY5Z 7a 6f                   2aE]   -Z   )W?W 9~ BW4YCY/bFp   3X  KY    FX  NZ    GZ "
liveimage_srv/CImg.h:      ")X %^G^ >} I~S I~ $Z B| ;^F_ 7Z -aEa Dv +Z \"[  0V   U  2Z CX9dI^'Z\"Z$~S AfGd'~U C~S FZ $gGg&Z(Z :Z \"Z 4Z0] H"
liveimage_srv/CImg.h:      "Z 5dGd   )X    Jd   \"e    KZ -`MUKY H~U IU&U 6Z  X  AY   5Z7Z          LZ7Z     ;~d       3cFk 8WEW           "
liveimage_srv/CImg.h:      "      dLd CdMd BdLd CdLd DeMd 2X !`     %X  =Y    ?U  LV  MZ !Y 5X.Y As AZ4Y 6` 5~]                  )x   -Z   "
liveimage_srv/CImg.h:      "*X@X 9} BX3YFZ-{L]   4Y  LY    FX  NZ    GZ )X $t >} I~S I} #Z B{ :v 7[ ,{ Cu *Z \"[  -S   S  0Z BW8aG[%[\"Z$~R"
liveimage_srv/CImg.h:      "Y FYNr ;u AqMY B{ 7Y -oLY GY1Y 5Y  NX 0X7\\ 4Y FY3Y2Y+Y1Y Cv BYNr ArMX ;Y *y 2j >qMY 8a 8^9^ I[6Z 5^ 6~P 2Y  X "
liveimage_srv/CImg.h:      " (v   ,Z   *X@X 9| AW1[K[+yJ]   5Y  LX    EX  NZ    GZ )X #r =} I~S I| \"Z Bz 8t 6Z *y Bt )Z \"[  *P   P  -Z BX"
liveimage_srv/CImg.h:      "DX KV*W0o-W KW%[ 1Z Z,Z!Z+Z Z,Z!Z+Z Z,Z!Z;Z-~T'~P M~T J~T I~S I~S 7Z !Z !Z \"Z :~R GY.` K| B| C{ B{ B{ FS\"S$YM"
liveimage_srv/CImg.h:      "{ Bz @z B{ B{ 1Z 2Z #YIq GqLY EqLY EqLX CqMY ErMY EqLY*sF{$u ?{ B{ B{ B{ 5Y  Y  NX  Y -t AX0X Bu ;u <t <u ;u   "
liveimage_srv/CImg.h:      "    5Z AX  HZ Z%~ 9|$~P >~S FZ  ~P\"Z(Z :Z \"Z 4Z-] K~Q)Y JY(Y.` Jy AZ  x EZ)Z#~P 0Y /x 3_ =_0_%Z([ ;Z =~a AX  "
liveimage_srv/CImg.h:      "JV+X0o.X KW%Z 0Z Z-Z NZ,Z Z-[ Z,Z Z-[ Z<Z-~T&| K~T J~T I~S I~S 7Z !Z !Z \"Z :~P EY.` Iy @y @y @y @y DQ Q$YKy @x"
liveimage_srv/CImg.h:      " !Y        InKY FYKl 5r ?lJY >w 7Y )hIY GY1Y 5Y  NX 0X4\\ 7Y FY3Y2Y+Y1Y @p ?YKl ;lJX ;Y *v -h ;kJY 7_ 7]7\\ J[2"
liveimage_srv/CImg.h:      "JV+W/o/X JW&Z 0[ Z-Z NZ-[ [.Z NZ,Z NZ.Z NZ=Z,~T$x I~T J~T I~S I~S 7Z !Z !Z \"Z :| BY-_ Hv <v =v =u =v   BXHu =v"
liveimage_srv/CImg.h:      " 9lJX AlJX AlJX AlJY 5[ 5YKl /\\      Hp 8q 7p 7p 8q -X  N]      NP  9V    ?Y  X  KS  IS 2X.Y <h <Z2Y 6^ -~V   "
liveimage_srv/CImg.h:      "               $n   (Z   +X@X 1o =W-f$pB]   6X  NX    DX  Z    FZ *X  Nk 9} I~S Iw  LZ Bv 0m 4Z %q >p %Z \"Z   "
liveimage_srv/CImg.h:      "     4Z @X  JZ MZ&{ 3u z 9~S FZ  Lx MZ(Z :Z \"Z 4Z+] M~Q)Y JY(Y-_ Fr >Z  Lr BZ(Z!y -Y -s /] <^.]&[&[ <Z =~a AX "
liveimage_srv/CImg.h:      "   EW IV,X/o/W IW&Z 0Z MZ/[ NZ-Z MZ.Z N[.Z MZ.Z MZ>Z,~T\"t G~T J~T I~S I~S 7Z !Z !Z \"Z :y ?Y-_ Fr 8r 9r :s :r "
liveimage_srv/CImg.h:      "  AXEr :r 8r :s :s -Z 2Z #YIn AkIY BkIY BkIX @jIY BkIY BkIY'l=t Mq :t ;t ;t ;t 3Y  Y  NX  Y *m =X0X >m 3m 5n 5m"
liveimage_srv/CImg.h:      " 3m   6XLm 7iHX @iHX @jIX @jIY 5[ 5YJj -Z      El 3k 2l 3l 4l *X  N\\        5U    ?Y  Y  KR  HQ 1X.Y 9b 9Y1Z 7"
liveimage_srv/CImg.h:      "] )~S                  \"j   &Z   +X@X -h ;X+c!l?\\   6X  Y    DX  Z    FZ +X  Kh 8} I~S Fr  JZ As ,i 3[ $n ;m "
liveimage_srv/CImg.h:      "#Z \"Y        3Z ?X  KZ MZ&x -p Mu 4~S FZ  Js JZ(Z :Z \"Z 4Z*] N~Q)Y JY(Y-_ Dn <Z  Jn @Z([ Nt +Y +o ,\\ ;].]&Z$"
liveimage_srv/CImg.h:      "<i 0j 1j 1j 1j   5XIi 3fGX >fGX >fGX >fGY 4Y 4YHf +Z      Bg /g .g -g /g (X  M[        5T    ?Z !Z  JP   'X.Y 5"
liveimage_srv/CImg.h:      " $k  ` 7cFY 6] 5[5Z KZ-[ 8Y 3~P 2Y  X  Y        ;b=X NYJe 0` $e +l BY1Y 4Y 7Y*Y LYIaE[ b@a >k 9Y6_ Ah ;YFc 0e  "
liveimage_srv/CImg.h:      "FZ 2a D~i$~T FZ 3oDo @Z :Z(Z :Z )i    LX    CV    CW    DZ #h D~U   *Z  X -R9Z   #[          *[     *~d       3"
liveimage_srv/CImg.h:      "YIaE\\ 8WEW            GX HV-W-o0W HW'Z 0Z L[0Z LZ/[ LZ0Z LZ/[ LZ0Z LZ?Z+~T Lj B~T J~T I~S I~S 7Z !Z !Z \"Z :o "
liveimage_srv/CImg.h:      "5Y,^ Ai /h 0i 0i 0i   >W?i 1j 0j 1j 1i (Z 2Z #YGh 9cEY ?dEY ?dEX =dFY >dFY >cEY#d5j Ch 1j 1j 1j 1j -Y  Y  NX  Y"
liveimage_srv/CImg.h:      " &e 9X0X :e ,f -f -e ,f   4XFe 0cEX <bEX <bEX <bEY 4Y 4YFb )Z      ?` (a '` '` (a %X          'T               "
liveimage_srv/CImg.h:      "X J\\;] 9e  A^ =` 7YC] *_    G[                 >a             NU    CZ  N`        9X -T<[                     "
liveimage_srv/CImg.h:      "    9Y #X      :Y      EX  ?Q      8R    ?R  @Q    @R  MQ    =Y          DY       @R        -Q      <Z         "
liveimage_srv/CImg.h:      "  @Q        *Z    DY  X  Y          ;Y  <P  AQ  CQ  ;Y 4Y   *YAQ8P @Q0Q -Y  8X 7Y 3Y=Q  LQ                     "
liveimage_srv/CImg.h:      " JQ                 4Z  IU        3X -W@[                              KYAQ8P 1WEW   $U        IV  MW  LW  FZ  "
liveimage_srv/CImg.h:      "X 3Y                                          CZ  IU        3X -\\I_                              KY  8WEW   $V"
liveimage_srv/CImg.h:      "         CZ  IU        3X -q                              JY  8WEW   #V              &Z                  NV    "
liveimage_srv/CImg.h:      ":Y         8Y 4Y   *Y    1Y    EX 3Y                                          CZ  IU        3X -p              "
liveimage_srv/CImg.h:      "                                     CZ  IU        3X -o                              HY  8WEW   \"V           "
liveimage_srv/CImg.h:      "U        3X -n                              GY  8WEW   \"V              '[3Q                 <V                "
liveimage_srv/CImg.h:      "                      V          5b?c                     A[               -\\                     ?e   !f     "
liveimage_srv/CImg.h:      "   HZ /Y  AZ                 DWIX                                                                LT        &X -"
liveimage_srv/CImg.h:      "                     CZ  IU        3X                                5Y      -PDX              %v              "
liveimage_srv/CImg.h:      "                                          -_Me     %b            .Y  'X                /e    9c /X 0c          "
liveimage_srv/CImg.h:      "               5Y      -d              $u                 Je                                                   "
liveimage_srv/CImg.h:      "                   ?d                                               $d -Y  Ne                 Ad               "
liveimage_srv/CImg.h:      " 5s                     Cd                                                               ,v     %b            -"
liveimage_srv/CImg.h:      "            CZ  IU        3X                                5Y      -d              #t                 Jd      "
liveimage_srv/CImg.h:      "  %e -Y  Nd                 @c                                                                                 "
liveimage_srv/CImg.h:      "                     +u     $b            -Y  'X                0d    2^ /X 0_          1Y         8Y 4Y   *Y  "
liveimage_srv/CImg.h:      "-c              !q                 Hd                                                                      >c  "
liveimage_srv/CImg.h:      "X                                5Y      -c               Nm                 Fc                                "
liveimage_srv/CImg.h:      "                               CZ          &W                                5Y      -b               Lj       "
liveimage_srv/CImg.h:      "     3Y      -`               He                 A`                                                            "
liveimage_srv/CImg.h:    // Lock/unlock mutex for CImg multi-thread programming.
liveimage_srv/CImg.h:       \param format C-string containing the format of the message, as with <tt>std::printf()</tt>.
liveimage_srv/CImg.h:       \param command C-string containing the command line to execute.
liveimage_srv/CImg.h:       \return Status value of the executed command, whose meaning is OS-dependent.
liveimage_srv/CImg.h:       on Windows-based systems.
liveimage_srv/CImg.h:      return -1;
liveimage_srv/CImg.h:      } else return -1;
liveimage_srv/CImg.h:        return -1;
liveimage_srv/CImg.h:            const unsigned short val = *(--ptr);
liveimage_srv/CImg.h:            const unsigned int val = *(--ptr);
liveimage_srv/CImg.h:            const cimg_uint64 val = *(--ptr);
liveimage_srv/CImg.h:            unsigned char *pb = (unsigned char*)(--ptr), *pe = pb + sizeof(T);
liveimage_srv/CImg.h:            for (int i = 0; i<(int)sizeof(T)/2; ++i) swap(*(pb++),*(--pe));
liveimage_srv/CImg.h:      // use memcpy instead of assignment to avoid undesired optimizations by C++-compiler.
liveimage_srv/CImg.h:      const unsigned int v = u|(3U<<(8*sizeof(unsigned int)-2)); // set sign & exponent bit to 1
liveimage_srv/CImg.h:      // use memcpy instead of simple assignment to avoid undesired optimizations by C++-compiler.
liveimage_srv/CImg.h:      const unsigned int time_diff = (unsigned int)(*p_timer + milliseconds - current_time);
liveimage_srv/CImg.h:    // Custom random number generator (allow re-entrance).
liveimage_srv/CImg.h:      return val_min + (val_max - val_min)*val;
liveimage_srv/CImg.h:        const double x2 = cimg::rand(-1,1,p_rng);
liveimage_srv/CImg.h:        x1 = cimg::rand(-1,1,p_rng);
liveimage_srv/CImg.h:      return x1*std::sqrt((-2*std::log(w))/w);
liveimage_srv/CImg.h:      if (z<=1.e-10) return 0;
liveimage_srv/CImg.h:      const double y = std::exp(-z);
liveimage_srv/CImg.h:      return k - 1;
liveimage_srv/CImg.h:    //! Bitwise-rotate value on the left.
liveimage_srv/CImg.h:      return n?(T)((a<<n)|(a>>((sizeof(T)<<3) - n))):a;
liveimage_srv/CImg.h:    //! Bitwise-rotate value on the right.
liveimage_srv/CImg.h:      return n?(T)((a>>n)|(a<<((sizeof(T)<<3) - n))):a;
liveimage_srv/CImg.h:      return a>=0?a:-a;
liveimage_srv/CImg.h:      return std::log(x + std::sqrt(x*x - 1));
liveimage_srv/CImg.h:      return 0.5*std::log((1. + x)/(1. - x));
liveimage_srv/CImg.h:    //! Return base-2 logarithm of a value.
liveimage_srv/CImg.h:        sgn = val<0?-1:1,
liveimage_srv/CImg.h:        x = (1 - val)*(1 + val),
liveimage_srv/CImg.h:      return sgn*std::sqrt(-tt1 + std::sqrt(tt1*tt1 - tt2));
liveimage_srv/CImg.h:      return x>=0?std::pow((double)x,1./3):-std::pow(-(double)x,1./3);
liveimage_srv/CImg.h:      return (T)(cimg::type<T>::is_nan(x)?0:x<0?-1:x>0);
liveimage_srv/CImg.h:       \note This modulo function accepts negative and floating-points modulo numbers, as well as variables of any type.
liveimage_srv/CImg.h:      if (cimg::type<double>::is_finite(dx)) return (T)(dx - dm * std::floor(dx / dm));
liveimage_srv/CImg.h:    //! Return the min-mod of two values.
liveimage_srv/CImg.h:       - <i>minmod(\p a,\p b) = min(\p a,\p b)</i>, if \p a and \p b have the same sign.
liveimage_srv/CImg.h:       - <i>minmod(\p a,\p b) = 0</i>, if \p a and \p b have different signs.
liveimage_srv/CImg.h:       \param rounding_type Type of rounding operation (\c 0 = nearest, \c -1 = backward, \c 1 = forward).
liveimage_srv/CImg.h:      const double sx = (double)x/y, floor = std::floor(sx), delta =  sx - floor;
liveimage_srv/CImg.h:      for (int i = n; i>=n - k + 1; --i) res*=i;
liveimage_srv/CImg.h:      return (char)((x<'A'||x>'Z')?x:x - 'A' + 'a');
liveimage_srv/CImg.h:      return (double)((x<'A'||x>'Z')?x:x - 'A' + 'a');
liveimage_srv/CImg.h:    //! Convert C-string to lower case.
liveimage_srv/CImg.h:      return (char)((x<'a'||x>'z')?x:x - 'a' + 'A');
liveimage_srv/CImg.h:      return (double)((x<'a'||x>'z')?x:x - 'a' + 'A');
liveimage_srv/CImg.h:    //! Convert C-string to upper case.
liveimage_srv/CImg.h:    //! Return \c true if input character is blank (space, tab, or non-printable character).
liveimage_srv/CImg.h:    //! Read value in a C-string.
liveimage_srv/CImg.h:       \param str C-string containing the float value to read.
liveimage_srv/CImg.h:       \note Same as <tt>std::atof()</tt> extended to manage the retrieval of fractions from C-strings,
liveimage_srv/CImg.h:    //! Compare the first \p l characters of two C-strings, ignoring the case.
liveimage_srv/CImg.h:       \param str1 C-string.
liveimage_srv/CImg.h:       \param str2 C-string.
liveimage_srv/CImg.h:       \note This function has to be defined since it is not provided by all C++-compilers (not ANSI).
liveimage_srv/CImg.h:      if (!str1) return str2?-1:0;
liveimage_srv/CImg.h:      int k, diff = 0; for (k = 0; k<l && !(diff = lowercase(*nstr1) - lowercase(*nstr2)); ++k) { ++nstr1; ++nstr2; }
liveimage_srv/CImg.h:    //! Compare two C-strings, ignoring the case.
liveimage_srv/CImg.h:       \param str1 C-string.
liveimage_srv/CImg.h:       \param str2 C-string.
liveimage_srv/CImg.h:       \note This function has to be defined since it is not provided by all C++-compilers (not ANSI).
liveimage_srv/CImg.h:      if (!str1) return str2?-1:0;
liveimage_srv/CImg.h:       \param str C-string.
liveimage_srv/CImg.h:      if (is_ending) std::strcpy(str + nl - 5,"(...)");
liveimage_srv/CImg.h:        const unsigned int ll = (nl - 5)/2 + 1 - (nl%2), lr = nl - ll - 5;
liveimage_srv/CImg.h:        std::memmove(str + ll + 5,str + ls - lr,lr);
liveimage_srv/CImg.h:       \param str C-string.
liveimage_srv/CImg.h:       \param res output C-string.
liveimage_srv/CImg.h:        std::strncpy(res,str,nl - 5);
liveimage_srv/CImg.h:        std::strcpy(res + nl -5,"(...)");
liveimage_srv/CImg.h:        const unsigned int ll = (nl - 5)/2 + 1 - (nl%2), lr = nl - ll - 5;
liveimage_srv/CImg.h:        std::strncpy(res + ll + 5,str + ls - lr,lr);
liveimage_srv/CImg.h:    //! Remove delimiters on the start and/or end of a C-string.
liveimage_srv/CImg.h:       \param[in,out] str C-string to work with (modified at output).
liveimage_srv/CImg.h:      if (is_symmetric) for (p = 0, q = l - 1; p<q && str[p]==delimiter && str[q]==delimiter; ) {
liveimage_srv/CImg.h:          --q; ++p; if (!is_iterative) break;
liveimage_srv/CImg.h:        for (q = l - 1; q>p && str[q]==delimiter; ) { --q; if (!is_iterative) break; }
liveimage_srv/CImg.h:      const int n = q - p + 1;
liveimage_srv/CImg.h:    //! Remove white spaces on the start and/or end of a C-string.
liveimage_srv/CImg.h:      if (is_symmetric) for (p = 0, q = l - 1; p<q && is_blank(str[p]) && is_blank(str[q]); ) {
liveimage_srv/CImg.h:          --q; ++p; if (!is_iterative) break;
liveimage_srv/CImg.h:        for (q = l - 1; q>p && is_blank(str[q]); ) { --q; if (!is_iterative) break; }
liveimage_srv/CImg.h:      const int n = q - p + 1;
liveimage_srv/CImg.h:       \param[in,out] str C-string to work with (modified at output).
liveimage_srv/CImg.h:    //! Replace escape sequences in C-strings by character values.
liveimage_srv/CImg.h:       \param[in,out] str C-string to work with (modified at output).
liveimage_srv/CImg.h:            val = (unsigned char)(*(ns++) - '0');
liveimage_srv/CImg.h:            if (*ns>='0' && *ns<='7') (val<<=3)|=*(ns++) - '0';
liveimage_srv/CImg.h:            if (*ns>='0' && *ns<='7') (val<<=3)|=*(ns++) - '0';
liveimage_srv/CImg.h:              val = (unsigned char)(c<='9'?c - '0':c - 'a' + 10);
liveimage_srv/CImg.h:                (val<<=4)|=(c<='9'?c - '0':c - 'a' + 10);
liveimage_srv/CImg.h:          case 'u' : { // UTF-8 BMP
liveimage_srv/CImg.h:              c1 = (c1<='9'?c1 - '0':c1 - 'a' + 10);
liveimage_srv/CImg.h:              c2 = (c2<='9'?c2 - '0':c2 - 'a' + 10);
liveimage_srv/CImg.h:              c3 = (c3<='9'?c3 - '0':c3 - 'a' + 10);
liveimage_srv/CImg.h:              c4 = (c4<='9'?c4 - '0':c4 - 'a' + 10);
liveimage_srv/CImg.h:          case 'U' : { // UTF-8 astral planes
liveimage_srv/CImg.h:              c1 = (c1<='9'?c1 - '0':c1 - 'a' + 10);
liveimage_srv/CImg.h:              c2 = (c2<='9'?c2 - '0':c2 - 'a' + 10);
liveimage_srv/CImg.h:              c3 = (c3<='9'?c3 - '0':c3 - 'a' + 10);
liveimage_srv/CImg.h:              c4 = (c4<='9'?c4 - '0':c4 - 'a' + 10);
liveimage_srv/CImg.h:              c5 = (c5<='9'?c5 - '0':c5 - 'a' + 10);
liveimage_srv/CImg.h:              c6 = (c6<='9'?c6 - '0':c6 - 'a' + 10);
liveimage_srv/CImg.h:              c7 = (c7<='9'?c7 - '0':c7 - 'a' + 10);
liveimage_srv/CImg.h:              c8 = (c8<='9'?c8 - '0':c8 - 'a' + 10);
liveimage_srv/CImg.h:    // Convert filename as a Windows-style filename (short path name).
liveimage_srv/CImg.h:       \param mode C-string describing the opening mode.
liveimage_srv/CImg.h:      if (*path=='-' && (!path[1] || path[1]=='.')) {
liveimage_srv/CImg.h:          if (setmode(_fileno(res),0x8000)==-1) res = 0;
liveimage_srv/CImg.h:          if (_setmode(_fileno(res),0x8000)==-1) res = 0;
liveimage_srv/CImg.h:    // Get the file or directory attributes with support for UTF-8 paths (Windows only).
liveimage_srv/CImg.h:       \return File size or '-1' if file does not exist.
liveimage_srv/CImg.h:      if (!file) return (cimg_int64)-1;
liveimage_srv/CImg.h:    //! Get last write time of a given file or directory (multiple-attributes version).
liveimage_srv/CImg.h:                      Replaced by read attributes after return (or -1 if an error occurred).
liveimage_srv/CImg.h:#define _cimg_fdate_err() for (unsigned int i = 0; i<nb_attr; ++i) attr[i] = (T)-1
liveimage_srv/CImg.h:      int res = -1;
liveimage_srv/CImg.h:      if (!path || !*path) { _cimg_fdate_err(); return -1; }
liveimage_srv/CImg.h:                        attr[i]==6?ft.wSecond:-1);
liveimage_srv/CImg.h:                      attr[i]==6?ft.tm_sec:-1);
liveimage_srv/CImg.h:    //! Get last write time of a given file or directory (single-attribute version).
liveimage_srv/CImg.h:       \return Specified attribute or -1 if an error occurred.
liveimage_srv/CImg.h:    //! Get current local time (multiple-attributes version).
liveimage_srv/CImg.h:                           Replaced by read attributes after return (or -1 if an error occurred).
liveimage_srv/CImg.h:      int res = -1;
liveimage_srv/CImg.h:                    attr[i]==7?st.wMilliseconds:-1);
liveimage_srv/CImg.h:        res = (int)(attr[i]==0?st->tm_year + 1900:
liveimage_srv/CImg.h:                    attr[i]==1?st->tm_mon + 1:
liveimage_srv/CImg.h:                    attr[i]==2?st->tm_mday:
liveimage_srv/CImg.h:                    attr[i]==3?st->tm_wday:
liveimage_srv/CImg.h:                    attr[i]==4?st->tm_hour:
liveimage_srv/CImg.h:                    attr[i]==5?st->tm_min:
liveimage_srv/CImg.h:                    attr[i]==6?st->tm_sec:
liveimage_srv/CImg.h:                    attr[i]==7?_st.tv_usec/1000:-1);
liveimage_srv/CImg.h:    //! Get current local time (single-attribute version).
liveimage_srv/CImg.h:       \return Specified attribute or -1 if an error occurred.
liveimage_srv/CImg.h:    //! Split filename into two C-strings \c body and \c extension.
liveimage_srv/CImg.h:      const unsigned int l = (unsigned int)(p - filename);
liveimage_srv/CImg.h:        to_read-=l_al_read;
liveimage_srv/CImg.h:        to_write-=l_al_write;
liveimage_srv/CImg.h:       \param filename Filename, as a C-string (can be \c 0 if \c file is set).
liveimage_srv/CImg.h:        visu = cimg::option("-h",argc,argv,(char*)0,(char*)0,false)!=0;
liveimage_srv/CImg.h:        visu |= cimg::option("-help",argc,argv,(char*)0,(char*)0,false)!=0;
liveimage_srv/CImg.h:        visu |= cimg::option("--help",argc,argv,(char*)0,(char*)0,false)!=0;
liveimage_srv/CImg.h:          res = (k++==argc?_default:(k==argc?argv[--k]:argv[k]));
liveimage_srv/CImg.h:        if (visu && usage) std::fprintf(cimg::output(),"    %s%-16s%s %-24s %s%s%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Operating System:         %s%-13s%s %s('cimg_OS'=%d)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Verbosity mode:           %s%-13s%s %s('cimg_verbosity'=%d)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Stricts warnings:         %s%-13s%s %s('cimg_strict_warnings' %s)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Support for C++11:        %s%-13s%s %s('cimg_use_cpp11'=%d)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Using VT100 messages:     %s%-13s%s %s('cimg_use_vt100' %s)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Display type:             %s%-13s%s %s('cimg_display'=%d)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Using XShm for X11:       %s%-13s%s %s('cimg_use_xshm' %s)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Using XRand for X11:      %s%-13s%s %s('cimg_use_xrandr' %s)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Using OpenMP:             %s%-13s%s %s('cimg_use_openmp' %s)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Using PNG library:        %s%-13s%s %s('cimg_use_png' %s)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Using JPEG library:       %s%-13s%s %s('cimg_use_jpeg' %s)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Using TIFF library:       %s%-13s%s %s('cimg_use_tiff' %s)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Using Magick++ library:   %s%-13s%s %s('cimg_use_magick' %s)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Using FFTW3 library:      %s%-13s%s %s('cimg_use_fftw3' %s)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Using LAPACK library:     %s%-13s%s %s('cimg_use_lapack' %s)%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Path of 'curl':           %s%-13s%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Path of 'dcraw':          %s%-13s%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Path of 'ffmpeg':         %s%-13s%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Path of 'graphicsmagick': %s%-13s%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Path of 'gunzip':         %s%-13s%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Path of 'gzip':           %s%-13s%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Path of 'imagemagick':    %s%-13s%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Path of 'medcon':         %s%-13s%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Temporary path:           %s%-13s%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Path of 'wget':           %s%-13s%s\n",
liveimage_srv/CImg.h:      std::fprintf(cimg::output(),"  > Path of 'powershell_path':           %s%-13s%s\n",
liveimage_srv/CImg.h:  /*------------------------------------------------
liveimage_srv/CImg.h:   -------------------------------------------------*/
liveimage_srv/CImg.h:  inline CImg<typename cimg::superset<T,typ>::type> operator-(const typ val, const CImg<T>& img) { \
liveimage_srv/CImg.h:    return CImg<Tt>(img._width,img._height,img._depth,img._spectrum,val)-=img; \
liveimage_srv/CImg.h:  inline CImg<_cimg_Tfloat> operator-(const char *const expression, const CImg<T>& img) {
liveimage_srv/CImg.h:    return CImg<_cimg_Tfloat>(img,false).fill(expression,true)-=img;
liveimage_srv/CImg.h:  /*-----------------------------------
liveimage_srv/CImg.h:   ----------------------------------*/
liveimage_srv/CImg.h:     CImgDisplay methods rely on a low-level graphic library to perform: it can be either \b X-Window
liveimage_srv/CImg.h:     (X11, for Unix-based systems) or \b GDI32 (for Windows-based systems).
liveimage_srv/CImg.h:     - 0: Disable display capabilities.
liveimage_srv/CImg.h:     - 1: Use \b X-Window (X11) library.
liveimage_srv/CImg.h:     - 2: Use \b GDI32 library.
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:    //--------------------------------------------------------
liveimage_srv/CImg.h:    //--------------------------------------------------------
liveimage_srv/CImg.h:      _mouse_x(-1),_mouse_y(-1),_wheel(0),
liveimage_srv/CImg.h:        (<tt>0</tt>=none, <tt>1</tt>=always, <tt>2</tt>=once, <tt>3</tt>=pixel type-dependent, see normalization()).
liveimage_srv/CImg.h:      _mouse_x(-1),_mouse_y(-1),_wheel(0),
liveimage_srv/CImg.h:        (<tt>0</tt>=none, <tt>1</tt>=always, <tt>2</tt>=once, <tt>3</tt>=pixel type-dependent, see normalization()).
liveimage_srv/CImg.h:      _mouse_x(-1),_mouse_y(-1),_wheel(0),
liveimage_srv/CImg.h:        (<tt>0</tt>=none, <tt>1</tt>=always, <tt>2</tt>=once, <tt>3</tt>=pixel type-dependent, see normalization()).
liveimage_srv/CImg.h:        \note All images of the list, appended along the X-axis, are initially displayed on the associated window.
liveimage_srv/CImg.h:      _mouse_x(-1),_mouse_y(-1),_wheel(0),
liveimage_srv/CImg.h:      _mouse_x(-1),_mouse_y(-1),_wheel(0),
liveimage_srv/CImg.h:    //! Destructor - Empty constructor \inplace.
liveimage_srv/CImg.h:#define cimg_fitscreen(dx,dy,dz) CImgDisplay::_fitscreen(dx,dy,dz,-25,-85,false), \
liveimage_srv/CImg.h:                                 CImgDisplay::_fitscreen(dx,dy,dz,-25,-85,true)
liveimage_srv/CImg.h:        mw = dmin<0?cimg::round(u*-dmin/100.f):(float)dmin,
liveimage_srv/CImg.h:        mh = dmin<0?cimg::round(v*-dmin/100.f):(float)dmin,
liveimage_srv/CImg.h:        Mw = dmax<0?cimg::round(u*-dmax/100.f):(float)dmax,
liveimage_srv/CImg.h:        Mh = dmax<0?cimg::round(v*-dmax/100.f):(float)dmax;
liveimage_srv/CImg.h:    //------------------------------------------
liveimage_srv/CImg.h:    //------------------------------------------
liveimage_srv/CImg.h:    //------------------------------------------
liveimage_srv/CImg.h:    //------------------------------------------
liveimage_srv/CImg.h:       - When a user physically closes the associated window, the display is set to closed.
liveimage_srv/CImg.h:       - A closed display is not destroyed. Its associated window can be show again on the screen using show().
liveimage_srv/CImg.h:       \note Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
liveimage_srv/CImg.h:       \param keycode C-string containing the keycode label of the key to test.
liveimage_srv/CImg.h:       \note Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
liveimage_srv/CImg.h:          *const ps_end = keycodes_sequence + length - 1,
liveimage_srv/CImg.h:          *const pk_end = (unsigned int*)_keys + 1 + 128 - length,
liveimage_srv/CImg.h:            for (unsigned int i = 1; i<length; ++i) res = (*(--ps)==*(pk2++));
liveimage_srv/CImg.h:              if (remove_sequence) std::memset((void*)(pk - 1),0,sizeof(unsigned int)*length);
liveimage_srv/CImg.h:    //------------------------------------------
liveimage_srv/CImg.h:    //------------------------------------------
liveimage_srv/CImg.h:    //! Return width of the screen (current resolution along the X-axis).
liveimage_srv/CImg.h:    //! Return height of the screen (current resolution along the Y-axis).
liveimage_srv/CImg.h:       - \c 0: Value normalization is disabled. It is then assumed that all input data to be displayed by the
liveimage_srv/CImg.h:       - \c 1: Value normalization is always performed (this is the default behavior).
liveimage_srv/CImg.h:       (e.g. float-valued images).
liveimage_srv/CImg.h:       - \c 2: Value normalization is performed once (on the first image display), then the same normalization
liveimage_srv/CImg.h:       - \c 3: Value normalization depends on the pixel type of the data to display. For integer pixel types,
liveimage_srv/CImg.h:       For float-valued pixel types, the normalization is done regarding the minimum/maximum value of the image
liveimage_srv/CImg.h:    //! Return title of the associated window as a C-string.
liveimage_srv/CImg.h:    //! Return X-coordinate of the associated window.
liveimage_srv/CImg.h:       \note The returned coordinate corresponds to the location of the upper-left corner of the associated window.
liveimage_srv/CImg.h:    //! Return Y-coordinate of the associated window.
liveimage_srv/CImg.h:       \note The returned coordinate corresponds to the location of the upper-left corner of the associated window.
liveimage_srv/CImg.h:    //! Return X-coordinate of the mouse pointer.
liveimage_srv/CImg.h:       - If the mouse pointer is outside window area, \c -1 is returned.
liveimage_srv/CImg.h:       - Otherwise, the returned value is in the range [0,width()-1].
liveimage_srv/CImg.h:    //! Return Y-coordinate of the mouse pointer.
liveimage_srv/CImg.h:       - If the mouse pointer is outside window area, \c -1 is returned.
liveimage_srv/CImg.h:       - Otherwise, the returned value is in the range [0,height()-1].
liveimage_srv/CImg.h:       - bit \c 0 (value \c 0x1): State of the left mouse button.
liveimage_srv/CImg.h:       - bit \c 1 (value \c 0x2): State of the right mouse button.
liveimage_srv/CImg.h:       - bit \c 2 (value \c 0x4): State of the middle mouse button.
liveimage_srv/CImg.h:       - The returned value can be positive or negative depending on whether the mouse wheel has been scrolled
liveimage_srv/CImg.h:       - Scrolling the wheel forward add \c 1 to the wheel value.
liveimage_srv/CImg.h:       - Scrolling the wheel backward subtract \c 1 to the wheel value.
liveimage_srv/CImg.h:       - The returned value cumulates the number of forward of backward scrolls since the creation of the display,
liveimage_srv/CImg.h:       - Each CImgDisplay stores a history of the pressed keys in a buffer of size \c 128. When a new key is pressed,
liveimage_srv/CImg.h:       - Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
liveimage_srv/CImg.h:       - Each CImgDisplay stores a history of the released keys in a buffer of size \c 128. When a new key is released,
liveimage_srv/CImg.h:       - Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
liveimage_srv/CImg.h:       \note Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
liveimage_srv/CImg.h:      const float delta = (float)((cimg::time() - _fps_timer)/1000.f);
liveimage_srv/CImg.h:        x1 = x0 + window_width() - 1,
liveimage_srv/CImg.h:        y1 = y0 + window_height() - 1,
liveimage_srv/CImg.h:        move(std::max(0,std::min(x0,sw - x1 + x0)),
liveimage_srv/CImg.h:             std::max(0,std::min(y0,sh - y1 + y0)));
liveimage_srv/CImg.h:    //---------------------------------------
liveimage_srv/CImg.h:    //---------------------------------------
liveimage_srv/CImg.h:       (\c 0 for upper-left, \c 0.5 for centering and \c 1 for lower-right).
liveimage_srv/CImg.h:        img._get_select(*this,_normalization,(img._width - 1)/2,(img._height - 1)/2,
liveimage_srv/CImg.h:                        (img._depth - 1)/2).move_to(visu[l]);
liveimage_srv/CImg.h:      cimglist_for(list,l) if (visu[l]._spectrum<dims) visu[l].resize(-100,-100,-100,dims,1);
liveimage_srv/CImg.h:       - Force the associated window of a display to be visible on the screen, even if it has been closed before.
liveimage_srv/CImg.h:       - Using show() on a visible display does nothing.
liveimage_srv/CImg.h:       - A closed display only means the associated window is not visible anymore. This does not mean the display has
liveimage_srv/CImg.h:       - Using close() on a closed display does nothing.
liveimage_srv/CImg.h:       \param pos_x X-coordinate of the new window location.
liveimage_srv/CImg.h:       \param pos_y Y-coordinate of the new window location.
liveimage_srv/CImg.h:       - Calling this method ensures that width() and window_width() become equal, as well as height() and
liveimage_srv/CImg.h:       - The associated window is also resized to specified dimensions.
liveimage_srv/CImg.h:       - Calling this method ensures that width() and <tt>img.width()</tt> become equal, as well as height() and
liveimage_srv/CImg.h:       - The associated window is also resized to specified dimensions.
liveimage_srv/CImg.h:       - Calling this method ensures that width() and <tt>disp.width()</tt> become equal, as well as height() and
liveimage_srv/CImg.h:       - The associated window is also resized to specified dimensions.
liveimage_srv/CImg.h:          *(poff_x++) = curr - old;
liveimage_srv/CImg.h:          *(poff_y++) = ws*(curr - old);
liveimage_srv/CImg.h:        for ( ; !dy && y<hd; std::memcpy(ptrd,ptrd - wd,sizeof(t)*wd), ++y, ptrd+=wd, dy = *(poff_y++)) {}
liveimage_srv/CImg.h:       \param format C-string containing the format of the title, as with <tt>std::printf()</tt>.
liveimage_srv/CImg.h:       - When the fullscreen mode is enabled, the associated window fills the entire screen but the size of the
liveimage_srv/CImg.h:       - The screen resolution may be switched to fit the associated window size and ensure it appears the largest
liveimage_srv/CImg.h:       For X-Window (X11) users, the configuration flag \c cimg_use_xrandr has to be set to allow the screen
liveimage_srv/CImg.h:       \note Keycode constants are defined in the cimg namespace and are architecture-dependent. Use them to ensure
liveimage_srv/CImg.h:       - Convert image data representation into the internal display buffer (architecture-dependent structure).
liveimage_srv/CImg.h:       - The content of the associated window is not modified, until paint() is called.
liveimage_srv/CImg.h:       - Should not be used for common CImgDisplay uses, since display() is more useful.
liveimage_srv/CImg.h:       - Update the content of the associated window with the internal display buffer, e.g. after a render() call.
liveimage_srv/CImg.h:       - Should not be used for common CImgDisplay uses, since display() is more useful.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the upper left corner.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the upper left corner.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the lower right corner.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the lower right corner.
liveimage_srv/CImg.h:    // X11-based implementation
liveimage_srv/CImg.h:    //--------------------------
liveimage_srv/CImg.h:          _window_width = nw; _window_height = nh; _mouse_x = _mouse_y = -1;
liveimage_srv/CImg.h:          if (_mouse_x<0 || _mouse_y<0 || _mouse_x>=width() || _mouse_y>=height()) _mouse_x = _mouse_y = -1;
liveimage_srv/CImg.h:          if (_mouse_x<0 || _mouse_y<0 || _mouse_x>=width() || _mouse_y>=height()) _mouse_x = _mouse_y = -1;
liveimage_srv/CImg.h:          case 5 : set_wheel(-1); break;
liveimage_srv/CImg.h:        if (_mouse_x<0 || _mouse_y<0 || _mouse_x>=width() || _mouse_y>=height()) _mouse_x = _mouse_y = -1;
liveimage_srv/CImg.h:        _mouse_x = _mouse_y = -1; _is_event = true;
liveimage_srv/CImg.h:        if (_mouse_x<0 || _mouse_y<0 || _mouse_x>=width() || _mouse_y>=height()) _mouse_x = _mouse_y = -1;
liveimage_srv/CImg.h:            if (!cimg::X11_attr().wins[i]->_is_closed && event.xany.window==cimg::X11_attr().wins[i]->_window)
liveimage_srv/CImg.h:              cimg::X11_attr().wins[i]->_handle_events(&event);
liveimage_srv/CImg.h:          nshminfo->shmid = shmget(IPC_PRIVATE,ndimx*ndimy*sizeof(T),IPC_CREAT | 0777);
liveimage_srv/CImg.h:          if (nshminfo->shmid==-1) { XDestroyImage(nimage); delete nshminfo; return; }
liveimage_srv/CImg.h:            nshminfo->shmaddr = nimage->data = (char*)shmat(nshminfo->shmid,0,0);
liveimage_srv/CImg.h:            if (nshminfo->shmaddr==(char*)-1) {
liveimage_srv/CImg.h:              shmctl(nshminfo->shmid,IPC_RMID,0); XDestroyImage(nimage); delete nshminfo; return;
liveimage_srv/CImg.h:              nshminfo->readOnly = 0;
liveimage_srv/CImg.h:                shmdt(nshminfo->shmaddr);
liveimage_srv/CImg.h:                shmctl(nshminfo->shmid,IPC_RMID,0);
liveimage_srv/CImg.h:                T *const ndata = (T*)nimage->data;
liveimage_srv/CImg.h:                shmdt(_shminfo->shmaddr);
liveimage_srv/CImg.h:                shmctl(_shminfo->shmid,IPC_RMID,0);
liveimage_srv/CImg.h:        if (vinfo && vinfo->red_mask<vinfo->blue_mask) cimg::X11_attr().is_blue_first = true;
liveimage_srv/CImg.h:        _window = XCreateWindow(dpy,DefaultRootWindow(dpy),(sx - _width)/2,(sy - _height)/2,_width,_height,0,0,
liveimage_srv/CImg.h:      window_class->res_name = (char*)_window_class;
liveimage_srv/CImg.h:      window_class->res_class = (char*)_window_class;
liveimage_srv/CImg.h:          _shminfo->shmid = shmget(IPC_PRIVATE,_image->bytes_per_line*_image->height,IPC_CREAT|0777);
liveimage_srv/CImg.h:          if (_shminfo->shmid==-1) { XDestroyImage(_image); delete _shminfo; _shminfo = 0; }
liveimage_srv/CImg.h:            _shminfo->shmaddr = _image->data = (char*)(_data = shmat(_shminfo->shmid,0,0));
liveimage_srv/CImg.h:            if (_shminfo->shmaddr==(char*)-1) {
liveimage_srv/CImg.h:              shmctl(_shminfo->shmid,IPC_RMID,0); XDestroyImage(_image); delete _shminfo; _shminfo = 0;
liveimage_srv/CImg.h:              _shminfo->readOnly = 0;
liveimage_srv/CImg.h:                shmdt(_shminfo->shmaddr); shmctl(_shminfo->shmid,IPC_RMID,0); XDestroyImage(_image);
liveimage_srv/CImg.h:      for ( ; i<cimg::X11_attr().nb_wins - 1; ++i) cimg::X11_attr().wins[i] = cimg::X11_attr().wins[i + 1];
liveimage_srv/CImg.h:      --cimg::X11_attr().nb_wins;
liveimage_srv/CImg.h:        shmdt(_shminfo->shmaddr);
liveimage_srv/CImg.h:        shmctl(_shminfo->shmid,IPC_RMID,0);
liveimage_srv/CImg.h:      const CImg<T>& nimg = (img._depth==1)?img:(tmp=img.get_projections2d((img._width - 1)/2,
liveimage_srv/CImg.h:                                                                           (img._height - 1)/2,
liveimage_srv/CImg.h:                                                                           (img._depth - 1)/2));
liveimage_srv/CImg.h:      const CImg<T> img = list>'x', &nimg = (img._depth==1)?img:(tmp=img.get_projections2d((img._width - 1)/2,
liveimage_srv/CImg.h:                                                                                           (img._height - 1)/2,
liveimage_srv/CImg.h:                                                                                           (img._depth - 1)/2));
liveimage_srv/CImg.h:        tmpdimx = (nwidth>0)?nwidth:(-nwidth*width()/100),
liveimage_srv/CImg.h:        tmpdimy = (nheight>0)?nheight:(-nheight*height()/100),
liveimage_srv/CImg.h:      if (_is_fullscreen) move((screen_width() - _width)/2,(screen_height() - _height)/2);
liveimage_srv/CImg.h:      if (img._depth!=1) return render(img.get_projections2d((img._width - 1)/2,(img._height - 1)/2,
liveimage_srv/CImg.h:                                                             (img._depth - 1)/2));
liveimage_srv/CImg.h:        return render(img.get_resize(_width,_height,1,-100,1));
liveimage_srv/CImg.h:            for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
liveimage_srv/CImg.h:          case 2 : for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:          default : for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:              } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:              } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:              } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:        const float delta = _max - _min, mm = 255/(delta?delta:1.f);
liveimage_srv/CImg.h:          case 1 : for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:              const unsigned char R = (unsigned char)((*(data1++) - _min)*mm);
liveimage_srv/CImg.h:          case 2 : for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                R = (unsigned char)((*(data1++) - _min)*mm),
liveimage_srv/CImg.h:                G = (unsigned char)((*(data2++) - _min)*mm);
liveimage_srv/CImg.h:            for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                R = (unsigned char)((*(data1++) - _min)*mm),
liveimage_srv/CImg.h:                G = (unsigned char)((*(data2++) - _min)*mm),
liveimage_srv/CImg.h:                B = (unsigned char)((*(data3++) - _min)*mm);
liveimage_srv/CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                const unsigned char val = (unsigned char)((*(data1++) - _min)*mm), G = val>>2;
liveimage_srv/CImg.h:              } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                const unsigned char val = (unsigned char)((*(data1++) - _min)*mm), G = val>>2;
liveimage_srv/CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                const unsigned char G = (unsigned char)((*(data2++) - _min)*mm)>>2;
liveimage_srv/CImg.h:                ptrd[0] = ((unsigned char)((*(data1++) - _min)*mm)&M) | (G>>3);
liveimage_srv/CImg.h:              } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                const unsigned char G = (unsigned char)((*(data2++) - _min)*mm)>>2;
liveimage_srv/CImg.h:                ptrd[1] = ((unsigned char)((*(data1++) - _min)*mm)&M) | (G>>3);
liveimage_srv/CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                const unsigned char G = (unsigned char)((*(data2++) - _min)*mm)>>2;
liveimage_srv/CImg.h:                ptrd[0] = ((unsigned char)((*(data1++) - _min)*mm)&M) | (G>>3);
liveimage_srv/CImg.h:                ptrd[1] = (G<<5) | ((unsigned char)((*(data3++) - _min)*mm)>>3);
liveimage_srv/CImg.h:              } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                const unsigned char G = (unsigned char)((*(data2++) - _min)*mm)>>2;
liveimage_srv/CImg.h:                ptrd[0] = (G<<5) | ((unsigned char)((*(data3++) - _min)*mm)>>3);
liveimage_srv/CImg.h:                ptrd[1] = ((unsigned char)((*(data1++) - _min)*mm)&M) | (G>>3);
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                  const unsigned char val = (unsigned char)((*(data1++) - _min)*mm);
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                  const unsigned char val = (unsigned char)((*(data1++) - _min)*mm);
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
liveimage_srv/CImg.h:                    ((unsigned char)((*(data1++) - _min)*mm)<<16) |
liveimage_srv/CImg.h:                    ((unsigned char)((*(data2++) - _min)*mm)<<8);
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
liveimage_srv/CImg.h:                    ((unsigned char)((*(data2++) - _min)*mm)<<16) |
liveimage_srv/CImg.h:                    ((unsigned char)((*(data1++) - _min)*mm)<<8);
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
liveimage_srv/CImg.h:                    ((unsigned char)((*(data1++) - _min)*mm)<<16) |
liveimage_srv/CImg.h:                    ((unsigned char)((*(data2++) - _min)*mm)<<8) |
liveimage_srv/CImg.h:                    (unsigned char)((*(data3++) - _min)*mm);
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy)
liveimage_srv/CImg.h:                    ((unsigned char)((*(data3++) - _min)*mm)<<24) |
liveimage_srv/CImg.h:                    ((unsigned char)((*(data2++) - _min)*mm)<<16) |
liveimage_srv/CImg.h:                    ((unsigned char)((*(data1++) - _min)*mm)<<8);
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                  const unsigned char val = (unsigned char)((*(data1++) - _min)*mm);
liveimage_srv/CImg.h:                } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                  const unsigned char val = (unsigned char)((*(data1++) - _min)*mm);
liveimage_srv/CImg.h:              for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                ptrd[1] = (unsigned char)((*(data2++) - _min)*mm);
liveimage_srv/CImg.h:                ptrd[2] = (unsigned char)((*(data1++) - _min)*mm);
liveimage_srv/CImg.h:                for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                  ptrd[1] = (unsigned char)((*(data1++) - _min)*mm);
liveimage_srv/CImg.h:                  ptrd[2] = (unsigned char)((*(data2++) - _min)*mm);
liveimage_srv/CImg.h:                  ptrd[3] = (unsigned char)((*(data3++) - _min)*mm);
liveimage_srv/CImg.h:                } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:                  ptrd[0] = (unsigned char)((*(data3++) - _min)*mm);
liveimage_srv/CImg.h:                  ptrd[1] = (unsigned char)((*(data2++) - _min)*mm);
liveimage_srv/CImg.h:                  ptrd[2] = (unsigned char)((*(data1++) - _min)*mm);
liveimage_srv/CImg.h:        _x1 = std::min(_x1,width - 1);
liveimage_srv/CImg.h:        _y1 = std::min(_y1,height - 1);
liveimage_srv/CImg.h:        image = XGetImage(dpy,root,_x0,_y0,_x1 - _x0 + 1,_y1 - _y0 + 1,AllPlanes,ZPixmap);
liveimage_srv/CImg.h:            red_mask = image->red_mask,
liveimage_srv/CImg.h:            green_mask = image->green_mask,
liveimage_srv/CImg.h:            blue_mask = image->blue_mask;
liveimage_srv/CImg.h:          img.assign(image->width,image->height,1,3);
liveimage_srv/CImg.h:                                   "with coordinates (%d,%d)-(%d,%d).",
liveimage_srv/CImg.h:        for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:        if (cimg::X11_attr().byte_order) for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:          } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:        if (cimg::X11_attr().byte_order) for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:          } else for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:    // Windows-based implementation.
liveimage_srv/CImg.h:    //-------------------------------
liveimage_srv/CImg.h:        disp->_mouse_x = disp->_mouse_y = -1;
liveimage_srv/CImg.h:        disp->_window_x = disp->_window_y = cimg::type<int>::min();
liveimage_srv/CImg.h:        disp->set_button().set_key(0).set_key(0,false)._is_closed = true;
liveimage_srv/CImg.h:        ReleaseMutex(disp->_mutex);
liveimage_srv/CImg.h:        ShowWindow(disp->_window,SW_HIDE);
liveimage_srv/CImg.h:        disp->_is_event = true;
liveimage_srv/CImg.h:        WaitForSingleObject(disp->_mutex,INFINITE);
liveimage_srv/CImg.h:        if (nw && nh && (nw!=disp->_width || nh!=disp->_height)) {
liveimage_srv/CImg.h:          disp->_window_width = nw;
liveimage_srv/CImg.h:          disp->_window_height = nh;
liveimage_srv/CImg.h:          disp->_mouse_x = disp->_mouse_y = -1;
liveimage_srv/CImg.h:          disp->_is_resized = disp->_is_event = true;
liveimage_srv/CImg.h:        ReleaseMutex(disp->_mutex);
liveimage_srv/CImg.h:        WaitForSingleObject(disp->_mutex,INFINITE);
liveimage_srv/CImg.h:        if (nx!=disp->_window_x || ny!=disp->_window_y) {
liveimage_srv/CImg.h:          disp->_window_x = nx;
liveimage_srv/CImg.h:          disp->_window_y = ny;
liveimage_srv/CImg.h:          disp->_is_moved = disp->_is_event = true;
liveimage_srv/CImg.h:        ReleaseMutex(disp->_mutex);
liveimage_srv/CImg.h:        disp->paint();
liveimage_srv/CImg.h:        if (disp->_is_cursor_visible) while (ShowCursor(TRUE)<0); else while (ShowCursor(FALSE_WIN)>=0);
liveimage_srv/CImg.h:        disp->set_key((unsigned int)wParam);
liveimage_srv/CImg.h:        disp->set_key((unsigned int)wParam,false);
liveimage_srv/CImg.h:        disp->_mouse_x = LOWORD(lParam);
liveimage_srv/CImg.h:        disp->_mouse_y = HIWORD(lParam);
liveimage_srv/CImg.h:        if (!disp->_is_mouse_tracked) {
liveimage_srv/CImg.h:          tme.hwndTrack = disp->_window;
liveimage_srv/CImg.h:          if (TrackMouseEvent(&tme)) disp->_is_mouse_tracked = true;
liveimage_srv/CImg.h:        if (disp->_mouse_x<0 || disp->_mouse_y<0 || disp->_mouse_x>=disp->width() || disp->_mouse_y>=disp->height())
liveimage_srv/CImg.h:          disp->_mouse_x = disp->_mouse_y = -1;
liveimage_srv/CImg.h:        disp->_is_event = true;
liveimage_srv/CImg.h:        if (disp->_is_cursor_visible) while (ShowCursor(TRUE)<0); else while (ShowCursor(FALSE_WIN)>=0);
liveimage_srv/CImg.h:        disp->_mouse_x = disp->_mouse_y = -1;
liveimage_srv/CImg.h:        disp->_is_mouse_tracked = false;
liveimage_srv/CImg.h:        disp->set_button(1);
liveimage_srv/CImg.h:        disp->set_button(2);
liveimage_srv/CImg.h:        disp->set_button(3);
liveimage_srv/CImg.h:        disp->set_button(1,false);
liveimage_srv/CImg.h:        disp->set_button(2,false);
liveimage_srv/CImg.h:        disp->set_button(3,false);
liveimage_srv/CImg.h:        disp->set_wheel((int)((short)HIWORD(wParam))/120);
liveimage_srv/CImg.h:      disp->_bmi.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
liveimage_srv/CImg.h:      disp->_bmi.bmiHeader.biWidth = disp->width();
liveimage_srv/CImg.h:      disp->_bmi.bmiHeader.biHeight = -disp->height();
liveimage_srv/CImg.h:      disp->_bmi.bmiHeader.biPlanes = 1;
liveimage_srv/CImg.h:      disp->_bmi.bmiHeader.biBitCount = 32;
liveimage_srv/CImg.h:      disp->_bmi.bmiHeader.biCompression = BI_RGB;
liveimage_srv/CImg.h:      disp->_bmi.bmiHeader.biSizeImage = 0;
liveimage_srv/CImg.h:      disp->_bmi.bmiHeader.biXPelsPerMeter = 1;
liveimage_srv/CImg.h:      disp->_bmi.bmiHeader.biYPelsPerMeter = 1;
liveimage_srv/CImg.h:      disp->_bmi.bmiHeader.biClrUsed = 0;
liveimage_srv/CImg.h:      disp->_bmi.bmiHeader.biClrImportant = 0;
liveimage_srv/CImg.h:      disp->_data = new unsigned int[(size_t)disp->_width*disp->_height];
liveimage_srv/CImg.h:      if (!disp->_is_fullscreen) { // Normal window
liveimage_srv/CImg.h:        rect.left = rect.top = 0; rect.right = (LONG)disp->_width - 1; rect.bottom = (LONG)disp->_height - 1;
liveimage_srv/CImg.h:          border1 = (int)((rect.right - rect.left + 1 - disp->_width)/2),
liveimage_srv/CImg.h:          border2 = (int)(rect.bottom - rect.top + 1 - disp->_height - border1),
liveimage_srv/CImg.h:          ww = disp->width() + 2*border1,
liveimage_srv/CImg.h:          wh = disp->height() + border1 + border2,
liveimage_srv/CImg.h:          wx = (int)cimg::round(cimg::rand(0,sw - ww -1)),
liveimage_srv/CImg.h:          wy = (int)cimg::round(cimg::rand(64,sh - wh - 65));
liveimage_srv/CImg.h:        if (wx + ww>=sw) wx = sw - ww;
liveimage_srv/CImg.h:        if (wy + wh>=sh) wy = sh - wh;
liveimage_srv/CImg.h:        disp->_window = CreateWindowA("MDICLIENT",title?title:" ",
liveimage_srv/CImg.h:                                      (DWORD)(WS_OVERLAPPEDWINDOW | (disp->_is_closed?0:WS_VISIBLE)),
liveimage_srv/CImg.h:                                      wx,wy,ww,wh,0,0,0,&(disp->_ccs));
liveimage_srv/CImg.h:        if (!disp->_is_closed) {
liveimage_srv/CImg.h:          GetWindowRect(disp->_window,&rect);
liveimage_srv/CImg.h:          disp->_window_x = rect.left;
liveimage_srv/CImg.h:          disp->_window_y = rect.top;
liveimage_srv/CImg.h:        } else disp->_window_x = disp->_window_y = cimg::type<int>::min();
liveimage_srv/CImg.h:        disp->_window = CreateWindowA("MDICLIENT",title?title:" ",
liveimage_srv/CImg.h:                                      (DWORD)(WS_POPUP | (disp->_is_closed?0:WS_VISIBLE)),
liveimage_srv/CImg.h:                                      (int)(sx - disp->_width)/2,
liveimage_srv/CImg.h:                                      (int)(sy - disp->_height)/2,
liveimage_srv/CImg.h:                                      disp->width(),disp->height(),0,0,0,&(disp->_ccs));
liveimage_srv/CImg.h:        disp->_window_x = disp->_window_y = 0;
liveimage_srv/CImg.h:      SetForegroundWindow(disp->_window);
liveimage_srv/CImg.h:      disp->_hdc = GetDC(disp->_window);
liveimage_srv/CImg.h:      disp->_window_width = disp->_width;
liveimage_srv/CImg.h:      disp->_window_height = disp->_height;
liveimage_srv/CImg.h:      disp->flush();
liveimage_srv/CImg.h:      SetWindowLongPtr(disp->_window,GWLP_USERDATA,(LONG_PTR)disp);
liveimage_srv/CImg.h:      SetWindowLongPtr(disp->_window,GWLP_WNDPROC,(LONG_PTR)_handle_events);
liveimage_srv/CImg.h:      SetWindowLong(disp->_window,GWL_USERDATA,(LONG)disp);
liveimage_srv/CImg.h:      SetWindowLong(disp->_window,GWL_WNDPROC,(LONG)_handle_events);
liveimage_srv/CImg.h:      SetEvent(disp->_is_created);
liveimage_srv/CImg.h:        rect.left = rect.top = 0; rect.right = (LONG)_width - 1; rect.bottom = (LONG)_height - 1;
liveimage_srv/CImg.h:      const CImg<T>& nimg = (img._depth==1)?img:(tmp=img.get_projections2d((img._width - 1)/2,
liveimage_srv/CImg.h:                                                                           (img._height - 1)/2,
liveimage_srv/CImg.h:                                                                           (img._depth - 1)/2));
liveimage_srv/CImg.h:      const CImg<T> img = list>'x', &nimg = (img._depth==1)?img:(tmp=img.get_projections2d((img._width - 1)/2,
liveimage_srv/CImg.h:                                                                                           (img._height - 1)/2,
liveimage_srv/CImg.h:                                                                                           (img._depth - 1)/2));
liveimage_srv/CImg.h:        tmpdimx = (nwidth>0)?nwidth:(-nwidth*_width/100),
liveimage_srv/CImg.h:        tmpdimy = (nheight>0)?nheight:(-nheight*_height/100),
liveimage_srv/CImg.h:          RECT rect; rect.left = rect.top = 0; rect.right = (LONG)dimx - 1; rect.bottom = (LONG)dimy - 1;
liveimage_srv/CImg.h:          const int cwidth = rect.right - rect.left + 1, cheight = rect.bottom - rect.top + 1;
liveimage_srv/CImg.h:          _bmi.bmiHeader.biHeight = -(int)dimy;
liveimage_srv/CImg.h:      if (_is_fullscreen) move((screen_width() - width())/2,(screen_height() - height())/2);
liveimage_srv/CImg.h:      if (img._depth!=1) return render(img.get_projections2d((img._width - 1)/2,(img._height - 1)/2,
liveimage_srv/CImg.h:                                                             (img._depth - 1)/2));
liveimage_srv/CImg.h:          for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:          for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:          for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:        const float delta = _max - _min, mm = 255/(delta?delta:1.f);
liveimage_srv/CImg.h:          for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:            const unsigned char val = (unsigned char)((*(data1++) - _min)*mm);
liveimage_srv/CImg.h:          for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:              R = (unsigned char)((*(data1++) - _min)*mm),
liveimage_srv/CImg.h:              G = (unsigned char)((*(data2++) - _min)*mm);
liveimage_srv/CImg.h:          for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:              R = (unsigned char)((*(data1++) - _min)*mm),
liveimage_srv/CImg.h:              G = (unsigned char)((*(data2++) - _min)*mm),
liveimage_srv/CImg.h:              B = (unsigned char)((*(data3++) - _min)*mm);
liveimage_srv/CImg.h:          _x1 = std::min(_x1,width - 1);
liveimage_srv/CImg.h:          _y1 = std::min(_y1,height - 1);
liveimage_srv/CImg.h:          const int bw = _x1 - _x0 + 1, bh = _y1 - _y0 + 1;
liveimage_srv/CImg.h:                bmi.biHeight = -bh;
liveimage_srv/CImg.h:                                   "with coordinates (%d,%d)-(%d,%d).",
liveimage_srv/CImg.h:      for (cimg_ulong xy = (cimg_ulong)img._width*img._height; xy>0; --xy) {
liveimage_srv/CImg.h:   #--------------------------------------
liveimage_srv/CImg.h:   #--------------------------------------
liveimage_srv/CImg.h:     while the number of channels is rather used as a vector-valued dimension
liveimage_srv/CImg.h:     Thus, the \c CImg<T> class is able to represent volumetric images of vector-valued pixels,
liveimage_srv/CImg.h:     images that have floating-point pixel values. The default value for the template T is \c float.
liveimage_srv/CImg.h:     - \c _width defines the number of \a columns of the image (size along the X-axis).
liveimage_srv/CImg.h:     - \c _height defines the number of \a rows of the image (size along the Y-axis).
liveimage_srv/CImg.h:     - \c _depth defines the number of \a slices of the image (size along the Z-axis).
liveimage_srv/CImg.h:     - \c _spectrum defines the number of \a channels of the image (size along the C-axis).
liveimage_srv/CImg.h:     - \c _data defines a \a pointer to the \a pixel \a data (of type \c T).
liveimage_srv/CImg.h:     - \c _is_shared is a boolean that tells if the memory buffer \c data is shared with
liveimage_srv/CImg.h:     - Construct images from arbitrary dimensions:
liveimage_srv/CImg.h:         - <tt>CImg<char> img;</tt> declares an empty image.
liveimage_srv/CImg.h:         - <tt>CImg<unsigned char> img(128,128);</tt> declares a 128x128 greyscale image with
liveimage_srv/CImg.h:         - <tt>CImg<double> img(3,3);</tt> declares a 3x3 matrix with \c double coefficients.
liveimage_srv/CImg.h:         - <tt>CImg<unsigned char> img(256,256,1,3);</tt> declares a 256x256x1x3 (color) image
liveimage_srv/CImg.h:         - <tt>CImg<double> img(128,128,128);</tt> declares a 128x128x128 volumetric and greyscale image
liveimage_srv/CImg.h:         - <tt>CImg<> img(128,128,128,3);</tt> declares a 128x128x128 volumetric color image
liveimage_srv/CImg.h:         - \b Note: images pixels are <b>not automatically initialized to 0</b>. You may use the function \c fill() to
liveimage_srv/CImg.h:     - Construct images from filenames:
liveimage_srv/CImg.h:         - <tt>CImg<unsigned char> img("image.jpg");</tt> reads a JPEG color image from the file "image.jpg".
liveimage_srv/CImg.h:         - <tt>CImg<float> img("analyze.hdr");</tt> reads a volumetric image (ANALYZE7.5 format) from the
liveimage_srv/CImg.h:         - \b Note: You need to install <a href="http://www.imagemagick.org">ImageMagick</a>
liveimage_srv/CImg.h:     - Construct images from C-style arrays:
liveimage_srv/CImg.h:         - <tt>CImg<int> img(data_buffer,256,256);</tt> constructs a 256x256 greyscale image from a \c int* buffer
liveimage_srv/CImg.h:         - <tt>CImg<unsigned char> img(data_buffer,256,256,1,3);</tt> constructs a 256x256 color image
liveimage_srv/CImg.h:     - operator()(): Read or write pixel values.
liveimage_srv/CImg.h:     - display(): displays the image in a new window.
liveimage_srv/CImg.h:       - The \c CImg<T>::iterator type is defined to be a <tt>T*</tt>.
liveimage_srv/CImg.h:       - You will seldom have to use iterators in %CImg, most classical operations
liveimage_srv/CImg.h:       img.fill(0);                                                              // Do the same with a built-in method
liveimage_srv/CImg.h:       - The \c CImg<T>::const_iterator type is defined to be a \c const \c T*.
liveimage_srv/CImg.h:       - You will seldom have to use iterators in %CImg, most classical operations
liveimage_srv/CImg.h:       const float sum2 = img.sum();                                              // Do the same with a built-in method
liveimage_srv/CImg.h:       - The \c CImg<T>::value_type type of a \c CImg<T> is defined to be a \c T.
liveimage_srv/CImg.h:       - \c CImg<T>::value_type is actually not used in %CImg methods. It has been mainly defined for
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:    //---------------------------------------------------------
liveimage_srv/CImg.h:    //---------------------------------------------------------
liveimage_srv/CImg.h:       - The pixel buffer data() is deallocated if necessary, e.g. for non-empty and non-shared image instances.
liveimage_srv/CImg.h:       - Destroying an empty or shared image does nothing actually.
liveimage_srv/CImg.h:       - When destroying a non-shared image, make sure that you will \e not operate on a remaining shared image
liveimage_srv/CImg.h:       - An empty image has no pixel data and all of its dimensions width(), height(), depth(), spectrum()
liveimage_srv/CImg.h:       - An empty image may be re-assigned afterwards, e.g. with the family of
liveimage_srv/CImg.h:       - An empty image is never shared.
liveimage_srv/CImg.h:       img1.assign(256,256,1,3);    // Re-assign 'img1' to be a 256x256x1x3 (color) image
liveimage_srv/CImg.h:       img2 = img1.get_rand(0,255); // Re-assign 'img2' to be a random-valued version of 'img1'
liveimage_srv/CImg.h:       img2.assign();               // Re-assign 'img2' to be an empty image again
liveimage_srv/CImg.h:       - It is able to create only \e non-shared images, and allocates thus a pixel buffer data()
liveimage_srv/CImg.h:       - Setting one dimension \c size_x,\c size_y,\c size_z or \c size_c to \c 0 leads to the construction of
liveimage_srv/CImg.h:       - A \c CImgInstanceException is thrown when the pixel buffer cannot be allocated
liveimage_srv/CImg.h:       - The allocated pixel buffer is \e not filled with a default value, and is likely to contain garbage values.
liveimage_srv/CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int),
liveimage_srv/CImg.h:       - It cannot be used to construct a vector-valued image and initialize it with \e vector-valued pixels
liveimage_srv/CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it also fills
liveimage_srv/CImg.h:       - You must specify \e exactly \c size_x*\c size_y*\c size_z*\c size_c integers in the initialization sequence.
liveimage_srv/CImg.h:        if (_siz--) { \
liveimage_srv/CImg.h:          if (_siz--) { \
liveimage_srv/CImg.h:            for ( ; _siz; --_siz) *(ptrd++) = (T)va_arg(ap,t); \
liveimage_srv/CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it also fills
liveimage_srv/CImg.h:  if (repeat_values) for (T *ptrd = _data; siz--; ) { \
liveimage_srv/CImg.h:  else { siz = std::min(siz,values.size()); for (T *ptrd = _data; siz--; ) *(ptrd++) = (T)(*(it++)); }
liveimage_srv/CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int) with height=1, depth=1, and spectrum=1,
liveimage_srv/CImg.h:      for (T *ptrd = _data; siz--; ) *(ptrd++) = (T)(*(it++));
liveimage_srv/CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int,int,int,...), but
liveimage_srv/CImg.h:       - You must specify \e exactly \c dx*\c dy*\c dz*\c dc doubles in the initialization sequence.
liveimage_srv/CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it also fills
liveimage_srv/CImg.h:       - Value string \c values may describe two different filling processes:
liveimage_srv/CImg.h:         - Either \c values is a sequences of values assigned to the image pixels, as in <tt>"1,2,3,7,8,2"</tt>.
liveimage_srv/CImg.h:         - Either, \c values is a formula, as in <tt>"cos(x/10)*sin(y/20)"</tt>.
liveimage_srv/CImg.h:       - For both cases, specifying \c repeat_values is mandatory.
liveimage_srv/CImg.h:       - A \c CImgArgumentException is thrown when an invalid value string \c values is specified.
liveimage_srv/CImg.h:       - If \c is_shared is \c false, the image instance allocates its own pixel buffer,
liveimage_srv/CImg.h:       - Otherwise, the image instance does \e not allocate a new buffer, and uses the input memory buffer as its
liveimage_srv/CImg.h:       - A \c CImgInstanceException is thrown when the pixel buffer cannot be allocated
liveimage_srv/CImg.h:       - You must take care when operating on a shared image, since it may have an invalid pixel buffer pointer data()
liveimage_srv/CImg.h:       CImg<unsigned char> img1(tab,256,256,1,1,false), // Construct new non-shared image from buffer 'tab'
liveimage_srv/CImg.h:                           img2(tab,256,256,1,1,true);  // Construct new shared-image from buffer 'tab'
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it reads the image
liveimage_srv/CImg.h:       - The recognition of the image file format by %CImg higlhy depends on the tools installed on your system
liveimage_srv/CImg.h:       - Considered pixel type \c T should better fit the file format specification, or data loss may occur during
liveimage_srv/CImg.h:         file load (e.g. constructing a \c CImg<unsigned char> from a float-valued image file).
liveimage_srv/CImg.h:       - A \c CImgIOException is thrown when the specified \c filename cannot be read, or if the file format is not
liveimage_srv/CImg.h:       - Constructed copy has the same size width() x height() x depth() x spectrum() and pixel values as the
liveimage_srv/CImg.h:       - If input image \c img is \e shared and if types \c T and \c t are the same, the constructed copy is also
liveimage_srv/CImg.h:       - Otherwise, the constructed copy allocates its own pixel buffer, and copies pixel values from the input
liveimage_srv/CImg.h:       - Constructing a copy from an image \c img when types \c t and \c T are the same is significantly faster than
liveimage_srv/CImg.h:       - A \c CImgInstanceException is thrown when the pixel buffer cannot be allocated
liveimage_srv/CImg.h:       - Similar to CImg(const CImg<t>&), except that it allows to decide the shared state of
liveimage_srv/CImg.h:         - If \c is_shared is \c true, the constructed copy will share its pixel buffer with the input image \c img.
liveimage_srv/CImg.h:         - If \c is_shared is \c false, the constructed copy will allocate its own pixel buffer, whether the input
liveimage_srv/CImg.h:       - A \c CImgArgumentException is thrown when a shared copy is requested with different pixel types \c T and \c t.
liveimage_srv/CImg.h:       \param dimensions C-string describing the image size along the X,Y,Z and C-dimensions.
liveimage_srv/CImg.h:       - Similar to CImg(unsigned int,unsigned int,unsigned int,unsigned int), but it takes the image dimensions
liveimage_srv/CImg.h:       - The allocated pixel buffer is \e not filled with a default value, and is likely to contain garbage values.
liveimage_srv/CImg.h:       \param dimensions String describing the image size along the X,Y,Z and V-dimensions.
liveimage_srv/CImg.h:       - Similar to CImg(const CImg<t>&,const char*), but it also fills the pixel buffer with the specified \c value.
liveimage_srv/CImg.h:       - The width() and height() of the constructed image instance are the same as the specified \c CImgDisplay.
liveimage_srv/CImg.h:       - The depth() and spectrum() of the constructed image instance are respectively set to \c 1 and \c 3
liveimage_srv/CImg.h:       - The image pixels are read as 8-bits RGB values.
liveimage_srv/CImg.h:       In-place version of the default constructor CImg(). It simply resets the instance to an empty image.
liveimage_srv/CImg.h:       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int).
liveimage_srv/CImg.h:       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int,T).
liveimage_srv/CImg.h:       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int,int,int,...).
liveimage_srv/CImg.h:       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int,double,double,...).
liveimage_srv/CImg.h:       In-place version of the constructor CImg(unsigned int,unsigned int,unsigned int,unsigned int,const char*,bool).
liveimage_srv/CImg.h:       In-place version of the constructor CImg(const t*,unsigned int,unsigned int,unsigned int,unsigned int).
liveimage_srv/CImg.h:       In-place version of the constructor CImg(const char*).
liveimage_srv/CImg.h:       In-place version of the constructor CImg(const CImg<t>&).
liveimage_srv/CImg.h:    //! In-place version of the advanced copy constructor.
liveimage_srv/CImg.h:       In-place version of the constructor CImg(const CImg<t>&,bool).
liveimage_srv/CImg.h:       In-place version of the constructor CImg(const CImg<t>&,const char*).
liveimage_srv/CImg.h:        if (cimg_sscanf(s,"%255[^0-9%xyzvwhdcXYZVWHDC]",item._data)>0) s+=std::strlen(item);
liveimage_srv/CImg.h:       In-place version of the constructor CImg(const CImg<t>&,const char*,T).
liveimage_srv/CImg.h:       In-place version of the constructor CImg(const CImgDisplay&).
liveimage_srv/CImg.h:       - It has been defined for compatibility with STL naming conventions.
liveimage_srv/CImg.h:       - Pixel types \c T and \c t of source and destination images can be different, though the process is
liveimage_srv/CImg.h:       - When optional parameter \c pos is omitted, the image instance is transferred as a new
liveimage_srv/CImg.h:       - It is convenient to sequentially insert new images into image lists, with no
liveimage_srv/CImg.h:      - It can be used to interchange the content of two images in a very fast way. Can be convenient when dealing
liveimage_srv/CImg.h:    //------------------------------------------
liveimage_srv/CImg.h:    //------------------------------------------
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       - Range of pixel coordinates start from <tt>(0,0,0,0)</tt> to
liveimage_srv/CImg.h:         <tt>(width() - 1,height() - 1,depth() - 1,spectrum() - 1)</tt>.
liveimage_srv/CImg.h:       - Due to the particular arrangement of the pixel buffers defined in %CImg, you can omit one coordinate if the
liveimage_srv/CImg.h:       - There is \e no boundary checking done in this operator, to make it as fast as possible.
liveimage_srv/CImg.h:         You \e must take care of out-of-bounds access by yourself, if necessary.
liveimage_srv/CImg.h:         when accessing out-of-bounds pixels.
liveimage_srv/CImg.h:          valB = img(10,10,2),   // Read blue value at coordinates (10,10) (Z-coordinate can be omitted)
liveimage_srv/CImg.h:      return const_cast<CImg<T>*>(this)->operator()(x,y,z,c);
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       - Similar to (but faster than) operator()().
liveimage_srv/CImg.h:       - It simply returns the pointer data() to the pixel buffer.
liveimage_srv/CImg.h:       - This implicit conversion is convenient to test the empty state of images (data() being \c 0 in this case), e.g.
liveimage_srv/CImg.h:       - It also allows to use brackets to access pixel values, without need for a \c CImg<T>::operator[](), e.g.
liveimage_srv/CImg.h:       - The image size is never modified.
liveimage_srv/CImg.h:       - The \c value may be casted to pixel type \c T if necessary.
liveimage_srv/CImg.h:       - String parameter \c expression may describe different things:
liveimage_srv/CImg.h:         - If \c expression is a list of values (as in \c "1,2,3,8,3,2"), or a formula (as in \c "(x*y)%255"),
liveimage_srv/CImg.h:         - If \c expression is a filename (as in \c "reference.jpg"), the corresponding image file is loaded and
liveimage_srv/CImg.h:       Similar to the in-place copy constructor assign(const CImg<t>&).
liveimage_srv/CImg.h:    //! In-place addition operator.
liveimage_srv/CImg.h:       - Resulting pixel values are casted to fit the pixel type \c T.
liveimage_srv/CImg.h:       - Overflow values are treated as with standard C++ numeric types. For instance,
liveimage_srv/CImg.h:       img+=1;                                   // Add '1' to each pixels -> Overflow
liveimage_srv/CImg.h:       - To prevent value overflow, you may want to consider pixel type \c T as \c float or \c double,
liveimage_srv/CImg.h:       CImg<unsigned char> img1("reference.jpg"); // Load a 8-bits RGB image (values in [0,255])
liveimage_srv/CImg.h:       CImg<float> img2(img1); // Construct a float-valued copy of 'img1'
liveimage_srv/CImg.h:       img2+=100; // Add '100' to pixel values -> goes out of [0,255] but no problems with floats
liveimage_srv/CImg.h:    //! In-place addition operator.
liveimage_srv/CImg.h:       - Similar to operator=(const char*), except that it adds values to the pixels of the current image instance,
liveimage_srv/CImg.h:    //! In-place addition operator.
liveimage_srv/CImg.h:       - The size of the image instance is never modified.
liveimage_srv/CImg.h:       - It is not mandatory that input image \c img has the same size as the image instance.
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:    //! In-place increment operator (prefix).
liveimage_srv/CImg.h:       - Writing \c ++img is equivalent to \c img+=1.
liveimage_srv/CImg.h:    //! In-place increment operator (postfix).
liveimage_srv/CImg.h:       Add \c 1 to all image pixels, and return a new copy of the initial (pre-incremented) image instance.
liveimage_srv/CImg.h:       - Use the prefixed version operator++() if you don't need a copy of the initial
liveimage_srv/CImg.h:         (pre-incremented) image instance, since a useless image copy may be expensive in terms of memory usage.
liveimage_srv/CImg.h:    //! Return a non-shared copy of the image instance.
liveimage_srv/CImg.h:       - Use this operator to ensure you get a non-shared copy of an image instance with same pixel type \c T.
liveimage_srv/CImg.h:       - Writing \c (+img) is equivalent to \c CImg<T>(img,false).
liveimage_srv/CImg.h:       Similar to operator+=(const t), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator+=(const char*), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator+=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:    //! In-place subtraction operator.
liveimage_srv/CImg.h:    CImg<T>& operator-=(const t value) {
liveimage_srv/CImg.h:      cimg_openmp_for(*this,*ptr - value,524288);
liveimage_srv/CImg.h:    //! In-place subtraction operator.
liveimage_srv/CImg.h:    CImg<T>& operator-=(const char *const expression) {
liveimage_srv/CImg.h:      return *this-=(+*this)._fill(expression,true,1,0,0,"operator-=",this);
liveimage_srv/CImg.h:    //! In-place subtraction operator.
liveimage_srv/CImg.h:    CImg<T>& operator-=(const CImg<t>& img) {
liveimage_srv/CImg.h:        if (is_overlapped(img)) return *this-=+img;
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:            *ptrd = (T)(*ptrd - *(ptrs++));
liveimage_srv/CImg.h:        for (const t *ptrs = img._data; ptrd<ptre; ++ptrd) *ptrd = (T)(*ptrd - *(ptrs++));
liveimage_srv/CImg.h:    //! In-place decrement operator (prefix).
liveimage_srv/CImg.h:    CImg<T>& operator--() {
liveimage_srv/CImg.h:      cimg_openmp_for(*this,*ptr - 1,524288);
liveimage_srv/CImg.h:    //! In-place decrement operator (postfix).
liveimage_srv/CImg.h:    CImg<T> operator--(int) {
liveimage_srv/CImg.h:      --*this;
liveimage_srv/CImg.h:       - If the computed opposite values are out-of-range, they are treated as with standard C++ numeric types.
liveimage_srv/CImg.h:         img2 = -img1;            // Compute its opposite (in 'unsigned char')
liveimage_srv/CImg.h:    CImg<T> operator-() const {
liveimage_srv/CImg.h:      return CImg<T>(_width,_height,_depth,_spectrum,(T)0)-=*this;
liveimage_srv/CImg.h:       Similar to operator-=(const t), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:    CImg<_cimg_Tt> operator-(const t value) const {
liveimage_srv/CImg.h:      return CImg<_cimg_Tt>(*this,false)-=value;
liveimage_srv/CImg.h:       Similar to operator-=(const char*), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:    CImg<Tfloat> operator-(const char *const expression) const {
liveimage_srv/CImg.h:      return CImg<Tfloat>(*this,false)-=expression;
liveimage_srv/CImg.h:       Similar to operator-=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:    CImg<_cimg_Tt> operator-(const CImg<t>& img) const {
liveimage_srv/CImg.h:      return CImg<_cimg_Tt>(*this,false)-=img;
liveimage_srv/CImg.h:    //! In-place multiplication operator.
liveimage_srv/CImg.h:    //! In-place multiplication operator.
liveimage_srv/CImg.h:    //! In-place multiplication operator.
liveimage_srv/CImg.h:       - It does \e not compute a pointwise multiplication between two images. For this purpose, use
liveimage_srv/CImg.h:       - The size of the image instance can be modified by this operator.
liveimage_srv/CImg.h:       Similar to operator*=(const t), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator*=(const char*), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator*=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:    //! In-place division operator.
liveimage_srv/CImg.h:    //! In-place division operator.
liveimage_srv/CImg.h:    //! In-place division operator.
liveimage_srv/CImg.h:       - It does \e not compute a pointwise division between two images. For this purpose, use
liveimage_srv/CImg.h:       - It returns the matrix operation \c A*inverse(img).
liveimage_srv/CImg.h:       - The size of the image instance can be modified by this operator.
liveimage_srv/CImg.h:       Similar to operator/=(const t), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator/=(const char*), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator/=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:    //! In-place modulo operator.
liveimage_srv/CImg.h:    //! In-place modulo operator.
liveimage_srv/CImg.h:    //! In-place modulo operator.
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:       Similar to operator%=(const t), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator%=(const char*), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator%=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:    //! In-place bitwise AND operator.
liveimage_srv/CImg.h:    //! In-place bitwise AND operator.
liveimage_srv/CImg.h:    //! In-place bitwise AND operator.
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:       Similar to operator&=(const t), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator&=(const char*), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator&=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:    //! In-place bitwise OR operator.
liveimage_srv/CImg.h:    //! In-place bitwise OR operator.
liveimage_srv/CImg.h:    //! In-place bitwise OR operator.
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:       Similar to operator|=(const t), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator|=(const char*), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator|=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:    //! In-place bitwise XOR operator.
liveimage_srv/CImg.h:       - It does \e not compute the \e power of pixel values. For this purpose, use pow(const t) instead.
liveimage_srv/CImg.h:    //! In-place bitwise XOR operator.
liveimage_srv/CImg.h:       - It does \e not compute the \e power of pixel values. For this purpose, use pow(const char*) instead.
liveimage_srv/CImg.h:    //! In-place bitwise XOR operator.
liveimage_srv/CImg.h:       - It does \e not compute the \e power of pixel values. For this purpose, use pow(const CImg<t>&) instead.
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:       Similar to operator^=(const t), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator^=(const char*), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator^=(const CImg<t>&), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:    //! In-place bitwise left shift operator.
liveimage_srv/CImg.h:    //! In-place bitwise left shift operator.
liveimage_srv/CImg.h:    //! In-place bitwise left shift operator.
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:       Similar to operator<<=(const t), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator<<=(const char*), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       operating in-place.
liveimage_srv/CImg.h:    //! In-place bitwise right shift operator.
liveimage_srv/CImg.h:    //! In-place bitwise right shift operator.
liveimage_srv/CImg.h:    //! In-place bitwise right shift operator.
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:       Similar to operator>>=(const t), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       Similar to operator>>=(const char*), except that it returns a new image instance instead of operating in-place.
liveimage_srv/CImg.h:       operating in-place.
liveimage_srv/CImg.h:       Similar to operator-(), except that it compute the bitwise inverse instead of the opposite value.
liveimage_srv/CImg.h:      for (T *ptrd = _data + size(); is_equal && ptrd>_data; is_equal = ((Tt)*(--ptrd)==(Tt)value)) {}
liveimage_srv/CImg.h:       - The pixel buffer pointers data() of the two compared images do not have to be the same for operator==()
liveimage_srv/CImg.h:      for (T *ptrd = _data + siz; is_equal && ptrd>_data; is_equal = ((Tt)*(--ptrd)==(Tt)*(--ptrs))) {}
liveimage_srv/CImg.h:       - Writing \c img1!=img2 is equivalent to \c !(img1==img2).
liveimage_srv/CImg.h:         - A copy of the image instance, at position [\c 0].
liveimage_srv/CImg.h:         - A copy of the specified image \c img, at position [\c 1].
liveimage_srv/CImg.h:       - The family of operator,() is convenient to easily create list of images, but it is also \e quite \e slow
liveimage_srv/CImg.h:       - Constructed lists contain no shared images. If image instance or input image \c img are shared, they are
liveimage_srv/CImg.h:         inserted as new non-shared copies in the resulting list.
liveimage_srv/CImg.h:       - The pixel type of the returned list may be a superset of the initial pixel type \c T, if necessary.
liveimage_srv/CImg.h:       - Pipelining operator,() \c N times will perform \c N copies of the entire content of a (growing) image list.
liveimage_srv/CImg.h:         - A copy of the image instance, at position [\c 0].
liveimage_srv/CImg.h:         - A copy of the specified image list \c list, from positions [\c 1] to [\c list.size()].
liveimage_srv/CImg.h:       - Similar to operator,(const CImg<t>&) const, except that it takes an image list as an argument.
liveimage_srv/CImg.h:       - Similar to get_split(char,int) const, with default second argument.
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:       - The returned string does not contain any spaces.
liveimage_srv/CImg.h:       - If the pixel type \c T does not correspond to a registered type, the string <tt>"unknown"</tt> is returned.
liveimage_srv/CImg.h:       Return the image width, i.e. the image dimension along the X-axis.
liveimage_srv/CImg.h:       - The width() of an empty image is equal to \c 0.
liveimage_srv/CImg.h:       - width() is typically equal to \c 1 when considering images as \e vectors for matrix calculations.
liveimage_srv/CImg.h:       - width() returns an \c int, although the image width is internally stored as an \c unsigned \c int.
liveimage_srv/CImg.h:       Return the image height, i.e. the image dimension along the Y-axis.
liveimage_srv/CImg.h:       - The height() of an empty image is equal to \c 0.
liveimage_srv/CImg.h:       - height() returns an \c int, although the image height is internally stored as an \c unsigned \c int.
liveimage_srv/CImg.h:       Return the image depth, i.e. the image dimension along the Z-axis.
liveimage_srv/CImg.h:       - The depth() of an empty image is equal to \c 0.
liveimage_srv/CImg.h:       - depth() is typically equal to \c 1 when considering usual 2D images. When depth()\c > \c 1, the image
liveimage_srv/CImg.h:       - depth() returns an \c int, although the image depth is internally stored as an \c unsigned \c int.
liveimage_srv/CImg.h:       Return the number of image channels, i.e. the image dimension along the C-axis.
liveimage_srv/CImg.h:       - The spectrum() of an empty image is equal to \c 0.
liveimage_srv/CImg.h:       - spectrum() is typically equal to \c 1 when considering scalar-valued images, to \c 3
liveimage_srv/CImg.h:         for RGB-coded color images, and to \c 4 for RGBA-coded color images (with alpha-channel).
liveimage_srv/CImg.h:         up to the number of channels (e.g. a 4-channel image may indifferently stands for a RGBA or CMYK color image).
liveimage_srv/CImg.h:       - spectrum() returns an \c int, although the image spectrum is internally stored as an \c unsigned \c int.
liveimage_srv/CImg.h:       - The size() of an empty image is equal to \c 0.
liveimage_srv/CImg.h:       - The allocated memory size for a pixel buffer of a non-shared \c CImg<T> instance is equal to
liveimage_srv/CImg.h:       - The data() of an empty image is equal to \c 0 (null pointer).
liveimage_srv/CImg.h:       - The allocated pixel buffer for the image instance starts from \c data()
liveimage_srv/CImg.h:         and goes to <tt>data()+\ref size() - 1</tt> (included).
liveimage_srv/CImg.h:       - To get the pointer to one particular location of the pixel buffer, use
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       - Writing \c img.data(x,y,z,c) is equivalent to <tt>&(img(x,y,z,c))</tt>. Thus, this method has the same
liveimage_srv/CImg.h:      return const_cast<CImg<T>*>(this)->data(x,y,z,c);
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       - Writing \c img.data(x,y,z,c) is equivalent to <tt>&(img(x,y,z,c)) - img.data()</tt>.
liveimage_srv/CImg.h:       const CImg<float> img(100,100,1,3);      // Define a 100x100 RGB-color image
liveimage_srv/CImg.h:       - Equivalent to data().
liveimage_srv/CImg.h:       - It has been mainly defined for compatibility with STL naming conventions.
liveimage_srv/CImg.h:       - Writing \c img.end() is equivalent to <tt>img.data() + img.size()</tt>.
liveimage_srv/CImg.h:       - It has been mainly defined for compatibility with STL naming conventions.
liveimage_srv/CImg.h:       - The returned iterator actually points to a value located \e outside the acceptable bounds of the pixel buffer.
liveimage_srv/CImg.h:       - Writing \c img.front() is equivalent to <tt>img[0]</tt>, or <tt>img(0,0,0,0)</tt>.
liveimage_srv/CImg.h:       - It has been mainly defined for compatibility with STL naming conventions.
liveimage_srv/CImg.h:       - Writing \c img.back() is equivalent to <tt>img[img.size() - 1]</tt>, or
liveimage_srv/CImg.h:         <tt>img(img.width() - 1,img.height() - 1,img.depth() - 1,img.spectrum() - 1)</tt>.
liveimage_srv/CImg.h:       - It has been mainly defined for compatibility with STL naming conventions.
liveimage_srv/CImg.h:      return *(_data + size() - 1);
liveimage_srv/CImg.h:      return *(_data + size() - 1);
liveimage_srv/CImg.h:       or to a specified default value in case of out-of-bounds access.
liveimage_srv/CImg.h:       - Writing \c img.at(offset,out_value) is similar to <tt>img[offset]</tt>, except that if \c offset
liveimage_srv/CImg.h:       - Due to the additional boundary checking operation, this method is slower than operator()(). Use it when
liveimage_srv/CImg.h:       or to the nearest pixel location in the image instance in case of out-of-bounds access.
liveimage_srv/CImg.h:       - Similar to at(int,const T), except that an out-of-bounds access returns the value of the
liveimage_srv/CImg.h:         - If \c offset<0, then \c img[0] is returned.
liveimage_srv/CImg.h:         - If \c offset>=img.size(), then \c img[img.size() - 1] is returned.
liveimage_srv/CImg.h:       - Due to the additional boundary checking operation, this method is slower than operator()(). Use it when
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method \c _at(int).
liveimage_srv/CImg.h:      return (*this)[offset<0?0:(unsigned int)offset>=siz?siz - 1:offset];
liveimage_srv/CImg.h:      return (*this)[offset<0?0:(unsigned int)offset>=siz?siz - 1:offset];
liveimage_srv/CImg.h:    //! Access to a pixel value, using Dirichlet boundary conditions for the X-coordinate.
liveimage_srv/CImg.h:       or to a specified default value in case of out-of-bounds access along the X-axis.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       - Similar to operator()(), except that an out-of-bounds access along the X-axis returns the specified value
liveimage_srv/CImg.h:       - Due to the additional boundary checking operation, this method is slower than operator()(). Use it when
liveimage_srv/CImg.h:       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
liveimage_srv/CImg.h:    //! Access to a pixel value, using Dirichlet boundary conditions for the X-coordinate \const.
liveimage_srv/CImg.h:    //! Access to a pixel value, using Neumann boundary conditions for the X-coordinate.
liveimage_srv/CImg.h:       or to the nearest pixel location in the image instance in case of out-of-bounds access along the X-axis.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       - Similar to at(int,int,int,int,const T), except that an out-of-bounds access returns the value of the
liveimage_srv/CImg.h:         nearest pixel in the image instance, regarding the specified X-coordinate.
liveimage_srv/CImg.h:       - Due to the additional boundary checking operation, this method is slower than operator()(). Use it when
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
liveimage_srv/CImg.h:       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
liveimage_srv/CImg.h:      return (*this)(x<0?0:(x>=width()?width() - 1:x),y,z,c);
liveimage_srv/CImg.h:    //! Access to a pixel value, using Neumann boundary conditions for the X-coordinate \const.
liveimage_srv/CImg.h:      return (*this)(x<0?0:(x>=width()?width() - 1:x),y,z,c);
liveimage_srv/CImg.h:    //! Access to a pixel value, using Dirichlet boundary conditions for the X and Y-coordinates.
liveimage_srv/CImg.h:       Similar to atX(int,int,int,int,const T), except that boundary checking is performed both on X and Y-coordinates.
liveimage_srv/CImg.h:    //! Access to a pixel value, using Neumann boundary conditions for the X and Y-coordinates.
liveimage_srv/CImg.h:       Similar to atX(int,int,int,int), except that boundary checking is performed both on X and Y-coordinates.
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
liveimage_srv/CImg.h:      return (*this)(cimg::cut(x,0,width() - 1),
liveimage_srv/CImg.h:                     cimg::cut(y,0,height() - 1),z,c);
liveimage_srv/CImg.h:    //! Access to a pixel value, using Neumann boundary conditions for the X and Y-coordinates \const.
liveimage_srv/CImg.h:      return (*this)(cimg::cut(x,0,width() - 1),
liveimage_srv/CImg.h:                     cimg::cut(y,0,height() - 1),z,c);
liveimage_srv/CImg.h:    //! Access to a pixel value, using Dirichlet boundary conditions for the X,Y and Z-coordinates.
liveimage_srv/CImg.h:       X,Y and Z-coordinates.
liveimage_srv/CImg.h:    //! Access to a pixel value, using Dirichlet boundary conditions for the X,Y and Z-coordinates \const.
liveimage_srv/CImg.h:    //! Access to a pixel value, using Neumann boundary conditions for the X,Y and Z-coordinates.
liveimage_srv/CImg.h:       Similar to atX(int,int,int,int), except that boundary checking is performed both on X,Y and Z-coordinates.
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
liveimage_srv/CImg.h:      return (*this)(cimg::cut(x,0,width() - 1),
liveimage_srv/CImg.h:                     cimg::cut(y,0,height() - 1),
liveimage_srv/CImg.h:                     cimg::cut(z,0,depth() - 1),c);
liveimage_srv/CImg.h:    //! Access to a pixel value, using Neumann boundary conditions for the X,Y and Z-coordinates \const.
liveimage_srv/CImg.h:      return (*this)(cimg::cut(x,0,width() - 1),
liveimage_srv/CImg.h:                     cimg::cut(y,0,height() - 1),
liveimage_srv/CImg.h:                     cimg::cut(z,0,depth() - 1),c);
liveimage_srv/CImg.h:       X,Y,Z and C-coordinates.
liveimage_srv/CImg.h:       Similar to atX(int,int,int,int), except that boundary checking is performed on all X,Y,Z and C-coordinates.
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
liveimage_srv/CImg.h:      return (*this)(cimg::cut(x,0,width() - 1),
liveimage_srv/CImg.h:                     cimg::cut(y,0,height() - 1),
liveimage_srv/CImg.h:                     cimg::cut(z,0,depth() - 1),
liveimage_srv/CImg.h:                     cimg::cut(c,0,spectrum() - 1));
liveimage_srv/CImg.h:      return (*this)(cimg::cut(x,0,width() - 1),
liveimage_srv/CImg.h:                     cimg::cut(y,0,height() - 1),
liveimage_srv/CImg.h:                     cimg::cut(z,0,depth() - 1),
liveimage_srv/CImg.h:                     cimg::cut(c,0,spectrum() - 1));
liveimage_srv/CImg.h:    //! Return pixel value, using linear interpolation and Dirichlet boundary conditions for the X-coordinate.
liveimage_srv/CImg.h:       Return a linearly-interpolated pixel value of the image instance located at (\c fx,\c y,\c z,\c c),
liveimage_srv/CImg.h:       or a specified default value in case of out-of-bounds access along the X-axis.
liveimage_srv/CImg.h:       \param fx X-coordinate of the pixel value (float-valued).
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       - Similar to atX(int,int,int,int,const T), except that the returned pixel value is approximated by
liveimage_srv/CImg.h:         a linear interpolation along the X-axis, if corresponding coordinates are not integers.
liveimage_srv/CImg.h:       - The type of the returned pixel value is extended to \c float, if the pixel type \c T is not float-valued.
liveimage_srv/CImg.h:       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
liveimage_srv/CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1;
liveimage_srv/CImg.h:        dx = fx - x;
liveimage_srv/CImg.h:      return Ic + dx*(In - Ic);
liveimage_srv/CImg.h:    //! Return pixel value, using linear interpolation and Neumann boundary conditions for the X-coordinate.
liveimage_srv/CImg.h:       Return a linearly-interpolated pixel value of the image instance located at (\c fx,\c y,\c z,\c c),
liveimage_srv/CImg.h:       or the value of the nearest pixel location in the image instance in case of out-of-bounds access along
liveimage_srv/CImg.h:       the X-axis.
liveimage_srv/CImg.h:       \param fx X-coordinate of the pixel value (float-valued).
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       - Similar to linear_atX(float,int,int,int,const T) const, except that an out-of-bounds access returns
liveimage_srv/CImg.h:         the value of the nearest pixel in the image instance, regarding the specified X-coordinate.
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
liveimage_srv/CImg.h:       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
liveimage_srv/CImg.h:        nfx = cimg::cut(fx,0,width() - 1);
liveimage_srv/CImg.h:        dx = nfx - x;
liveimage_srv/CImg.h:      return Ic + dx*(In - Ic);
liveimage_srv/CImg.h:    //! Return pixel value, using linear interpolation and periodic boundary conditions for the X-coordinate.
liveimage_srv/CImg.h:        nfx = cimg::mod(fx,_width - 0.5f);
liveimage_srv/CImg.h:        dx = nfx - x;
liveimage_srv/CImg.h:      return Ic + dx*(In - Ic);
liveimage_srv/CImg.h:    //! Return pixel value, using linear interpolation and Dirichlet boundary conditions for the X and Y-coordinates.
liveimage_srv/CImg.h:       boundary checking are achieved both for X and Y-coordinates.
liveimage_srv/CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1,
liveimage_srv/CImg.h:        y = (int)fy - (fy>=0?0:1), ny = y + 1;
liveimage_srv/CImg.h:        dx = fx - x,
liveimage_srv/CImg.h:        dy = fy - y;
liveimage_srv/CImg.h:      return Icc + (Inc - Icc + (Icc + Inn - Icn - Inc)*dy)*dx + (Icn - Icc)*dy;
liveimage_srv/CImg.h:    //! Return pixel value, using linear interpolation and Neumann boundary conditions for the X and Y-coordinates.
liveimage_srv/CImg.h:       are achieved both for X and Y-coordinates.
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
liveimage_srv/CImg.h:        nfx = cimg::cut(fx,0,width() - 1),
liveimage_srv/CImg.h:        nfy = cimg::cut(fy,0,height() - 1);
liveimage_srv/CImg.h:        dx = nfx - x,
liveimage_srv/CImg.h:        dy = nfy - y;
liveimage_srv/CImg.h:      return Icc + (Inc - Icc + (Icc + Inn - Icn - Inc)*dy)*dx + (Icn - Icc)*dy;
liveimage_srv/CImg.h:    //! Return pixel value, using linear interpolation and periodic boundary conditions for the X and Y-coordinates.
liveimage_srv/CImg.h:        nfx = cimg::mod(fx,_width - 0.5f),
liveimage_srv/CImg.h:        nfy = cimg::mod(fy,_height - 0.5f);
liveimage_srv/CImg.h:        dx = nfx - x,
liveimage_srv/CImg.h:        dy = nfy - y;
liveimage_srv/CImg.h:      return Icc + (Inc - Icc + (Icc + Inn - Icn - Inc)*dy)*dx + (Icn - Icc)*dy;
liveimage_srv/CImg.h:    //! Return pixel value, using linear interpolation and Dirichlet boundary conditions for the X,Y and Z-coordinates.
liveimage_srv/CImg.h:       boundary checking are achieved both for X,Y and Z-coordinates.
liveimage_srv/CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1,
liveimage_srv/CImg.h:        y = (int)fy - (fy>=0?0:1), ny = y + 1,
liveimage_srv/CImg.h:        z = (int)fz - (fz>=0?0:1), nz = z + 1;
liveimage_srv/CImg.h:        dx = fx - x,
liveimage_srv/CImg.h:        dy = fy - y,
liveimage_srv/CImg.h:        dz = fz - z;
liveimage_srv/CImg.h:        (Incc - Iccc +
liveimage_srv/CImg.h:         (Iccc + Innc - Icnc - Incc +
liveimage_srv/CImg.h:          (Iccn + Innn + Icnc + Incc - Icnn - Incn - Iccc - Innc)*dz)*dy +
liveimage_srv/CImg.h:         (Iccc + Incn - Iccn - Incc)*dz)*dx +
liveimage_srv/CImg.h:        (Icnc - Iccc +
liveimage_srv/CImg.h:         (Iccc + Icnn - Iccn - Icnc)*dz)*dy +
liveimage_srv/CImg.h:        (Iccn - Iccc)*dz;
liveimage_srv/CImg.h:    //! Return pixel value, using linear interpolation and Neumann boundary conditions for the X,Y and Z-coordinates.
liveimage_srv/CImg.h:       are achieved both for X,Y and Z-coordinates.
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
liveimage_srv/CImg.h:        nfx = cimg::cut(fx,0,width() - 1),
liveimage_srv/CImg.h:        nfy = cimg::cut(fy,0,height() - 1),
liveimage_srv/CImg.h:        nfz = cimg::cut(fz,0,depth() - 1);
liveimage_srv/CImg.h:        dx = nfx - x,
liveimage_srv/CImg.h:        dy = nfy - y,
liveimage_srv/CImg.h:        dz = nfz - z;
liveimage_srv/CImg.h:        (Incc - Iccc +
liveimage_srv/CImg.h:         (Iccc + Innc - Icnc - Incc +
liveimage_srv/CImg.h:          (Iccn + Innn + Icnc + Incc - Icnn - Incn - Iccc - Innc)*dz)*dy +
liveimage_srv/CImg.h:         (Iccc + Incn - Iccn - Incc)*dz)*dx +
liveimage_srv/CImg.h:        (Icnc - Iccc +
liveimage_srv/CImg.h:         (Iccc + Icnn - Iccn - Icnc)*dz)*dy +
liveimage_srv/CImg.h:        (Iccn - Iccc)*dz;
liveimage_srv/CImg.h:    //! Return pixel value, using linear interpolation and periodic boundary conditions for the X,Y and Z-coordinates.
liveimage_srv/CImg.h:        nfx = cimg::mod(fx,_width - 0.5f),
liveimage_srv/CImg.h:        nfy = cimg::mod(fy,_height - 0.5f),
liveimage_srv/CImg.h:        nfz = cimg::mod(fz,_depth - 0.5f);
liveimage_srv/CImg.h:        dx = nfx - x,
liveimage_srv/CImg.h:        dy = nfy - y,
liveimage_srv/CImg.h:        dz = nfz - z;
liveimage_srv/CImg.h:        (Incc - Iccc +
liveimage_srv/CImg.h:         (Iccc + Innc - Icnc - Incc +
liveimage_srv/CImg.h:          (Iccn + Innn + Icnc + Incc - Icnn - Incn - Iccc - Innc)*dz)*dy +
liveimage_srv/CImg.h:         (Iccc + Incn - Iccn - Incc)*dz)*dx +
liveimage_srv/CImg.h:        (Icnc - Iccc +
liveimage_srv/CImg.h:         (Iccc + Icnn - Iccn - Icnc)*dz)*dy +
liveimage_srv/CImg.h:        (Iccn - Iccc)*dz;
liveimage_srv/CImg.h:    //! Return pixel value, using linear interpolation and Dirichlet boundary conditions for all X,Y,Z,C-coordinates.
liveimage_srv/CImg.h:       boundary checking are achieved for all X,Y,Z and C-coordinates.
liveimage_srv/CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1,
liveimage_srv/CImg.h:        y = (int)fy - (fy>=0?0:1), ny = y + 1,
liveimage_srv/CImg.h:        z = (int)fz - (fz>=0?0:1), nz = z + 1,
liveimage_srv/CImg.h:        c = (int)fc - (fc>=0?0:1), nc = c + 1;
liveimage_srv/CImg.h:        dx = fx - x,
liveimage_srv/CImg.h:        dy = fy - y,
liveimage_srv/CImg.h:        dz = fz - z,
liveimage_srv/CImg.h:        dc = fc - c;
liveimage_srv/CImg.h:        dx*(Inccc - Icccc +
liveimage_srv/CImg.h:            dy*(Icccc + Inncc - Icncc - Inccc +
liveimage_srv/CImg.h:                dz*(Iccnc + Innnc + Icncc + Inccc - Icnnc - Incnc - Icccc - Inncc +
liveimage_srv/CImg.h:                    dc*(Iccnn + Innnn + Icncn + Inccn + Icnnc + Incnc + Icccc + Inncc -
liveimage_srv/CImg.h:                        Icnnn - Incnn - Icccn - Inncn - Iccnc - Innnc - Icncc - Inccc)) +
liveimage_srv/CImg.h:                dc*(Icccn + Inncn + Icncc + Inccc - Icncn - Inccn - Icccc - Inncc)) +
liveimage_srv/CImg.h:            dz*(Icccc + Incnc - Iccnc - Inccc +
liveimage_srv/CImg.h:                dc*(Icccn + Incnn + Iccnc + Inccc - Iccnn - Inccn - Icccc - Incnc)) +
liveimage_srv/CImg.h:            dc*(Icccc + Inccn - Inccc - Icccn)) +
liveimage_srv/CImg.h:        dy*(Icncc - Icccc +
liveimage_srv/CImg.h:            dz*(Icccc + Icnnc - Iccnc - Icncc +
liveimage_srv/CImg.h:                dc*(Icccn + Icnnn + Iccnc + Icncc - Iccnn - Icncn - Icccc - Icnnc)) +
liveimage_srv/CImg.h:            dc*(Icccc + Icncn - Icncc - Icccn)) +
liveimage_srv/CImg.h:        dz*(Iccnc - Icccc +
liveimage_srv/CImg.h:            dc*(Icccc + Iccnn - Iccnc - Icccn)) +
liveimage_srv/CImg.h:        dc*(Icccn  -Icccc);
liveimage_srv/CImg.h:    //! Return pixel value, using linear interpolation and Neumann boundary conditions for all X,Y,Z and C-coordinates.
liveimage_srv/CImg.h:       are achieved for all X,Y,Z and C-coordinates.
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
liveimage_srv/CImg.h:        nfx = cimg::cut(fx,0,width() - 1),
liveimage_srv/CImg.h:        nfy = cimg::cut(fy,0,height() - 1),
liveimage_srv/CImg.h:        nfz = cimg::cut(fz,0,depth() - 1),
liveimage_srv/CImg.h:        nfc = cimg::cut(fc,0,spectrum() - 1);
liveimage_srv/CImg.h:        dx = nfx - x,
liveimage_srv/CImg.h:        dy = nfy - y,
liveimage_srv/CImg.h:        dz = nfz - z,
liveimage_srv/CImg.h:        dc = nfc - c;
liveimage_srv/CImg.h:        dx*(Inccc - Icccc +
liveimage_srv/CImg.h:            dy*(Icccc + Inncc - Icncc - Inccc +
liveimage_srv/CImg.h:                dz*(Iccnc + Innnc + Icncc + Inccc - Icnnc - Incnc - Icccc - Inncc +
liveimage_srv/CImg.h:                    dc*(Iccnn + Innnn + Icncn + Inccn + Icnnc + Incnc + Icccc + Inncc -
liveimage_srv/CImg.h:                        Icnnn - Incnn - Icccn - Inncn - Iccnc - Innnc - Icncc - Inccc)) +
liveimage_srv/CImg.h:                dc*(Icccn + Inncn + Icncc + Inccc - Icncn - Inccn - Icccc - Inncc)) +
liveimage_srv/CImg.h:            dz*(Icccc + Incnc - Iccnc - Inccc +
liveimage_srv/CImg.h:                dc*(Icccn + Incnn + Iccnc + Inccc - Iccnn - Inccn - Icccc - Incnc)) +
liveimage_srv/CImg.h:            dc*(Icccc + Inccn - Inccc - Icccn)) +
liveimage_srv/CImg.h:        dy*(Icncc - Icccc +
liveimage_srv/CImg.h:            dz*(Icccc + Icnnc - Iccnc - Icncc +
liveimage_srv/CImg.h:                dc*(Icccn + Icnnn + Iccnc + Icncc - Iccnn - Icncn - Icccc - Icnnc)) +
liveimage_srv/CImg.h:            dc*(Icccc + Icncn - Icncc - Icccn)) +
liveimage_srv/CImg.h:        dz*(Iccnc - Icccc +
liveimage_srv/CImg.h:            dc*(Icccc + Iccnn - Iccnc - Icccn)) +
liveimage_srv/CImg.h:        dc*(Icccn - Icccc);
liveimage_srv/CImg.h:    //! Return pixel value, using linear interpolation and periodic boundary conditions for all X,Y,Z and C-coordinates.
liveimage_srv/CImg.h:        nfx = cimg::mod(fx,_width - 0.5f),
liveimage_srv/CImg.h:        nfy = cimg::mod(fy,_height - 0.5f),
liveimage_srv/CImg.h:        nfz = cimg::mod(fz,_depth - 0.5f),
liveimage_srv/CImg.h:        nfc = cimg::mod(fc,_spectrum - 0.5f);
liveimage_srv/CImg.h:        dx = nfx - x,
liveimage_srv/CImg.h:        dy = nfy - y,
liveimage_srv/CImg.h:        dz = nfz - z,
liveimage_srv/CImg.h:        dc = nfc - c;
liveimage_srv/CImg.h:        dx*(Inccc - Icccc +
liveimage_srv/CImg.h:            dy*(Icccc + Inncc - Icncc - Inccc +
liveimage_srv/CImg.h:                dz*(Iccnc + Innnc + Icncc + Inccc - Icnnc - Incnc - Icccc - Inncc +
liveimage_srv/CImg.h:                    dc*(Iccnn + Innnn + Icncn + Inccn + Icnnc + Incnc + Icccc + Inncc -
liveimage_srv/CImg.h:                        Icnnn - Incnn - Icccn - Inncn - Iccnc - Innnc - Icncc - Inccc)) +
liveimage_srv/CImg.h:                dc*(Icccn + Inncn + Icncc + Inccc - Icncn - Inccn - Icccc - Inncc)) +
liveimage_srv/CImg.h:            dz*(Icccc + Incnc - Iccnc - Inccc +
liveimage_srv/CImg.h:                dc*(Icccn + Incnn + Iccnc + Inccc - Iccnn - Inccn - Icccc - Incnc)) +
liveimage_srv/CImg.h:            dc*(Icccc + Inccn - Inccc - Icccn)) +
liveimage_srv/CImg.h:        dy*(Icncc - Icccc +
liveimage_srv/CImg.h:            dz*(Icccc + Icnnc - Iccnc - Icncc +
liveimage_srv/CImg.h:                dc*(Icccn + Icnnn + Iccnc + Icncc - Iccnn - Icncn - Icccc - Icnnc)) +
liveimage_srv/CImg.h:            dc*(Icccc + Icncn - Icncc - Icccn)) +
liveimage_srv/CImg.h:        dz*(Iccnc - Icccc +
liveimage_srv/CImg.h:            dc*(Icccc + Iccnn - Iccnc - Icccn)) +
liveimage_srv/CImg.h:        dc*(Icccn - Icccc);
liveimage_srv/CImg.h:    //! Return pixel value, using cubic interpolation and Dirichlet boundary conditions for the X-coordinate.
liveimage_srv/CImg.h:       Return a cubicly-interpolated pixel value of the image instance located at (\c fx,\c y,\c z,\c c),
liveimage_srv/CImg.h:       or a specified default value in case of out-of-bounds access along the X-axis.
liveimage_srv/CImg.h:       \param fx d X-coordinate of the pixel value (float-valued).
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       - Similar to linear_atX(float,int,int,int,const T) const, except that the returned pixel value is
liveimage_srv/CImg.h:         approximated by a \e cubic interpolation along the X-axis.
liveimage_srv/CImg.h:       - The type of the returned pixel value is extended to \c float, if the pixel type \c T is not float-valued.
liveimage_srv/CImg.h:       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
liveimage_srv/CImg.h:        x = (int)fx - (fx>=0?0:1), px = x - 1, nx = x + 1, ax = x + 2;
liveimage_srv/CImg.h:        dx = fx - x;
liveimage_srv/CImg.h:      return Ic + 0.5f*(dx*(-Ip + In) + dx*dx*(2*Ip - 5*Ic + 4*In - Ia) + dx*dx*dx*(-Ip + 3*Ic - 3*In + Ia));
liveimage_srv/CImg.h:    //! Return clamped pixel value, using cubic interpolation and Dirichlet boundary conditions for the X-coordinate.
liveimage_srv/CImg.h:    //! Return pixel value, using cubic interpolation and Neumann boundary conditions for the X-coordinate.
liveimage_srv/CImg.h:       Return a cubicly-interpolated pixel value of the image instance located at (\c fx,\c y,\c z,\c c),
liveimage_srv/CImg.h:       or the value of the nearest pixel location in the image instance in case of out-of-bounds access
liveimage_srv/CImg.h:       along the X-axis. The cubic interpolation uses Hermite splines.
liveimage_srv/CImg.h:       \param fx X-coordinate of the pixel value (float-valued).
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       - Similar to cubic_atX(float,int,int,int,const T) const, except that the returned pixel value is
liveimage_srv/CImg.h:         approximated by a cubic interpolation along the X-axis.
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
liveimage_srv/CImg.h:       - There is \e no boundary checking performed for the Y,Z and C-coordinates, so they must be inside image bounds.
liveimage_srv/CImg.h:        nfx = cimg::type<float>::is_nan(fx)?0:cimg::cut(fx,0,width() - 1);
liveimage_srv/CImg.h:        dx = nfx - x;
liveimage_srv/CImg.h:        px = x - 1<0?0:x - 1, nx = dx>0?x + 1:x, ax = x + 2>=width()?width() - 1:x + 2;
liveimage_srv/CImg.h:      return Ic + 0.5f*(dx*(-Ip + In) + dx*dx*(2*Ip - 5*Ic + 4*In - Ia) + dx*dx*dx*(-Ip + 3*Ic - 3*In + Ia));
liveimage_srv/CImg.h:    //! Return clamped pixel value, using cubic interpolation and Neumann boundary conditions for the X-coordinate.
liveimage_srv/CImg.h:    //! Return pixel value, using cubic interpolation and periodic boundary conditions for the X-coordinate.
liveimage_srv/CImg.h:        nfx = cimg::type<float>::is_nan(fx)?0:cimg::mod(fx,_width - 0.5f);
liveimage_srv/CImg.h:        dx = nfx - x;
liveimage_srv/CImg.h:        px = cimg::mod(x - 1,width()), nx = cimg::mod(x + 1,width()), ax = cimg::mod(x + 2,width());
liveimage_srv/CImg.h:      return Ic + 0.5f*(dx*(-Ip + In) + dx*dx*(2*Ip - 5*Ic + 4*In - Ia) + dx*dx*dx*(-Ip + 3*Ic - 3*In + Ia));
liveimage_srv/CImg.h:    //! Return pixel value, using cubic interpolation and Dirichlet boundary conditions for the X and Y-coordinates.
liveimage_srv/CImg.h:       are achieved both for X and Y-coordinates.
liveimage_srv/CImg.h:        x = (int)fx - (fx>=0?0:1), px = x - 1, nx = x + 1, ax = x + 2,
liveimage_srv/CImg.h:        y = (int)fy - (fy>=0?0:1), py = y - 1, ny = y + 1, ay = y + 2;
liveimage_srv/CImg.h:      const float dx = fx - x, dy = fy - y;
liveimage_srv/CImg.h:        Ip = Icp + 0.5f*(dx*(-Ipp + Inp) + dx*dx*(2*Ipp - 5*Icp + 4*Inp - Iap) + dx*dx*dx*(-Ipp + 3*Icp - 3*Inp + Iap)),
liveimage_srv/CImg.h:        Ic = Icc + 0.5f*(dx*(-Ipc + Inc) + dx*dx*(2*Ipc - 5*Icc + 4*Inc - Iac) + dx*dx*dx*(-Ipc + 3*Icc - 3*Inc + Iac)),
liveimage_srv/CImg.h:        In = Icn + 0.5f*(dx*(-Ipn + Inn) + dx*dx*(2*Ipn - 5*Icn + 4*Inn - Ian) + dx*dx*dx*(-Ipn + 3*Icn - 3*Inn + Ian)),
liveimage_srv/CImg.h:        Ia = Ica + 0.5f*(dx*(-Ipa + Ina) + dx*dx*(2*Ipa - 5*Ica + 4*Ina - Iaa) + dx*dx*dx*(-Ipa + 3*Ica - 3*Ina + Iaa));
liveimage_srv/CImg.h:      return Ic + 0.5f*(dy*(-Ip + In) + dy*dy*(2*Ip - 5*Ic + 4*In - Ia) + dy*dy*dy*(-Ip + 3*Ic - 3*In + Ia));
liveimage_srv/CImg.h:    //! Return clamped pixel value, using cubic interpolation and Dirichlet boundary conditions for the X,Y-coordinates.
liveimage_srv/CImg.h:    //! Return pixel value, using cubic interpolation and Neumann boundary conditions for the X and Y-coordinates.
liveimage_srv/CImg.h:       are achieved for both X and Y-coordinates.
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
liveimage_srv/CImg.h:        nfx = cimg::type<float>::is_nan(fx)?0:cimg::cut(fx,0,width() - 1),
liveimage_srv/CImg.h:        nfy = cimg::type<float>::is_nan(fy)?0:cimg::cut(fy,0,height() - 1);
liveimage_srv/CImg.h:      const float dx = nfx - x, dy = nfy - y;
liveimage_srv/CImg.h:        px = x - 1<0?0:x - 1, nx = dx<=0?x:x + 1, ax = x + 2>=width()?width() - 1:x + 2,
liveimage_srv/CImg.h:        py = y - 1<0?0:y - 1, ny = dy<=0?y:y + 1, ay = y + 2>=height()?height() - 1:y + 2;
liveimage_srv/CImg.h:        Ip = Icp + 0.5f*(dx*(-Ipp + Inp) + dx*dx*(2*Ipp - 5*Icp + 4*Inp - Iap) + dx*dx*dx*(-Ipp + 3*Icp - 3*Inp + Iap)),
liveimage_srv/CImg.h:        Ic = Icc + 0.5f*(dx*(-Ipc + Inc) + dx*dx*(2*Ipc - 5*Icc + 4*Inc - Iac) + dx*dx*dx*(-Ipc + 3*Icc - 3*Inc + Iac)),
liveimage_srv/CImg.h:        In = Icn + 0.5f*(dx*(-Ipn + Inn) + dx*dx*(2*Ipn - 5*Icn + 4*Inn - Ian) + dx*dx*dx*(-Ipn + 3*Icn - 3*Inn + Ian)),
liveimage_srv/CImg.h:        Ia = Ica + 0.5f*(dx*(-Ipa + Ina) + dx*dx*(2*Ipa - 5*Ica + 4*Ina - Iaa) + dx*dx*dx*(-Ipa + 3*Ica - 3*Ina + Iaa));
liveimage_srv/CImg.h:      return Ic + 0.5f*(dy*(-Ip + In) + dy*dy*(2*Ip - 5*Ic + 4*In - Ia) + dy*dy*dy*(-Ip + 3*Ic - 3*In + Ia));
liveimage_srv/CImg.h:    //! Return clamped pixel value, using cubic interpolation and Neumann boundary conditions for the X,Y-coordinates.
liveimage_srv/CImg.h:    //! Return pixel value, using cubic interpolation and periodic boundary conditions for the X and Y-coordinates.
liveimage_srv/CImg.h:        nfx = cimg::type<float>::is_nan(fx)?0:cimg::mod(fx,_width - 0.5f),
liveimage_srv/CImg.h:        nfy = cimg::type<float>::is_nan(fy)?0:cimg::mod(fy,_height - 0.5f);
liveimage_srv/CImg.h:      const float dx = nfx - x, dy = nfy - y;
liveimage_srv/CImg.h:        px = cimg::mod(x - 1,width()), nx = cimg::mod(x + 1,width()), ax = cimg::mod(x + 2,width()),
liveimage_srv/CImg.h:        py = cimg::mod(y - 1,height()), ny = cimg::mod(y + 1,height()), ay = cimg::mod(y + 2,height());
liveimage_srv/CImg.h:        Ip = Icp + 0.5f*(dx*(-Ipp + Inp) + dx*dx*(2*Ipp - 5*Icp + 4*Inp - Iap) + dx*dx*dx*(-Ipp + 3*Icp - 3*Inp + Iap)),
liveimage_srv/CImg.h:        Ic = Icc + 0.5f*(dx*(-Ipc + Inc) + dx*dx*(2*Ipc - 5*Icc + 4*Inc - Iac) + dx*dx*dx*(-Ipc + 3*Icc - 3*Inc + Iac)),
liveimage_srv/CImg.h:        In = Icn + 0.5f*(dx*(-Ipn + Inn) + dx*dx*(2*Ipn - 5*Icn + 4*Inn - Ian) + dx*dx*dx*(-Ipn + 3*Icn - 3*Inn + Ian)),
liveimage_srv/CImg.h:        Ia = Ica + 0.5f*(dx*(-Ipa + Ina) + dx*dx*(2*Ipa - 5*Ica + 4*Ina - Iaa) + dx*dx*dx*(-Ipa + 3*Ica - 3*Ina + Iaa));
liveimage_srv/CImg.h:      return Ic + 0.5f*(dy*(-Ip + In) + dy*dy*(2*Ip - 5*Ic + 4*In - Ia) + dy*dy*dy*(-Ip + 3*Ic - 3*In + Ia));
liveimage_srv/CImg.h:    //! Return pixel value, using cubic interpolation and Dirichlet boundary conditions for the X,Y and Z-coordinates.
liveimage_srv/CImg.h:       are achieved both for X,Y and Z-coordinates.
liveimage_srv/CImg.h:        x = (int)fx - (fx>=0?0:1), px = x - 1, nx = x + 1, ax = x + 2,
liveimage_srv/CImg.h:        y = (int)fy - (fy>=0?0:1), py = y - 1, ny = y + 1, ay = y + 2,
liveimage_srv/CImg.h:        z = (int)fz - (fz>=0?0:1), pz = z - 1, nz = z + 1, az = z + 2;
liveimage_srv/CImg.h:      const float dx = fx - x, dy = fy - y, dz = fz - z;
liveimage_srv/CImg.h:        Ipp = Icpp + 0.5f*(dx*(-Ippp + Inpp) + dx*dx*(2*Ippp - 5*Icpp + 4*Inpp - Iapp) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ippp + 3*Icpp - 3*Inpp + Iapp)),
liveimage_srv/CImg.h:        Icp = Iccp + 0.5f*(dx*(-Ipcp + Incp) + dx*dx*(2*Ipcp - 5*Iccp + 4*Incp - Iacp) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipcp + 3*Iccp - 3*Incp + Iacp)),
liveimage_srv/CImg.h:        Inp = Icnp + 0.5f*(dx*(-Ipnp + Innp) + dx*dx*(2*Ipnp - 5*Icnp + 4*Innp - Ianp) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipnp + 3*Icnp - 3*Innp + Ianp)),
liveimage_srv/CImg.h:        Iap = Icap + 0.5f*(dx*(-Ipap + Inap) + dx*dx*(2*Ipap - 5*Icap + 4*Inap - Iaap) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipap + 3*Icap - 3*Inap + Iaap)),
liveimage_srv/CImg.h:        Ip = Icp + 0.5f*(dy*(-Ipp + Inp) + dy*dy*(2*Ipp - 5*Icp + 4*Inp - Iap) +
liveimage_srv/CImg.h:                         dy*dy*dy*(-Ipp + 3*Icp - 3*Inp + Iap)),
liveimage_srv/CImg.h:        Ipc = Icpc + 0.5f*(dx*(-Ippc + Inpc) + dx*dx*(2*Ippc - 5*Icpc + 4*Inpc - Iapc) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ippc + 3*Icpc - 3*Inpc + Iapc)),
liveimage_srv/CImg.h:        Icc = Iccc + 0.5f*(dx*(-Ipcc + Incc) + dx*dx*(2*Ipcc - 5*Iccc + 4*Incc - Iacc) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipcc + 3*Iccc - 3*Incc + Iacc)),
liveimage_srv/CImg.h:        Inc = Icnc + 0.5f*(dx*(-Ipnc + Innc) + dx*dx*(2*Ipnc - 5*Icnc + 4*Innc - Ianc) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipnc + 3*Icnc - 3*Innc + Ianc)),
liveimage_srv/CImg.h:        Iac = Icac + 0.5f*(dx*(-Ipac + Inac) + dx*dx*(2*Ipac - 5*Icac + 4*Inac - Iaac) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipac + 3*Icac - 3*Inac + Iaac)),
liveimage_srv/CImg.h:        Ic = Icc + 0.5f*(dy*(-Ipc + Inc) + dy*dy*(2*Ipc - 5*Icc + 4*Inc - Iac) +
liveimage_srv/CImg.h:                         dy*dy*dy*(-Ipc + 3*Icc - 3*Inc + Iac)),
liveimage_srv/CImg.h:        Ipn = Icpn + 0.5f*(dx*(-Ippn + Inpn) + dx*dx*(2*Ippn - 5*Icpn + 4*Inpn - Iapn) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ippn + 3*Icpn - 3*Inpn + Iapn)),
liveimage_srv/CImg.h:        Icn = Iccn + 0.5f*(dx*(-Ipcn + Incn) + dx*dx*(2*Ipcn - 5*Iccn + 4*Incn - Iacn) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipcn + 3*Iccn - 3*Incn + Iacn)),
liveimage_srv/CImg.h:        Inn = Icnn + 0.5f*(dx*(-Ipnn + Innn) + dx*dx*(2*Ipnn - 5*Icnn + 4*Innn - Iann) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipnn + 3*Icnn - 3*Innn + Iann)),
liveimage_srv/CImg.h:        Ian = Ican + 0.5f*(dx*(-Ipan + Inan) + dx*dx*(2*Ipan - 5*Ican + 4*Inan - Iaan) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipan + 3*Ican - 3*Inan + Iaan)),
liveimage_srv/CImg.h:        In = Icn + 0.5f*(dy*(-Ipn + Inn) + dy*dy*(2*Ipn - 5*Icn + 4*Inn - Ian) +
liveimage_srv/CImg.h:                         dy*dy*dy*(-Ipn + 3*Icn - 3*Inn + Ian)),
liveimage_srv/CImg.h:        Ipa = Icpa + 0.5f*(dx*(-Ippa + Inpa) + dx*dx*(2*Ippa - 5*Icpa + 4*Inpa - Iapa) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ippa + 3*Icpa - 3*Inpa + Iapa)),
liveimage_srv/CImg.h:        Ica = Icca + 0.5f*(dx*(-Ipca + Inca) + dx*dx*(2*Ipca - 5*Icca + 4*Inca - Iaca) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipca + 3*Icca - 3*Inca + Iaca)),
liveimage_srv/CImg.h:        Ina = Icna + 0.5f*(dx*(-Ipna + Inna) + dx*dx*(2*Ipna - 5*Icna + 4*Inna - Iana) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipna + 3*Icna - 3*Inna + Iana)),
liveimage_srv/CImg.h:        Iaa = Icaa + 0.5f*(dx*(-Ipaa + Inaa) + dx*dx*(2*Ipaa - 5*Icaa + 4*Inaa - Iaaa) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipaa + 3*Icaa - 3*Inaa + Iaaa)),
liveimage_srv/CImg.h:        Ia = Ica + 0.5f*(dy*(-Ipa + Ina) + dy*dy*(2*Ipa - 5*Ica + 4*Ina - Iaa) +
liveimage_srv/CImg.h:                         dy*dy*dy*(-Ipa + 3*Ica - 3*Ina + Iaa));
liveimage_srv/CImg.h:      return Ic + 0.5f*(dz*(-Ip + In) + dz*dz*(2*Ip - 5*Ic + 4*In - Ia) + dz*dz*dz*(-Ip + 3*Ic - 3*In + Ia));
liveimage_srv/CImg.h:    //! Return clamped pixel value, using cubic interpolation and Dirichlet boundary conditions for the XYZ-coordinates.
liveimage_srv/CImg.h:    //! Return pixel value, using cubic interpolation and Neumann boundary conditions for the X,Y and Z-coordinates.
liveimage_srv/CImg.h:       are achieved both for X,Y and Z-coordinates.
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
liveimage_srv/CImg.h:        nfx = cimg::type<float>::is_nan(fx)?0:cimg::cut(fx,0,width() - 1),
liveimage_srv/CImg.h:        nfy = cimg::type<float>::is_nan(fy)?0:cimg::cut(fy,0,height() - 1),
liveimage_srv/CImg.h:        nfz = cimg::type<float>::is_nan(fz)?0:cimg::cut(fz,0,depth() - 1);
liveimage_srv/CImg.h:      const float dx = nfx - x, dy = nfy - y, dz = nfz - z;
liveimage_srv/CImg.h:        px = x - 1<0?0:x - 1, nx = dx>0?x + 1:x, ax = x + 2>=width()?width() - 1:x + 2,
liveimage_srv/CImg.h:        py = y - 1<0?0:y - 1, ny = dy>0?y + 1:y, ay = y + 2>=height()?height() - 1:y + 2,
liveimage_srv/CImg.h:        pz = z - 1<0?0:z - 1, nz = dz>0?z + 1:z, az = z + 2>=depth()?depth() - 1:z + 2;
liveimage_srv/CImg.h:        Ipp = Icpp + 0.5f*(dx*(-Ippp + Inpp) + dx*dx*(2*Ippp - 5*Icpp + 4*Inpp - Iapp) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ippp + 3*Icpp - 3*Inpp + Iapp)),
liveimage_srv/CImg.h:        Icp = Iccp + 0.5f*(dx*(-Ipcp + Incp) + dx*dx*(2*Ipcp - 5*Iccp + 4*Incp - Iacp) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipcp + 3*Iccp - 3*Incp + Iacp)),
liveimage_srv/CImg.h:        Inp = Icnp + 0.5f*(dx*(-Ipnp + Innp) + dx*dx*(2*Ipnp - 5*Icnp + 4*Innp - Ianp) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipnp + 3*Icnp - 3*Innp + Ianp)),
liveimage_srv/CImg.h:        Iap = Icap + 0.5f*(dx*(-Ipap + Inap) + dx*dx*(2*Ipap - 5*Icap + 4*Inap - Iaap) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipap + 3*Icap - 3*Inap + Iaap)),
liveimage_srv/CImg.h:        Ip = Icp + 0.5f*(dy*(-Ipp + Inp) + dy*dy*(2*Ipp - 5*Icp + 4*Inp - Iap) +
liveimage_srv/CImg.h:                         dy*dy*dy*(-Ipp + 3*Icp - 3*Inp + Iap)),
liveimage_srv/CImg.h:        Ipc = Icpc + 0.5f*(dx*(-Ippc + Inpc) + dx*dx*(2*Ippc - 5*Icpc + 4*Inpc - Iapc) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ippc + 3*Icpc - 3*Inpc + Iapc)),
liveimage_srv/CImg.h:        Icc = Iccc + 0.5f*(dx*(-Ipcc + Incc) + dx*dx*(2*Ipcc - 5*Iccc + 4*Incc - Iacc) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipcc + 3*Iccc - 3*Incc + Iacc)),
liveimage_srv/CImg.h:        Inc = Icnc + 0.5f*(dx*(-Ipnc + Innc) + dx*dx*(2*Ipnc - 5*Icnc + 4*Innc - Ianc) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipnc + 3*Icnc - 3*Innc + Ianc)),
liveimage_srv/CImg.h:        Iac = Icac + 0.5f*(dx*(-Ipac + Inac) + dx*dx*(2*Ipac - 5*Icac + 4*Inac - Iaac) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipac + 3*Icac - 3*Inac + Iaac)),
liveimage_srv/CImg.h:        Ic = Icc + 0.5f*(dy*(-Ipc + Inc) + dy*dy*(2*Ipc - 5*Icc + 4*Inc - Iac) +
liveimage_srv/CImg.h:                         dy*dy*dy*(-Ipc + 3*Icc - 3*Inc + Iac)),
liveimage_srv/CImg.h:        Ipn = Icpn + 0.5f*(dx*(-Ippn + Inpn) + dx*dx*(2*Ippn - 5*Icpn + 4*Inpn - Iapn) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ippn + 3*Icpn - 3*Inpn + Iapn)),
liveimage_srv/CImg.h:        Icn = Iccn + 0.5f*(dx*(-Ipcn + Incn) + dx*dx*(2*Ipcn - 5*Iccn + 4*Incn - Iacn) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipcn + 3*Iccn - 3*Incn + Iacn)),
liveimage_srv/CImg.h:        Inn = Icnn + 0.5f*(dx*(-Ipnn + Innn) + dx*dx*(2*Ipnn - 5*Icnn + 4*Innn - Iann) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipnn + 3*Icnn - 3*Innn + Iann)),
liveimage_srv/CImg.h:        Ian = Ican + 0.5f*(dx*(-Ipan + Inan) + dx*dx*(2*Ipan - 5*Ican + 4*Inan - Iaan) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipan + 3*Ican - 3*Inan + Iaan)),
liveimage_srv/CImg.h:        In = Icn + 0.5f*(dy*(-Ipn + Inn) + dy*dy*(2*Ipn - 5*Icn + 4*Inn - Ian) +
liveimage_srv/CImg.h:                         dy*dy*dy*(-Ipn + 3*Icn - 3*Inn + Ian)),
liveimage_srv/CImg.h:        Ipa = Icpa + 0.5f*(dx*(-Ippa + Inpa) + dx*dx*(2*Ippa - 5*Icpa + 4*Inpa - Iapa) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ippa + 3*Icpa - 3*Inpa + Iapa)),
liveimage_srv/CImg.h:        Ica = Icca + 0.5f*(dx*(-Ipca + Inca) + dx*dx*(2*Ipca - 5*Icca + 4*Inca - Iaca) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipca + 3*Icca - 3*Inca + Iaca)),
liveimage_srv/CImg.h:        Ina = Icna + 0.5f*(dx*(-Ipna + Inna) + dx*dx*(2*Ipna - 5*Icna + 4*Inna - Iana) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipna + 3*Icna - 3*Inna + Iana)),
liveimage_srv/CImg.h:        Iaa = Icaa + 0.5f*(dx*(-Ipaa + Inaa) + dx*dx*(2*Ipaa - 5*Icaa + 4*Inaa - Iaaa) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipaa + 3*Icaa - 3*Inaa + Iaaa)),
liveimage_srv/CImg.h:        Ia = Ica + 0.5f*(dy*(-Ipa + Ina) + dy*dy*(2*Ipa - 5*Ica + 4*Ina - Iaa) +
liveimage_srv/CImg.h:                         dy*dy*dy*(-Ipa + 3*Ica - 3*Ina + Iaa));
liveimage_srv/CImg.h:      return Ic + 0.5f*(dz*(-Ip + In) + dz*dz*(2*Ip - 5*Ic + 4*In - Ia) + dz*dz*dz*(-Ip + 3*Ic - 3*In + Ia));
liveimage_srv/CImg.h:    //! Return clamped pixel value, using cubic interpolation and Neumann boundary conditions for the XYZ-coordinates.
liveimage_srv/CImg.h:    //! Return pixel value, using cubic interpolation and Neumann boundary conditions for the X,Y and Z-coordinates.
liveimage_srv/CImg.h:       are achieved both for X,Y and Z-coordinates.
liveimage_srv/CImg.h:       - If you know your image instance is \e not empty, you may rather use the slightly faster method
liveimage_srv/CImg.h:        nfx = cimg::type<float>::is_nan(fx)?0:cimg::mod(fx,_width - 0.5f),
liveimage_srv/CImg.h:        nfy = cimg::type<float>::is_nan(fy)?0:cimg::mod(fy,_height - 0.5f),
liveimage_srv/CImg.h:        nfz = cimg::type<float>::is_nan(fz)?0:cimg::mod(fz,_depth - 0.5f);
liveimage_srv/CImg.h:      const float dx = nfx - x, dy = nfy - y, dz = nfz - z;
liveimage_srv/CImg.h:        px = cimg::mod(x - 1,width()), nx = cimg::mod(x + 1,width()), ax = cimg::mod(x + 2,width()),
liveimage_srv/CImg.h:        py = cimg::mod(y - 1,height()), ny = cimg::mod(y + 1,height()), ay = cimg::mod(y + 2,height()),
liveimage_srv/CImg.h:        pz = cimg::mod(z - 1,depth()), nz = cimg::mod(z + 1,depth()), az = cimg::mod(z + 2,depth());
liveimage_srv/CImg.h:        Ipp = Icpp + 0.5f*(dx*(-Ippp + Inpp) + dx*dx*(2*Ippp - 5*Icpp + 4*Inpp - Iapp) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ippp + 3*Icpp - 3*Inpp + Iapp)),
liveimage_srv/CImg.h:        Icp = Iccp + 0.5f*(dx*(-Ipcp + Incp) + dx*dx*(2*Ipcp - 5*Iccp + 4*Incp - Iacp) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipcp + 3*Iccp - 3*Incp + Iacp)),
liveimage_srv/CImg.h:        Inp = Icnp + 0.5f*(dx*(-Ipnp + Innp) + dx*dx*(2*Ipnp - 5*Icnp + 4*Innp - Ianp) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipnp + 3*Icnp - 3*Innp + Ianp)),
liveimage_srv/CImg.h:        Iap = Icap + 0.5f*(dx*(-Ipap + Inap) + dx*dx*(2*Ipap - 5*Icap + 4*Inap - Iaap) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipap + 3*Icap - 3*Inap + Iaap)),
liveimage_srv/CImg.h:        Ip = Icp + 0.5f*(dy*(-Ipp + Inp) + dy*dy*(2*Ipp - 5*Icp + 4*Inp - Iap) +
liveimage_srv/CImg.h:                         dy*dy*dy*(-Ipp + 3*Icp - 3*Inp + Iap)),
liveimage_srv/CImg.h:        Ipc = Icpc + 0.5f*(dx*(-Ippc + Inpc) + dx*dx*(2*Ippc - 5*Icpc + 4*Inpc - Iapc) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ippc + 3*Icpc - 3*Inpc + Iapc)),
liveimage_srv/CImg.h:        Icc = Iccc + 0.5f*(dx*(-Ipcc + Incc) + dx*dx*(2*Ipcc - 5*Iccc + 4*Incc - Iacc) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipcc + 3*Iccc - 3*Incc + Iacc)),
liveimage_srv/CImg.h:        Inc = Icnc + 0.5f*(dx*(-Ipnc + Innc) + dx*dx*(2*Ipnc - 5*Icnc + 4*Innc - Ianc) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipnc + 3*Icnc - 3*Innc + Ianc)),
liveimage_srv/CImg.h:        Iac = Icac + 0.5f*(dx*(-Ipac + Inac) + dx*dx*(2*Ipac - 5*Icac + 4*Inac - Iaac) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipac + 3*Icac - 3*Inac + Iaac)),
liveimage_srv/CImg.h:        Ic = Icc + 0.5f*(dy*(-Ipc + Inc) + dy*dy*(2*Ipc - 5*Icc + 4*Inc - Iac) +
liveimage_srv/CImg.h:                         dy*dy*dy*(-Ipc + 3*Icc - 3*Inc + Iac)),
liveimage_srv/CImg.h:        Ipn = Icpn + 0.5f*(dx*(-Ippn + Inpn) + dx*dx*(2*Ippn - 5*Icpn + 4*Inpn - Iapn) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ippn + 3*Icpn - 3*Inpn + Iapn)),
liveimage_srv/CImg.h:        Icn = Iccn + 0.5f*(dx*(-Ipcn + Incn) + dx*dx*(2*Ipcn - 5*Iccn + 4*Incn - Iacn) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipcn + 3*Iccn - 3*Incn + Iacn)),
liveimage_srv/CImg.h:        Inn = Icnn + 0.5f*(dx*(-Ipnn + Innn) + dx*dx*(2*Ipnn - 5*Icnn + 4*Innn - Iann) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipnn + 3*Icnn - 3*Innn + Iann)),
liveimage_srv/CImg.h:        Ian = Ican + 0.5f*(dx*(-Ipan + Inan) + dx*dx*(2*Ipan - 5*Ican + 4*Inan - Iaan) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipan + 3*Ican - 3*Inan + Iaan)),
liveimage_srv/CImg.h:        In = Icn + 0.5f*(dy*(-Ipn + Inn) + dy*dy*(2*Ipn - 5*Icn + 4*Inn - Ian) +
liveimage_srv/CImg.h:                         dy*dy*dy*(-Ipn + 3*Icn - 3*Inn + Ian)),
liveimage_srv/CImg.h:        Ipa = Icpa + 0.5f*(dx*(-Ippa + Inpa) + dx*dx*(2*Ippa - 5*Icpa + 4*Inpa - Iapa) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ippa + 3*Icpa - 3*Inpa + Iapa)),
liveimage_srv/CImg.h:        Ica = Icca + 0.5f*(dx*(-Ipca + Inca) + dx*dx*(2*Ipca - 5*Icca + 4*Inca - Iaca) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipca + 3*Icca - 3*Inca + Iaca)),
liveimage_srv/CImg.h:        Ina = Icna + 0.5f*(dx*(-Ipna + Inna) + dx*dx*(2*Ipna - 5*Icna + 4*Inna - Iana) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipna + 3*Icna - 3*Inna + Iana)),
liveimage_srv/CImg.h:        Iaa = Icaa + 0.5f*(dx*(-Ipaa + Inaa) + dx*dx*(2*Ipaa - 5*Icaa + 4*Inaa - Iaaa) +
liveimage_srv/CImg.h:                           dx*dx*dx*(-Ipaa + 3*Icaa - 3*Inaa + Iaaa)),
liveimage_srv/CImg.h:        Ia = Ica + 0.5f*(dy*(-Ipa + Ina) + dy*dy*(2*Ipa - 5*Ica + 4*Ina - Iaa) +
liveimage_srv/CImg.h:                         dy*dy*dy*(-Ipa + 3*Ica - 3*Ina + Iaa));
liveimage_srv/CImg.h:      return Ic + 0.5f*(dz*(-Ip + In) + dz*dz*(2*Ip - 5*Ic + 4*In - Ia) + dz*dz*dz*(-Ip + 3*Ic - 3*In + Ia));
liveimage_srv/CImg.h:    //! Set pixel value, using linear interpolation for the X-coordinates.
liveimage_srv/CImg.h:       the value is spread amongst several neighbors if the pixel coordinates are float-valued.
liveimage_srv/CImg.h:       \param fx X-coordinate of the pixel value (float-valued).
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       - Calling this method with out-of-bounds coordinates does nothing.
liveimage_srv/CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1;
liveimage_srv/CImg.h:        dx = fx - x;
liveimage_srv/CImg.h:          const float w1 = 1 - dx, w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:          const float w1 = dx, w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:    //! Set pixel value, using linear interpolation for the X and Y-coordinates.
liveimage_srv/CImg.h:       is achieved both for X and Y-coordinates.
liveimage_srv/CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1,
liveimage_srv/CImg.h:        y = (int)fy - (fy>=0?0:1), ny = y + 1;
liveimage_srv/CImg.h:        dx = fx - x,
liveimage_srv/CImg.h:        dy = fy - y;
liveimage_srv/CImg.h:            const float w1 = (1 - dx)*(1 - dy), w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:            const float w1 = dx*(1 - dy), w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:            const float w1 = (1 - dx)*dy, w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:            const float w1 = dx*dy, w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:    //! Set pixel value, using linear interpolation for the X,Y and Z-coordinates.
liveimage_srv/CImg.h:       is achieved both for X,Y and Z-coordinates.
liveimage_srv/CImg.h:        x = (int)fx - (fx>=0?0:1), nx = x + 1,
liveimage_srv/CImg.h:        y = (int)fy - (fy>=0?0:1), ny = y + 1,
liveimage_srv/CImg.h:        z = (int)fz - (fz>=0?0:1), nz = z + 1;
liveimage_srv/CImg.h:        dx = fx - x,
liveimage_srv/CImg.h:        dy = fy - y,
liveimage_srv/CImg.h:        dz = fz - z;
liveimage_srv/CImg.h:              const float w1 = (1 - dx)*(1 - dy)*(1 - dz), w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:              const float w1 = dx*(1 - dy)*(1 - dz), w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:              const float w1 = (1 - dx)*dy*(1 - dz), w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:              const float w1 = dx*dy*(1 - dz), w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:              const float w1 = (1 - dx)*(1 - dy)*dz, w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:              const float w1 = dx*(1 - dy)*dz, w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:              const float w1 = (1 - dx)*dy*dz, w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:              const float w1 = dx*dy*dz, w2 = is_added?1:(1 - w1);
liveimage_srv/CImg.h:    //! Return a C-string containing a list of all values of the image instance.
liveimage_srv/CImg.h:       \param separator A \c char character which specifies the separator between values in the returned C-string.
liveimage_srv/CImg.h:       \param format For float/double-values, tell the printf format used to generate the text representation
liveimage_srv/CImg.h:       - The returned image is never empty.
liveimage_srv/CImg.h:       - For an empty image instance, the returned string is <tt>""</tt>.
liveimage_srv/CImg.h:       - If \c max_size is equal to \c 0, there are no limits on the size of the returned string.
liveimage_srv/CImg.h:       - Otherwise, if the maximum number of string characters is exceeded, the value string is cut off
liveimage_srv/CImg.h:        item[printed_size - 1] = separator;
liveimage_srv/CImg.h:      if (max_size && res._width>=max_size) res.crop(0,max_size - 1);
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:       - A shared image do not own his pixel buffer data() and will not deallocate it on destruction.
liveimage_srv/CImg.h:       - Most of the time, a \c CImg<T> image instance will \e not be shared.
liveimage_srv/CImg.h:       - A shared image can only be obtained by a limited set of constructors and methods (see list below).
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       - Return \c true only if all these conditions are verified:
liveimage_srv/CImg.h:         - The image instance is \e not empty.
liveimage_srv/CImg.h:         - <tt>0<=x<=\ref width() - 1</tt>.
liveimage_srv/CImg.h:         - <tt>0<=y<=\ref height() - 1</tt>.
liveimage_srv/CImg.h:         - <tt>0<=z<=\ref depth() - 1</tt>.
liveimage_srv/CImg.h:         - <tt>0<=c<=\ref spectrum() - 1</tt>.
liveimage_srv/CImg.h:    //! Test if pixel value is inside image bounds and get its X,Y,Z and C-coordinates.
liveimage_srv/CImg.h:       \param[out] x X-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       \param[out] y Y-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       \param[out] z Z-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       \param[out] c C-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       - Useful to convert an offset to a buffer value into pixel value coordinates:
liveimage_srv/CImg.h:      ulongT off = (ulongT)(ppixel - _data);
liveimage_srv/CImg.h:    //! Test if pixel value is inside image bounds and get its X,Y and Z-coordinates.
liveimage_srv/CImg.h:       Similar to contains(const T&,t&,t&,t&,t&) const, except that only the X,Y and Z-coordinates are set.
liveimage_srv/CImg.h:      ulongT off = ((ulongT)(ppixel - _data))%whd;
liveimage_srv/CImg.h:    //! Test if pixel value is inside image bounds and get its X and Y-coordinates.
liveimage_srv/CImg.h:       Similar to contains(const T&,t&,t&,t&,t&) const, except that only the X and Y-coordinates are set.
liveimage_srv/CImg.h:      ulongT off = ((unsigned int)(ppixel - _data))%wh;
liveimage_srv/CImg.h:    //! Test if pixel value is inside image bounds and get its X-coordinate.
liveimage_srv/CImg.h:       Similar to contains(const T&,t&,t&,t&,t&) const, except that only the X-coordinate is set.
liveimage_srv/CImg.h:      x = (t)(((ulongT)(ppixel - _data))%_width);
liveimage_srv/CImg.h:       - Buffer overlapping may happen when manipulating \e shared images.
liveimage_srv/CImg.h:       - If two image buffers overlap, operating on one of the image will probably modify the other one.
liveimage_srv/CImg.h:       - Most of the time, \c CImg<T> instances are \e non-shared and do not overlap between each others.
liveimage_srv/CImg.h:         img1("reference.jpg"),             // Load RGB-color image
liveimage_srv/CImg.h:       \param[out] error_message C-string to contain the error message, if the test does not succeed.
liveimage_srv/CImg.h:       - Set \c full_checking to \c false to speed-up the 3D object checking. In this case, only the size of
liveimage_srv/CImg.h:       - Size of the string \c error_message should be at least 128-bytes long, to be able to contain the error message.
liveimage_srv/CImg.h:       \param[out] error_message C-string to contain the error message, if the test does not succeed.
liveimage_srv/CImg.h:       - Set \c full_check to \c false to speed-up the 3D object checking. In this case, only the size of
liveimage_srv/CImg.h:       - Size of the string \c error_message should be at least 128-bytes long, to be able to contain the error message.
liveimage_srv/CImg.h:                                          nb_points,nb_primitives,(unsigned int)(ptre - ptrs),(ptre - ptrs)>1?"s":"");
liveimage_srv/CImg.h:                                        nb_points,nb_primitives,(unsigned int)(ptre - ptrs)/3);
liveimage_srv/CImg.h:                                          nb_points,nb_primitives,p,(unsigned int)(ptrs - ptre));
liveimage_srv/CImg.h:        if (*(ptrs++)!=(T)-128) ptrs+=2;
liveimage_srv/CImg.h:            w = (unsigned int)*(ptrs - 3),
liveimage_srv/CImg.h:            h = (unsigned int)*(ptrs - 2),
liveimage_srv/CImg.h:            s = (unsigned int)*(ptrs - 1);
liveimage_srv/CImg.h:                                          nb_points,nb_primitives,c,(unsigned int)(ptrs - ptre));
liveimage_srv/CImg.h:        if (*(ptrs++)==(T)-128 && (ptrs+=3)<ptre) {
liveimage_srv/CImg.h:            w = (unsigned int)*(ptrs - 3),
liveimage_srv/CImg.h:            h = (unsigned int)*(ptrs - 2),
liveimage_srv/CImg.h:            s = (unsigned int)*(ptrs - 1);
liveimage_srv/CImg.h:                                        nb_points,nb_primitives,(unsigned int)(ptre - ptrs),(ptre - ptrs)>1?"s":"");
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:#define _cimg_mp_is_reserved(arg) (memtype[arg]==-1) // Is scalar and reserved (e.g. variable)?
liveimage_srv/CImg.h:#define _cimg_mp_size(arg) (_cimg_mp_is_scalar(arg)?0U:(unsigned int)memtype[arg] - 1) // Size (0=scalar, N>0=vectorN)
liveimage_srv/CImg.h:  for (s0 = ss; s0>expr._data && *s0!=';'; --s0) {} \
liveimage_srv/CImg.h:        p_break((CImg<ulongT>*)(cimg_ulong)-2),imgin(img_input),
liveimage_srv/CImg.h:        char *ps = &expr.back() - 1;
liveimage_srv/CImg.h:        while (ps>expr._data && (cimg::is_blank(*ps) || *ps==';')) --ps;
liveimage_srv/CImg.h:        *(++ps) = 0; expr._width = (unsigned int)(ps - expr._data + 1);
liveimage_srv/CImg.h:        // Ease the retrieval of previous non-space characters afterwards.
liveimage_srv/CImg.h:        for (unsigned int i = 0; i<=10; ++i) mem[i] = (double)i; // mem[0-10] = 0...10
liveimage_srv/CImg.h:        for (unsigned int i = 1; i<=5; ++i) mem[i + 10] = -(double)i; // mem[11-15] = -1...-5
liveimage_srv/CImg.h:        // { -1 = reserved (e.g. variable) | 0 = computation value |
liveimage_srv/CImg.h:        //    1 = compile-time constant | N>1 = constant ptr to vector[N-1] }.
liveimage_srv/CImg.h:          memtype[_cimg_mp_slot_z] = memtype[_cimg_mp_slot_c] = -1;
liveimage_srv/CImg.h:        // reserved_label[0-31] are used to store the memory index of these variables:
liveimage_srv/CImg.h:        const unsigned int ind_result = compile(expr._data,expr._data + expr._width - 1,0,0,0);
liveimage_srv/CImg.h:        if (mem._width>=256 && mem._width - mempos>=mem._width/2) mem.resize(mempos,1,1,1,-1);
liveimage_srv/CImg.h:            opcode._data = p_code->_data;
liveimage_srv/CImg.h:        p_code_end(0),p_break((CImg<ulongT>*)(cimg_ulong)-2),
liveimage_srv/CImg.h:        need_input_copy(mp.need_input_copy),result(mem._data + (mp.result - mp.mem._data)),
liveimage_srv/CImg.h:                                      (ss - 4)>expr._data?ss - 4:expr._data);
liveimage_srv/CImg.h:            while (se>ss && (cimg::is_blank(c1 = *(se - 1)) || c1==';')) --se; // Remove trailing blanks and ';'
liveimage_srv/CImg.h:          while (*ss=='(' && *(se - 1)==')' && std::strchr(ss,')')==se - 1) { // Remove useless start/end parentheses
liveimage_srv/CImg.h:            ++ss; --se; c2 = 1;
liveimage_srv/CImg.h:            const unsigned int clevel = level[ss - expr._data];
liveimage_srv/CImg.h:            while (ss<se && (*ss!=')' || level[ss - expr._data]!=clevel)) ++ss;
liveimage_srv/CImg.h:          *const se1 = se - 1, *const se2 = se - 2, *const se3 = se - 3,
liveimage_srv/CImg.h:        const unsigned int clevel = level[ss - expr._data], clevel1 = clevel + 1;
liveimage_srv/CImg.h:        // Look for a single value or a pre-defined variable.
liveimage_srv/CImg.h:        s = ss + (*ss=='+' || *ss=='-'?1:0);
liveimage_srv/CImg.h:        if (*s=='i' || *s=='I' || *s=='n' || *s=='N') { // Particular cases : +/-NaN and +/-Inf
liveimage_srv/CImg.h:          is_sth = *ss=='-';
liveimage_srv/CImg.h:          if (nb==1 && is_sth) val = -val;
liveimage_srv/CImg.h:          is_sth = *ss=='-';
liveimage_srv/CImg.h:            if (is_sth) val = -val;
liveimage_srv/CImg.h:        if (ss1==se) switch (*ss) { // One-char reserved variable
liveimage_srv/CImg.h:        else if (ss2==se) { // Two-chars reserved variable
liveimage_srv/CImg.h:              pos = 20 + *ss1 - '0';
liveimage_srv/CImg.h:              _cimg_mp_scalar6(mp_ixyzc,_cimg_mp_slot_x,_cimg_mp_slot_y,_cimg_mp_slot_z,pos - 20,0,0);
liveimage_srv/CImg.h:        } else if (ss3==se) { // Three-chars reserved variable
liveimage_srv/CImg.h:        } else if (ss4==se) { // Four-chars reserved variable
liveimage_srv/CImg.h:          if (*s==';' && level[s - expr._data]==clevel) { // Separator ';'
liveimage_srv/CImg.h:              *ps!='+' && *ps!='-' && *ps!='*' && *ps!='/' && *ps!='%' &&
liveimage_srv/CImg.h:              level[s - expr._data]==clevel) {
liveimage_srv/CImg.h:            variable_name.assign(ss,(unsigned int)(s + 1 - ss)).back() = 0;
liveimage_srv/CImg.h:            char *const ve1 = ss + l_variable_name - 1;
liveimage_srv/CImg.h:                  s0 = ss3; while (s0<ve1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                  else if (_cimg_mp_is_comp(arg2)) memtype[arg2] = -1;
liveimage_srv/CImg.h:                  if (_cimg_mp_is_comp(arg1)) memtype[arg1] = -1;
liveimage_srv/CImg.h:                  s0 = ss3; while (s0<ve1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                  s1 = s0; while (s1<ve1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                    s2 = ++s1; while (s2<ve1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                      s3 = ++s2; while (s3<ve1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
liveimage_srv/CImg.h:                  else if (_cimg_mp_is_comp(arg5)) memtype[arg5] = -1;
liveimage_srv/CImg.h:                  if (p1!=~0U && _cimg_mp_is_comp(p1)) memtype[p1] = -1;
liveimage_srv/CImg.h:                  if (_cimg_mp_is_comp(arg1)) memtype[arg1] = -1;
liveimage_srv/CImg.h:                  if (_cimg_mp_is_comp(arg2)) memtype[arg2] = -1;
liveimage_srv/CImg.h:                  if (_cimg_mp_is_comp(arg3)) memtype[arg3] = -1;
liveimage_srv/CImg.h:                  if (_cimg_mp_is_comp(arg4)) memtype[arg4] = -1;
liveimage_srv/CImg.h:              s0 = ve1; while (s0>ss && (*s0!='[' || level[s0 - expr._data]!=clevel)) --s0;
liveimage_srv/CImg.h:              if (s0>ss && is_varname(ss,s0 - ss)) {
liveimage_srv/CImg.h:                variable_name[s0 - ss] = 0; // Remove brackets in variable name
liveimage_srv/CImg.h:                  compile(ss,s0,depth1,0,bloc_flags); // Variable does not exist or is not a vector -> error
liveimage_srv/CImg.h:                if (_cimg_mp_is_const_scalar(arg2)) { // Constant index -> return corresponding variable slot directly
liveimage_srv/CImg.h:                  compile(ss,s,depth1,0,bloc_flags); // Out-of-bounds reference -> error
liveimage_srv/CImg.h:                // Case of non-constant index -> return assigned value + linked reference
liveimage_srv/CImg.h:                  if (_cimg_mp_is_comp(arg3)) memtype[arg3] = -1; // Prevent from being used in further optimization
liveimage_srv/CImg.h:                  if (_cimg_mp_is_comp(arg2)) memtype[arg2] = -1;
liveimage_srv/CImg.h:            // Assign user-defined macro.
liveimage_srv/CImg.h:              s0 = ve1; while (s0>ss && *s0!='(') --s0;
liveimage_srv/CImg.h:              if (is_varname(ss,s0 - ss) && std::strncmp(variable_name,"debug(",6) &&
liveimage_srv/CImg.h:                s0 = variable_name._data + (s0 - ss);
liveimage_srv/CImg.h:                s1 = variable_name._data + l_variable_name - 1; // Pointer to closing parenthesis
liveimage_srv/CImg.h:                CImg<charT>(variable_name._data,(unsigned int)(s0 - variable_name._data + 1)).move_to(macro_def,0);
liveimage_srv/CImg.h:                CImg<charT>(s,(unsigned int)(se - s + 1)).move_to(macro_body,0);
liveimage_srv/CImg.h:                    p2 = (unsigned int)(s3 - s2); // Argument length
liveimage_srv/CImg.h:                      if (!((ps>macro_body[0]._data && is_varchar(*(ps - 1))) ||
liveimage_srv/CImg.h:                        if (ps>macro_body[0]._data && *(ps - 1)=='#') { // Remove pre-number sign
liveimage_srv/CImg.h:                          *(ps - 1) = (char)p1;
liveimage_srv/CImg.h:                            std::memmove(ps,ps + p2 + 1,macro_body[0].end() - ps - p2 - 1);
liveimage_srv/CImg.h:                            macro_body[0]._width-=p2 + 1;
liveimage_srv/CImg.h:                            std::memmove(ps,ps + p2,macro_body[0].end() - ps - p2);
liveimage_srv/CImg.h:                            macro_body[0]._width-=p2;
liveimage_srv/CImg.h:                        } else if (ps + p2<macro_body[0].end() && *(ps + p2)=='#') { // Remove post-number sign
liveimage_srv/CImg.h:                          std::memmove(ps,ps + p2,macro_body[0].end() - ps - p2);
liveimage_srv/CImg.h:                          macro_body[0]._width-=p2;
liveimage_srv/CImg.h:                          std::memmove(ps,ps + p2 - 1,macro_body[0].end() - ps - p2 + 1);
liveimage_srv/CImg.h:                          macro_body[0]._width-=p2 - 1;
liveimage_srv/CImg.h:                            ps-=(ulongT)macro_body[0]._data;
liveimage_srv/CImg.h:                            macro_body[0].resize(macro_body[0]._width - p2 + 3,1,1,1,0);
liveimage_srv/CImg.h:                          } else macro_body[0]._width-=p2 - 3;
liveimage_srv/CImg.h:                          std::memmove(ps + 3,ps + p2,macro_body[0].end() - ps - 3);
liveimage_srv/CImg.h:                macro_def[0].resize(macro_def[0]._width + 1,1,1,1,0).back() = is_variadic?(char)-1:(char)(p1 - 1);
liveimage_srv/CImg.h:              variable_name.resize(variable_name.end() - s0,1,1,1,0,0,1);
liveimage_srv/CImg.h:                    memtype[arg1] = -1;
liveimage_srv/CImg.h:                    if (variable_def._width>=variable_pos._width) variable_pos.resize(-200,1,1,1,0);
liveimage_srv/CImg.h:              } else { // Variable already exists -> assign a new value
liveimage_srv/CImg.h:                                              _cimg_mp_is_const_scalar(arg1)?"":"non-",
liveimage_srv/CImg.h:            // No assignment expressions match -> error
liveimage_srv/CImg.h:        for (s = se2, ps = se3, ns = ps - 1; s>ss1; --s, --ps, --ns) // Here, ns = ps - 1
liveimage_srv/CImg.h:              level[s - expr._data]==clevel) { // Self-operators for complex numbers only (**=,//=,^^=)
liveimage_srv/CImg.h:        for (s = se2, ps = se3, ns = ps - 1; s>ss1; --s, --ps, --ns) // Here, ns = ps - 1
liveimage_srv/CImg.h:          if (*s=='=' && (*ps=='+' || *ps=='-' || *ps=='*' || *ps=='/' || (*ps=='%' && s[1]!='=') ||
liveimage_srv/CImg.h:              level[s - expr._data]==clevel) { // Self-operators (+=,-=,*=,/=,%=,>>=,<<=,&=,^=,|=)
liveimage_srv/CImg.h:            case '-' : op = mp_self_sub; _cimg_mp_op("Operator '-='"); break;
liveimage_srv/CImg.h:            variable_name.assign(ss,(unsigned int)(s - ss)).back() = 0;
liveimage_srv/CImg.h:          if (*s=='?' && level[s - expr._data]==clevel) { // Ternary operator 'cond?expr1:expr2'
liveimage_srv/CImg.h:            s1 = s + 1; while (s1<se1 && (*s1!=':' || level[s1 - expr._data]!=clevel)) ++s1;
liveimage_srv/CImg.h:                                p3 - p2,code._width - p3,arg4).move_to(code,p2);
liveimage_srv/CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
liveimage_srv/CImg.h:          if (*s=='|' && *ns=='|' && level[s - expr._data]==clevel) { // Logical or ('||')
liveimage_srv/CImg.h:            CImg<ulongT>::vector((ulongT)mp_logical_or,pos,arg1,arg2,code._width - p2).
liveimage_srv/CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
liveimage_srv/CImg.h:          if (*s=='&' && *ns=='&' && level[s - expr._data]==clevel) { // Logical and ('&&')
liveimage_srv/CImg.h:            CImg<ulongT>::vector((ulongT)mp_logical_and,pos,arg1,arg2,code._width - p2).
liveimage_srv/CImg.h:        for (s = se2; s>ss; --s)
liveimage_srv/CImg.h:          if (*s=='|' && level[s - expr._data]==clevel) { // Bitwise or ('|')
liveimage_srv/CImg.h:        for (s = se2; s>ss; --s)
liveimage_srv/CImg.h:          if (*s=='&' && level[s - expr._data]==clevel) { // Bitwise and ('&')
liveimage_srv/CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
liveimage_srv/CImg.h:          if (*s=='!' && *ns=='=' && level[s - expr._data]==clevel) { // Not equal to ('!=')
liveimage_srv/CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
liveimage_srv/CImg.h:          if (*s=='=' && *ns=='=' && level[s - expr._data]==clevel) { // Equal to ('==')
liveimage_srv/CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
liveimage_srv/CImg.h:          if (*s=='<' && *ns=='=' && level[s - expr._data]==clevel) { // Less or equal than ('<=')
liveimage_srv/CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
liveimage_srv/CImg.h:          if (*s=='>' && *ns=='=' && level[s - expr._data]==clevel) { // Greater or equal than ('>=')
liveimage_srv/CImg.h:        for (s = se2, ns = se1, ps = se3; s>ss; --s, --ns, --ps)
liveimage_srv/CImg.h:          if (*s=='<' && *ns!='<' && *ps!='<' && level[s - expr._data]==clevel) { // Less than ('<')
liveimage_srv/CImg.h:        for (s = se2, ns = se1, ps = se3; s>ss; --s, --ns, --ps)
liveimage_srv/CImg.h:          if (*s=='>' && *ns!='>' && *ps!='>' && level[s - expr._data]==clevel) { // Greater than ('>')
liveimage_srv/CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
liveimage_srv/CImg.h:          if (*s=='<' && *ns=='<' && level[s - expr._data]==clevel) { // Left bit shift ('<<')
liveimage_srv/CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
liveimage_srv/CImg.h:          if (*s=='>' && *ns=='>' && level[s - expr._data]==clevel) { // Right bit shift ('>>')
liveimage_srv/CImg.h:        for (ns = se1, s = se2, ps = pexpr._data + (se3 - expr._data); s>ss; --ns, --s, --ps)
liveimage_srv/CImg.h:          if (*s=='+' && (*ns!='+' || ns!=se1) && *ps!='-' && *ps!='+' && *ps!='*' && *ps!='/' && *ps!='%' &&
liveimage_srv/CImg.h:              (*ps!='e' || !(ps - pexpr._data>ss - expr._data && (*(ps - 1)=='.' || (*(ps - 1)>='0' &&
liveimage_srv/CImg.h:                                                                                     *(ps - 1)<='9')))) &&
liveimage_srv/CImg.h:              level[s - expr._data]==clevel) { // Addition ('+')
liveimage_srv/CImg.h:        for (ns = se1, s = se2, ps = pexpr._data + (se3 - expr._data); s>ss; --ns, --s, --ps)
liveimage_srv/CImg.h:          if (*s=='-' && (*ns!='-' || ns!=se1) && *ps!='-' && *ps!='+' && *ps!='*' && *ps!='/' && *ps!='%' &&
liveimage_srv/CImg.h:              (*ps!='e' || !(ps - pexpr._data>ss - expr._data && (*(ps - 1)=='.' || (*(ps - 1)>='0' &&
liveimage_srv/CImg.h:                                                                                     *(ps - 1)<='9')))) &&
liveimage_srv/CImg.h:              level[s - expr._data]==clevel) { // Subtraction ('-')
liveimage_srv/CImg.h:            _cimg_mp_op("Operator '-'");
liveimage_srv/CImg.h:              _cimg_mp_const_scalar(mem[arg1] - mem[arg2]);
liveimage_srv/CImg.h:            if (code) { // Try to spot linear cases 'a*b - c' and 'c - a*b'
liveimage_srv/CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
liveimage_srv/CImg.h:          if (*s=='*' && *ns=='*' && level[s - expr._data]==clevel) { // Complex multiplication ('**')
liveimage_srv/CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
liveimage_srv/CImg.h:          if (*s=='/' && *ns=='/' && level[s - expr._data]==clevel) { // Complex division ('//')
liveimage_srv/CImg.h:        for (s = se2; s>ss; --s) if (*s=='*' && level[s - expr._data]==clevel) { // Multiplication ('*')
liveimage_srv/CImg.h:        for (s = se2; s>ss; --s) if (*s=='/' && level[s - expr._data]==clevel) { // Division ('/')
liveimage_srv/CImg.h:        for (s = se2, ns = se1; s>ss; --s, --ns)
liveimage_srv/CImg.h:          if (*s=='%' && *ns!='^' && level[s - expr._data]==clevel) { // Modulo ('%')
liveimage_srv/CImg.h:          if (*ss=='-' && (*ss1!='-' || (ss2<se && *ss2>='0' && *ss2<='9'))) { // Unary minus ('-')
liveimage_srv/CImg.h:            _cimg_mp_op("Operator '-'");
liveimage_srv/CImg.h:            if (_cimg_mp_is_const_scalar(arg1)) _cimg_mp_const_scalar(-mem[arg1]);
liveimage_srv/CImg.h:        for (s = se3, ns = se2; s>ss; --s, --ns)
liveimage_srv/CImg.h:          if (*s=='^' && *ns=='^' && level[s - expr._data]==clevel) { // Complex power ('^^')
liveimage_srv/CImg.h:        for (s = se2; s>ss; --s)
liveimage_srv/CImg.h:          if (*s=='^' && level[s - expr._data]==clevel) { // Power ('^')
liveimage_srv/CImg.h:        // Degree to radian postfix operator ('°' in UTF-8).
liveimage_srv/CImg.h:        // Pre/post-decrement and increment.
liveimage_srv/CImg.h:        is_sth = ss1<se1 && (*ss=='+' || *ss=='-') && *ss1==*ss; // is pre-?
liveimage_srv/CImg.h:        if (is_sth || (se2>ss && (*se1=='+' || *se1=='-') && *se2==*se1)) {
liveimage_srv/CImg.h:            _cimg_mp_op("Operator '--'");
liveimage_srv/CImg.h:          if (is_sth) variable_name.assign(ss2,(unsigned int)(se - ss1));
liveimage_srv/CImg.h:          else variable_name.assign(ss,(unsigned int)(se1 - ss));
liveimage_srv/CImg.h:        // Array-like access to vectors and image values 'i/j/I/J[_#ind,offset,_boundary]' and 'vector[offset]'.
liveimage_srv/CImg.h:          s0 = se1; while (s0>ss && (*s0!='[' || level[s0 - expr._data]!=clevel)) --s0;
liveimage_srv/CImg.h:          if (s0>ss) { s1 = s0; do { --s1; } while (cimg::is_blank(*s1)); cimg::swap(*s0,*++s1); }
liveimage_srv/CImg.h:          is_sth=s0>ss && *(s0-1)==']';  // Particular case s.a. '..[..][..]' ?
liveimage_srv/CImg.h:              s0 = ss3; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:            s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              if (_cimg_mp_is_comp(arg1)) memtype[arg1] = -1;
liveimage_srv/CImg.h:            p2 = ~0U; // 'p2' must be the dimension of the vector-valued operand if any
liveimage_srv/CImg.h:              s0 = ss3; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:            s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              if (p1!=~0U && _cimg_mp_is_comp(p1)) memtype[p1] = -1; // Prevent from being used in further optimization
liveimage_srv/CImg.h:              if (_cimg_mp_is_comp(arg1)) memtype[arg1] = -1;
liveimage_srv/CImg.h:            memtype[pos] = -1; // Prevent from being used in further optimization
liveimage_srv/CImg.h:          s0 = se1; while (s0>ss && (*s0!='[' || level[s0 - expr._data]!=clevel)) --s0;
liveimage_srv/CImg.h:              variable_name.assign(ss,(unsigned int)(s0 - ss + 1)).back() = 0;
liveimage_srv/CImg.h:                                          "CImg<%s>::%s: %s: Array brackets used on non-vector variable '%s', "
liveimage_srv/CImg.h:            s1 = s0 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:            if (s1<se1) { // Two or three arguments -> sub-vector extraction
liveimage_srv/CImg.h:              s0 = ++s1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:            // One argument -> vector value reference
liveimage_srv/CImg.h:              variable_name.assign(ss,(unsigned int)(s0 - ss)).back() = 0;
liveimage_srv/CImg.h:                                          "CImg<%s>::%s: Out-of-bounds reference '%s[%d]' "
liveimage_srv/CImg.h:              if (_cimg_mp_is_comp(arg2)) memtype[arg2] = -1; // Prevent from being used in further optimization
liveimage_srv/CImg.h:            memtype[pos] = -1; // Prevent from being used in further optimization
liveimage_srv/CImg.h:          s0 = s1 = std::strchr(ss,'('); if (s0) { do { --s1; } while (cimg::is_blank(*s1)); cimg::swap(*s0,*++s1); }
liveimage_srv/CImg.h:              s0 = ss3; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:              s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                  s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                  s3 = ++s2; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
liveimage_srv/CImg.h:                    s2 = ++s3; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:              if (p1!=~0U && _cimg_mp_is_comp(p1)) memtype[p1] = -1; // Prevent from being used in further optimization
liveimage_srv/CImg.h:              if (_cimg_mp_is_comp(arg1)) memtype[arg1] = -1;
liveimage_srv/CImg.h:              if (_cimg_mp_is_comp(arg2)) memtype[arg2] = -1;
liveimage_srv/CImg.h:              if (_cimg_mp_is_comp(arg3)) memtype[arg3] = -1;
liveimage_srv/CImg.h:            p2 = ~0U; // 'p2' must be the dimension of the vector-valued operand if any
liveimage_srv/CImg.h:              s0 = ss3; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:              s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                  s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                  s3 = ++s2; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
liveimage_srv/CImg.h:                    s2 = ++s3; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                      s3 = ++s2; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
liveimage_srv/CImg.h:              if (p1!=~0U && _cimg_mp_is_comp(p1)) memtype[p1] = -1; // Prevent from being used in further optimization
liveimage_srv/CImg.h:              if (_cimg_mp_is_comp(arg1)) memtype[arg1] = -1;
liveimage_srv/CImg.h:              if (_cimg_mp_is_comp(arg2)) memtype[arg2] = -1;
liveimage_srv/CImg.h:              if (_cimg_mp_is_comp(arg3)) memtype[arg3] = -1;
liveimage_srv/CImg.h:              if (_cimg_mp_is_comp(arg4)) memtype[arg4] = -1;
liveimage_srv/CImg.h:            memtype[pos] = -1; // Prevent from being used in further optimization
liveimage_srv/CImg.h:              s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:                p3-=1; // Number of args
liveimage_srv/CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              if (pexpr[se2 - expr._data]=='(') { // no arguments?
liveimage_srv/CImg.h:              if (pexpr[se2 - expr._data]=='(') { // no arguments?
liveimage_srv/CImg.h:              if (pexpr[se2 - expr._data]=='(') { // no arguments?
liveimage_srv/CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                s3 = ++s2; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
liveimage_srv/CImg.h:                  s1 = ++s3; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                    s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:              CImg<ulongT>::vector((ulongT)mp_critical,arg1,code._width - p1).move_to(code,p1);
liveimage_srv/CImg.h:                s0 = ss6; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:              default : // Error -> too much arguments
liveimage_srv/CImg.h:                                              "some xyzc-coordinates are unspecified, in expression '%s'.",
liveimage_srv/CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:                xend = opcode[21]!=~0U?(int)mem[opcode[21]]:wA - 1,
liveimage_srv/CImg.h:                yend = opcode[22]!=~0U?(int)mem[opcode[22]]:hA - 1,
liveimage_srv/CImg.h:                zend = opcode[23]!=~0U?(int)mem[opcode[23]]:dA - 1;
liveimage_srv/CImg.h:                                            "CImg<%s>::%s: %s: Invalid xyz-start/end arguments "
liveimage_srv/CImg.h:              arg2 = xend - xstart + 1;
liveimage_srv/CImg.h:              arg3 = yend - ystart + 1;
liveimage_srv/CImg.h:                s1 = ++s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s1 = ++s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s0 = s1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:              if (p1==~0U) compile(s1 + 1,se1,depth1,0,bloc_flags); // Missing element -> error
liveimage_srv/CImg.h:                s0 = ss + 11; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s0 = ss + 9; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              ((CImg<ulongT>::vector((ulongT)mp_debug,arg1,0,code._width - p1),
liveimage_srv/CImg.h:              if (pexpr[se2 - expr._data]=='(') { // no arguments?
liveimage_srv/CImg.h:                s1 = ss8; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                  s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                    s3 = ++s2; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
liveimage_srv/CImg.h:                      s2 = ++s3; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:              arg1 = opcode._height - 3;
liveimage_srv/CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              CImg<ulongT>::vector((ulongT)mp_do,p1,p2,arg2 - arg1,code._width - arg2,_cimg_mp_size(p1),
liveimage_srv/CImg.h:                s0 = ss6; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:              s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s0 = s1 + 1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                    s1 = s0 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                      s0 = s1 + 1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                        s1 = s0 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                  s0 = s1 + 1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                    s1 = s0 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                      s0 = s1 + 1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                s1 = s0 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                  s0 = s1 + 1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                ns = s; while (ns<se1 && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:                s0 = ss + 9; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                  s1 = s2 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                    s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:            if (!std::strncmp(ss,"f2ui(",5)) { // Special float->uint conversion
liveimage_srv/CImg.h:              s0 = ss5; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:              s1 = ++s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                variable_name.assign(s0,(unsigned int)(s1 + 1 - s0)).back() = 0;
liveimage_srv/CImg.h:                                  _cimg_mp_is_const_scalar(arg2))) { // Variable is not a vector or is a constant->error
liveimage_srv/CImg.h:                } else if (arg2==~0U) { // Variable does not exist -> create it
liveimage_srv/CImg.h:                    if (variable_def._width>=variable_pos._width) variable_pos.resize(-200,1,1,1,0);
liveimage_srv/CImg.h:                  memtype[arg2] = -1;
liveimage_srv/CImg.h:              CImg<ulongT>::vector((ulongT)mp_fill,arg1,_cimg_mp_size(arg1),arg2,arg3,code._width - p1).
liveimage_srv/CImg.h:              s0 = ss5; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:              s1 = ++s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s0 = s1 + 1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:              s3 = s2 + 1; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
liveimage_srv/CImg.h:              CImg<ulongT>::vector((ulongT)mp_for,p3,(ulongT)_cimg_mp_size(p3),p2,arg2 - arg1,arg3 - arg2,
liveimage_srv/CImg.h:                                   arg4 - arg3,code._width - arg4,
liveimage_srv/CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                _cimg_mp_const_scalar(std::exp(-val1*val1/(2*val2*val2))/(mem[arg3]?std::sqrt(2*val2*val2*cimg::PI):1));
liveimage_srv/CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:              s1 = ss3; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                                  p3 - p2,code._width - p3,arg4).move_to(code,p2);
liveimage_srv/CImg.h:              s1 = ss8; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:              s1 = s2 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:              s1 = ss7; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                  ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                                 (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                  _cimg_mp_const_scalar(mem[arg1]*(1-t) + mem[arg2]*t);
liveimage_srv/CImg.h:            if (!std::strncmp(ss,"log2(",5)) { // Base-2 logarithm
liveimage_srv/CImg.h:            if (!std::strncmp(ss,"log10(",6)) { // Base-10 logarithm
liveimage_srv/CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:              s1 = s2 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                s1 = s2 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                  s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:            if (!std::strncmp(ss,"merge(",6)) { // Merge inter-thread variables
liveimage_srv/CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                          // (0='=',1='+',2='-',3='*',4='/',5='&',6='|',7='xor',8='&&',9=='||',10='min',11='max')
liveimage_srv/CImg.h:                if (cimg_sscanf(s1," %3[=+-*/&|minaxor]%c",st_op,&sep)==2 && (sep==')' ||
liveimage_srv/CImg.h:                  if (!is_sth || (is_sth && cimg_sscanf(s1," %*[=+-*/&|minaxor ]%c",&sep)==1 && sep==')')) {
liveimage_srv/CImg.h:                      arg1 = *st_op=='='?0:*st_op=='+'?1:*st_op=='-'?2:*st_op=='*'?3:*st_op=='/'?4:
liveimage_srv/CImg.h:                                            "(should be one of '=,+,-,*,/,&,|,xor,&&,||,min,max'), "
liveimage_srv/CImg.h:              memmerge(0,memmerge._height - 1) = (int)pos;
liveimage_srv/CImg.h:              memmerge(1,memmerge._height - 1) = (int)_cimg_mp_size(pos);
liveimage_srv/CImg.h:              memmerge(2,memmerge._height - 1) = (int)arg1;
liveimage_srv/CImg.h:                s0 = ss6; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:                CImg<ulongT>::vector((ulongT)mp_normp,pos,0,(ulongT)(arg1==~0U?-1:(int)arg1)).
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:              s1 = ss7; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                s0 = ss + 9; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:                else // Vector or non-const scalar
liveimage_srv/CImg.h:            if (!std::strncmp(ss,"pseudoinvert(",13)) { // Matrix/scalar pseudo-inversion
liveimage_srv/CImg.h:              s1 = ss + 13; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s2 = ++s1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                variable_name.assign(s1,(unsigned int)(se1 + 1 - s1)).back() = 0;
liveimage_srv/CImg.h:                if (variable_def._width>=variable_pos._width) variable_pos.resize(-200,1,1,1,0);
liveimage_srv/CImg.h:              else if (_cimg_mp_is_comp(arg3)) memtype[arg3] = -1;
liveimage_srv/CImg.h:              s0 = ss7; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:              s1 = ++s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                variable_name.assign(s0,(unsigned int)(s1 + 1 - s0)).back() = 0;
liveimage_srv/CImg.h:                                  _cimg_mp_is_const_scalar(arg2))) { // Variable is not a vector or is a constant->error
liveimage_srv/CImg.h:                } else if (arg2==~0U) { // Variable does not exist -> create it
liveimage_srv/CImg.h:                    if (variable_def._width>=variable_pos._width) variable_pos.resize(-200,1,1,1,0);
liveimage_srv/CImg.h:                  memtype[arg2] = -1;
liveimage_srv/CImg.h:              CImg<ulongT>::vector((ulongT)mp_repeat,arg3,arg1,arg2,code._width - p1).move_to(code,p1);
liveimage_srv/CImg.h:                  ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                                 (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:                if (opcode.height()<2) compile(s,se1,depth1,0,bloc_flags); // Not enough arguments -> throw exception
liveimage_srv/CImg.h:                  if (opcode.height()<6) compile(s,se1,depth1,0,bloc_flags); // Not enough arguments -> throw exception
liveimage_srv/CImg.h:                s0 = ss8; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                  ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                                 (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1-expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                  s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                  s3 = s2 + 1; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
liveimage_srv/CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                s3 = s2 + 1; while (s3<se1 && (*s3!=',' || level[s3 - expr._data]!=clevel1)) ++s3;
liveimage_srv/CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s0 = ++s1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s0 = ++s1; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                  s1 = ++s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s1 = ss6; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                s1 = s2 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                  s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                    s1 = s2 + 1; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                      s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:                s0 = ss8; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s1 = ss + 10; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              s1 = ss2; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:            if (!std::strncmp(ss,"ui2f(",5)) { // Special uint->float conversion
liveimage_srv/CImg.h:            if (!std::strncmp(ss,"unref(",6)) { // Un-reference variable
liveimage_srv/CImg.h:                    if (arg1<variable_pos._width - 1)
liveimage_srv/CImg.h:                                   sizeof(uintT)*(variable_pos._width - arg1 - 1));
liveimage_srv/CImg.h:                    --variable_pos._width;
liveimage_srv/CImg.h:                s0 = ++s; while (s0<se1 && (*s0!=',' || level[s0 - expr._data]!=clevel1)) ++s0;
liveimage_srv/CImg.h:                  ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                                 (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:                !std::strncmp(ss,"vargkth(",8)) { // Multi-argument vector functions
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:              s1 = ss5; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:                s2 = s1 + 1; while (s2<se1 && (*s2!=',' || level[s2 - expr._data]!=clevel1)) ++s2;
liveimage_srv/CImg.h:              if (arg3==~0U) { // Auto-guess best output vector size
liveimage_srv/CImg.h:                p1 = p1?25*p1 - 1:24;
liveimage_srv/CImg.h:              s1 = s0; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              CImg<ulongT>::vector((ulongT)mp_while,pos,arg1,p2 - p1,code._width - p2,arg2,
liveimage_srv/CImg.h:              s1 = ss4; while (s1<se1 && (*s1!=',' || level[s1 - expr._data]!=clevel1)) ++s1;
liveimage_srv/CImg.h:              !std::strncmp(ss,"argkth(",7)) { // Multi-argument functions
liveimage_srv/CImg.h:              ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                             (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:          // No corresponding built-in function -> Look for a user-defined macro call.
liveimage_srv/CImg.h:            variable_name.assign(ss,(unsigned int)(s0 - ss + 1)).back() = 0;
liveimage_srv/CImg.h:              ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                             (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:                                          ((mb = macro_def[l].back())==(char)p1 || mb==(char)-1)) {
liveimage_srv/CImg.h:              const bool is_variadic = mb==(char)-1;
liveimage_srv/CImg.h:                  ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                                 (*ns!=')' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:                variable_name.assign(s,(unsigned int)(ns - s + 1)).back() = 0; // Argument to write
liveimage_srv/CImg.h:                      _expr.resize(arg1 + variable_name._width - 2,1,1,1,0);
liveimage_srv/CImg.h:                      std::memmove(_expr._data + k + variable_name._width - 1,_expr._data + k + 1,arg1 - k - 1);
liveimage_srv/CImg.h:                      std::memcpy(_expr._data + k,variable_name,variable_name._width - 1);
liveimage_srv/CImg.h:                      k+=variable_name._width - 2;
liveimage_srv/CImg.h:                      std::memmove(_expr._data + k,_expr._data + k + 1,arg1 - k - 1);
liveimage_srv/CImg.h:                      --k;
liveimage_srv/CImg.h:              pos = compile(expr._data,expr._data + expr._width - 1,depth1,p_ref,bloc_flags);
liveimage_srv/CImg.h:                --sig_nargs._width;
liveimage_srv/CImg.h:          arg1 = (unsigned int)(se1 - s1); // Original string length
liveimage_srv/CImg.h:          if (!arg1) _cimg_mp_return(0); // Empty string -> 0
liveimage_srv/CImg.h:          s2 = se2; while (s2>s1 && cimg::is_blank(*s2)) --s2;
liveimage_srv/CImg.h:            arg1 = (unsigned int)(s2 - s1 - 1); // Original string length
liveimage_srv/CImg.h:            if (!arg1) _cimg_mp_return(0); // Empty string -> 0
liveimage_srv/CImg.h:                ns = s; while (ns<se && (*ns!=',' || level[ns - expr._data]!=clevel1) &&
liveimage_srv/CImg.h:                               (*ns!=']' || level[ns - expr._data]!=clevel)) ++ns;
liveimage_srv/CImg.h:              _cimg_mp_scalar7(mp_list_ixyzc,arg1,_cimg_mp_slot_x,_cimg_mp_slot_y,_cimg_mp_slot_z,*ss1 - '0',
liveimage_srv/CImg.h:        variable_name.assign(ss,(unsigned int)(se + 1 - ss)).back() = 0;
liveimage_srv/CImg.h:        // Reached an unknown item -> error.
liveimage_srv/CImg.h:          opcode._data = p_code->_data;
liveimage_srv/CImg.h:          opcode._data = p_code->_data;
liveimage_srv/CImg.h:          opcode._data = p_code->_data;
liveimage_srv/CImg.h:          mem[_cimg_mp_slot_x] = imgin._width - 1.;
liveimage_srv/CImg.h:          mem[_cimg_mp_slot_y] = imgin._height - 1.;
liveimage_srv/CImg.h:          mem[_cimg_mp_slot_z] = imgin._depth - 1.;
liveimage_srv/CImg.h:          mem[_cimg_mp_slot_c] = imgin._spectrum - 1.;
liveimage_srv/CImg.h:          opcode._data = p_code->_data;
liveimage_srv/CImg.h:          mem[_cimg_mp_slot_x] = imgin._width - 1.;
liveimage_srv/CImg.h:          mem[_cimg_mp_slot_y] = imgin._height - 1.;
liveimage_srv/CImg.h:          mem[_cimg_mp_slot_z] = imgin._depth - 1.;
liveimage_srv/CImg.h:          mem[_cimg_mp_slot_c] = imgin._spectrum - 1.;
liveimage_srv/CImg.h:          opcode._data = p_code->_data;
liveimage_srv/CImg.h:      // Merge inter-thread variables.
liveimage_srv/CImg.h:            case 2 : mp.mem[pos]-=mem[pos]; break;                                        // Operator-
liveimage_srv/CImg.h:            case 2 : // Operator-
liveimage_srv/CImg.h:              CImg<doubleT>(&mp.mem[pos + 1],siz,1,1,1,true)-=CImg<doubleT>(&mem[pos + 1],siz,1,1,1,true);
liveimage_srv/CImg.h:        return _s_arg[n_arg<sizeof(_s_arg)/sizeof(char*)?n_arg:sizeof(_s_arg)/sizeof(char*)-1];
liveimage_srv/CImg.h:      // Return a string that defines the calling function + the user-defined function scope.
liveimage_srv/CImg.h:        unsigned int mode = 0, next_mode = 0; // { 0=normal | 1=char-string | 2=vector-string
liveimage_srv/CImg.h:        CImg<uintT> res(_expr._width - 1);
liveimage_srv/CImg.h:          if (!is_escaped && *ps=='\'') { // Non-escaped character
liveimage_srv/CImg.h:            if (!mode && ps>_expr._data && *(ps - 1)=='[') next_mode = mode = 2; // Start vector-string
liveimage_srv/CImg.h:            else if (mode==2 && *(ps + 1)==']') next_mode = !mode; // End vector-string
liveimage_srv/CImg.h:            else if (mode<2) next_mode = mode?(mode = 0):1; // Start/end char-string
liveimage_srv/CImg.h:                                   *ps==')' || *ps==']'?--_level:
liveimage_srv/CImg.h:            mem_img_index = const_scalar((double)(&imgout - imglist.data()));
liveimage_srv/CImg.h:        unsigned int rp = variable_name[1]?~0U:*variable_name; // One-char variable
liveimage_srv/CImg.h:        if (variable_name[1] && !variable_name[2]) { // Two-chars variable
liveimage_srv/CImg.h:            if (c2>='0' && c2<='9') rp = 20 + c2 - '0'; // i0...i9
liveimage_srv/CImg.h:        } else if (variable_name[1] && variable_name[2] && !variable_name[3]) { // Three-chars variable
liveimage_srv/CImg.h:                   !variable_name[4]) { // Four-chars variable
liveimage_srv/CImg.h:        // Multi-char variable name : check for existing variable with same name
liveimage_srv/CImg.h:        while (siz-->0) if (*(ptr++)) { is_tmp = false; break; }
liveimage_srv/CImg.h:      // { 0=constant | 1=integer constant | 2=positive integer constant | 3=strictly-positive integer constant }
liveimage_srv/CImg.h:          if (*s_op!='F') s_arg = !n_arg?"":n_arg==1?"Left-hand":"Right-hand";
liveimage_srv/CImg.h:          if (*s_op!='F') s_arg = !n_arg?"":n_arg==1?"Left-hand":"Right-hand";
liveimage_srv/CImg.h:        // Search for built-in constant.
liveimage_srv/CImg.h:          if (val<0 && val>=-5) return (unsigned int)(10 - val);
liveimage_srv/CImg.h:            const double val_beg = *constcache_vals, val_end = constcache_vals[constcache_size - 1];
liveimage_srv/CImg.h:            else if (val_end==val) ind = constcache_size - 1;
liveimage_srv/CImg.h:              unsigned int i0 = 1, i1 = constcache_size - 2;
liveimage_srv/CImg.h:                else i1 = mid - 1;
liveimage_srv/CImg.h:                constcache_vals.resize(-200,1,1,1,0);
liveimage_srv/CImg.h:                constcache_inds.resize(-200,1,1,1,0);
liveimage_srv/CImg.h:              const int l = constcache_size - (int)ind - 1;
liveimage_srv/CImg.h:        if (mempos>=mem._width) { mem.resize(-200,1,1,1,0); memtype.resize(-200,1,1,1,0); }
liveimage_srv/CImg.h:        if (mempos>=mem._width) { mem.resize(-200,1,1,1,0); memtype.resize(mem._width,1,1,1,0); }
liveimage_srv/CImg.h:        while (siz-->0) *(ptr++) = -1;
liveimage_srv/CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1).move_to(code[code._width - 1 - siz + k]);
liveimage_srv/CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1 + k).move_to(code[code._width - 1 - siz + k]);
liveimage_srv/CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1 + k).move_to(code[code._width - 1 - siz + k]);
liveimage_srv/CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1 + k,arg2 + k).move_to(code[code._width - 1 - siz + k]);
liveimage_srv/CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1 + k,arg2).move_to(code[code._width - 1 - siz + k]);
liveimage_srv/CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1,arg2 + k).move_to(code[code._width - 1 - siz + k]);
liveimage_srv/CImg.h:            CImg<ulongT>::vector((ulongT)op,pos + k,arg1 + k,arg2,arg3).move_to(code[code._width - 1 - siz + k]);
liveimage_srv/CImg.h:          nb_args = (unsigned int)mp.opcode[2] - 4,
liveimage_srv/CImg.h:          nb_args = (unsigned int)mp.opcode[2] - 4,
liveimage_srv/CImg.h:        for (unsigned int i = 4; i<i_end; ++i) if (val==_mp_arg(i)) return i - 3.;
liveimage_srv/CImg.h:          if (_val<val) { val = _val; argval = i - 3; }
liveimage_srv/CImg.h:          if (_absval<absval) { val = _val; absval = _absval; argval = i - 3; }
liveimage_srv/CImg.h:          if (_val>val) { val = _val; argval = i - 3; }
liveimage_srv/CImg.h:          if (_absval>absval) { val = _val; absval = _absval; argval = i - 3; }
liveimage_srv/CImg.h:        return val/(i_end - 3);
liveimage_srv/CImg.h:        mp.p_code = mp.p_break - 1;
liveimage_srv/CImg.h:        const unsigned int nb_args = (unsigned int)(mp.opcode[2] - 3)/2;
liveimage_srv/CImg.h:          if (siz) { // Vector argument -> string
liveimage_srv/CImg.h:          } else { // Scalar argument -> number
liveimage_srv/CImg.h:        ptrd[1] = -imag;
liveimage_srv/CImg.h:        *ptrd =  -r1*i2/denom;
liveimage_srv/CImg.h:        *ptrd = (r2*i1 - r1*i2)/denom;
liveimage_srv/CImg.h:        *(ptrd++) = r1*r2 - i1*i2;
liveimage_srv/CImg.h:        if (cimg::abs(i2)<1e-15) { // Exponent is real
liveimage_srv/CImg.h:          if (cimg::abs(r1)<1e-15 && cimg::abs(i1)<1e-15) {
liveimage_srv/CImg.h:            if (cimg::abs(r2)<1e-15) { ro = 1; io = 0; }
liveimage_srv/CImg.h:          if (cimg::abs(r1)<1e-15 && cimg::abs(i1)<1e-15) ro = io = 0;
liveimage_srv/CImg.h:            modo = std::pow(mod1_2,0.5*r2)*std::exp(-i2*phi1),
liveimage_srv/CImg.h:        ptrd[1] = -std::sin(real)*std::sinh(imag);
liveimage_srv/CImg.h:        mp.p_code = mp.p_break - 1;
liveimage_srv/CImg.h:            mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:        --mp.p_code;
liveimage_srv/CImg.h:                                                                 x + dx - 1,y + dy - 1,
liveimage_srv/CImg.h:                                                                 z + dz - 1,c + dc - 1,
liveimage_srv/CImg.h:        int siz = img?(int)img[img._height - 1]:0;
liveimage_srv/CImg.h:        if (img && (img._width!=1 || img._depth!=1 || siz<0 || siz>img.height() - 1))
liveimage_srv/CImg.h:        if (dim<1) ret = img[siz - 1]; // Scalar element
liveimage_srv/CImg.h:        else cimg_forC(img,c) ptrd[c] = img(0,siz - 1,0,c); // Vector element
liveimage_srv/CImg.h:          --siz;
liveimage_srv/CImg.h:            img.resize(1,std::max(2*siz + 1,32),1,-100,0);
liveimage_srv/CImg.h:          img[img._height - 1] = (T)siz;
liveimage_srv/CImg.h:          nb_elts = (unsigned int)mp.opcode[5] - 6,
liveimage_srv/CImg.h:          siz = img?(int)img[img._height - 1]:0,
liveimage_srv/CImg.h:        if (img && (img._width!=1 || img._depth!=1 || siz<0 || siz>img.height() - 1))
liveimage_srv/CImg.h:                                      "Invalid position %d (not in range -%d...%d).",
liveimage_srv/CImg.h:          cimg_forC(img,c) std::memmove(img.data(0,pos + nb_elts,0,c),img.data(0,pos,0,c),(siz - pos)*sizeof(T));
liveimage_srv/CImg.h:        img[img._height - 1] = (T)(siz + nb_elts);
liveimage_srv/CImg.h:        int siz = img?(int)img[img._height - 1]:0;
liveimage_srv/CImg.h:        if (img && (img._width!=1 || img._depth!=1 || siz<0 || siz>img.height() - 1))
liveimage_srv/CImg.h:          start0 = mp.opcode[3]==~0U?siz - 1:_mp_arg(3),
liveimage_srv/CImg.h:                                      "(not ordered, in range -%d...%d).",
liveimage_srv/CImg.h:                                      mp.imgout.pixel_type(),start0,end0,siz,siz - 1);
liveimage_srv/CImg.h:        if (end<siz - 1) // Move remaining data in dynamic array
liveimage_srv/CImg.h:          cimg_forC(img,c) std::memmove(img.data(0,start,0,c),img.data(0,end + 1,0,c),(siz - 1 - end)*sizeof(T));
liveimage_srv/CImg.h:        siz-=end - start + 1;
liveimage_srv/CImg.h:          img.resize(1,std::max(2*siz + 1,32),1,-100,0);
liveimage_srv/CImg.h:        img[img._height - 1] = (T)siz;
liveimage_srv/CImg.h:        const int siz = img?(int)img[img._height - 1]:0;
liveimage_srv/CImg.h:        if (img && (img._width!=1 || img._depth!=1 || siz<0 || siz>img.height() - 1))
liveimage_srv/CImg.h:        CImg<charT> expr(mp.opcode[2] - 4);
liveimage_srv/CImg.h:                       "Start debugging expression '%s', code length %u -> mem[%u] (memsize: %u)",
liveimage_srv/CImg.h:          _op.assign(1,op._height - 1);
liveimage_srv/CImg.h:                         "Opcode %p = [ %p,%s ] -> mem[%u] = %.17g",
liveimage_srv/CImg.h:          mp.debug_indent-=3;
liveimage_srv/CImg.h:            "End debugging expression '%s' -> mem[%u] = %.17g (memsize: %u)",
liveimage_srv/CImg.h:        --mp.p_code;
liveimage_srv/CImg.h:        return _mp_arg(2) - 1;
liveimage_srv/CImg.h:        const unsigned int i_end = (unsigned int)mp.opcode[2], siz = mp.opcode[2] - 3;
liveimage_srv/CImg.h:          else img.assign(ptr,siz).resize(w,h,d,s,-1);
liveimage_srv/CImg.h:        CImg<charT> expr(mp.opcode[2] - 8);
liveimage_srv/CImg.h:            mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:            mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:        mp.p_code = p_end - 1;
liveimage_srv/CImg.h:        const unsigned int nb_args = (unsigned int)(mp.opcode[2] - 3)/2;
liveimage_srv/CImg.h:          if (siz) { // Vector argument -> string
liveimage_srv/CImg.h:          } else { // Scalar argument -> number
liveimage_srv/CImg.h:                      r1 = -r1; r2 = -r2;
liveimage_srv/CImg.h:                      else { color.resize(k,1,1,1,-1); break; }
liveimage_srv/CImg.h:          CImg<doubleT> args(i_end - 4);
liveimage_srv/CImg.h:        cimg_for_inX(ss,0,ss.width() - 1,i) ss[i] = (char)ptrs[i];
liveimage_srv/CImg.h:        if (siz) ++ptrd; else ++siz; // Fill vector-valued slot
liveimage_srv/CImg.h:              mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:              mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:        mp.p_code = p_end - 1;
liveimage_srv/CImg.h:        const int _step = (int)_mp_arg(6), step = _step?_step:-1;
liveimage_srv/CImg.h:        longT ind = (longT)(mp.opcode[5]!=_cimg_mp_slot_nan?_mp_arg(5):step>0?0:siz - 1);
liveimage_srv/CImg.h:        if (ind<0 || ind>=(longT)siz) return -1.;
liveimage_srv/CImg.h:          return ptr>=ptre?-1.:(double)(ptr - ptrb);
liveimage_srv/CImg.h:        return ptr<ptrb?-1.:(double)(ptr - ptrb);
liveimage_srv/CImg.h:        const int _step = (int)_mp_arg(7), step = _step?_step:-1;
liveimage_srv/CImg.h:        longT ind = (longT)(mp.opcode[6]!=_cimg_mp_slot_nan?_mp_arg(6):step>0?0:siz1 - 1);
liveimage_srv/CImg.h:        if (ind<0 || ind>=(longT)siz1) return -1.;
liveimage_srv/CImg.h:            if (ptr1>=ptr1e) return -1.;
liveimage_srv/CImg.h:          return p2<ptr2e?-1.:(double)(ptr1 - ptr1b);
liveimage_srv/CImg.h:          if (ptr1<ptr1b) return -1.;
liveimage_srv/CImg.h:        return p2<ptr2e?-1.:(double)(ptr1 - ptr1b);
liveimage_srv/CImg.h:          mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:              mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:                mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:              for (mp.p_code = p_post; mp.p_code<p_end; ++mp.p_code) { // Evaluate post-code
liveimage_srv/CImg.h:                mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:        mp.p_code = p_end - 1;
liveimage_srv/CImg.h:        return std::exp(-x*x/(2*s*s))/(_mp_arg(4)?std::sqrt(2*s*s*cimg::PI):1);
liveimage_srv/CImg.h:        cimg_for_inX(ss,0,ss.width() - 1,i) ss[i] = (char)ptrs[i];
liveimage_srv/CImg.h:            mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:            mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:        if (mp.p_code==mp.p_break) --mp.p_code;
liveimage_srv/CImg.h:        else mp.p_code = p_end - 1;
liveimage_srv/CImg.h:          _w = mp.opcode[3]==~0U?-100:_mp_arg(3),
liveimage_srv/CImg.h:          _h = mp.opcode[4]==~0U?-100:_mp_arg(4),
liveimage_srv/CImg.h:          _d = mp.opcode[5]==~0U?-100:_mp_arg(5),
liveimage_srv/CImg.h:          _s = mp.opcode[6]==~0U?-100:_mp_arg(6);
liveimage_srv/CImg.h:          w = (unsigned int)(_w>=0?_w:-_w*img.width()/100),
liveimage_srv/CImg.h:          h = (unsigned int)(_h>=0?_h:-_h*img.height()/100),
liveimage_srv/CImg.h:          d = (unsigned int)(_d>=0?_d:-_d*img.depth()/100),
liveimage_srv/CImg.h:          s = (unsigned int)(_s>=0?_s:-_s*img.spectrum()/100),
liveimage_srv/CImg.h:            return (double)img[moff<whds?moff:whds2 - moff - 1];
liveimage_srv/CImg.h:            return (double)img[off<0?0:whds - 1];
liveimage_srv/CImg.h:            return (double)img._cubic_atXYZ(mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                            my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                            mz<img.depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                                            (int)(mc<img.spectrum()?mc:s2 - mc - 1));
liveimage_srv/CImg.h:                                            (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
liveimage_srv/CImg.h:            return (double)img._linear_atXYZ(mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                             my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                             mz<img.depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                                             (int)(mc<img.spectrum()?mc:s2 - mc - 1));
liveimage_srv/CImg.h:                                             (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
liveimage_srv/CImg.h:            return (double)img(mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                               my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                               mz<img.depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                               mc<img.spectrum()?mc:s2 - mc - 1);
liveimage_srv/CImg.h:            return (double)img[moff<whds?moff:whds2 - moff - 1];
liveimage_srv/CImg.h:            return (double)img[off<0?0:whds - 1];
liveimage_srv/CImg.h:            return (double)img._cubic_atXYZ(mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                            my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                            mz<img.depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                                            (int)(mc<img.spectrum()?mc:s2 - mc - 1));
liveimage_srv/CImg.h:                                            (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
liveimage_srv/CImg.h:            return (double)img._linear_atXYZ(mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                             my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                             mz<img.depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                                             (int)(mc<img.spectrum()?mc:s2 - mc - 1));
liveimage_srv/CImg.h:                                             (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
liveimage_srv/CImg.h:            return (double)img(mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                               my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                               mz<img.depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                               mc<img.spectrum()?mc:s2 - mc - 1);
liveimage_srv/CImg.h:        CImg<doubleT> vals(i_end - 4);
liveimage_srv/CImg.h:        return vals.kth_smallest((ulongT)(ind - 1));
liveimage_srv/CImg.h:        return _mp_arg(2)*(1-t) + _mp_arg(3)*t;
liveimage_srv/CImg.h:        return _mp_arg(2)*_mp_arg(3) - _mp_arg(4);
liveimage_srv/CImg.h:        return _mp_arg(4) - _mp_arg(2)*_mp_arg(3);
liveimage_srv/CImg.h:        const int _step = (int)_mp_arg(5), step = _step?_step:-1;
liveimage_srv/CImg.h:        longT ind = (longT)(mp.opcode[4]!=_cimg_mp_slot_nan?_mp_arg(4):step>0?0:siz - 1);
liveimage_srv/CImg.h:        if (ind<0 || ind>=(longT)siz) return -1.;
liveimage_srv/CImg.h:          return ptr>=ptre?-1.:(double)(ptr - ptrb);
liveimage_srv/CImg.h:        return ptr<ptrb?-1.:(double)(ptr - ptrb);
liveimage_srv/CImg.h:        const int _step = (bool)_mp_arg(6), step = _step?_step:-1;
liveimage_srv/CImg.h:        longT ind = (longT)(mp.opcode[5]!=_cimg_mp_slot_nan?_mp_arg(5):step>0?0:siz1 - 1);
liveimage_srv/CImg.h:        if (ind<0 || ind>=(longT)siz1) return -1.;
liveimage_srv/CImg.h:            if (ptr1>=ptr1e) return -1.;
liveimage_srv/CImg.h:          return p2<ptr2e?-1.:(double)(ptr1 - ptr1b);
liveimage_srv/CImg.h:          if (ptr1<ptr1b) return -1.;
liveimage_srv/CImg.h:        return p2<ptr2e?-1.:(double)(ptr1 - ptr1b);
liveimage_srv/CImg.h:            return (double)img[moff<whds?moff:whds2 - moff - 1];
liveimage_srv/CImg.h:            return (double)img[off<0?0:whds - 1];
liveimage_srv/CImg.h:            return (double)img._cubic_atXYZ(mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                            my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                            mz<img.depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                                            (int)(mc<img.spectrum()?mc:s2 - mc - 1));
liveimage_srv/CImg.h:                                            (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
liveimage_srv/CImg.h:            return (double)img._linear_atXYZ(mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                             my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                             mz<img.depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                                             (int)(mc<img.spectrum()?mc:s2 - mc - 1));
liveimage_srv/CImg.h:                                             (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
liveimage_srv/CImg.h:            return (double)img(mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                               my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                               mz<img.depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                               mc<img.spectrum()?mc:s2 - mc - 1);
liveimage_srv/CImg.h:            return (double)img[moff<whds?moff:whds2 - moff - 1];
liveimage_srv/CImg.h:            return (double)img[off<0?0:whds - 1];
liveimage_srv/CImg.h:            return (double)img._cubic_atXYZ(mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                            my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                            mz<img.depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                                            (int)(mc<img.spectrum()?mc:s2 - mc - 1));
liveimage_srv/CImg.h:                                            (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
liveimage_srv/CImg.h:            return (double)img._linear_atXYZ(mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                             my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                             mz<img.depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                                             (int)(mc<img.spectrum()?mc:s2 - mc - 1));
liveimage_srv/CImg.h:                                             (int)(c<0?0:c>=img._spectrum?img._spectrum - 1:c));
liveimage_srv/CImg.h:            return (double)img(mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                               my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                               mz<img.depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                               mc<img.spectrum()?mc:s2 - mc - 1);
liveimage_srv/CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
liveimage_srv/CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
liveimage_srv/CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
liveimage_srv/CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
liveimage_srv/CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            ptrs = &img[moff<whd?moff:whd2 - moff - 1];
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            ptrs = off<0?&img[0]:&img[whd - 1];
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:              cy = my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ(cx,cy,cz,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ_p((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.cubic_atXYZ((float)x,(float)y,(float)z,c,(T)0);
liveimage_srv/CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:              cy = my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ(cx,cy,cz,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ_p((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.linear_atXYZ((float)x,(float)y,(float)z,c,(T)0);
liveimage_srv/CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:              cy = my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:              cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            ptrs = &img[moff<whd?moff:whd2 - moff - 1];
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            ptrs = off<0?&img[0]:&img[whd - 1];
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:              cy = my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ(cx,cy,cz,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ_p((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.cubic_atXYZ((float)x,(float)y,(float)z,c,(T)0);
liveimage_srv/CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:              cy = my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ(cx,cy,cz,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ_p((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.linear_atXYZ((float)x,(float)y,(float)z,c,(T)0);
liveimage_srv/CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:              cy = my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:              cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:        if (!val_left) { mp.p_code = p_end - 1; return 0; }
liveimage_srv/CImg.h:          mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:        --mp.p_code;
liveimage_srv/CImg.h:        if (val_left) { mp.p_code = p_end - 1; return 1; }
liveimage_srv/CImg.h:          mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:        --mp.p_code;
liveimage_srv/CImg.h:          eoff = off + (siz - 1)*inc;
liveimage_srv/CImg.h:                                      "Out-of-bounds variable pointer "
liveimage_srv/CImg.h:                                      mp.imgin.pixel_type(),siz,inc,off,eoff,mp.mem._width - 1);
liveimage_srv/CImg.h:        const longT eoff = off + (siz - 1)*inc;
liveimage_srv/CImg.h:                                      "Out-of-bounds image pointer "
liveimage_srv/CImg.h:                                      mp.imgin.pixel_type(),siz,inc,off,eoff,img.size() - 1);
liveimage_srv/CImg.h:          omopacity = 1 - std::max(_opacity,0.f);
liveimage_srv/CImg.h:          if (is_doubled && is_doubles) { // (double*) <- (double*)
liveimage_srv/CImg.h:              if (ptrs + siz - 1<ptrd || ptrs>ptrd + siz - 1) std::memcpy(ptrd,ptrs,siz*sizeof(double));
liveimage_srv/CImg.h:              if (ptrs + (siz - 1)*inc_s<ptrd || ptrs>ptrd + (siz - 1)*inc_d) {
liveimage_srv/CImg.h:                if (_opacity>=1) while (siz-->0) { *ptrd = *ptrs; ptrd+=inc_d; ptrs+=inc_s; }
liveimage_srv/CImg.h:                else while (siz-->0) { *ptrd = omopacity**ptrd + opacity**ptrs; ptrd+=inc_d; ptrs+=inc_s; }
liveimage_srv/CImg.h:                if (_opacity>=1) while (siz-->0) { *ptrd = *(ptrs++); ptrd+=inc_d; }
liveimage_srv/CImg.h:                else while (siz-->0) { *ptrd = omopacity**ptrd + opacity**(ptrs++); ptrd+=inc_d; }
liveimage_srv/CImg.h:          } else if (is_doubled && !is_doubles) { // (double*) <- (float*)
liveimage_srv/CImg.h:            if (_opacity>=1) while (siz-->0) { *ptrd = *ptrs; ptrd+=inc_d; ptrs+=inc_s; }
liveimage_srv/CImg.h:            else while (siz-->0) { *ptrd = omopacity**ptrd + _opacity**ptrs; ptrd+=inc_d; ptrs+=inc_s; }
liveimage_srv/CImg.h:          } else if (!is_doubled && is_doubles) { // (float*) <- (double*)
liveimage_srv/CImg.h:            if (_opacity>=1) while (siz-->0) { *ptrd = (float)*ptrs; ptrd+=inc_d; ptrs+=inc_s; }
liveimage_srv/CImg.h:            else while (siz-->0) { *ptrd = (float)(omopacity**ptrd + opacity**ptrs); ptrd+=inc_d; ptrs+=inc_s; }
liveimage_srv/CImg.h:          } else { // (float*) <- (float*)
liveimage_srv/CImg.h:              if (ptrs + siz - 1<ptrd || ptrs>ptrd + siz - 1) std::memcpy(ptrd,ptrs,siz*sizeof(float));
liveimage_srv/CImg.h:              if (ptrs + (siz - 1)*inc_s<ptrd || ptrs>ptrd + (siz - 1)*inc_d) {
liveimage_srv/CImg.h:                if (_opacity>=1) while (siz-->0) { *ptrd = *ptrs; ptrd+=inc_d; ptrs+=inc_s; }
liveimage_srv/CImg.h:                else while (siz-->0) { *ptrd = omopacity**ptrd + opacity**ptrs; ptrd+=inc_d; ptrs+=inc_s; }
liveimage_srv/CImg.h:                if (_opacity>=1) while (siz-->0) { *ptrd = *(ptrs++); ptrd+=inc_d; }
liveimage_srv/CImg.h:                else while (siz-->0) { *ptrd = omopacity**ptrd + opacity**(ptrs++); ptrd+=inc_d; }
liveimage_srv/CImg.h:        return -_mp_arg(2);
liveimage_srv/CImg.h:        switch (i_end - 3) {
liveimage_srv/CImg.h:        CImg<doubleT> vals(i_end - 3);
liveimage_srv/CImg.h:        switch (i_end - 3) {
liveimage_srv/CImg.h:        switch (i_end - 3) {
liveimage_srv/CImg.h:        switch (i_end - 3) {
liveimage_srv/CImg.h:        switch (i_end - 3) {
liveimage_srv/CImg.h:            if (nbv<0) { nbv = -nbv; is_outlined = true; }
liveimage_srv/CImg.h:              else { color.resize(k,1,1,1,-1); break; }
liveimage_srv/CImg.h:          CImg<doubleT> args(i_end - 4);
liveimage_srv/CImg.h:            CImg<charT> _expr(mp.opcode[2] - 4);
liveimage_srv/CImg.h:                mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:                mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:        mp.p_code = p_end - 1;
liveimage_srv/CImg.h:        *(ptrd++) = -sa;
liveimage_srv/CImg.h:        return --_mp_arg(1);
liveimage_srv/CImg.h:        while (siz-->0) { target = ptrd++; (*op)(mp); }
liveimage_srv/CImg.h:        while (siz-->0) { target = ptrd++; argument = ptrs++; (*op)(mp); }
liveimage_srv/CImg.h:        return _mp_arg(1)-=_mp_arg(2);
liveimage_srv/CImg.h:        cimg_for_inX(sd,0,sd.width() - 1,i) sd[i] = (char)ptrd[i];
liveimage_srv/CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
liveimage_srv/CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
liveimage_srv/CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
liveimage_srv/CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *ptrd = (T)*(ptrs++); ptrd+=whd; }
liveimage_srv/CImg.h:        if (sn<siz) CImg<doubleT>(ptrd + sn,siz - sn,1,1,1,true) = CImg<doubleT>(ptrs + sn,siz - sn,1,1,1,true);
liveimage_srv/CImg.h:        CImg<doubleT> vals(i_end - 3);
liveimage_srv/CImg.h:        while (siz-->0) mp.mem[ptrd++] = (double)*(ptrs++);
liveimage_srv/CImg.h:        cimg_for_inX(ss,0,ss.width() - 1,i) ss[i] = (char)ptr2[i];
liveimage_srv/CImg.h:        if (!siz) return *ptrs>='0' && *ptrs<='9'?*ptrs - '0':val;
liveimage_srv/CImg.h:        CImg<charT> ss(siz + 1 - ind);
liveimage_srv/CImg.h:        const bool is_negative = *s=='-';
liveimage_srv/CImg.h:          // Check for +/-NaN and +/-inf as Microsoft's sscanf() version is not able
liveimage_srv/CImg.h:        if (is_negative) val = -val;
liveimage_srv/CImg.h:        const unsigned int nb_args = (unsigned int)(mp.opcode[3] - 3)/2;
liveimage_srv/CImg.h:          if (siz) { // Vector argument -> string
liveimage_srv/CImg.h:          } else { // Scalar argument -> number
liveimage_srv/CImg.h:        return _mp_arg(2) - _mp_arg(3);
liveimage_srv/CImg.h:        CImg<doubleT> vals(i_end - 3);
liveimage_srv/CImg.h:        if (start<0 || start + step*(sublength-1)>=length)
liveimage_srv/CImg.h:                                      "Out-of-bounds sub-vector request "
liveimage_srv/CImg.h:                                      "(length: %ld, start: %ld, sub-length: %ld, step: %ld).",
liveimage_srv/CImg.h:        switch (mp.opcode[2] - 4) {
liveimage_srv/CImg.h:        case 1 : { const double val = _mp_arg(ptrs); while (siz-->0) mp.mem[ptrd++] = val; } break;
liveimage_srv/CImg.h:        default : while (siz-->0) { mp.mem[ptrd++] = _mp_arg(ptrs++); if (ptrs>=mp.opcode[2]) ptrs = 4U; }
liveimage_srv/CImg.h:              while (still_equal && p1--) still_equal = *(ptr1++)==*(ptr2++);
liveimage_srv/CImg.h:              while (still_equal && p1--)
liveimage_srv/CImg.h:            while (still_equal && p1--) still_equal = *(ptr1++)==value;
liveimage_srv/CImg.h:            while (still_equal && p2--) still_equal = *(ptr2++)==value;
liveimage_srv/CImg.h:            while (still_equal && n--) still_equal = *(ptr1++)==(*ptr2++);
liveimage_srv/CImg.h:            while (still_equal && n--) still_equal = cimg::lowercase(*(ptr1++))==cimg::lowercase(*(ptr2++));
liveimage_srv/CImg.h:          while (still_equal && n--) still_equal = *(ptr1++)==value;
liveimage_srv/CImg.h:          while (still_equal && n--) still_equal = *(ptr2++)==value;
liveimage_srv/CImg.h:        for (unsigned int k = 0; k<siz; ++k) ptrd[k] = ptrs1[k]*(1-t) + ptrs2[k]*t;
liveimage_srv/CImg.h:        while (siz-->0) { argument2 = ptrs++; *(ptrd++) = (*op)(mp); }
liveimage_srv/CImg.h:        while (siz-->0) { argument = ptrs++; *(ptrd++) = (*op)(mp); }
liveimage_srv/CImg.h:        while (siz-->0) { argument1 = ptrs++; *(ptrd++) = (*op)(mp); }
liveimage_srv/CImg.h:        while (siz-->0) { argument1 = ptrs++; *(ptrd++) = (*op)(mp); }
liveimage_srv/CImg.h:        while (siz-->0) { argument1 = ptrs1++; argument2 = ptrs2++; *(ptrd++) = (*op)(mp); }
liveimage_srv/CImg.h:          CImg<charT> _expr(mp.opcode[2] - 5);
liveimage_srv/CImg.h:          while (siz-->0) {
liveimage_srv/CImg.h:              ptr = (unsigned int)mp.opcode[1] + 1 + siz0 - 64;
liveimage_srv/CImg.h:      const unsigned int nbargs = (unsigned int)(mp.opcode[3] - 4)/2; \
liveimage_srv/CImg.h:        cimg_pragma_openmp(for) for (longT k = sizd?sizd - 1:0; k>=0; --k) { \
liveimage_srv/CImg.h:        const double val = (+vec).get_shared_points(1,vec.width() - 1).
liveimage_srv/CImg.h:          kth_smallest((ulongT)cimg::cut((longT)*vec - 1,(longT)0,(longT)vec.width() - 2));
liveimage_srv/CImg.h:        cimg_for_inX(vec,1,vec.width()-1,ind) if (vec[ind]==val) return ind - 1.;
liveimage_srv/CImg.h:        _cimg_mp_vfunc(res = (double)(&vec.max() - vec.data()));
liveimage_srv/CImg.h:        _cimg_mp_vfunc(res = (double)(&vec.maxabs() - vec.data()));
liveimage_srv/CImg.h:        _cimg_mp_vfunc(res = (double)(&vec.min() - vec.data()));
liveimage_srv/CImg.h:        _cimg_mp_vfunc(res = (double)(&vec.minabs() - vec.data()));
liveimage_srv/CImg.h:        _cimg_mp_vfunc(res = vec.get_shared_points(1,vec.width() - 1).
liveimage_srv/CImg.h:                       kth_smallest((ulongT)cimg::cut((longT)*vec - 1,(longT)0,(longT)vec.width() - 2)));
liveimage_srv/CImg.h:        case -1 : std::strcpy(format,"%g"); break;
liveimage_srv/CImg.h:        CImg<doubleT>(ptrd,l,1,1,1,true) = str.get_shared_points(0,l - 1);
liveimage_srv/CImg.h:            mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:              mp.opcode._data = mp.p_code->_data;
liveimage_srv/CImg.h:        mp.p_code = p_end - 1;
liveimage_srv/CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            ptrs = &img[moff<whd?moff:whd2 - moff - 1];
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            ptrs = off<0?&img[0]:&img[whd - 1];
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:              cy = my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ(cx,cy,cz,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ_p((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.cubic_atXYZ((float)x,(float)y,(float)z,c,(T)0);
liveimage_srv/CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:              cy = my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ(cx,cy,cz,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ_p((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.linear_atXYZ((float)x,(float)y,(float)z,c,(T)0);
liveimage_srv/CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:              cy = my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:              cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:          cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            ptrs = &img[moff<whd?moff:whd2 - moff - 1];
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            ptrs = off<0?&img[0]:&img[whd - 1];
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = *ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:              cy = my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ(cx,cy,cz,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ_p((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._cubic_atXYZ((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.cubic_atXYZ((float)x,(float)y,(float)z,c,(T)0);
liveimage_srv/CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:              cy = my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ(cx,cy,cz,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ_p((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img._linear_atXYZ((float)x,(float)y,(float)z,c);
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) *(ptrd++) = (double)img.linear_atXYZ((float)x,(float)y,(float)z,c,(T)0);
liveimage_srv/CImg.h:              cx = mx<img.width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:              cy = my<img.height()?my:h2 - my - 1,
liveimage_srv/CImg.h:              cz = mz<img.depth()?mz:d2 - mz - 1;
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:            cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:              cimg_for_inC(img,0,vsiz - 1,c) { *(ptrd++) = (double)*ptrs; ptrs+=whd; }
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:    //! Compute the base-2 logarithm of each pixel value.
liveimage_srv/CImg.h:       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its base-2 logarithm
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:    //! Compute the base-10 logarithm of each pixel value.
liveimage_srv/CImg.h:       Replace each pixel value \f$I_{(x,y,z,c)}\f$ of the image instance by its base-10 logarithm
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The sign is set to:
liveimage_srv/CImg.h:         - \c 1 if pixel value is strictly positive.
liveimage_srv/CImg.h:         - \c -1 if pixel value is strictly negative.
liveimage_srv/CImg.h:         - \c 0 if pixel value is equal to \c 0.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - Pixel values are regarded as being in \e radian.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - Pixel values are regarded as being in \e radian.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - Pixel values are regarded as being exin \e radian.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - Pixel values are regarded as being exin \e radian.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:          img_x(100,100,1,1,"x-w/2",false),   // Define an horizontal centered gradient, from '-width/2' to 'width/2'
liveimage_srv/CImg.h:          img_y(100,100,1,1,"y-h/2",false),   // Define a vertical centered gradient, from '-height/2' to 'height/2'
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:    //! In-place pointwise multiplication.
liveimage_srv/CImg.h:       - Similar to operator+=(const CImg<t>&), except that it performs a pointwise multiplication
liveimage_srv/CImg.h:       - It does \e not perform a \e matrix multiplication. For this purpose, use operator*=(const CImg<t>&) instead.
liveimage_srv/CImg.h:         shade(img.width,img.height(),1,1,"-(x-w/2)^2-(y-h/2)^2",false);
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:    //! In-place pointwise multiplication \newinstance.
liveimage_srv/CImg.h:    //! In-place pointwise division.
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:    //! In-place pointwise division \newinstance.
liveimage_srv/CImg.h:       - The \inplace of this method statically casts the computed values to the pixel type \c T.
liveimage_srv/CImg.h:       - The \newinstance returns a \c CImg<float> image, if the pixel type \c T is \e not float-valued.
liveimage_srv/CImg.h:      if (p==-4) { cimg_openmp_for(*this,1/(Tfloat)cimg::pow4(*ptr),32768); return *this; }
liveimage_srv/CImg.h:      if (p==-3) { cimg_openmp_for(*this,1/(Tfloat)cimg::pow3(*ptr),32768); return *this; }
liveimage_srv/CImg.h:      if (p==-2) { cimg_openmp_for(*this,1/(Tfloat)cimg::sqr(*ptr),32768); return *this; }
liveimage_srv/CImg.h:      if (p==-1) { cimg_openmp_for(*this,1/(Tfloat)*ptr,32768); return *this; }
liveimage_srv/CImg.h:      if (p==-0.5) { cimg_openmp_for(*this,1/std::sqrt((Tfloat)*ptr),8192); return *this; }
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:       \param expression Math formula as a C-string.
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:       \param expression Math formula as a C-string.
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:       \param expression Math formula as a C-string.
liveimage_srv/CImg.h:        if (siz>isiz) for (ulongT n = siz/isiz; n; --n)
liveimage_srv/CImg.h:       \param expression Math formula as a C-string.
liveimage_srv/CImg.h:      ulongT l = 0, ir = size() - 1;
liveimage_srv/CImg.h:            do --j; while (arr[j]>pivot);
liveimage_srv/CImg.h:          if (j>=k) ir = j - 1;
liveimage_srv/CImg.h:      return (s%2)?res:(T)((res + kth_smallest((s>>1) - 1))/2);
liveimage_srv/CImg.h:       - \c 0: Second moment, computed as
liveimage_srv/CImg.h:       \f$1/N \sum\limits_{k=1}^{N} (x_k - \bar x)^2 =
liveimage_srv/CImg.h:       1/N \left( \sum\limits_{k=1}^N x_k^2 - \left( \sum\limits_{k=1}^N x_k \right)^2 / N \right)\f$
liveimage_srv/CImg.h:       - \c 1: Best unbiased estimator, computed as \f$\frac{1}{N - 1} \sum\limits_{k=1}^{N} (x_k - \bar x)^2 \f$.
liveimage_srv/CImg.h:       - \c 2: Least median of squares.
liveimage_srv/CImg.h:       - \c 3: Least trimmed of squares.
liveimage_srv/CImg.h:        variance = (S2 - S*S/siz)/siz;
liveimage_srv/CImg.h:        variance = siz>1?(S2 - S*S/siz)/(siz - 1):0;
liveimage_srv/CImg.h:          const double val = (double)*ptrs; *ptrs = (Tfloat)cimg::abs(val - med_i); average+=val;
liveimage_srv/CImg.h:                                 (double)Icp - 4*(double)Icc);
liveimage_srv/CImg.h:                                   (double)Iccn + (double)Iccp - 6*(double)Iccc);
liveimage_srv/CImg.h:                                   (double)Icn + (double)Icp - 4*(double)Icc);
liveimage_srv/CImg.h:             (double)Iccn + (double)Iccp - 6*(double)Iccc);
liveimage_srv/CImg.h:      if (variance_method) variance = siz>1?(S2 - S*S/siz)/(siz - 1):0;
liveimage_srv/CImg.h:      else variance = (S2 - S*S/siz)/siz;
liveimage_srv/CImg.h:    //! Compute the MSE (Mean-Squared Error) between two images.
liveimage_srv/CImg.h:        const double diff = (double)*ptr1 - (double)*(ptr2++);
liveimage_srv/CImg.h:    //! Compute the PSNR (Peak Signal-to-Noise Ratio) between two images.
liveimage_srv/CImg.h:       \param expression Math formula, as a C-string.
liveimage_srv/CImg.h:       \param x Value of the pre-defined variable \c x.
liveimage_srv/CImg.h:       \param y Value of the pre-defined variable \c y.
liveimage_srv/CImg.h:       \param z Value of the pre-defined variable \c z.
liveimage_srv/CImg.h:       \param c Value of the pre-defined variable \c c.
liveimage_srv/CImg.h:    // Fast function to pre-evaluate common expressions.
liveimage_srv/CImg.h:          res = (t)(c - '0');
liveimage_srv/CImg.h:          case '-' : res = (t)(val - val2); is_success = true; break;
liveimage_srv/CImg.h:      } else if ((c=='+' || c=='-' || c=='!') && // +Value, -Value or !Value
liveimage_srv/CImg.h:        if (!expression[2]) { // [+-!] + Single digit
liveimage_srv/CImg.h:          const int ival = sep - '0';
liveimage_srv/CImg.h:          res = (t)(c=='+'?ival:c=='-'?-ival:!ival);
liveimage_srv/CImg.h:        } else if ((err = std::sscanf(expression + 1,"%lf %c%lf %c",&val,&sep,&val2,&end))==1) { // [+-!] Single value
liveimage_srv/CImg.h:          res = (t)(c=='+'?val:c=='-'?-val:(double)!val);
liveimage_srv/CImg.h:        } else if (err==3) { // [+-!] Value1 Operator Value2
liveimage_srv/CImg.h:          const double val1 = c=='+'?val:c=='-'?-val:(double)!val;
liveimage_srv/CImg.h:          case '-' : res = (t)(val1 - val2); is_success = true; break;
liveimage_srv/CImg.h:          case '^' : val = std::pow(val,val2); res = (t)(c=='+'?val:c=='-'?-val:!val); is_success = true; break;
liveimage_srv/CImg.h:      } else if (!expression[1]) switch (*expression) { // Other common single-char expressions
liveimage_srv/CImg.h:       \param expression Math formula, as a C-string.
liveimage_srv/CImg.h:       \param x Value of the pre-defined variable \c x.
liveimage_srv/CImg.h:       \param y Value of the pre-defined variable \c y.
liveimage_srv/CImg.h:       \param z Value of the pre-defined variable \c z.
liveimage_srv/CImg.h:       \param c Value of the pre-defined variable \c c.
liveimage_srv/CImg.h:       \param expression Math formula, as a C-string.
liveimage_srv/CImg.h:        _variance_value = variance_method==0?(S2 - S*S/siz)/siz:
liveimage_srv/CImg.h:        (variance_method==1?(siz>1?(S2 - S*S/siz)/(siz - 1):0):
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:       - \c -1: Linf-norm
liveimage_srv/CImg.h:       - \c 0: L0-norm
liveimage_srv/CImg.h:       - \c 1: L1-norm
liveimage_srv/CImg.h:       - \c 2: L2-norm
liveimage_srv/CImg.h:      case -1 : {
liveimage_srv/CImg.h:      case 2 : return (double)((*this)(0,0))*(double)((*this)(1,1)) - (double)((*this)(0,1))*(double)((*this)(1,0));
liveimage_srv/CImg.h:        return i*a*e - a*h*f - i*b*d + b*g*f + c*d*h - c*g*e;
liveimage_srv/CImg.h:        double res = d?(double)1:(double)-1;
liveimage_srv/CImg.h:    //! Get vector-valued pixel located at specified position.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:    //! Get (square) matrix-valued pixel located at specified position.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \note - The spectrum() of the image must be a square.
liveimage_srv/CImg.h:    //! Get tensor-valued pixel located at specified position.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:    //! Set vector-valued pixel at specified position.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:        for (unsigned int k = std::min((unsigned int)vec.size(),_spectrum); k; --k) {
liveimage_srv/CImg.h:    //! Set (square) matrix-valued pixel at specified position.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:    //! Set tensor-valued pixel at specified position.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:      const ulongT siz = size() - 1;
liveimage_srv/CImg.h:        const double delta = (double)a1 - (double)a0;
liveimage_srv/CImg.h:      (*this)[0] = (T)(y*img[2] - z*img[1]);
liveimage_srv/CImg.h:      (*this)[1] = (T)(z*img[0] - x*img[2]);
liveimage_srv/CImg.h:      (*this)[2] = (T)(x*img[1] - y*img[0]);
liveimage_srv/CImg.h:       - \c true: LU-based matrix inversion.
liveimage_srv/CImg.h:       - \c false: SVD-based matrix inversion.
liveimage_srv/CImg.h:      const double dete = _width>3?-1.:det();
liveimage_srv/CImg.h:        _data[0] = (T)(d/dete); _data[1] = (T)(-c/dete);
liveimage_srv/CImg.h:        _data[2] = (T)(-b/dete); _data[3] = (T)(a/dete);
liveimage_srv/CImg.h:        _data[0] = (T)((i*e - f*h)/dete), _data[1] = (T)((g*f - i*d)/dete), _data[2] = (T)((d*h - g*e)/dete);
liveimage_srv/CImg.h:        _data[3] = (T)((h*c - i*b)/dete), _data[4] = (T)((i*a - c*g)/dete), _data[5] = (T)((g*b - a*h)/dete);
liveimage_srv/CImg.h:        _data[6] = (T)((b*f - e*c)/dete), _data[7] = (T)((d*c - a*f)/dete), _data[8] = (T)((a*e - d*b)/dete);
liveimage_srv/CImg.h:        if (use_LU) { // LU-based
liveimage_srv/CImg.h:        } else pseudoinvert(false); // SVD-based
liveimage_srv/CImg.h:    //! Compute the Moore-Penrose pseudo-inverse of the instance image, viewed as a matrix.
liveimage_srv/CImg.h:    //! Compute the Moore-Penrose pseudo-inverse of the instance image, viewed as a matrix \newinstance.
liveimage_srv/CImg.h:      // LU-based method.
liveimage_srv/CImg.h:      // SVD-based method.
liveimage_srv/CImg.h:      const Tfloat epsilon = (sizeof(Tfloat)<=4?5.96e-8f:1.11e-16f)*std::max(_width,_height)*S.max();
liveimage_srv/CImg.h:       \param use_LU In case of non square system (least-square solution),
liveimage_srv/CImg.h:                     choose between SVD-based (\c false) or LU-based (\c true) method.
liveimage_srv/CImg.h:          det = a*d - b*c, fM = cimg::max(fa,fb,fc,fd);
liveimage_srv/CImg.h:            const double u = (double)(*this)(k,0), v = (double)(*this)(k,1), y = (a*v - c*u)/det;
liveimage_srv/CImg.h:            (*this)(k,0) = (T)((u - b*y)/a); (*this)(k,1) = (T)y;
liveimage_srv/CImg.h:            const double u = (double)(*this)(k,0), v = (double)(*this)(k,1), y = (a*v - c*u)/det;
liveimage_srv/CImg.h:            (*this)(k,0) = (T)((v - d*y)/c); (*this)(k,1) = (T)y;
liveimage_srv/CImg.h:            const double u = (double)(*this)(k,0), v = (double)(*this)(k,1), x = (d*u - b*v)/det;
liveimage_srv/CImg.h:            (*this)(k,0) = (T)x; (*this)(k,1) = (T)((u - a*x)/b);
liveimage_srv/CImg.h:            const double u = (double)(*this)(k,0), v = (double)(*this)(k,1), x = (d*u - b*v)/det;
liveimage_srv/CImg.h:            (*this)(k,0) = (T)x; (*this)(k,1) = (T)((v - c*x)/d);
liveimage_srv/CImg.h:      } else { // Least-square solution for non-square systems
liveimage_srv/CImg.h:        int INFO, N = A._width, M = A._height, LWORK = -1, LDA = M, LDB = M, NRHS = _width;
liveimage_srv/CImg.h:      int ii = -1;
liveimage_srv/CImg.h:        if (ii>=0) for (int j = ii; j<=i - 1; ++j) sum-=A(j,i)*(*this)(j);
liveimage_srv/CImg.h:      for (int i = N - 1; i>=0; --i) {
liveimage_srv/CImg.h:        for (int j = i + 1; j<N; ++j) sum-=A(j,i)*(*this)(j);
liveimage_srv/CImg.h:      const Ttfloat epsilon = 1e-4f;
liveimage_srv/CImg.h:        const Ttfloat m = A(0,i)/(B[i - 1]?B[i - 1]:epsilon);
liveimage_srv/CImg.h:        B[i] -= m*A(2,i - 1);
liveimage_srv/CImg.h:        V[i] -= m*V[i - 1];
liveimage_srv/CImg.h:      (*this)[siz - 1] = (T)(V[siz - 1]/(B[siz - 1]?B[siz - 1]:epsilon));
liveimage_srv/CImg.h:      for (int i = (int)siz - 2; i>=0; --i) (*this)[i] = (T)((V[i] - A(2,i)*(*this)[i + 1])/(B[i]?B[i]:epsilon));
liveimage_srv/CImg.h:          double f = e*e - 4*(a*d - b*c);
liveimage_srv/CImg.h:            l1 = 0.5*(e - f),
liveimage_srv/CImg.h:            norm1 = std::sqrt(cimg::sqr(l2 - a) + b2),
liveimage_srv/CImg.h:            norm2 = std::sqrt(cimg::sqr(l1 - a) + b2);
liveimage_srv/CImg.h:          if (norm1>0) { vec(0,0) = (t)(b/norm1); vec(0,1) = (t)((l2 - a)/norm1); } else { vec(0,0) = 1; vec(0,1) = 0; }
liveimage_srv/CImg.h:          if (norm2>0) { vec(1,0) = (t)(b/norm2); vec(1,1) = (t)((l1 - a)/norm2); } else { vec(1,0) = 1; vec(1,1) = 0; }
liveimage_srv/CImg.h:          e = a + d, f = std::sqrt(std::max(e*e - 4*(a*d - b*c),0.0)),
liveimage_srv/CImg.h:          l1 = 0.5*(e - f), l2 = 0.5*(e + f),
liveimage_srv/CImg.h:          n = std::sqrt(cimg::sqr(l2 - a) + b*b);
liveimage_srv/CImg.h:        if (n>0) { vec[0] = (t)(b/n); vec[2] = (t)((l2 - a)/n); } else { vec[0] = 1; vec[2] = 0; }
liveimage_srv/CImg.h:        vec[1] = -vec[2];
liveimage_srv/CImg.h:        cimg_forY(val,i) val(i) = (T)lapW[N - 1 -i];
liveimage_srv/CImg.h:        cimg_forXY(vec,k,l) vec(k,l) = (T)(lapA[(N - 1 - k)*N + l]);
liveimage_srv/CImg.h:        if (scal<0) val[p] = -val[p];
liveimage_srv/CImg.h:        val-=eig;
liveimage_srv/CImg.h:      return _quicksort(0,size() - 1,permutations,is_increasing,true);
liveimage_srv/CImg.h:       - \c 0: All pixel values are sorted, independently on their initial position.
liveimage_srv/CImg.h:       - \c 'x': Image columns are sorted, according to the first value in each column.
liveimage_srv/CImg.h:       - \c 'y': Image rows are sorted, according to the first value in each row.
liveimage_srv/CImg.h:       - \c 'z': Image slices are sorted, according to the first value in each slice.
liveimage_srv/CImg.h:       - \c 'c': Image channels are sorted, according to the first value in each channel.
liveimage_srv/CImg.h:        _quicksort(0,size() - 1,perm,is_increasing,false);
liveimage_srv/CImg.h:        get_crop(0,0,0,0,_width - 1,0,0,0).sort(perm,is_increasing);
liveimage_srv/CImg.h:        get_crop(0,0,0,0,0,_height - 1,0,0).sort(perm,is_increasing);
liveimage_srv/CImg.h:        get_crop(0,0,0,0,0,0,_depth - 1,0).sort(perm,is_increasing);
liveimage_srv/CImg.h:        get_crop(0,0,0,0,0,0,0,_spectrum - 1).sort(perm,is_increasing);
liveimage_srv/CImg.h:        if (indM - indm>=3) {
liveimage_srv/CImg.h:              while ((*this)[j]>pivot) --j;
liveimage_srv/CImg.h:                cimg::swap((*this)[i++],(*this)[j--]);
liveimage_srv/CImg.h:              while ((*this)[j]<pivot) --j;
liveimage_srv/CImg.h:                cimg::swap((*this)[i++],(*this)[j--]);
liveimage_srv/CImg.h:      const Ttfloat epsilon = (Ttfloat)1e-25;
liveimage_srv/CImg.h:              g = (Ttfloat)((f>=0?-1:1)*std::sqrt(s));
liveimage_srv/CImg.h:              h = f*g - s;
liveimage_srv/CImg.h:              U(i,i) = f - g;
liveimage_srv/CImg.h:          if (i<height() && i!=width() - 1) {
liveimage_srv/CImg.h:              g = (Ttfloat)((f>=0?-1:1)*std::sqrt(s));
liveimage_srv/CImg.h:              h = f*g - s;
liveimage_srv/CImg.h:              U(l,i) = f - g;
liveimage_srv/CImg.h:        for (int i = width() - 1; i>=0; --i) {
liveimage_srv/CImg.h:          if (i<width() - 1) {
liveimage_srv/CImg.h:        for (int i = std::min(width(),height()) - 1; i>=0; --i) {
liveimage_srv/CImg.h:        for (int k = width() - 1; k>=0; --k) {
liveimage_srv/CImg.h:            for (l = k; l>=1; --l) {
liveimage_srv/CImg.h:              nm = l - 1;
liveimage_srv/CImg.h:                s = -f*h;
liveimage_srv/CImg.h:                  U(i,j) = z*c - y*s;
liveimage_srv/CImg.h:            if (l==k) { if (z<0) { S[k] = -z; cimg_forX(U,j) V(k,j) = -V(k,j); } break; }
liveimage_srv/CImg.h:            nm = k - 1;
liveimage_srv/CImg.h:            f = ((y - z)*(y + z) + (g - h)*(g + h))/std::max(epsilon,(Ttfloat)2*h*y);
liveimage_srv/CImg.h:            f = ((x - z)*(x + z) + h*((y/(f + (f>=0?g:-g))) - h))/std::max(epsilon,(Ttfloat)x);
liveimage_srv/CImg.h:              g = g*c - x*s;
liveimage_srv/CImg.h:                V(i,jj) = z2*c - x2*s;
liveimage_srv/CImg.h:              x = c*y1 - s*g;
liveimage_srv/CImg.h:                U(i,jj) = z2*c - y2*s;
liveimage_srv/CImg.h:          for (int k = 0; k<i; ++k) sum-=(*this)(k,i)*(*this)(j,k);
liveimage_srv/CImg.h:          for (int k = 0; k<j; ++k) sum-=(*this)(k,i)*(*this)(j,k);
liveimage_srv/CImg.h:        if ((*this)(j,j)==0) (*this)(j,j) = (T)1e-20;
liveimage_srv/CImg.h:       Find the best matching projection of selected matrix onto the span of an over-complete dictionary D,
liveimage_srv/CImg.h:       Instance image must a 2D-matrix in which each column represent a signal to project.
liveimage_srv/CImg.h:         - 0 = orthogonal projection (default).
liveimage_srv/CImg.h:         - 1 = matching pursuit.
liveimage_srv/CImg.h:         - 2 = matching pursuit, with a single orthogonal projection step at the end.
liveimage_srv/CImg.h:         - >=3 = orthogonal matching pursuit where an orthogonal projection step is performed
liveimage_srv/CImg.h:                 every 'method-2' iterations.
liveimage_srv/CImg.h:                            const unsigned int max_iter=0, const double max_residual=1e-6) {
liveimage_srv/CImg.h:                                    const unsigned int max_iter=0, const double max_residual=1e-6) const {
liveimage_srv/CImg.h:        Dnorm[d] = std::max((Tfloat)1e-8,std::sqrt(norm));
liveimage_srv/CImg.h:      const unsigned int proj_step = method<3?1:method - 2;
liveimage_srv/CImg.h:              S[y]-=dotmax*D(dmax,y);
liveimage_srv/CImg.h:            S0.get_solve(sD,true).move_to(sD); // sD is now a one-column vector of weights
liveimage_srv/CImg.h:              cimg_forY(S,y) S[y]-=weight*D(ind,y);
liveimage_srv/CImg.h:      // Normalize resulting coefficients according to initial (non-normalized) dictionary.
liveimage_srv/CImg.h:      previous_node.assign(1,nb_nodes,1,1,(t)-1);
liveimage_srv/CImg.h:                for (unsigned int pos = q, par = 0; pos && distpos<dist(Q(par=(pos + 1)/2 - 1)); pos=par)
liveimage_srv/CImg.h:          Q(0) = Q(--sizeQ);
liveimage_srv/CImg.h:               ((right=2*(pos + 1),(left=right - 1))<sizeQ && distpos>dist(Q(left))) ||
liveimage_srv/CImg.h:       \param str input C-string to encode as an image.
liveimage_srv/CImg.h:    //! Return a N-numbered sequence vector from \p a0 to \p a1.
liveimage_srv/CImg.h:       \param x X-coordinate of the rotation axis, or first quaternion coordinate.
liveimage_srv/CImg.h:       \param y Y-coordinate of the rotation axis, or second quaternion coordinate.
liveimage_srv/CImg.h:       \param z Z-coordinate of the rotation axis, or third quaternion coordinate.
liveimage_srv/CImg.h:        return CImg<T>::matrix((T)(X*X + Y*Y - Z*Z - W*W),(T)(2*Y*Z - 2*X*W),(T)(2*X*Z + 2*Y*W),
liveimage_srv/CImg.h:                               (T)(2*X*W + 2*Y*Z),(T)(X*X - Y*Y + Z*Z - W*W),(T)(2*Z*W - 2*X*Y),
liveimage_srv/CImg.h:                               (T)(2*Y*W - 2*X*Z),(T)(2*X*Y + 2*Z*W),(T)(X*X - Y*Y - Z*Z + W*W));
liveimage_srv/CImg.h:      const double ang = w*cimg::PI/180, c = std::cos(ang), omc = 1 - c, s = std::sin(ang);
liveimage_srv/CImg.h:      return CImg<T>::matrix((T)(X*X*omc + c),(T)(X*Y*omc - Z*s),(T)(X*Z*omc + Y*s),
liveimage_srv/CImg.h:                             (T)(X*Y*omc + Z*s),(T)(Y*Y*omc + c),(T)(Y*Z*omc - X*s),
liveimage_srv/CImg.h:                             (T)(X*Z*omc - Y*s),(T)(Y*Z*omc + X*s),(T)(Z*Z*omc + c));
liveimage_srv/CImg.h:    //-----------------------------------
liveimage_srv/CImg.h:    //-----------------------------------
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 1;
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 2;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 3;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 4;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 5;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
liveimage_srv/CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 6;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
liveimage_srv/CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
liveimage_srv/CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 7;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
liveimage_srv/CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
liveimage_srv/CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
liveimage_srv/CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 8;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
liveimage_srv/CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
liveimage_srv/CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
liveimage_srv/CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
liveimage_srv/CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 9;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
liveimage_srv/CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
liveimage_srv/CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
liveimage_srv/CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
liveimage_srv/CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
liveimage_srv/CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 10;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 10 : *(--ptre) = val9; // fallthrough
liveimage_srv/CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
liveimage_srv/CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
liveimage_srv/CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
liveimage_srv/CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
liveimage_srv/CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
liveimage_srv/CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 11;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 11 : *(--ptre) = val10; // fallthrough
liveimage_srv/CImg.h:      case 10 : *(--ptre) = val9; // fallthrough
liveimage_srv/CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
liveimage_srv/CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
liveimage_srv/CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
liveimage_srv/CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
liveimage_srv/CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
liveimage_srv/CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 12;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 12 : *(--ptre) = val11; // fallthrough
liveimage_srv/CImg.h:      case 11 : *(--ptre) = val10; // fallthrough
liveimage_srv/CImg.h:      case 10 : *(--ptre) = val9; // fallthrough
liveimage_srv/CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
liveimage_srv/CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
liveimage_srv/CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
liveimage_srv/CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
liveimage_srv/CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
liveimage_srv/CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 13;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 13 : *(--ptre) = val12; // fallthrough
liveimage_srv/CImg.h:      case 12 : *(--ptre) = val11; // fallthrough
liveimage_srv/CImg.h:      case 11 : *(--ptre) = val10; // fallthrough
liveimage_srv/CImg.h:      case 10 : *(--ptre) = val9; // fallthrough
liveimage_srv/CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
liveimage_srv/CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
liveimage_srv/CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
liveimage_srv/CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
liveimage_srv/CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
liveimage_srv/CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 14;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 14 : *(--ptre) = val13; // fallthrough
liveimage_srv/CImg.h:      case 13 : *(--ptre) = val12; // fallthrough
liveimage_srv/CImg.h:      case 12 : *(--ptre) = val11; // fallthrough
liveimage_srv/CImg.h:      case 11 : *(--ptre) = val10; // fallthrough
liveimage_srv/CImg.h:      case 10 : *(--ptre) = val9; // fallthrough
liveimage_srv/CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
liveimage_srv/CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
liveimage_srv/CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
liveimage_srv/CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
liveimage_srv/CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
liveimage_srv/CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:      T *ptrd, *ptre = end() - 15;
liveimage_srv/CImg.h:      switch (ptre - ptrd) {
liveimage_srv/CImg.h:      case 15 : *(--ptre) = val14; // fallthrough
liveimage_srv/CImg.h:      case 14 : *(--ptre) = val13; // fallthrough
liveimage_srv/CImg.h:      case 13 : *(--ptre) = val12; // fallthrough
liveimage_srv/CImg.h:      case 12 : *(--ptre) = val11; // fallthrough
liveimage_srv/CImg.h:      case 11 : *(--ptre) = val10; // fallthrough
liveimage_srv/CImg.h:      case 10 : *(--ptre) = val9; // fallthrough
liveimage_srv/CImg.h:      case 9 : *(--ptre) = val8; // fallthrough
liveimage_srv/CImg.h:      case 8 : *(--ptre) = val7; // fallthrough
liveimage_srv/CImg.h:      case 7 : *(--ptre) = val6; // fallthrough
liveimage_srv/CImg.h:      case 6 : *(--ptre) = val5; // fallthrough
liveimage_srv/CImg.h:      case 5 : *(--ptre) = val4; // fallthrough
liveimage_srv/CImg.h:      case 4 : *(--ptre) = val3; // fallthrough
liveimage_srv/CImg.h:      case 3 : *(--ptre) = val2; // fallthrough
liveimage_srv/CImg.h:      case 2 : *(--ptre) = val1; // fallthrough
liveimage_srv/CImg.h:      case 1 : *(--ptre) = val0; // fallthrough
liveimage_srv/CImg.h:       \param expression C-string describing a math formula, or a sequence of values.
liveimage_srv/CImg.h:        // Try to pre-detect regular value sequence to avoid exception thrown by _cimg_math_parser.
liveimage_srv/CImg.h:            CImg<T> base = provides_copy?provides_copy->get_shared():get_shared();
liveimage_srv/CImg.h:            if (mp.result_dim) { // Vector-valued expression
liveimage_srv/CImg.h:              T *ptrd = *expression=='<'?_data + _width*_height*_depth - 1:_data;
liveimage_srv/CImg.h:                      T *_ptrd = ptrd--; for (unsigned int n = N; n>0; --n) { *_ptrd = (T)(*ptrs++); _ptrd+=whd; }
liveimage_srv/CImg.h:                      T *_ptrd = ptrd++; for (unsigned int n = N; n>0; --n) { *_ptrd = (T)(*ptrs++); _ptrd+=whd; }
liveimage_srv/CImg.h:        for (unsigned int n = N; n>0; --n) { *_ptrd = (T)(*ptrs++); _ptrd+=whd; } \
liveimage_srv/CImg.h:            } else { // Scalar-valued expression
liveimage_srv/CImg.h:              T *ptrd = *expression=='<'?end() - 1:_data;
liveimage_srv/CImg.h:                else cimg_rofYZC(*this,y,z,c) { cimg_abort_test; cimg_rofX(*this,x) *(ptrd--) = (T)mp(x,y,z,c); }
liveimage_srv/CImg.h:          const int err = cimg_sscanf(nexpression,"%255[ \n\t0-9.eEinfa+-]%c",item._data,&sep);
liveimage_srv/CImg.h:    //! Fill pixel values along the X-axis at a specified pixel position.
liveimage_srv/CImg.h:       \param y Y-coordinate of the filled column.
liveimage_srv/CImg.h:       \param z Z-coordinate of the filled column.
liveimage_srv/CImg.h:       \param c C-coordinate of the filled column.
liveimage_srv/CImg.h:    //! Fill pixel values along the X-axis at a specified pixel position \overloading.
liveimage_srv/CImg.h:    //! Fill pixel values along the Y-axis at a specified pixel position.
liveimage_srv/CImg.h:       \param x X-coordinate of the filled row.
liveimage_srv/CImg.h:       \param z Z-coordinate of the filled row.
liveimage_srv/CImg.h:       \param c C-coordinate of the filled row.
liveimage_srv/CImg.h:    //! Fill pixel values along the Y-axis at a specified pixel position \overloading.
liveimage_srv/CImg.h:    //! Fill pixel values along the Z-axis at a specified pixel position.
liveimage_srv/CImg.h:       \param x X-coordinate of the filled slice.
liveimage_srv/CImg.h:       \param y Y-coordinate of the filled slice.
liveimage_srv/CImg.h:       \param c C-coordinate of the filled slice.
liveimage_srv/CImg.h:    //! Fill pixel values along the Z-axis at a specified pixel position \overloading.
liveimage_srv/CImg.h:    //! Fill pixel values along the C-axis at a specified pixel position.
liveimage_srv/CImg.h:       \param x X-coordinate of the filled channel.
liveimage_srv/CImg.h:       \param y Y-coordinate of the filled channel.
liveimage_srv/CImg.h:       \param z Z-coordinate of the filled channel.
liveimage_srv/CImg.h:    //! Fill pixel values along the C-axis at a specified pixel position \overloading.
liveimage_srv/CImg.h:         the method does it for all the buffer values and returns a one-column vector.
liveimage_srv/CImg.h:         is returned as a one-column vector.
liveimage_srv/CImg.h:            if (j) --i;
liveimage_srv/CImg.h:            k+=i - i0 + 1; i0 = i + 1; j = 0;
liveimage_srv/CImg.h:        if (i0<width()) { res.draw_image(k,get_columns(i0,width() - 1)); k+=width() - i0; }
liveimage_srv/CImg.h:        res.resize(k,-100,-100,-100,0);
liveimage_srv/CImg.h:            if (j) --i;
liveimage_srv/CImg.h:            k+=i - i0 + 1; i0 = i + 1; j = 0;
liveimage_srv/CImg.h:        if (i0<height()) { res.draw_image(0,k,get_rows(i0,height() - 1)); k+=height() - i0; }
liveimage_srv/CImg.h:        res.resize(-100,k,-100,-100,0);
liveimage_srv/CImg.h:            if (j) --i;
liveimage_srv/CImg.h:            k+=i - i0 + 1; i0 = i + 1; j = 0;
liveimage_srv/CImg.h:        if (i0<depth()) { res.draw_image(0,0,k,get_slices(i0,height() - 1)); k+=depth() - i0; }
liveimage_srv/CImg.h:        res.resize(-100,-100,k,-100,0);
liveimage_srv/CImg.h:            if (j) --i;
liveimage_srv/CImg.h:            k+=i - i0 + 1; i0 = i + 1; j = 0;
liveimage_srv/CImg.h:        if (i0<spectrum()) { res.draw_image(0,0,k,get_channels(i0,height() - 1)); k+=spectrum() - i0; }
liveimage_srv/CImg.h:        res.resize(-100,-100,-100,k,0);
liveimage_srv/CImg.h:              if (j) --i;
liveimage_srv/CImg.h:              std::memcpy(res._data + k,_data + i0,(i - i0 + 1)*sizeof(T));
liveimage_srv/CImg.h:              k+=i - i0 + 1; i0 = (int)i + 1; j = 0;
liveimage_srv/CImg.h:          if ((ulongT)i0<siz) { std::memcpy(res._data + k,_data + i0,(siz - i0)*sizeof(T)); k+=siz - i0; }
liveimage_srv/CImg.h:        res.resize(j,-100,-100,-100,0);
liveimage_srv/CImg.h:        res.resize(-100,j,-100,-100,0);
liveimage_srv/CImg.h:        res.resize(-100,-100,j,-100,0);
liveimage_srv/CImg.h:        res.resize(-100,-100,-100,j,0);
liveimage_srv/CImg.h:        res.resize(-100,j,-100,-100,0);
liveimage_srv/CImg.h:      const float delta = (float)val_max - (float)val_min + (cimg::type<T>::is_float()?0:1);
liveimage_srv/CImg.h:       - \c -1: Backward.
liveimage_srv/CImg.h:       - \c 0: Nearest.
liveimage_srv/CImg.h:       - \c 1: Forward.
liveimage_srv/CImg.h:       - For Poisson noise (\p noise_type=3), parameter \p sigma is ignored, as Poisson noise only depends on
liveimage_srv/CImg.h:       - Function \p CImg<T>::get_noise() is also defined. It returns a non-shared modified copy of the image instance.
liveimage_srv/CImg.h:      if (nsigma<0) nsigma = (Tfloat)(-nsigma*(M-m)/100.);
liveimage_srv/CImg.h:            Tfloat val = (Tfloat)(_data[off] + nsigma*cimg::rand(-1,1,&rng));
liveimage_srv/CImg.h:        if (nsigma<0) nsigma = -nsigma;
liveimage_srv/CImg.h:          if (cimg::type<T>::is_float()) { --m; ++M; }
liveimage_srv/CImg.h:                    (T)((1 - constant_case_ratio)*a + constant_case_ratio*b));
liveimage_srv/CImg.h:      if (m!=a || M!=b) cimg_rof(*this,ptrd,T) *ptrd = (T)((*ptrd - fm)/(fM - fm)*(b - a) + a);
liveimage_srv/CImg.h:    //! Normalize multi-valued pixels of the image instance, with respect to their L2-norm.
liveimage_srv/CImg.h:    //! Normalize multi-valued pixels of the image instance, with respect to their L2-norm \newinstance.
liveimage_srv/CImg.h:    //! Compute Lp-norm of each multi-valued pixel of the image instance.
liveimage_srv/CImg.h:       \param norm_type Type of computed vector norm (can be \p -1=Linf, or \p greater or equal than 0).
liveimage_srv/CImg.h:    //! Compute L2-norm of each multi-valued pixel of the image instance \newinstance.
liveimage_srv/CImg.h:      case -1 : { // Linf-norm
liveimage_srv/CImg.h:      case 0 : { // L0-norm
liveimage_srv/CImg.h:      case 1 : { // L1-norm
liveimage_srv/CImg.h:      case 2 : { // L2-norm
liveimage_srv/CImg.h:      default : { // Linf-norm
liveimage_srv/CImg.h:      Tfloat m, M = (Tfloat)max_min(m), range = M - m;
liveimage_srv/CImg.h:            const unsigned int val = (unsigned int)((_data[off] - m)*nb_levels/range);
liveimage_srv/CImg.h:            _data[off] = (T)(m + std::min(val,nb_levels - 1)*range/nb_levels);
liveimage_srv/CImg.h:            const unsigned int val = (unsigned int)((_data[off] - m)*nb_levels/range);
liveimage_srv/CImg.h:            _data[off] = (T)std::min(val,nb_levels - 1);
liveimage_srv/CImg.h:          const ulongT wF = size() - wB;
liveimage_srv/CImg.h:            mF = (double)(sum - sumB)/wF,
liveimage_srv/CImg.h:            variance = wB*wF*cimg::sqr(mB - mF);
liveimage_srv/CImg.h:      return m + best_t*(M - m)/(hist.width() - 1);
liveimage_srv/CImg.h:            _data[off] = v>value?(T)(v-value):v<-(float)value?(T)(v + value):(T)0;
liveimage_srv/CImg.h:            _data[off] = v>=value?(T)(v-value):v<=-(float)value?(T)(v + value):(T)0;
liveimage_srv/CImg.h:       - The histogram H of an image I is the 1D function where H(x) counts the number of occurrences of the value x
liveimage_srv/CImg.h:       - The resulting histogram is always defined in 1D. Histograms of multi-valued images are not multi-dimensional.
liveimage_srv/CImg.h:        if (val>=vmin && val<=vmax) ++res[val==vmax?nb_levels - 1:(unsigned int)((val - vmin)*nb_levels/(vmax - vmin))];
liveimage_srv/CImg.h:        const int pos = (int)((_data[off] - vmin)*(nb_levels - 1.)/(vmax - vmin));
liveimage_srv/CImg.h:        if (pos>=0 && pos<(int)nb_levels) _data[off] = (T)(vmin + (vmax - vmin)*hist[pos]/cumul);
liveimage_srv/CImg.h:    //! Index multi-valued pixels regarding to a specified colormap.
liveimage_srv/CImg.h:       \param colormap Multi-valued colormap used as the basis for multi-valued pixel indexing.
liveimage_srv/CImg.h:       - \p img.index(colormap,dithering,1) is equivalent to <tt>img.index(colormap,dithering,0).map(colormap)</tt>.
liveimage_srv/CImg.h:    //! Index multi-valued pixels regarding to a specified colormap \newinstance.
liveimage_srv/CImg.h:        CImg<Tfloat> cache = get_crop(-1,0,0,0,_width,1,0,_spectrum - 1);
liveimage_srv/CImg.h:            if (y<height() - 2) {
liveimage_srv/CImg.h:                const Tfloat pval0 = (Tfloat)*(ptrp0++) - val0, dist = pval0*pval0;
liveimage_srv/CImg.h:                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
liveimage_srv/CImg.h:              const Tfloat err0 = ((*(ptrs0++)=val0) - (Tfloat)*ptrmin0)*ndithering;
liveimage_srv/CImg.h:              *ptrs0+=7*err0; *(ptrsn0 - 1)+=3*err0; *(ptrsn0++)+=5*err0; *ptrsn0+=err0;
liveimage_srv/CImg.h:              if (map_indexes) *(ptrd++) = (tuint)*ptrmin0; else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
liveimage_srv/CImg.h:            if (y<height() - 2) {
liveimage_srv/CImg.h:                  pval0 = (Tfloat)*(ptrp0++) - val0, pval1 = (Tfloat)*(ptrp1++) - val1,
liveimage_srv/CImg.h:                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
liveimage_srv/CImg.h:                err0 = ((*(ptrs0++)=val0) - (Tfloat)*ptrmin0)*ndithering,
liveimage_srv/CImg.h:                err1 = ((*(ptrs1++)=val1) - (Tfloat)*ptrmin1)*ndithering;
liveimage_srv/CImg.h:              *(ptrsn0 - 1)+=3*err0; *(ptrsn1 - 1)+=3*err1;
liveimage_srv/CImg.h:              else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
liveimage_srv/CImg.h:            if (y<height() - 2) {
liveimage_srv/CImg.h:                  pval0 = (Tfloat)*(ptrp0++) - val0,
liveimage_srv/CImg.h:                  pval1 = (Tfloat)*(ptrp1++) - val1,
liveimage_srv/CImg.h:                  pval2 = (Tfloat)*(ptrp2++) - val2,
liveimage_srv/CImg.h:                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
liveimage_srv/CImg.h:                err0 = ((*(ptrs0++)=val0) - (Tfloat)*ptrmin0)*ndithering,
liveimage_srv/CImg.h:                err1 = ((*(ptrs1++)=val1) - (Tfloat)*ptrmin1)*ndithering,
liveimage_srv/CImg.h:                err2 = ((*(ptrs2++)=val2) - (Tfloat)*ptrmin2)*ndithering;
liveimage_srv/CImg.h:              *(ptrsn0 - 1)+=3*err0; *(ptrsn1 - 1)+=3*err1; *(ptrsn2 - 1)+=3*err2;
liveimage_srv/CImg.h:              } else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
liveimage_srv/CImg.h:            if (y<height() - 2) {
liveimage_srv/CImg.h:                  dist+=cimg::sqr((*_ptrs=val) - (Tfloat)*_ptrp); _ptrs+=cwhd; _ptrp+=pwhd;
liveimage_srv/CImg.h:              const t *_ptrmin = ptrmin; Tfloat *_ptrs = ptrs++, *_ptrsn = (ptrsn++) - 1;
liveimage_srv/CImg.h:                const Tfloat err = (*(_ptrs++) - (Tfloat)*_ptrmin)*ndithering;
liveimage_srv/CImg.h:                _ptrmin+=pwhd; _ptrs+=cwhd - 1; _ptrsn+=cwhd - 2;
liveimage_srv/CImg.h:              else *(ptrd++) = (tuint)(ptrmin - colormap._data);
liveimage_srv/CImg.h:      } else { // Non-dithered versions
liveimage_srv/CImg.h:                const Tfloat pval0 = (Tfloat)*(ptrp0++) - val0, dist = pval0*pval0;
liveimage_srv/CImg.h:                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
liveimage_srv/CImg.h:              if (map_indexes) *(ptrd++) = (tuint)*ptrmin0; else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
liveimage_srv/CImg.h:                  pval0 = (Tfloat)*(ptrp0++) - val0, pval1 = (Tfloat)*(ptrp1++) - val1,
liveimage_srv/CImg.h:                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
liveimage_srv/CImg.h:              else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
liveimage_srv/CImg.h:                  pval0 = (Tfloat)*(ptrp0++) - val0,
liveimage_srv/CImg.h:                  pval1 = (Tfloat)*(ptrp1++) - val1,
liveimage_srv/CImg.h:                  pval2 = (Tfloat)*(ptrp2++) - val2,
liveimage_srv/CImg.h:                if (dist<distmin) { ptrmin0 = ptrp0 - 1; distmin = dist; }
liveimage_srv/CImg.h:              } else *(ptrd++) = (tuint)(ptrmin0 - colormap._data);
liveimage_srv/CImg.h:                cimg_forC(*this,c) { dist+=cimg::sqr((Tfloat)*_ptrs - (Tfloat)*_ptrp); _ptrs+=whd; _ptrp+=pwhd; }
liveimage_srv/CImg.h:              else *(ptrd++) = (tuint)(ptrmin - colormap._data);
liveimage_srv/CImg.h:       \param colormap Multi-valued colormap used for mapping the indexes.
liveimage_srv/CImg.h:            res[off] = colormap[ind<cwhd?ind:cwhd2 - ind - 1];
liveimage_srv/CImg.h:            res[off] = colormap[cimg::cut(ind,(longT)0,(longT)cwhd - 1)];
liveimage_srv/CImg.h:                ind = _ind<cwhd?_ind:cwhd2 - _ind - 1;
liveimage_srv/CImg.h:              const longT ind = cimg::cut((longT)ptrs[off],(longT)0,(longT)cwhd - 1);
liveimage_srv/CImg.h:                ind = _ind<cwhd?_ind:cwhd2 - _ind - 1;
liveimage_srv/CImg.h:              const longT ind = cimg::cut((longT)ptrs[off],(longT)0,(longT)cwhd - 1);
liveimage_srv/CImg.h:                ind = _ind<cwhd?_ind:cwhd2 - _ind - 1;
liveimage_srv/CImg.h:              const longT ind = cimg::cut((longT)ptrs[off],(longT)0,(longT)cwhd - 1);
liveimage_srv/CImg.h:       \param is_high_connectivity Boolean that choose between 4(false)- or 8(true)-connectivity
liveimage_srv/CImg.h:       in 2D case, and between 6(false)- or 26(true)-connectivity in 3D case.
liveimage_srv/CImg.h:       In: Science of Computer Programming 41 (2001), pp. 173--194'.
liveimage_srv/CImg.h:        dx[nb] = 1; dy[nb] = -1; dz[nb++] = 0;
liveimage_srv/CImg.h:          dx[nb] = 1; dy[nb] = 1; dz[nb++] = -1;
liveimage_srv/CImg.h:          dx[nb] = 1; dy[nb] = 0; dz[nb++] = -1;
liveimage_srv/CImg.h:          dx[nb] = 1; dy[nb] = -1; dz[nb++] = -1;
liveimage_srv/CImg.h:          dx[nb] = 0; dy[nb] = 1; dz[nb++] = -1;
liveimage_srv/CImg.h:          dx[nb] = 1; dy[nb] = -1; dz[nb++] = 1;
liveimage_srv/CImg.h:      // For each neighbour-direction, label.
liveimage_srv/CImg.h:            x0 = _dx<0?-_dx:0,
liveimage_srv/CImg.h:            x1 = _dx<0?width():width() - _dx,
liveimage_srv/CImg.h:            y0 = _dy<0?-_dy:0,
liveimage_srv/CImg.h:            y1 = _dy<0?height():height() - _dy,
liveimage_srv/CImg.h:            z0 = _dz<0?-_dz:0,
liveimage_srv/CImg.h:            z1 = _dz<0?depth():depth() - _dz;
liveimage_srv/CImg.h:                  diff = cimg::abs((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd));
liveimage_srv/CImg.h:                    diff = cimg::sqr((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd)) +
liveimage_srv/CImg.h:                      cimg::sqr((Tfloat)(*this)(x,y,z,1,wh,whd) - (Tfloat)(*this)(nx,ny,nz,1,wh,whd));
liveimage_srv/CImg.h:                    diff = cimg::abs((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd)) +
liveimage_srv/CImg.h:                      cimg::abs((Tfloat)(*this)(x,y,z,1,wh,whd) - (Tfloat)(*this)(nx,ny,nz,1,wh,whd));
liveimage_srv/CImg.h:                    diff = cimg::sqr((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd)) +
liveimage_srv/CImg.h:                      cimg::sqr((Tfloat)(*this)(x,y,z,1,wh,whd) - (Tfloat)(*this)(nx,ny,nz,1,wh,whd)) +
liveimage_srv/CImg.h:                      cimg::sqr((Tfloat)(*this)(x,y,z,2,wh,whd) - (Tfloat)(*this)(nx,ny,nz,2,wh,whd));
liveimage_srv/CImg.h:                    diff = cimg::abs((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd)) +
liveimage_srv/CImg.h:                      cimg::abs((Tfloat)(*this)(x,y,z,1,wh,whd) - (Tfloat)(*this)(nx,ny,nz,1,wh,whd)) +
liveimage_srv/CImg.h:                      cimg::abs((Tfloat)(*this)(x,y,z,2,wh,whd) - (Tfloat)(*this)(nx,ny,nz,2,wh,whd));
liveimage_srv/CImg.h:                    diff = cimg::sqr((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd)) +
liveimage_srv/CImg.h:                      cimg::sqr((Tfloat)(*this)(x,y,z,1,wh,whd) - (Tfloat)(*this)(nx,ny,nz,1,wh,whd)) +
liveimage_srv/CImg.h:                      cimg::sqr((Tfloat)(*this)(x,y,z,2,wh,whd) - (Tfloat)(*this)(nx,ny,nz,2,wh,whd)) +
liveimage_srv/CImg.h:                      cimg::sqr((Tfloat)(*this)(x,y,z,3,wh,whd) - (Tfloat)(*this)(nx,ny,nz,3,wh,whd));
liveimage_srv/CImg.h:                    diff = cimg::abs((Tfloat)(*this)(x,y,z,0,wh,whd) - (Tfloat)(*this)(nx,ny,nz,0,wh,whd)) +
liveimage_srv/CImg.h:                      cimg::abs((Tfloat)(*this)(x,y,z,1,wh,whd) - (Tfloat)(*this)(nx,ny,nz,1,wh,whd)) +
liveimage_srv/CImg.h:                      cimg::abs((Tfloat)(*this)(x,y,z,2,wh,whd) - (Tfloat)(*this)(nx,ny,nz,2,wh,whd)) +
liveimage_srv/CImg.h:                      cimg::abs((Tfloat)(*this)(x,y,z,3,wh,whd) - (Tfloat)(*this)(nx,ny,nz,3,wh,whd));
liveimage_srv/CImg.h:                      diff+=cimg::sqr((Tfloat)(*this)(x,y,z,c,wh,whd) - (Tfloat)(*this)(nx,ny,nz,c,wh,whd));
liveimage_srv/CImg.h:                      diff+=cimg::abs((Tfloat)(*this)(x,y,z,c,wh,whd) - (Tfloat)(*this)(nx,ny,nz,c,wh,whd));
liveimage_srv/CImg.h:#define cimg_system_strescape(c,s) case c : if (p!=ptrs) CImg<T>(ptrs,(unsigned int)(p-ptrs),1,1,1,false).\
liveimage_srv/CImg.h:      if (ptrs<end()) CImg<T>(ptrs,(unsigned int)(end()-ptrs),1,1,1,false).move_to(list);
liveimage_srv/CImg.h:    //---------------------------------
liveimage_srv/CImg.h:    //---------------------------------
liveimage_srv/CImg.h:          sval = (Tfloat)(val<=0.0031308f?val*12.92f:1.055f*std::pow(val,0.416667f) - 0.055f);
liveimage_srv/CImg.h:          C = M - m,
liveimage_srv/CImg.h:          H = 60*(C==0?0:M==R?cimg::mod((G - B)/C,(Tfloat)6):M==G?(B - R)/C + 2:(R - G)/C + 4),
liveimage_srv/CImg.h:          S = sum<=0?0:1 - 3*m/sum,
liveimage_srv/CImg.h:          Z = 1 - cimg::abs(cimg::mod(H,(Tfloat)2) - 1),
liveimage_srv/CImg.h:          m = I*(1 - S)/3;
liveimage_srv/CImg.h:          C = M - m,
liveimage_srv/CImg.h:          H = 60*(C==0?0:M==R?cimg::mod((G - B)/C,(Tfloat)6):M==G?(B - R)/C + 2:(R - G)/C + 4),
liveimage_srv/CImg.h:          S = L==1 || L==0?0:C/(1 - cimg::abs(2*L - 1))/255;
liveimage_srv/CImg.h:          C = (1 - cimg::abs(2*L - 1))*S,
liveimage_srv/CImg.h:          X = C*(1 - cimg::abs(cimg::mod(H,(Tfloat)2) - 1)),
liveimage_srv/CImg.h:          m = L - C/2;
liveimage_srv/CImg.h:          C = M - cimg::min(R,G,B),
liveimage_srv/CImg.h:          H = 60*(C==0?0:M==R?cimg::mod((G-B)/C,(Tfloat)6):M==G?(B - R)/C + 2:(R - G)/C + 4),
liveimage_srv/CImg.h:          X = C*(1 - cimg::abs(cimg::mod(H,(Tfloat)2) - 1)),
liveimage_srv/CImg.h:          m = V - C;
liveimage_srv/CImg.h:          Cb = (-38*R - 74*G + 112*B + 128)/256 + 128,
liveimage_srv/CImg.h:          Cr = (112*R - 94*G - 18*B + 128)/256 + 128;
liveimage_srv/CImg.h:          Y = (Tfloat)p1[N] - 16,
liveimage_srv/CImg.h:          Cb = (Tfloat)p2[N] - 128,
liveimage_srv/CImg.h:          Cr = (Tfloat)p3[N] - 128,
liveimage_srv/CImg.h:          G = (298*Y - 100*Cb - 208*Cr + 128)/256,
liveimage_srv/CImg.h:        p2[N] = (T)(0.492f*(B - Y));
liveimage_srv/CImg.h:        p3[N] = (T)(0.877*(R - Y));
liveimage_srv/CImg.h:          G = (Y - 0.395f*U - 0.581f*V)*255,
liveimage_srv/CImg.h:          C = 255 - R,
liveimage_srv/CImg.h:          M = 255 - G,
liveimage_srv/CImg.h:          Y = 255 - B;
liveimage_srv/CImg.h:          R = 255 - C,
liveimage_srv/CImg.h:          G = 255 - M,
liveimage_srv/CImg.h:          B = 255 - Y;
liveimage_srv/CImg.h:        else { const Tfloat K1 = 255 - K; C = 255*(C - K)/K1; M = 255*(M - K)/K1; Y = 255*(Y - K)/K1; }
liveimage_srv/CImg.h:          K1 = 1 - K/255,
liveimage_srv/CImg.h:          p1[N] = (T)cimg::cut(3.2404542*X - 1.5371385*Y - 0.4985314*Z,0,255);
liveimage_srv/CImg.h:          p2[N] = (T)cimg::cut(-0.9692660*X + 1.8760108*Y + 0.0415560*Z,0,255);
liveimage_srv/CImg.h:          p3[N] = (T)cimg::cut(0.0556434*X - 0.2040259*Y + 1.0572252*Z,0,255);
liveimage_srv/CImg.h:          p1[N] = (T)cimg::cut(3.134274799724*X  - 1.617275708956*Y - 0.490724283042*Z,0,255);
liveimage_srv/CImg.h:          p2[N] = (T)cimg::cut(-0.978795575994*X + 1.916161689117*Y + 0.033453331711*Z,0,255);
liveimage_srv/CImg.h:          p3[N] = (T)cimg::cut(0.071976988401*X - 0.228984974402*Y + 1.405718224383*Z,0,255);
liveimage_srv/CImg.h:        p1[N] = (T)cimg::cut(116*fY - 16,0,100);
liveimage_srv/CImg.h:        p2[N] = (T)(500*(fX - fY));
liveimage_srv/CImg.h:        p3[N] = (T)(200*(fY - fZ));
liveimage_srv/CImg.h:          cZ = cY - b/200,
liveimage_srv/CImg.h:          X = (Tfloat)(24389*cX>216?cX*cX*cX:(116*cX - 16)*27/24389),
liveimage_srv/CImg.h:          Z = (Tfloat)(24389*cZ>216?cZ*cZ*cZ:(116*cZ - 16)*27/24389);
liveimage_srv/CImg.h:        p3[N] = (T)((1 - px - py)*Y/ny);
liveimage_srv/CImg.h:    //------------------------------------------
liveimage_srv/CImg.h:    //------------------------------------------
liveimage_srv/CImg.h:      if (x<=-2 || x>=2) return 0;
liveimage_srv/CImg.h:       \param size_x Number of columns (new size along the X-axis).
liveimage_srv/CImg.h:       \param size_y Number of rows (new size along the Y-axis).
liveimage_srv/CImg.h:       \param size_z Number of slices (new size along the Z-axis).
liveimage_srv/CImg.h:       \param size_c Number of vector-channels (new size along the C-axis).
liveimage_srv/CImg.h:       - -1 = no interpolation: raw memory resizing.
liveimage_srv/CImg.h:       - 0 = no interpolation: additional space is filled according to \p boundary_conditions.
liveimage_srv/CImg.h:       - 1 = nearest-neighbor interpolation.
liveimage_srv/CImg.h:       - 2 = moving average interpolation.
liveimage_srv/CImg.h:       - 3 = linear interpolation.
liveimage_srv/CImg.h:       - 4 = grid interpolation.
liveimage_srv/CImg.h:       - 5 = cubic interpolation.
liveimage_srv/CImg.h:       - 6 = lanczos interpolation.
liveimage_srv/CImg.h:       \note If pd[x,y,z,v]<0, it corresponds to a percentage of the original size (the default value is -100).
liveimage_srv/CImg.h:    CImg<T>& resize(const int size_x, const int size_y=-100,
liveimage_srv/CImg.h:                    const int size_z=-100, const int size_c=-100,
liveimage_srv/CImg.h:        _sx = (unsigned int)(size_x<0?-size_x*width()/100:size_x),
liveimage_srv/CImg.h:        _sy = (unsigned int)(size_y<0?-size_y*height()/100:size_y),
liveimage_srv/CImg.h:        _sz = (unsigned int)(size_z<0?-size_z*depth()/100:size_z),
liveimage_srv/CImg.h:        _sc = (unsigned int)(size_c<0?-size_c*spectrum()/100:size_c),
liveimage_srv/CImg.h:      if (interpolation_type==-1 && sx*sy*sz*sc==size()) {
liveimage_srv/CImg.h:    CImg<T> get_resize(const int size_x, const int size_y = -100,
liveimage_srv/CImg.h:                       const int size_z = -100, const int size_c = -100,
liveimage_srv/CImg.h:        sx = std::max(1U,(unsigned int)(size_x>=0?size_x:-size_x*width()/100)),
liveimage_srv/CImg.h:        sy = std::max(1U,(unsigned int)(size_y>=0?size_y:-size_y*height()/100)),
liveimage_srv/CImg.h:        sz = std::max(1U,(unsigned int)(size_z>=0?size_z:-size_z*depth()/100)),
liveimage_srv/CImg.h:        sc = std::max(1U,(unsigned int)(size_c>=0?size_c:-size_c*spectrum()/100));
liveimage_srv/CImg.h:      case -1 :
liveimage_srv/CImg.h:          xc = (int)(centering_x*((int)sx - width())),
liveimage_srv/CImg.h:          yc = (int)(centering_y*((int)sy - height())),
liveimage_srv/CImg.h:          zc = (int)(centering_z*((int)sz - depth())),
liveimage_srv/CImg.h:          cc = (int)(centering_c*((int)sc - spectrum()));
liveimage_srv/CImg.h:              mx = cimg::mod(x - xc,w2), my = cimg::mod(y - yc,h2),
liveimage_srv/CImg.h:              mz = cimg::mod(z - zc,d2), mc = cimg::mod(c - cc,s2);
liveimage_srv/CImg.h:            res(x,y,z,c) = (*this)(mx<width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                   my<height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                   mz<depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                                   mc<spectrum()?mc:s2 - mc - 1);
liveimage_srv/CImg.h:            x0 = ((int)xc%width()) - width(),
liveimage_srv/CImg.h:            y0 = ((int)yc%height()) - height(),
liveimage_srv/CImg.h:            z0 = ((int)zc%depth()) - depth(),
liveimage_srv/CImg.h:            c0 = ((int)cc%spectrum()) - spectrum(),
liveimage_srv/CImg.h:          if (xc>0) {  // X-backward
liveimage_srv/CImg.h:            res.get_crop(xc,yc,zc,cc,xc,yc + height() - 1,zc + depth() - 1,cc + spectrum() - 1).move_to(sprite);
liveimage_srv/CImg.h:            for (int x = xc - 1; x>=0; --x) res.draw_image(x,yc,zc,cc,sprite);
liveimage_srv/CImg.h:          if (xc + width()<(int)sx) { // X-forward
liveimage_srv/CImg.h:            res.get_crop(xc + width() - 1,yc,zc,cc,xc + width() - 1,yc + height() - 1,
liveimage_srv/CImg.h:                         zc + depth() - 1,cc + spectrum() - 1).move_to(sprite);
liveimage_srv/CImg.h:          if (yc>0) {  // Y-backward
liveimage_srv/CImg.h:            res.get_crop(0,yc,zc,cc,sx - 1,yc,zc + depth() - 1,cc + spectrum() - 1).move_to(sprite);
liveimage_srv/CImg.h:            for (int y = yc - 1; y>=0; --y) res.draw_image(0,y,zc,cc,sprite);
liveimage_srv/CImg.h:          if (yc + height()<(int)sy) { // Y-forward
liveimage_srv/CImg.h:            res.get_crop(0,yc + height() - 1,zc,cc,sx - 1,yc + height() - 1,
liveimage_srv/CImg.h:                         zc + depth() - 1,cc + spectrum() - 1).move_to(sprite);
liveimage_srv/CImg.h:          if (zc>0) {  // Z-backward
liveimage_srv/CImg.h:            res.get_crop(0,0,zc,cc,sx - 1,sy - 1,zc,cc + spectrum() - 1).move_to(sprite);
liveimage_srv/CImg.h:            for (int z = zc - 1; z>=0; --z) res.draw_image(0,0,z,cc,sprite);
liveimage_srv/CImg.h:          if (zc + depth()<(int)sz) { // Z-forward
liveimage_srv/CImg.h:            res.get_crop(0,0,zc  +depth() - 1,cc,sx - 1,sy - 1,zc + depth() - 1,cc + spectrum() - 1).move_to(sprite);
liveimage_srv/CImg.h:          if (cc>0) {  // C-backward
liveimage_srv/CImg.h:            res.get_crop(0,0,0,cc,sx - 1,sy - 1,sz - 1,cc).move_to(sprite);
liveimage_srv/CImg.h:            for (int c = cc - 1; c>=0; --c) res.draw_image(0,0,0,c,sprite);
liveimage_srv/CImg.h:          if (cc + spectrum()<(int)sc) { // C-forward
liveimage_srv/CImg.h:            res.get_crop(0,0,0,cc + spectrum() - 1,sx - 1,sy - 1,sz - 1,cc + spectrum() - 1).move_to(sprite);
liveimage_srv/CImg.h:            *(poff_x++) = curr - old;
liveimage_srv/CImg.h:            *(poff_y++) = _width*(curr - old);
liveimage_srv/CImg.h:            *(poff_z++) = wh*(curr - old);
liveimage_srv/CImg.h:            *(poff_c++) = whd*(curr - old);
liveimage_srv/CImg.h:              for ( ; !dy && y<dy; std::memcpy(ptrd,ptrd - sx,sizeof(T)*sx), ++y, ptrd+=sx, dy = *(poff_y++)) {}
liveimage_srv/CImg.h:            for ( ; !dz && z<dz; std::memcpy(ptrd,ptrd - sxy,sizeof(T)*sxy), ++z, ptrd+=sxy, dz = *(poff_z++)) {}
liveimage_srv/CImg.h:          for ( ; !dc && c<dc; std::memcpy(ptrd,ptrd - sxyz,sizeof(T)*sxyz), ++c, ptrd+=sxyz, dc = *(poff_c++)) {}
liveimage_srv/CImg.h:                a-=d; b-=d; c-=d;
liveimage_srv/CImg.h:                a-=d; b-=d; c-=d;
liveimage_srv/CImg.h:                a-=d; b-=d; c-=d;
liveimage_srv/CImg.h:                a-=d; b-=d; c-=d;
liveimage_srv/CImg.h:            const double fx = (!boundary_conditions && sx>_width)?(sx>1?(_width - 1.)/(sx - 1):0):
liveimage_srv/CImg.h:                *(pfoff++) = curr - (unsigned int)curr;
liveimage_srv/CImg.h:                curr = std::min(width() - 1.,curr + fx);
liveimage_srv/CImg.h:                *(poff++) = (unsigned int)curr - (unsigned int)old;
liveimage_srv/CImg.h:              const T *ptrs = data(0,y,z,c), *const ptrsmax = ptrs + _width - 1;
liveimage_srv/CImg.h:                *(ptrd++) = (T)((1 - alpha)*val1 + alpha*val2);
liveimage_srv/CImg.h:              const double fy = (!boundary_conditions && sy>_height)?(sy>1?(_height - 1.)/(sy - 1):0):
liveimage_srv/CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
liveimage_srv/CImg.h:                  curr = std::min(height() - 1.,curr + fy);
liveimage_srv/CImg.h:                  *(poff++) = sx*((unsigned int)curr - (unsigned int)old);
liveimage_srv/CImg.h:                const T *ptrs = resx.data(x,0,z,c), *const ptrsmax = ptrs + (_height - 1)*sx;
liveimage_srv/CImg.h:                  *ptrd = (T)((1 - alpha)*val1 + alpha*val2);
liveimage_srv/CImg.h:              const double fz = (!boundary_conditions && sz>_depth)?(sz>1?(_depth - 1.)/(sz - 1):0):
liveimage_srv/CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
liveimage_srv/CImg.h:                  curr = std::min(depth() - 1.,curr + fz);
liveimage_srv/CImg.h:                  *(poff++) = sxy*((unsigned int)curr - (unsigned int)old);
liveimage_srv/CImg.h:                const T *ptrs = resy.data(x,y,0,c), *const ptrsmax = ptrs + (_depth - 1)*sxy;
liveimage_srv/CImg.h:                  *ptrd = (T)((1 - alpha)*val1 + alpha*val2);
liveimage_srv/CImg.h:              const double fc = (!boundary_conditions && sc>_spectrum)?(sc>1?(_spectrum - 1.)/(sc - 1):0):
liveimage_srv/CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
liveimage_srv/CImg.h:                  curr = std::min(spectrum() - 1.,curr + fc);
liveimage_srv/CImg.h:                  *(poff++) = sxyz*((unsigned int)curr - (unsigned int)old);
liveimage_srv/CImg.h:                const T *ptrs = resz.data(x,y,z,0), *const ptrsmax = ptrs + (_spectrum - 1)*sxyz;
liveimage_srv/CImg.h:                  *ptrd = (T)((1 - alpha)*val1 + alpha*val2);
liveimage_srv/CImg.h:            int err = (int)(dy + centering_x*(sx*dy/width() - dy)), xs = 0;
liveimage_srv/CImg.h:            cimg_forX(resx,x) if ((err-=dy)<=0) {
liveimage_srv/CImg.h:            int err = (int)(dy + centering_y*(sy*dy/height() - dy)), ys = 0;
liveimage_srv/CImg.h:            cimg_forY(resy,y) if ((err-=dy)<=0) {
liveimage_srv/CImg.h:            int err = (int)(dy + centering_z*(sz*dy/depth() - dy)), zs = 0;
liveimage_srv/CImg.h:            cimg_forZ(resz,z) if ((err-=dy)<=0) {
liveimage_srv/CImg.h:            int err = (int)(dy + centering_c*(sc*dy/spectrum() - dy)), cs = 0;
liveimage_srv/CImg.h:            cimg_forC(resc,c) if ((err-=dy)<=0) {
liveimage_srv/CImg.h:              const double fx = (!boundary_conditions && sx>_width)?(sx>1?(_width - 1.)/(sx - 1):0):
liveimage_srv/CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
liveimage_srv/CImg.h:                  curr = std::min(width() - 1.,curr + fx);
liveimage_srv/CImg.h:                  *(poff++) = (unsigned int)curr - (unsigned int)old;
liveimage_srv/CImg.h:                const T *const ptrs0 = data(0,y,z,c), *ptrs = ptrs0, *const ptrsmax = ptrs + (_width - 2);
liveimage_srv/CImg.h:                    val0 = ptrs>ptrs0?(double)*(ptrs - 1):val1,
liveimage_srv/CImg.h:                    val = val1 + 0.5f*(t*(-val0 + val2) + t*t*(2*val0 - 5*val1 + 4*val2 - val3) +
liveimage_srv/CImg.h:                                       t*t*t*(-val0 + 3*val1 - 3*val2 + val3));
liveimage_srv/CImg.h:              const double fy = (!boundary_conditions && sy>_height)?(sy>1?(_height - 1.)/(sy - 1):0):
liveimage_srv/CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
liveimage_srv/CImg.h:                  curr = std::min(height() - 1.,curr + fy);
liveimage_srv/CImg.h:                  *(poff++) = sx*((unsigned int)curr - (unsigned int)old);
liveimage_srv/CImg.h:                const T *const ptrs0 = resx.data(x,0,z,c), *ptrs = ptrs0, *const ptrsmax = ptrs + (_height - 2)*sx;
liveimage_srv/CImg.h:                    val0 = ptrs>ptrs0?(double)*(ptrs - sx):val1,
liveimage_srv/CImg.h:                    val = val1 + 0.5f*(t*(-val0 + val2) + t*t*(2*val0 - 5*val1 + 4*val2 - val3) +
liveimage_srv/CImg.h:                                       t*t*t*(-val0 + 3*val1 - 3*val2 + val3));
liveimage_srv/CImg.h:              const double fz = (!boundary_conditions && sz>_depth)?(sz>1?(_depth - 1.)/(sz - 1):0):
liveimage_srv/CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
liveimage_srv/CImg.h:                  curr = std::min(depth() - 1.,curr + fz);
liveimage_srv/CImg.h:                  *(poff++) = sxy*((unsigned int)curr - (unsigned int)old);
liveimage_srv/CImg.h:                const T *const ptrs0 = resy.data(x,y,0,c), *ptrs = ptrs0, *const ptrsmax = ptrs + (_depth - 2)*sxy;
liveimage_srv/CImg.h:                    val0 = ptrs>ptrs0?(double)*(ptrs - sxy):val1,
liveimage_srv/CImg.h:                    val = val1 + 0.5f*(t*(-val0 + val2) + t*t*(2*val0 - 5*val1 + 4*val2 - val3) +
liveimage_srv/CImg.h:                                       t*t*t*(-val0 + 3*val1 - 3*val2 + val3));
liveimage_srv/CImg.h:              const double fc = (!boundary_conditions && sc>_spectrum)?(sc>1?(_spectrum - 1.)/(sc - 1):0):
liveimage_srv/CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
liveimage_srv/CImg.h:                  curr = std::min(spectrum() - 1.,curr + fc);
liveimage_srv/CImg.h:                  *(poff++) = sxyz*((unsigned int)curr - (unsigned int)old);
liveimage_srv/CImg.h:                const T *const ptrs0 = resz.data(x,y,z,0), *ptrs = ptrs0, *const ptrsmax = ptrs + (_spectrum - 2)*sxyz;
liveimage_srv/CImg.h:                    val0 = ptrs>ptrs0?(double)*(ptrs - sxyz):val1,
liveimage_srv/CImg.h:                    val = val1 + 0.5f*(t*(-val0 + val2) + t*t*(2*val0 - 5*val1 + 4*val2 - val3) +
liveimage_srv/CImg.h:                                       t*t*t*(-val0 + 3*val1 - 3*val2 + val3));
liveimage_srv/CImg.h:              const double fx = (!boundary_conditions && sx>_width)?(sx>1?(_width - 1.)/(sx - 1):0):
liveimage_srv/CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
liveimage_srv/CImg.h:                  curr = std::min(width() - 1.,curr + fx);
liveimage_srv/CImg.h:                  *(poff++) = (unsigned int)curr - (unsigned int)old;
liveimage_srv/CImg.h:                  *const ptrsmax = ptrs0 + (_width - 2);
liveimage_srv/CImg.h:                    w3 = _cimg_lanczos(t - 1),
liveimage_srv/CImg.h:                    w4 = _cimg_lanczos(t - 2),
liveimage_srv/CImg.h:                    val1 = ptrs>=ptrsmin?(double)*(ptrs - 1):val2,
liveimage_srv/CImg.h:                    val0 = ptrs>ptrsmin?(double)*(ptrs - 2):val1,
liveimage_srv/CImg.h:              const double fy = (!boundary_conditions && sy>_height)?(sy>1?(_height - 1.)/(sy - 1):0):
liveimage_srv/CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
liveimage_srv/CImg.h:                  curr = std::min(height() - 1.,curr + fy);
liveimage_srv/CImg.h:                  *(poff++) = sx*((unsigned int)curr - (unsigned int)old);
liveimage_srv/CImg.h:                  *const ptrsmax = ptrs0 + (_height - 2)*sx;
liveimage_srv/CImg.h:                    w3 = _cimg_lanczos(t - 1),
liveimage_srv/CImg.h:                    w4 = _cimg_lanczos(t - 2),
liveimage_srv/CImg.h:                    val1 = ptrs>=ptrsmin?(double)*(ptrs - sx):val2,
liveimage_srv/CImg.h:                    val0 = ptrs>ptrsmin?(double)*(ptrs - 2*sx):val1,
liveimage_srv/CImg.h:              const double fz = (!boundary_conditions && sz>_depth)?(sz>1?(_depth - 1.)/(sz - 1):0):
liveimage_srv/CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
liveimage_srv/CImg.h:                  curr = std::min(depth() - 1.,curr + fz);
liveimage_srv/CImg.h:                  *(poff++) = sxy*((unsigned int)curr - (unsigned int)old);
liveimage_srv/CImg.h:                  *const ptrsmax = ptrs0 + (_depth - 2)*sxy;
liveimage_srv/CImg.h:                    w3 = _cimg_lanczos(t - 1),
liveimage_srv/CImg.h:                    w4 = _cimg_lanczos(t - 2),
liveimage_srv/CImg.h:                    val1 = ptrs>=ptrsmin?(double)*(ptrs - sxy):val2,
liveimage_srv/CImg.h:                    val0 = ptrs>ptrsmin?(double)*(ptrs - 2*sxy):val1,
liveimage_srv/CImg.h:              const double fc = (!boundary_conditions && sc>_spectrum)?(sc>1?(_spectrum - 1.)/(sc - 1):0):
liveimage_srv/CImg.h:                  *(pfoff++) = curr - (unsigned int)curr;
liveimage_srv/CImg.h:                  curr = std::min(spectrum() - 1.,curr + fc);
liveimage_srv/CImg.h:                  *(poff++) = sxyz*((unsigned int)curr - (unsigned int)old);
liveimage_srv/CImg.h:                  *const ptrsmax = ptrs + (_spectrum - 2)*sxyz;
liveimage_srv/CImg.h:                    w3 = _cimg_lanczos(t - 1),
liveimage_srv/CImg.h:                    w4 = _cimg_lanczos(t - 2),
liveimage_srv/CImg.h:                    val1 = ptrs>=ptrsmin?(double)*(ptrs - sxyz):val2,
liveimage_srv/CImg.h:                    val0 = ptrs>ptrsmin?(double)*(ptrs - 2*sxyz):val1,
liveimage_srv/CImg.h:                                    "(should be { -1=raw | 0=none | 1=nearest | 2=average | 3=linear | 4=grid | "
liveimage_srv/CImg.h:    //! Resize image to half-size along XY axes, using an optimized filter.
liveimage_srv/CImg.h:    //! Resize image to half-size along XY axes, using an optimized filter \newinstance.
liveimage_srv/CImg.h:    //! Resize image to double-size, using the Scale2X algorithm.
liveimage_srv/CImg.h:    //! Resize image to double-size, using the Scale2X algorithm \newinstance.
liveimage_srv/CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1; \
liveimage_srv/CImg.h:      _n1##i<(int)(bound) || i==--_n1##i; \
liveimage_srv/CImg.h:   1>=(img)._width?(img).width() - 1:1); \
liveimage_srv/CImg.h:   x==--_n1##x; \
liveimage_srv/CImg.h:    //! Resize image to triple-size, using the Scale3X algorithm.
liveimage_srv/CImg.h:    //! Resize image to triple-size, using the Scale3X algorithm \newinstance.
liveimage_srv/CImg.h:      _n1##i = 1>=(bound)?(int)(bound) - 1:1; \
liveimage_srv/CImg.h:      _n1##i<(int)(bound) || i==--_n1##i; \
liveimage_srv/CImg.h:   1>=(img)._width?(img).width() - 1:1); \
liveimage_srv/CImg.h:   x==--_n1##x; \
liveimage_srv/CImg.h:        pf = _data; pb = data(_width - 1);
liveimage_srv/CImg.h:          for (unsigned int x = 0; x<width2; ++x) { const T val = *pf; *(pf++) = *pb; *(pb--) = val; }
liveimage_srv/CImg.h:          pf+=_width - width2;
liveimage_srv/CImg.h:        pf = _data; pb = data(0,_height - 1);
liveimage_srv/CImg.h:            pb-=_width;
liveimage_srv/CImg.h:          pf+=(ulongT)_width*(_height - height2);
liveimage_srv/CImg.h:        pf = _data; pb = data(0,0,_depth - 1);
liveimage_srv/CImg.h:            pb-=(ulongT)_width*_height;
liveimage_srv/CImg.h:          pf+=(ulongT)_width*_height*(_depth - depth2);
liveimage_srv/CImg.h:        pf = _data; pb = data(0,0,0,_spectrum - 1);
liveimage_srv/CImg.h:          pb-=(ulongT)_width*_height*_depth;
liveimage_srv/CImg.h:       \param axes Mirror axes, as a C-string.
liveimage_srv/CImg.h:       \param delta_x Amount of displacement along the X-axis.
liveimage_srv/CImg.h:       \param delta_y Amount of displacement along the Y-axis.
liveimage_srv/CImg.h:       \param delta_z Amount of displacement along the Z-axis.
liveimage_srv/CImg.h:       \param delta_c Amount of displacement along the C-axis.
liveimage_srv/CImg.h:        return get_crop(-delta_x,-delta_y,-delta_z,-delta_c,
liveimage_srv/CImg.h:                        width() - delta_x - 1,
liveimage_srv/CImg.h:                        height() - delta_y - 1,
liveimage_srv/CImg.h:                        depth() - delta_z - 1,
liveimage_srv/CImg.h:                        spectrum() - delta_c - 1,3).move_to(*this);
liveimage_srv/CImg.h:      if (delta_x) // Shift along X-axis
liveimage_srv/CImg.h:          const int ml = cimg::mod(-delta_x,width()), ndelta_x = (ml<=width()/2)?ml:(ml-width());
liveimage_srv/CImg.h:              std::memmove(data(0,y,z,c),data(ndelta_x,y,z,c),(_width-ndelta_x)*sizeof(T));
liveimage_srv/CImg.h:              std::memcpy(data(_width-ndelta_x,y,z,c),buf,ndelta_x*sizeof(T));
liveimage_srv/CImg.h:              std::memcpy(buf,data(_width + ndelta_x,y,z,c),-ndelta_x*sizeof(T));
liveimage_srv/CImg.h:              std::memmove(data(-ndelta_x,y,z,c),data(0,y,z,c),(_width + ndelta_x)*sizeof(T));
liveimage_srv/CImg.h:              std::memcpy(data(0,y,z,c),buf,-ndelta_x*sizeof(T));
liveimage_srv/CImg.h:            const int ndelta_x = (-delta_x>=width())?width() - 1:-delta_x;
liveimage_srv/CImg.h:              std::memmove(data(0,y,z,c),data(ndelta_x,y,z,c),(_width-ndelta_x)*sizeof(T));
liveimage_srv/CImg.h:              T *ptrd = data(_width - 1,y,z,c);
liveimage_srv/CImg.h:              for (int l = 0; l<ndelta_x - 1; ++l) *(--ptrd) = val;
liveimage_srv/CImg.h:            const int ndelta_x = (delta_x>=width())?width() - 1:delta_x;
liveimage_srv/CImg.h:              std::memmove(data(ndelta_x,y,z,c),data(0,y,z,c),(_width-ndelta_x)*sizeof(T));
liveimage_srv/CImg.h:              for (int l = 0; l<ndelta_x - 1; ++l) *(++ptrd) = val;
liveimage_srv/CImg.h:          if (delta_x<=-width() || delta_x>=width()) return fill((T)0);
liveimage_srv/CImg.h:              std::memmove(data(0,y,z,c),data(-delta_x,y,z,c),(_width + delta_x)*sizeof(T));
liveimage_srv/CImg.h:              std::memset(data(_width + delta_x,y,z,c),0,-delta_x*sizeof(T));
liveimage_srv/CImg.h:              std::memmove(data(delta_x,y,z,c),data(0,y,z,c),(_width-delta_x)*sizeof(T));
liveimage_srv/CImg.h:      if (delta_y) // Shift along Y-axis
liveimage_srv/CImg.h:          const int ml = cimg::mod(-delta_y,height()), ndelta_y = (ml<=height()/2)?ml:(ml-height());
liveimage_srv/CImg.h:              std::memmove(data(0,0,z,c),data(0,ndelta_y,z,c),_width*(_height-ndelta_y)*sizeof(T));
liveimage_srv/CImg.h:              std::memcpy(data(0,_height-ndelta_y,z,c),buf,_width*ndelta_y*sizeof(T));
liveimage_srv/CImg.h:              std::memcpy(buf,data(0,_height + ndelta_y,z,c),-ndelta_y*_width*sizeof(T));
liveimage_srv/CImg.h:              std::memmove(data(0,-ndelta_y,z,c),data(0,0,z,c),_width*(_height + ndelta_y)*sizeof(T));
liveimage_srv/CImg.h:              std::memcpy(data(0,0,z,c),buf,-ndelta_y*_width*sizeof(T));
liveimage_srv/CImg.h:            const int ndelta_y = (-delta_y>=height())?height() - 1:-delta_y;
liveimage_srv/CImg.h:              std::memmove(data(0,0,z,c),data(0,ndelta_y,z,c),_width*(_height-ndelta_y)*sizeof(T));
liveimage_srv/CImg.h:              T *ptrd = data(0,_height-ndelta_y,z,c), *ptrs = data(0,_height - 1,z,c);
liveimage_srv/CImg.h:              for (int l = 0; l<ndelta_y - 1; ++l) { std::memcpy(ptrd,ptrs,_width*sizeof(T)); ptrd+=_width; }
liveimage_srv/CImg.h:            const int ndelta_y = (delta_y>=height())?height() - 1:delta_y;
liveimage_srv/CImg.h:              std::memmove(data(0,ndelta_y,z,c),data(0,0,z,c),_width*(_height-ndelta_y)*sizeof(T));
liveimage_srv/CImg.h:              for (int l = 0; l<ndelta_y - 1; ++l) { std::memcpy(ptrd,ptrs,_width*sizeof(T)); ptrd+=_width; }
liveimage_srv/CImg.h:          if (delta_y<=-height() || delta_y>=height()) return fill((T)0);
liveimage_srv/CImg.h:              std::memmove(data(0,0,z,c),data(0,-delta_y,z,c),_width*(_height + delta_y)*sizeof(T));
liveimage_srv/CImg.h:              std::memset(data(0,_height + delta_y,z,c),0,-delta_y*_width*sizeof(T));
liveimage_srv/CImg.h:              std::memmove(data(0,delta_y,z,c),data(0,0,z,c),_width*(_height-delta_y)*sizeof(T));
liveimage_srv/CImg.h:      if (delta_z) // Shift along Z-axis
liveimage_srv/CImg.h:          const int ml = cimg::mod(-delta_z,depth()), ndelta_z = (ml<=depth()/2)?ml:(ml-depth());
liveimage_srv/CImg.h:              std::memmove(data(0,0,0,c),data(0,0,ndelta_z,c),_width*_height*(_depth-ndelta_z)*sizeof(T));
liveimage_srv/CImg.h:              std::memcpy(data(0,0,_depth-ndelta_z,c),buf,_width*_height*ndelta_z*sizeof(T));
liveimage_srv/CImg.h:              std::memcpy(buf,data(0,0,_depth + ndelta_z,c),-ndelta_z*_width*_height*sizeof(T));
liveimage_srv/CImg.h:              std::memmove(data(0,0,-ndelta_z,c),data(0,0,0,c),_width*_height*(_depth + ndelta_z)*sizeof(T));
liveimage_srv/CImg.h:              std::memcpy(data(0,0,0,c),buf,-ndelta_z*_width*_height*sizeof(T));
liveimage_srv/CImg.h:            const int ndelta_z = (-delta_z>=depth())?depth() - 1:-delta_z;
liveimage_srv/CImg.h:              std::memmove(data(0,0,0,c),data(0,0,ndelta_z,c),_width*_height*(_depth-ndelta_z)*sizeof(T));
liveimage_srv/CImg.h:              T *ptrd = data(0,0,_depth-ndelta_z,c), *ptrs = data(0,0,_depth - 1,c);
liveimage_srv/CImg.h:              for (int l = 0; l<ndelta_z - 1; ++l) {
liveimage_srv/CImg.h:            const int ndelta_z = (delta_z>=depth())?depth() - 1:delta_z;
liveimage_srv/CImg.h:              std::memmove(data(0,0,ndelta_z,c),data(0,0,0,c),_width*_height*(_depth-ndelta_z)*sizeof(T));
liveimage_srv/CImg.h:              for (int l = 0; l<ndelta_z - 1; ++l) {
liveimage_srv/CImg.h:          if (delta_z<=-depth() || delta_z>=depth()) return fill((T)0);
liveimage_srv/CImg.h:              std::memmove(data(0,0,0,c),data(0,0,-delta_z,c),_width*_height*(_depth + delta_z)*sizeof(T));
liveimage_srv/CImg.h:              std::memset(data(0,0,_depth + delta_z,c),0,_width*_height*(-delta_z)*sizeof(T));
liveimage_srv/CImg.h:              std::memmove(data(0,0,delta_z,c),data(0,0,0,c),_width*_height*(_depth-delta_z)*sizeof(T));
liveimage_srv/CImg.h:      if (delta_c) // Shift along C-axis
liveimage_srv/CImg.h:          const int ml = cimg::mod(-delta_c,spectrum()), ndelta_c = (ml<=spectrum()/2)?ml:(ml-spectrum());
liveimage_srv/CImg.h:            std::memmove(_data,data(0,0,0,ndelta_c),_width*_height*_depth*(_spectrum-ndelta_c)*sizeof(T));
liveimage_srv/CImg.h:            std::memcpy(data(0,0,0,_spectrum-ndelta_c),buf,_width*_height*_depth*ndelta_c*sizeof(T));
liveimage_srv/CImg.h:            std::memcpy(buf,data(0,0,0,_spectrum + ndelta_c),-ndelta_c*_width*_height*_depth*sizeof(T));
liveimage_srv/CImg.h:            std::memmove(data(0,0,0,-ndelta_c),_data,_width*_height*_depth*(_spectrum + ndelta_c)*sizeof(T));
liveimage_srv/CImg.h:            std::memcpy(_data,buf,-ndelta_c*_width*_height*_depth*sizeof(T));
liveimage_srv/CImg.h:            const int ndelta_c = (-delta_c>=spectrum())?spectrum() - 1:-delta_c;
liveimage_srv/CImg.h:            std::memmove(_data,data(0,0,0,ndelta_c),_width*_height*_depth*(_spectrum-ndelta_c)*sizeof(T));
liveimage_srv/CImg.h:            T *ptrd = data(0,0,0,_spectrum-ndelta_c), *ptrs = data(0,0,0,_spectrum - 1);
liveimage_srv/CImg.h:            for (int l = 0; l<ndelta_c - 1; ++l) {
liveimage_srv/CImg.h:            const int ndelta_c = (delta_c>=spectrum())?spectrum() - 1:delta_c;
liveimage_srv/CImg.h:            std::memmove(data(0,0,0,ndelta_c),_data,_width*_height*_depth*(_spectrum-ndelta_c)*sizeof(T));
liveimage_srv/CImg.h:            for (int l = 0; l<ndelta_c - 1; ++l) {
liveimage_srv/CImg.h:          if (delta_c<=-spectrum() || delta_c>=spectrum()) return fill((T)0);
liveimage_srv/CImg.h:            std::memmove(_data,data(0,0,0,-delta_c),_width*_height*_depth*(_spectrum + delta_c)*sizeof(T));
liveimage_srv/CImg.h:            std::memset(data(0,0,0,_spectrum + delta_c),0,_width*_height*_depth*(-delta_c)*sizeof(T));
liveimage_srv/CImg.h:            std::memmove(data(0,0,0,delta_c),_data,_width*_height*_depth*(_spectrum-delta_c)*sizeof(T));
liveimage_srv/CImg.h:       \param axes_order Axes permutations, as a C-string of 4 characters.
liveimage_srv/CImg.h:            for (unsigned int siz = _height*_depth*_spectrum; siz; --siz) {
liveimage_srv/CImg.h:            for (unsigned int siz = _height*_depth*_spectrum; siz; --siz) {
liveimage_srv/CImg.h:            for (unsigned int siz = _height*_depth*_spectrum; siz; --siz) {
liveimage_srv/CImg.h:            for (unsigned int siz = _height*_depth*_spectrum; siz; --siz) {
liveimage_srv/CImg.h:            for (ulongT siz = (ulongT)_width*_height*_depth; siz; --siz) *(ptrd++) = (t)*(ptr_r++);
liveimage_srv/CImg.h:            for (ulongT siz = (ulongT)_width*_height*_depth; siz; --siz) {
liveimage_srv/CImg.h:            for (ulongT siz = (ulongT)_width*_height*_depth; siz; --siz) {
liveimage_srv/CImg.h:            for (ulongT siz = (ulongT)_width*_height*_depth; siz; --siz) {
liveimage_srv/CImg.h:        const int wm1 = width() - 1, hm1 = height() - 1;
liveimage_srv/CImg.h:          cimg_forXYZC(res,x,y,z,c) *(ptrd++) = (*this)(y,hm1 - x,z,c);
liveimage_srv/CImg.h:          cimg_forXYZC(res,x,y,z,c) *(ptrd++) = (*this)(wm1 - x,hm1 - y,z,c);
liveimage_srv/CImg.h:          cimg_forXYZC(res,x,y,z,c) *(ptrd++) = (*this)(wm1 - y,x,z,c);
liveimage_srv/CImg.h:          ux = cimg::abs((_width - 1)*ca), uy = cimg::abs((_width - 1)*sa),
liveimage_srv/CImg.h:          vx = cimg::abs((_height - 1)*sa), vy = cimg::abs((_height - 1)*ca),
liveimage_srv/CImg.h:          w2 = 0.5f*(_width - 1), h2 = 0.5f*(_height - 1);
liveimage_srv/CImg.h:        const float rw2 = 0.5f*(res._width - 1), rh2 = 0.5f*(res._height - 1);
liveimage_srv/CImg.h:       \param cx X-coordinate of the rotation center.
liveimage_srv/CImg.h:       \param cy Y-coordinate of the rotation center.
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2,
liveimage_srv/CImg.h:              my = cimg::mod(h2 - xc*sa + yc*ca,hh);
liveimage_srv/CImg.h:            res(x,y,z,c) = _cubic_atXY_c(mx<width()?mx:ww - mx - 1,my<height()?my:hh - my - 1,z,c);
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2,
liveimage_srv/CImg.h:              my = cimg::mod(h2 - xc*sa + yc*ca,hh);
liveimage_srv/CImg.h:            res(x,y,z,c) = (T)_linear_atXY(mx<width()?mx:ww - mx - 1,my<height()?my:hh - my - 1,z,c);
liveimage_srv/CImg.h:        default : { // Nearest-neighbor interpolation
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2,
liveimage_srv/CImg.h:              my = cimg::mod((int)cimg::round(h2 - xc*sa + yc*ca),hh);
liveimage_srv/CImg.h:            res(x,y,z,c) = (*this)(mx<width()?mx:ww - mx - 1,my<height()?my:hh - my - 1,z,c);
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2;
liveimage_srv/CImg.h:            res(x,y,z,c) = _cubic_atXY_pc(w2 + xc*ca + yc*sa,h2 - xc*sa + yc*ca,z,c);
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2;
liveimage_srv/CImg.h:            res(x,y,z,c) = (T)_linear_atXY_p(w2 + xc*ca + yc*sa,h2 - xc*sa + yc*ca,z,c);
liveimage_srv/CImg.h:        default : { // Nearest-neighbor interpolation
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2;
liveimage_srv/CImg.h:                                   cimg::mod((int)cimg::round(h2 - xc*sa + yc*ca),(float)height()),z,c);
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2;
liveimage_srv/CImg.h:            res(x,y,z,c) = _cubic_atXY_c(w2 + xc*ca + yc*sa,h2 - xc*sa + yc*ca,z,c);
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2;
liveimage_srv/CImg.h:            res(x,y,z,c) = (T)_linear_atXY(w2 + xc*ca + yc*sa,h2 - xc*sa + yc*ca,z,c);
liveimage_srv/CImg.h:        default : { // Nearest-neighbor interpolation
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2;
liveimage_srv/CImg.h:                                 (int)cimg::round(h2 - xc*sa + yc*ca),z,c);
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2;
liveimage_srv/CImg.h:            res(x,y,z,c) = cubic_atXY_c(w2 + xc*ca + yc*sa,h2 - xc*sa + yc*ca,z,c,(T)0);
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2;
liveimage_srv/CImg.h:            res(x,y,z,c) = (T)linear_atXY(w2 + xc*ca + yc*sa,h2 - xc*sa + yc*ca,z,c,(T)0);
liveimage_srv/CImg.h:        default : { // Nearest-neighbor interpolation
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2;
liveimage_srv/CImg.h:                                (int)cimg::round(h2 - xc*sa + yc*ca),z,c,(T)0);
liveimage_srv/CImg.h:       \param u X-coordinate of the 3D rotation axis.
liveimage_srv/CImg.h:       \param v Y-coordinate of the 3D rotation axis.
liveimage_srv/CImg.h:       \param w Z-coordinate of the 3D rotation axis.
liveimage_srv/CImg.h:        w1 = _width - 1, h1 = _height - 1, d1 = _depth -1,
liveimage_srv/CImg.h:        dx = (int)cimg::round(xM - xm),
liveimage_srv/CImg.h:        dy = (int)cimg::round(yM - ym),
liveimage_srv/CImg.h:        dz = (int)cimg::round(zM - zm);
liveimage_srv/CImg.h:       \param u X-coordinate of the 3D rotation axis.
liveimage_srv/CImg.h:       \param v Y-coordinate of the 3D rotation axis.
liveimage_srv/CImg.h:       \param w Z-coordinate of the 3D rotation axis.
liveimage_srv/CImg.h:       \param cx X-coordinate of the rotation center.
liveimage_srv/CImg.h:       \param cy Y-coordinate of the rotation center.
liveimage_srv/CImg.h:       \param cz Z-coordinate of the rotation center.
liveimage_srv/CImg.h:      CImg<floatT> R = CImg<floatT>::rotation_matrix(u,v,w,-angle);
liveimage_srv/CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
liveimage_srv/CImg.h:            cimg_forC(res,c) res(x,y,z,c) = _cubic_atXYZ_c(X<width()?X:ww - X - 1,
liveimage_srv/CImg.h:                                                           Y<height()?Y:hh - Y - 1,
liveimage_srv/CImg.h:                                                           Z<depth()?Z:dd - Z - z,c);
liveimage_srv/CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
liveimage_srv/CImg.h:            cimg_forC(res,c) res(x,y,z,c) = (T)_linear_atXYZ(X<width()?X:ww - X - 1,
liveimage_srv/CImg.h:                                                             Y<height()?Y:hh - Y - 1,
liveimage_srv/CImg.h:                                                             Z<depth()?Z:dd - Z - 1,c);
liveimage_srv/CImg.h:        default : { // Nearest-neighbor interpolation
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2, zc = z - rd2;
liveimage_srv/CImg.h:            cimg_forC(res,c) res(x,y,z,c) = (*this)(X<width()?X:ww - X - 1,
liveimage_srv/CImg.h:                                                    Y<height()?Y:hh - Y - 1,
liveimage_srv/CImg.h:                                                    Z<depth()?Z:dd - Z -  1,c);
liveimage_srv/CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
liveimage_srv/CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
liveimage_srv/CImg.h:        default : { // Nearest-neighbor interpolation
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2, zc = z - rd2;
liveimage_srv/CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
liveimage_srv/CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
liveimage_srv/CImg.h:        default : { // Nearest-neighbor interpolation
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2, zc = z - rd2;
liveimage_srv/CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
liveimage_srv/CImg.h:              xc = x - rw2, yc = y - rh2, zc = z - rd2,
liveimage_srv/CImg.h:        default : { // Nearest-neighbor interpolation
liveimage_srv/CImg.h:            const float xc = x - rw2, yc = y - rh2, zc = z - rd2;
liveimage_srv/CImg.h:       \param mode Can be { 0=backward-absolute | 1=backward-relative | 2=forward-absolute | 3=foward-relative }
liveimage_srv/CImg.h:        if (mode>=3) { // Forward-relative warp
liveimage_srv/CImg.h:          else // Nearest-neighbor interpolation
liveimage_srv/CImg.h:        } else if (mode==2) { // Forward-absolute warp
liveimage_srv/CImg.h:          else // Nearest-neighbor interpolation
liveimage_srv/CImg.h:        } else if (mode==1) { // Backward-relative warp
liveimage_srv/CImg.h:                  const float mx = cimg::mod(x - (float)*(ptrs0++),w2);
liveimage_srv/CImg.h:                  *(ptrd++) = _cubic_atX_c(mx<width()?mx:w2 - mx - 1,y,z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = _cubic_atX_pc(x - (float)*(ptrs0++),y,z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = _cubic_atX_c(x - (float)*(ptrs0++),y,z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = cubic_atX_c(x - (float)*(ptrs0++),y,z,c,(T)0);
liveimage_srv/CImg.h:                  const float mx = cimg::mod(x - (float)*(ptrs0++),w2);
liveimage_srv/CImg.h:                  *(ptrd++) = (T)_linear_atX(mx<width()?mx:w2 - mx - 1,y,z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)_linear_atX_p(x - (float)*(ptrs0++),y,z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)_linear_atX(x - (float)*(ptrs0++),y,z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)linear_atX(x - (float)*(ptrs0++),y,z,c,(T)0);
liveimage_srv/CImg.h:          else // Nearest-neighbor interpolation
liveimage_srv/CImg.h:                  const int mx = cimg::mod(x - (int)cimg::round(*(ptrs0++)),w2);
liveimage_srv/CImg.h:                  *(ptrd++) = (*this)(mx<width()?mx:w2 - mx - 1,y,z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = (*this)(cimg::mod(x - (int)cimg::round(*(ptrs0++)),width()),y,z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = _atX(x - (int)cimg::round(*(ptrs0++)),y,z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = atX(x - (int)cimg::round(*(ptrs0++)),y,z,c,(T)0);
liveimage_srv/CImg.h:        else { // Backward-absolute warp
liveimage_srv/CImg.h:                  *(ptrd++) = _cubic_atX_c(mx<width()?mx:w2 - mx - 1,0,0,c);
liveimage_srv/CImg.h:                  *(ptrd++) = (T)_linear_atX(mx<width()?mx:w2 - mx - 1,0,0,c);
liveimage_srv/CImg.h:          else // Nearest-neighbor interpolation
liveimage_srv/CImg.h:                  *(ptrd++) = (*this)(mx<width()?mx:w2 - mx - 1,0,0,c);
liveimage_srv/CImg.h:        if (mode>=3) { // Forward-relative warp
liveimage_srv/CImg.h:          else // Nearest-neighbor interpolation
liveimage_srv/CImg.h:        } else if (mode==2) { // Forward-absolute warp
liveimage_srv/CImg.h:          else // Nearest-neighbor interpolation
liveimage_srv/CImg.h:        } else if (mode==1) { // Backward-relative warp
liveimage_srv/CImg.h:                    mx = cimg::mod(x - (float)*(ptrs0++),w2),
liveimage_srv/CImg.h:                    my = cimg::mod(y - (float)*(ptrs1++),h2);
liveimage_srv/CImg.h:                  *(ptrd++) = _cubic_atXY_c(mx<width()?mx:w2 - mx - 1,my<height()?my:h2 - my - 1,z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = _cubic_atXY_pc(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = _cubic_atXY_c(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = cubic_atXY_c(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c,(T)0);
liveimage_srv/CImg.h:                    mx = cimg::mod(x - (float)*(ptrs0++),w2),
liveimage_srv/CImg.h:                    my = cimg::mod(y - (float)*(ptrs1++),h2);
liveimage_srv/CImg.h:                  *(ptrd++) = (T)_linear_atXY(mx<width()?mx:w2 - mx - 1,my<height()?my:h2 - my - 1,z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)_linear_atXY_p(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)_linear_atXY(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)linear_atXY(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z,c,(T)0);
liveimage_srv/CImg.h:          else // Nearest-neighbor interpolation
liveimage_srv/CImg.h:                    mx = cimg::mod(x - (int)cimg::round(*(ptrs0++)),w2),
liveimage_srv/CImg.h:                    my = cimg::mod(y - (int)cimg::round(*(ptrs1++)),h2);
liveimage_srv/CImg.h:                  *(ptrd++) = (*this)(mx<width()?mx:w2 - mx - 1,my<height()?my:h2 - my - 1,z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = (*this)(cimg::mod(x - (int)cimg::round(*(ptrs0++)),width()),
liveimage_srv/CImg.h:                                                     cimg::mod(y - (int)cimg::round(*(ptrs1++)),height()),z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = _atXY(x - (int)cimg::round(*(ptrs0++)),
liveimage_srv/CImg.h:                                                   y - (int)cimg::round(*(ptrs1++)),z,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = atXY(x - (int)cimg::round(*(ptrs0++)),
liveimage_srv/CImg.h:                                                  y - (int)cimg::round(*(ptrs1++)),z,c,(T)0);
liveimage_srv/CImg.h:        } else { // Backward-absolute warp
liveimage_srv/CImg.h:                  *(ptrd++) = _cubic_atXY_c(mx<width()?mx:w2 - mx - 1,my<height()?my:h2 - my - 1,0,c);
liveimage_srv/CImg.h:                  *(ptrd++) = (T)_linear_atXY(mx<width()?mx:w2 - mx - 1,my<height()?my:h2 - my - 1,0,c);
liveimage_srv/CImg.h:          else // Nearest-neighbor interpolation
liveimage_srv/CImg.h:                  *(ptrd++) = (*this)(mx<width()?mx:w2 - mx - 1,my<height()?my:h2 - my - 1,0,c);
liveimage_srv/CImg.h:        if (mode>=3) { // Forward-relative warp
liveimage_srv/CImg.h:          else // Nearest-neighbor interpolation
liveimage_srv/CImg.h:        } else if (mode==2) { // Forward-absolute warp
liveimage_srv/CImg.h:          else // Nearest-neighbor interpolation
liveimage_srv/CImg.h:        } else if (mode==1) { // Backward-relative warp
liveimage_srv/CImg.h:                    mx = cimg::mod(x - (float)*(ptrs0++),w2),
liveimage_srv/CImg.h:                    my = cimg::mod(y - (float)*(ptrs1++),h2),
liveimage_srv/CImg.h:                    mz = cimg::mod(z - (float)*(ptrs2++),d2);
liveimage_srv/CImg.h:                  *(ptrd++) = _cubic_atXYZ_c(mx<width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                             my<height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                             mz<depth()?mz:d2 - mz - 1,c);
liveimage_srv/CImg.h:                  *(ptrd++) = _cubic_atXYZ_pc(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c);
liveimage_srv/CImg.h:                  *(ptrd++) = _cubic_atXYZ_c(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c);
liveimage_srv/CImg.h:                  *(ptrd++) = cubic_atXYZ_c(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c,(T)0);
liveimage_srv/CImg.h:                    mx = cimg::mod(x - (float)*(ptrs0++),w2),
liveimage_srv/CImg.h:                    my = cimg::mod(y - (float)*(ptrs1++),h2),
liveimage_srv/CImg.h:                    mz = cimg::mod(z - (float)*(ptrs2++),d2);
liveimage_srv/CImg.h:                  *(ptrd++) = (T)_linear_atXYZ(mx<width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                               my<height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                               mz<depth()?mz:d2 - mz - 1,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = (T)_linear_atXYZ_p(x - (float)*(ptrs0++),y - (float)*(ptrs1++),
liveimage_srv/CImg.h:                                                                z - (float)*(ptrs2++),c);
liveimage_srv/CImg.h:                  *(ptrd++) = (T)_linear_atXYZ(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c);
liveimage_srv/CImg.h:                  *(ptrd++) = (T)linear_atXYZ(x - (float)*(ptrs0++),y - (float)*(ptrs1++),z - (float)*(ptrs2++),c,(T)0);
liveimage_srv/CImg.h:                    mx = cimg::mod(x - (int)cimg::round(*(ptrs0++)),w2),
liveimage_srv/CImg.h:                    my = cimg::mod(y - (int)cimg::round(*(ptrs1++)),h2),
liveimage_srv/CImg.h:                    mz = cimg::mod(z - (int)cimg::round(*(ptrs2++)),d2);
liveimage_srv/CImg.h:                  *(ptrd++) = (*this)(mx<width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                      my<height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                      mz<depth()?mz:d2 - mz - 1,c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = (*this)(cimg::mod(x - (int)cimg::round(*(ptrs0++)),width()),
liveimage_srv/CImg.h:                                                     cimg::mod(y - (int)cimg::round(*(ptrs1++)),height()),
liveimage_srv/CImg.h:                                                     cimg::mod(z - (int)cimg::round(*(ptrs2++)),depth()),c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = _atXYZ(x - (int)cimg::round(*(ptrs0++)),
liveimage_srv/CImg.h:                                                    y - (int)cimg::round(*(ptrs1++)),
liveimage_srv/CImg.h:                                                    z - (int)cimg::round(*(ptrs2++)),c);
liveimage_srv/CImg.h:                cimg_forX(res,x) *(ptrd++) = atXYZ(x - (int)cimg::round(*(ptrs0++)),
liveimage_srv/CImg.h:                                                   y - (int)cimg::round(*(ptrs1++)),
liveimage_srv/CImg.h:                                                   z - (int)cimg::round(*(ptrs2++)),c,(T)0);
liveimage_srv/CImg.h:        } else { // Backward-absolute warp
liveimage_srv/CImg.h:                  *(ptrd++) = _cubic_atXYZ_c(mx<width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                             my<height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                             mz<depth()?mz:d2 - mz - 1,c);
liveimage_srv/CImg.h:                  *(ptrd++) = (T)_linear_atXYZ(mx<width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                               my<height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                               mz<depth()?mz:d2 - mz - 1,c);
liveimage_srv/CImg.h:          else // Nearest-neighbor interpolation
liveimage_srv/CImg.h:                  *(ptrd++) = (*this)(mx<width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                      my<height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                      mz<depth()?mz:d2 - mz - 1,c);
liveimage_srv/CImg.h:       \param x0 X-coordinate of the projection point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the projection point.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the projection point.
liveimage_srv/CImg.h:        _x0 = (x0>=_width)?_width - 1:x0,
liveimage_srv/CImg.h:        _y0 = (y0>=_height)?_height - 1:y0,
liveimage_srv/CImg.h:        _z0 = (z0>=_depth)?_depth - 1:z0;
liveimage_srv/CImg.h:        img_xy = get_crop(0,0,_z0,0,_width - 1,_height - 1,_z0,_spectrum - 1),
liveimage_srv/CImg.h:        img_zy = get_crop(_x0,0,0,0,_x0,_height - 1,_depth - 1,_spectrum - 1).permute_axes("xzyc").
liveimage_srv/CImg.h:        resize(_depth,_height,1,-100,-1),
liveimage_srv/CImg.h:        img_xz = get_crop(0,_y0,0,0,_width - 1,_y0,_depth - 1,_spectrum - 1).resize(_width,_depth,1,-100,-1);
liveimage_srv/CImg.h:       \param x0 = X-coordinate of the upper-left crop rectangle corner.
liveimage_srv/CImg.h:       \param y0 = Y-coordinate of the upper-left crop rectangle corner.
liveimage_srv/CImg.h:       \param z0 = Z-coordinate of the upper-left crop rectangle corner.
liveimage_srv/CImg.h:       \param c0 = C-coordinate of the upper-left crop rectangle corner.
liveimage_srv/CImg.h:       \param x1 = X-coordinate of the lower-right crop rectangle corner.
liveimage_srv/CImg.h:       \param y1 = Y-coordinate of the lower-right crop rectangle corner.
liveimage_srv/CImg.h:       \param z1 = Z-coordinate of the lower-right crop rectangle corner.
liveimage_srv/CImg.h:       \param c1 = C-coordinate of the lower-right crop rectangle corner.
liveimage_srv/CImg.h:      CImg<T> res(1U + nx1 - nx0,1U + ny1 - ny0,1U + nz1 - nz0,1U + nc1 - nc0);
liveimage_srv/CImg.h:            res(x,y,z,c) = (*this)(mx<width()?mx:w2 - mx - 1,
liveimage_srv/CImg.h:                                   my<height()?my:h2 - my - 1,
liveimage_srv/CImg.h:                                   mz<depth()?mz:d2 - mz - 1,
liveimage_srv/CImg.h:                                   mc<spectrum()?mc:s2 - mc - 1);
liveimage_srv/CImg.h:          res.fill((T)0).draw_image(-nx0,-ny0,-nz0,-nc0,*this);
liveimage_srv/CImg.h:      else res.draw_image(-nx0,-ny0,-nz0,-nc0,*this);
liveimage_srv/CImg.h:      return crop(x0,y0,z0,0,x1,y1,z1,_spectrum - 1,boundary_conditions);
liveimage_srv/CImg.h:      return get_crop(x0,y0,z0,0,x1,y1,z1,_spectrum - 1,boundary_conditions);
liveimage_srv/CImg.h:      return crop(x0,y0,0,0,x1,y1,_depth - 1,_spectrum - 1,boundary_conditions);
liveimage_srv/CImg.h:      return get_crop(x0,y0,0,0,x1,y1,_depth - 1,_spectrum - 1,boundary_conditions);
liveimage_srv/CImg.h:      return crop(x0,0,0,0,x1,_height - 1,_depth - 1,_spectrum - 1,boundary_conditions);
liveimage_srv/CImg.h:      return get_crop(x0,0,0,0,x1,_height - 1,_depth - 1,_spectrum - 1,boundary_conditions);
liveimage_srv/CImg.h:        if (coords[0]==-1 && coords[1]==-1) return assign(); // Image has only 'value' pixels
liveimage_srv/CImg.h:          if (y0>=0 && y1>=0) crop(0,y0,_width - 1,y1);
liveimage_srv/CImg.h:          if (z0>=0 && z1>=0) crop(0,0,z0,_width - 1,_height - 1,z1);
liveimage_srv/CImg.h:          if (c0>=0 && c1>=0) crop(0,0,0,c0,_width - 1,_height - 1,_depth - 1,c1);
liveimage_srv/CImg.h:          const CImg<T> col2 = get_vector_at(w - 1,h - 1,d - 1);
liveimage_srv/CImg.h:          int x0 = width(), x1 = -1;
liveimage_srv/CImg.h:          if (x0==width() && x1==-1) return assign(); else crop(x0,x1);
liveimage_srv/CImg.h:          int y0 = height(), y1 = -1;
liveimage_srv/CImg.h:          if (y0==height() && y1==-1) return assign(); else crop(0,y0,_width - 1,y1);
liveimage_srv/CImg.h:          int z0 = depth(), z1 = -1;
liveimage_srv/CImg.h:          if (z0==depth() && z1==-1) return assign(); else crop(0,0,z0,_width - 1,_height - 1,z1);
liveimage_srv/CImg.h:        int x0 = -1, x1 = -1;
liveimage_srv/CImg.h:          for (int x = width() - 1; x>=0; --x) cimg_forYZC(*this,y,z,c)
liveimage_srv/CImg.h:        int y0 = -1, y1 = -1;
liveimage_srv/CImg.h:          for (int y = height() - 1; y>=0; --y) cimg_forXZC(*this,x,z,c)
liveimage_srv/CImg.h:        int z0 = -1, z1 = -1;
liveimage_srv/CImg.h:          for (int z = depth() - 1; z>=0; --z) cimg_forXYC(*this,x,y,c)
liveimage_srv/CImg.h:        int c0 = -1, c1 = -1;
liveimage_srv/CImg.h:          for (int c = spectrum() - 1; c>=0; --c) cimg_forXYZ(*this,x,y,z)
liveimage_srv/CImg.h:      return get_crop(x0,0,0,0,x1,height() - 1,depth() - 1,spectrum() - 1);
liveimage_srv/CImg.h:      return get_crop(0,y0,0,0,width() - 1,y1,depth() - 1,spectrum() - 1);
liveimage_srv/CImg.h:      return get_crop(0,0,z0,0,width() - 1,height() - 1,z1,spectrum() - 1);
liveimage_srv/CImg.h:      return get_crop(0,0,0,c0,width() - 1,height() - 1,depth() - 1,c1);
liveimage_srv/CImg.h:                            0,0,0,_width - 1.f,_height - 1.f,0.f);
liveimage_srv/CImg.h:                            0,0,0,_width - 1.f,_height - 1.f,0.f);
liveimage_srv/CImg.h:                          0,0,0,_width - 1.f,_height - 1.f,_depth - 1.f);
liveimage_srv/CImg.h:                        0,0,0,_width - 1.f,_height - 1.f,_depth - 1.f);
liveimage_srv/CImg.h:       \param x X-coordinate of the starting point of the streamline.
liveimage_srv/CImg.h:       \param y Y-coordinate of the starting point of the streamline.
liveimage_srv/CImg.h:       \param z Z-coordinate of the starting point of the streamline.
liveimage_srv/CImg.h:         Can be <tt>{ 0=nearest int | 1=linear | 2=2nd-order RK | 3=4th-order RK. }</tt>.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the first bounding-box vertex.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the first bounding-box vertex.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the first bounding-box vertex.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the second bounding-box vertex.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the second bounding-box vertex.
liveimage_srv/CImg.h:       \param z1 Z-coordinate of the second bounding-box vertex.
liveimage_srv/CImg.h:            xi = (int)(X>0?X + 0.5f:X - 0.5f),
liveimage_srv/CImg.h:            yi = (int)(Y>0?Y + 0.5f:Y - 0.5f),
liveimage_srv/CImg.h:            zi = (int)(Z>0?Z + 0.5f:Z - 0.5f);
liveimage_srv/CImg.h:          if (is_oriented_only && u*pu + v*pv + w*pw<0) { u = -u; v = -v; w = -w; }
liveimage_srv/CImg.h:          if (is_backward_tracking) { X-=(pu=u); Y-=(pv=v); Z-=(pw=w); } else { X+=(pu=u); Y+=(pv=v); Z+=(pw=w); }
liveimage_srv/CImg.h:      case 1 : { // First-order interpolation
liveimage_srv/CImg.h:          if (is_oriented_only && u*pu + v*pv + w*pw<0) { u = -u; v = -v; w = -w; }
liveimage_srv/CImg.h:          if (is_backward_tracking) { X-=(pu=u); Y-=(pv=v); Z-=(pw=w); } else { X+=(pu=u); Y+=(pv=v); Z+=(pw=w); }
liveimage_srv/CImg.h:          if (is_oriented_only && u0*pu + v0*pv + w0*pw<0) { u0 = -u0; v0 = -v0; w0 = -w0; }
liveimage_srv/CImg.h:          if (is_oriented_only && u*pu + v*pv + w*pw<0) { u = -u; v = -v; w = -w; }
liveimage_srv/CImg.h:          if (is_backward_tracking) { X-=(pu=u); Y-=(pv=v); Z-=(pw=w); } else { X+=(pu=u); Y+=(pv=v); Z+=(pw=w); }
liveimage_srv/CImg.h:          if (is_oriented_only && u0*pu + v0*pv + w0*pw<0) { u0 = -u0; v0 = -v0; w0 = -w0; }
liveimage_srv/CImg.h:          if (is_oriented_only && u1*pu + v1*pv + w1*pw<0) { u1 = -u1; v1 = -v1; w1 = -w1; }
liveimage_srv/CImg.h:          if (is_oriented_only && u2*pu + v2*pv + w2*pw<0) { u2 = -u2; v2 = -v2; w2 = -w2; }
liveimage_srv/CImg.h:          if (is_oriented_only && u2*pu + v2*pv + w2*pw<0) { u3 = -u3; v3 = -v3; w3 = -w3; }
liveimage_srv/CImg.h:          if (is_backward_tracking) { X-=(pu=u); Y-=(pv=v); Z-=(pw=w); } else { X+=(pu=u); Y+=(pv=v); Z+=(pw=w); }
liveimage_srv/CImg.h:      if (ptr_x!=coordinates.data(0,1)) coordinates.resize((int)(ptr_x-coordinates.data()),3,1,1,0);
liveimage_srv/CImg.h:        if (I(i,j,0)*I(0,0,0) + I(i,j,1)*I(0,0,1)<0) { I(i,j,0) = -I(i,j,0); I(i,j,1) = -I(i,j,1); }
liveimage_srv/CImg.h:          xi = (int)x - (x>=0?0:1), nxi = xi + 1,
liveimage_srv/CImg.h:          yi = (int)y - (y>=0?0:1), nyi = yi + 1,
liveimage_srv/CImg.h:          dx = x - xi,
liveimage_srv/CImg.h:          dy = y - yi;
liveimage_srv/CImg.h:          if (xi>=ref.width()) xi = ref.width() - 1;
liveimage_srv/CImg.h:          if (nxi>=ref.width()) nxi = ref.width() - 1;
liveimage_srv/CImg.h:          if (yi>=ref.height()) yi = ref.height() - 1;
liveimage_srv/CImg.h:          if (nyi>=ref.height()) nyi = ref.height() - 1;
liveimage_srv/CImg.h:        return c<2?(float)pI->_linear_atXY(dx,dy,0,c):0;
liveimage_srv/CImg.h:  I(i,j,k,0) = -I(i,j,k,0); I(i,j,k,1) = -I(i,j,k,1); I(i,j,k,2) = -I(i,j,k,2); }
liveimage_srv/CImg.h:          xi = (int)x - (x>=0?0:1), nxi = xi + 1,
liveimage_srv/CImg.h:          yi = (int)y - (y>=0?0:1), nyi = yi + 1,
liveimage_srv/CImg.h:          zi = (int)z - (z>=0?0:1), nzi = zi + 1;
liveimage_srv/CImg.h:          dx = x - xi,
liveimage_srv/CImg.h:          dy = y - yi,
liveimage_srv/CImg.h:          dz = z - zi;
liveimage_srv/CImg.h:          if (xi>=ref.width()) xi = ref.width() - 1;
liveimage_srv/CImg.h:          if (nxi>=ref.width()) nxi = ref.width() - 1;
liveimage_srv/CImg.h:          if (yi>=ref.height()) yi = ref.height() - 1;
liveimage_srv/CImg.h:          if (nyi>=ref.height()) nyi = ref.height() - 1;
liveimage_srv/CImg.h:          if (zi>=ref.depth()) zi = ref.depth() - 1;
liveimage_srv/CImg.h:          if (nzi>=ref.depth()) nzi = ref.depth() - 1;
liveimage_srv/CImg.h:        return (float)pI->_linear_atXYZ(dx,dy,dz,c);
liveimage_srv/CImg.h:      ~_functor4d_streamline_expr() { mp->end(); delete mp; }
liveimage_srv/CImg.h:    //! Return a shared-memory image referencing a range of pixels of the image instance.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting pixel.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending pixel.
liveimage_srv/CImg.h:       \param y0 Y-coordinate.
liveimage_srv/CImg.h:       \param z0 Z-coordinate.
liveimage_srv/CImg.h:       \param c0 C-coordinate.
liveimage_srv/CImg.h:                                    "get_shared_points(): Invalid request of a shared-memory subset (%u->%u,%u,%u,%u).",
liveimage_srv/CImg.h:      return CImg<T>(_data + beg,x1 - x0 + 1,1,1,1,true);
liveimage_srv/CImg.h:    //! Return a shared-memory image referencing a range of pixels of the image instance \const.
liveimage_srv/CImg.h:                                    "get_shared_points(): Invalid request of a shared-memory subset (%u->%u,%u,%u,%u).",
liveimage_srv/CImg.h:      return CImg<T>(_data + beg,x1 - x0 + 1,1,1,1,true);
liveimage_srv/CImg.h:    //! Return a shared-memory image referencing a range of rows of the image instance.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting row.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending row.
liveimage_srv/CImg.h:       \param z0 Z-coordinate.
liveimage_srv/CImg.h:       \param c0 C-coordinate.
liveimage_srv/CImg.h:                                    "get_shared_rows(): Invalid request of a shared-memory subset "
liveimage_srv/CImg.h:                                    "(0->%u,%u->%u,%u,%u).",
liveimage_srv/CImg.h:                                    _width - 1,y0,y1,z0,c0);
liveimage_srv/CImg.h:      return CImg<T>(_data + beg,_width,y1 - y0 + 1,1,1,true);
liveimage_srv/CImg.h:    //! Return a shared-memory image referencing a range of rows of the image instance \const.
liveimage_srv/CImg.h:                                    "get_shared_rows(): Invalid request of a shared-memory subset "
liveimage_srv/CImg.h:                                    "(0->%u,%u->%u,%u,%u).",
liveimage_srv/CImg.h:                                    _width - 1,y0,y1,z0,c0);
liveimage_srv/CImg.h:      return CImg<T>(_data + beg,_width,y1 - y0 + 1,1,1,true);
liveimage_srv/CImg.h:    //! Return a shared-memory image referencing one row of the image instance.
liveimage_srv/CImg.h:       \param y0 Y-coordinate.
liveimage_srv/CImg.h:       \param z0 Z-coordinate.
liveimage_srv/CImg.h:       \param c0 C-coordinate.
liveimage_srv/CImg.h:    //! Return a shared-memory image referencing one row of the image instance \const.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the starting slice.
liveimage_srv/CImg.h:       \param z1 Z-coordinate of the ending slice.
liveimage_srv/CImg.h:       \param c0 C-coordinate.
liveimage_srv/CImg.h:                                    "get_shared_slices(): Invalid request of a shared-memory subset "
liveimage_srv/CImg.h:                                    "(0->%u,0->%u,%u->%u,%u).",
liveimage_srv/CImg.h:                                    _width - 1,_height - 1,z0,z1,c0);
liveimage_srv/CImg.h:      return CImg<T>(_data + beg,_width,_height,z1 - z0 + 1,1,true);
liveimage_srv/CImg.h:                                    "get_shared_slices(): Invalid request of a shared-memory subset "
liveimage_srv/CImg.h:                                    "(0->%u,0->%u,%u->%u,%u).",
liveimage_srv/CImg.h:                                    _width - 1,_height - 1,z0,z1,c0);
liveimage_srv/CImg.h:      return CImg<T>(_data + beg,_width,_height,z1 - z0 + 1,1,true);
liveimage_srv/CImg.h:    //! Return a shared-memory image referencing one slice of the image instance.
liveimage_srv/CImg.h:       \param z0 Z-coordinate.
liveimage_srv/CImg.h:       \param c0 C-coordinate.
liveimage_srv/CImg.h:    //! Return a shared-memory image referencing one slice of the image instance \const.
liveimage_srv/CImg.h:    //! Return a shared-memory image referencing a range of channels of the image instance.
liveimage_srv/CImg.h:       \param c0 C-coordinate of the starting channel.
liveimage_srv/CImg.h:       \param c1 C-coordinate of the ending channel.
liveimage_srv/CImg.h:                                    "get_shared_channels(): Invalid request of a shared-memory subset "
liveimage_srv/CImg.h:                                    "(0->%u,0->%u,0->%u,%u->%u).",
liveimage_srv/CImg.h:                                    _width - 1,_height - 1,_depth - 1,c0,c1);
liveimage_srv/CImg.h:      return CImg<T>(_data + beg,_width,_height,_depth,c1 - c0 + 1,true);
liveimage_srv/CImg.h:    //! Return a shared-memory image referencing a range of channels of the image instance \const.
liveimage_srv/CImg.h:                                    "get_shared_channels(): Invalid request of a shared-memory subset "
liveimage_srv/CImg.h:                                    "(0->%u,0->%u,0->%u,%u->%u).",
liveimage_srv/CImg.h:                                    _width - 1,_height - 1,_depth - 1,c0,c1);
liveimage_srv/CImg.h:      return CImg<T>(_data + beg,_width,_height,_depth,c1 - c0 + 1,true);
liveimage_srv/CImg.h:    //! Return a shared-memory image referencing one channel of the image instance.
liveimage_srv/CImg.h:       \param c0 C-coordinate.
liveimage_srv/CImg.h:    //! Return a shared-memory image referencing one channel of the image instance \const.
liveimage_srv/CImg.h:    //! Return a shared-memory version of the image instance.
liveimage_srv/CImg.h:    //! Return a shared-memory version of the image instance \const.
liveimage_srv/CImg.h:       - If \c nb==0, instance image is split into blocs of equal values along the specified axis.
liveimage_srv/CImg.h:       - If \c nb<=0, instance image is split into blocs of -\c nb pixel wide.
liveimage_srv/CImg.h:       - If \c nb>0, instance image is split into \c nb blocs.
liveimage_srv/CImg.h:    CImgList<T> get_split(const char axis, const int nb=-1) const {
liveimage_srv/CImg.h:        const unsigned int dp = (unsigned int)(nb?-nb:1);
liveimage_srv/CImg.h:            const unsigned int pe = _width - dp;
liveimage_srv/CImg.h:              get_crop(p,0,0,0,p + dp - 1,_height - 1,_depth - 1,_spectrum - 1).move_to(res[p/dp]);
liveimage_srv/CImg.h:            get_crop((res._width - 1)*dp,0,0,0,_width - 1,_height - 1,_depth - 1,_spectrum - 1).move_to(res.back());
liveimage_srv/CImg.h:            const unsigned int pe = _height - dp;
liveimage_srv/CImg.h:              get_crop(0,p,0,0,_width - 1,p + dp - 1,_depth - 1,_spectrum - 1).move_to(res[p/dp]);
liveimage_srv/CImg.h:            get_crop(0,(res._width - 1)*dp,0,0,_width - 1,_height - 1,_depth - 1,_spectrum - 1).move_to(res.back());
liveimage_srv/CImg.h:            const unsigned int pe = _depth - dp;
liveimage_srv/CImg.h:              get_crop(0,0,p,0,_width - 1,_height - 1,p + dp - 1,_spectrum - 1).move_to(res[p/dp]);
liveimage_srv/CImg.h:            get_crop(0,0,(res._width - 1)*dp,0,_width - 1,_height - 1,_depth - 1,_spectrum - 1).move_to(res.back());
liveimage_srv/CImg.h:            const unsigned int pe = _spectrum - dp;
liveimage_srv/CImg.h:              get_crop(0,0,0,p,_width - 1,_height - 1,_depth - 1,p + dp - 1).move_to(res[p/dp]);
liveimage_srv/CImg.h:            get_crop(0,0,0,(res._width - 1)*dp,_width - 1,_height - 1,_depth - 1,_spectrum - 1).move_to(res.back());
liveimage_srv/CImg.h:      } else if (nb>0) { // Split by number of (non-homogeneous) blocs
liveimage_srv/CImg.h:                                      "get_split(): Instance cannot be split along %c-axis into %u blocs.",
liveimage_srv/CImg.h:            cimg_forX(*this,p) if ((err-=nb)<=0) {
liveimage_srv/CImg.h:              get_crop(_p,0,0,0,p,_height - 1,_depth - 1,_spectrum - 1).move_to(res);
liveimage_srv/CImg.h:            cimg_forY(*this,p) if ((err-=nb)<=0) {
liveimage_srv/CImg.h:              get_crop(0,_p,0,0,_width - 1,p,_depth - 1,_spectrum - 1).move_to(res);
liveimage_srv/CImg.h:            cimg_forZ(*this,p) if ((err-=nb)<=0) {
liveimage_srv/CImg.h:              get_crop(0,0,_p,0,_width - 1,_height - 1,p,_spectrum - 1).move_to(res);
liveimage_srv/CImg.h:            cimg_forC(*this,p) if ((err-=nb)<=0) {
liveimage_srv/CImg.h:              get_crop(0,0,0,_p,_width - 1,_height - 1,_depth - 1,p).move_to(res);
liveimage_srv/CImg.h:            if ((*this)(i)!=current) { get_columns(i0,i - 1).move_to(res); i0 = i; current = (*this)(i); }
liveimage_srv/CImg.h:          get_columns(i0,width() - 1).move_to(res);
liveimage_srv/CImg.h:            if ((*this)(0,i)!=current) { get_rows(i0,i - 1).move_to(res); i0 = i; current = (*this)(0,i); }
liveimage_srv/CImg.h:          get_rows(i0,height() - 1).move_to(res);
liveimage_srv/CImg.h:            if ((*this)(0,0,i)!=current) { get_slices(i0,i - 1).move_to(res); i0 = i; current = (*this)(0,0,i); }
liveimage_srv/CImg.h:          get_slices(i0,depth() - 1).move_to(res);
liveimage_srv/CImg.h:            if ((*this)(0,0,0,i)!=current) { get_channels(i0,i - 1).move_to(res); i0 = i; current = (*this)(0,0,0,i); }
liveimage_srv/CImg.h:          get_channels(i0,spectrum() - 1).move_to(res);
liveimage_srv/CImg.h:              CImg<T>(_data + i0,1,(unsigned int)(i - i0)).move_to(res);
liveimage_srv/CImg.h:          CImg<T>(_data + i0,1,(unsigned int)(size() - i0)).move_to(res);
liveimage_srv/CImg.h:    //! Split image into a list of sub-images, according to a specified splitting value sequence and optionally axis.
liveimage_srv/CImg.h:            if (i>i0) { if (keep_values) get_columns(i0,i - 1).move_to(res); i0 = i; }
liveimage_srv/CImg.h:            if (i>i0) { get_columns(i0,i - 1).move_to(res); i0 = i; }
liveimage_srv/CImg.h:            if (i>i0) { if (keep_values) get_rows(i0,i - 1).move_to(res); i0 = i; }
liveimage_srv/CImg.h:            if (i>i0) { get_rows(i0,i - 1).move_to(res); i0 = i; }
liveimage_srv/CImg.h:            if (i>i0) { if (keep_values) get_slices(i0,i - 1).move_to(res); i0 = i; }
liveimage_srv/CImg.h:            if (i>i0) { get_slices(i0,i - 1).move_to(res); i0 = i; }
liveimage_srv/CImg.h:            if (i>i0) { if (keep_values) get_channels(i0,i - 1).move_to(res); i0 = i; }
liveimage_srv/CImg.h:            if (i>i0) { get_channels(i0,i - 1).move_to(res); i0 = i; }
liveimage_srv/CImg.h:              if (keep_values) CImg<T>(_data + i0,1,(unsigned int)(i - i0)).move_to(res);
liveimage_srv/CImg.h:            if (i>i0) { CImg<T>(_data + i0,1,(unsigned int)(i - i0)).move_to(res); i0 = i; }
liveimage_srv/CImg.h:              i-=j;
liveimage_srv/CImg.h:                if (i1>i0) get_columns(i0,i1 - 1).move_to(res);
liveimage_srv/CImg.h:                if (keep_values) get_columns(i1,i - 1).move_to(res);
liveimage_srv/CImg.h:          if (i0<_width) get_columns(i0,width() - 1).move_to(res);
liveimage_srv/CImg.h:              i-=j;
liveimage_srv/CImg.h:                if (i1>i0) get_rows(i0,i1 - 1).move_to(res);
liveimage_srv/CImg.h:                if (keep_values) get_rows(i1,i - 1).move_to(res);
liveimage_srv/CImg.h:          if (i0<_height) get_rows(i0,height() - 1).move_to(res);
liveimage_srv/CImg.h:              i-=j;
liveimage_srv/CImg.h:                if (i1>i0) get_slices(i0,i1 - 1).move_to(res);
liveimage_srv/CImg.h:                if (keep_values) get_slices(i1,i - 1).move_to(res);
liveimage_srv/CImg.h:          if (i0<_depth) get_slices(i0,depth() - 1).move_to(res);
liveimage_srv/CImg.h:              i-=j;
liveimage_srv/CImg.h:                if (i1>i0) get_channels(i0,i1 - 1).move_to(res);
liveimage_srv/CImg.h:                if (keep_values) get_channels(i1,i - 1).move_to(res);
liveimage_srv/CImg.h:          if (i0<_spectrum) get_channels(i0,spectrum() - 1).move_to(res);
liveimage_srv/CImg.h:              i-=j;
liveimage_srv/CImg.h:                if (i1>i0) CImg<T>(_data + i0,1,(unsigned int)(i1 - i0)).move_to(res);
liveimage_srv/CImg.h:                if (keep_values) CImg<T>(_data + i1,1,(unsigned int)(i - i1)).move_to(res);
liveimage_srv/CImg.h:          if (i0<siz) CImg<T>(_data + i0,1,(unsigned int)(siz - i0)).move_to(res);
liveimage_srv/CImg.h:    //---------------------------------------
liveimage_srv/CImg.h:    //---------------------------------------
liveimage_srv/CImg.h:       \param xcenter X-coordinate of the kernel center (~0U>>1 means 'centered').
liveimage_srv/CImg.h:       \param ycenter Y-coordinate of the kernel center (~0U>>1 means 'centered').
liveimage_srv/CImg.h:       \param zcenter Z-coordinate of the kernel center (~0U>>1 means 'centered').
liveimage_srv/CImg.h:       \param xstart Starting X-coordinate of the instance image.
liveimage_srv/CImg.h:       \param ystart Starting Y-coordinate of the instance image.
liveimage_srv/CImg.h:       \param zstart Starting Z-coordinate of the instance image.
liveimage_srv/CImg.h:       \param xend Ending X-coordinate of the instance image.
liveimage_srv/CImg.h:       \param yend Ending Y-coordinate of the instance image.
liveimage_srv/CImg.h:       \param zend Ending Z-coordinate of the instance image.
liveimage_srv/CImg.h:       \param xstride Stride along the X-axis.
liveimage_srv/CImg.h:       \param ystride Stride along the Y-axis.
liveimage_srv/CImg.h:       \param zstride Stride along the Z-axis.
liveimage_srv/CImg.h:       \param xdilation Dilation along the X-axis.
liveimage_srv/CImg.h:       \param ydilation Dilation along the Y-axis.
liveimage_srv/CImg.h:       \param zdilation Dilation along the Z-axis.
liveimage_srv/CImg.h:       - The correlation of the image instance \p *this by the kernel \p kernel is defined to be:
liveimage_srv/CImg.h:       res(x,y,z) = sum_{i,j,k} (*this)(\alpha_x\;x + \beta_x\;(i - c_x),\alpha_y\;y + \beta_y\;(j -
liveimage_srv/CImg.h:                    c_y),\alpha_z\;z + \beta_z\;(k - c_z))*kernel(i,j,k).
liveimage_srv/CImg.h:                                    "%s(): Invalid xyz-start/end arguments (start = (%d,%d,%d), end = (%d,%d,%d)).",
liveimage_srv/CImg.h:        _xcenter = xcenter==(int)(~0U>>1)?kernel.width()/2 - 1 + (kernel.width()%2):
liveimage_srv/CImg.h:        std::min(xcenter,kernel.width() - 1),
liveimage_srv/CImg.h:        _ycenter = ycenter==(int)(~0U>>1)?kernel.height()/2 - 1 + (kernel.height()%2):
liveimage_srv/CImg.h:        std::min(ycenter,kernel.height() - 1),
liveimage_srv/CImg.h:        _zcenter = zcenter==(int)(~0U>>1)?kernel.depth()/2 - 1 + (kernel.depth()%2):
liveimage_srv/CImg.h:        std::min(zcenter,kernel.depth() - 1);
liveimage_srv/CImg.h:            get_mirror('x').resize(kernel,-1);
liveimage_srv/CImg.h:          _xcenter = kernel.width() - 1 - _xcenter;
liveimage_srv/CImg.h:          _ycenter = kernel.height() - 1 - _ycenter;
liveimage_srv/CImg.h:          _zcenter = kernel.depth() - _zcenter - 1;
liveimage_srv/CImg.h:        } else { _kernel = kernel.get_shared(); _xdilation*=-1; _ydilation*=-1; _zdilation*=-1; }
liveimage_srv/CImg.h:        _xend = xend==(int)(~0U>>1)?width() - 1:xend,
liveimage_srv/CImg.h:        _yend = yend==(int)(~0U>>1)?height() - 1:yend,
liveimage_srv/CImg.h:        _zend = zend==(int)(~0U>>1)?depth() - 1:zend,
liveimage_srv/CImg.h:        res_width = _xend - xstart + 1,
liveimage_srv/CImg.h:        res_height = _yend - ystart + 1,
liveimage_srv/CImg.h:        w1 = w  - 1, h1 = h - 1, d1 = d - 1,
liveimage_srv/CImg.h:        _kernel.assign(_kernel.get_resize(M + 1 - (M%2),M + 1 - (M%2),_kernel._depth>1?M + 1 - (M%2):1,-100,
liveimage_srv/CImg.h:                  px = x - i_xdilation>0?x - i_xdilation:0, nx = x + i_xdilation<w1?x + i_xdilation:w1,
liveimage_srv/CImg.h:                  py = y - i_ydilation>0?y - i_ydilation:0, ny = y + i_ydilation<h1?y + i_ydilation:h1,
liveimage_srv/CImg.h:                  pz = z - i_zdilation>0?z - i_zdilation:0, nz = z + i_zdilation<d1?z + i_zdilation:d1;
liveimage_srv/CImg.h:                  px = x - i_xdilation>0?x - i_xdilation:0, nx = x + i_xdilation<w1?x + i_xdilation:w1,
liveimage_srv/CImg.h:                  py = y - i_ydilation>0?y - i_ydilation:0, ny = y + i_ydilation<h1?y + i_ydilation:h1,
liveimage_srv/CImg.h:                  pz = z - i_zdilation>0?z - i_zdilation:0, nz = z + i_zdilation<d1?z + i_zdilation:d1;
liveimage_srv/CImg.h:                    px = x - i_xdilation>0?x - i_xdilation:0, bx = px - i_xdilation>0?px - i_xdilation:0,
liveimage_srv/CImg.h:                    py = y - i_ydilation>0?y - i_ydilation:0, by = py - i_ydilation>0?py - i_ydilation:0,
liveimage_srv/CImg.h:                    px = x - i_xdilation>0?x - i_xdilation:0, bx = px - i_xdilation>0?px - i_xdilation:0,
liveimage_srv/CImg.h:                    py = y - i_ydilation>0?y - i_ydilation:0, by = py - i_ydilation>0?py - i_ydilation:0,
liveimage_srv/CImg.h:                    px = x - i_xdilation>0?x - i_xdilation:0, nx = x + i_xdilation<w1?x + i_xdilation:w1,
liveimage_srv/CImg.h:                    py = y - i_ydilation>0?y - i_ydilation:0, ny = y + i_ydilation<h1?y + i_ydilation:h1;
liveimage_srv/CImg.h:                    px = x - i_xdilation>0?x - i_xdilation:0, nx = x + i_xdilation<w1?x + i_xdilation:w1,
liveimage_srv/CImg.h:                    py = y - i_ydilation>0?y - i_ydilation:0, ny = y + i_ydilation<h1?y + i_ydilation:h1;
liveimage_srv/CImg.h:#define _cimg_correlate_x_int const int ix = xstart + i_xstride*x + i_xdilation*(p - _xcenter)
liveimage_srv/CImg.h:#define _cimg_correlate_y_int const int iy = ystart + i_ystride*y + i_ydilation*(q - _ycenter)
liveimage_srv/CImg.h:#define _cimg_correlate_z_int const int iz = zstart + i_zstride*z + i_zdilation*(r - _zcenter)
liveimage_srv/CImg.h:#define _cimg_correlate_x_float const float ix = xstart + xstride*x + _xdilation*(p - _xcenter)
liveimage_srv/CImg.h:#define _cimg_correlate_y_float const float iy = ystart + ystride*y + _ydilation*(q - _ycenter)
liveimage_srv/CImg.h:#define _cimg_correlate_z_float const float iz = zstart + zstride*z + _zdilation*(r - _zcenter)
liveimage_srv/CImg.h:#define _cimg_correlate_x_int_mirror const int mx = cimg::mod(ix,w2), nix = mx<w?mx:w2 - mx - 1
liveimage_srv/CImg.h:#define _cimg_correlate_y_int_mirror const int my = cimg::mod(iy,h2), niy = my<h?my:h2 - my - 1
liveimage_srv/CImg.h:#define _cimg_correlate_z_int_mirror const int mz = cimg::mod(iz,d2), niz = mz<d?mz:d2 - mz - 1
liveimage_srv/CImg.h:#define _cimg_correlate_x_float_mirror const float mx = cimg::mod(ix,w2), nix = mx<w?mx:w2 - mx - 1
liveimage_srv/CImg.h:#define _cimg_correlate_y_float_mirror const float my = cimg::mod(iy,h2), niy = my<h?my:h2 - my - 1
liveimage_srv/CImg.h:#define _cimg_correlate_z_float_mirror const float mz = cimg::mod(iz,d2), niz = mz<d?mz:d2 - mz - 1
liveimage_srv/CImg.h:            else if (interpolation_type) // Non-integer stride or dilation, linear interpolation
liveimage_srv/CImg.h:            else // Non-integer stride or dilation, nearest-neighbor interpolation
liveimage_srv/CImg.h:            else if (interpolation_type) // Non-integer stride or dilation, linear interpolation
liveimage_srv/CImg.h:            else // Non-integer stride or dilation, nearest-neighbor interpolation
liveimage_srv/CImg.h:       \param xcenter X-coordinate of the kernel center (~0U means 'centered').
liveimage_srv/CImg.h:       \param ycenter Y-coordinate of the kernel center (~0U means 'centered').
liveimage_srv/CImg.h:       \param zcenter Z-coordinate of the kernel center (~0U means 'centered').
liveimage_srv/CImg.h:       \param xstart Starting X-coordinate of the instance image.
liveimage_srv/CImg.h:       \param ystart Starting Y-coordinate of the instance image.
liveimage_srv/CImg.h:       \param zstart Starting Z-coordinate of the instance image.
liveimage_srv/CImg.h:       \param xend Ending X-coordinate of the instance image.
liveimage_srv/CImg.h:       \param yend Ending Y-coordinate of the instance image.
liveimage_srv/CImg.h:       \param zend Ending Z-coordinate of the instance image.
liveimage_srv/CImg.h:       \param xstride Stride along the X-axis.
liveimage_srv/CImg.h:       \param ystride Stride along the Y-axis.
liveimage_srv/CImg.h:       \param zstride Stride along the Z-axis.
liveimage_srv/CImg.h:       \param xdilation Dilation along the X-axis.
liveimage_srv/CImg.h:       \param ydilation Dilation along the Y-axis.
liveimage_srv/CImg.h:       \param zdilation Dilation along the Z-axis.
liveimage_srv/CImg.h:       - The convolution of the image instance \p *this by the kernel \p kernel is defined to be:
liveimage_srv/CImg.h:       res(x,y,z) = sum_{i,j,k} (*this)(\alpha_x\;x - \beta_x\;(i - c_x),\alpha_y\;y
liveimage_srv/CImg.h:                    - \beta_y\;(j - c_y),\alpha_z\;z - \beta_z\;(k - c_z))*kernel(i,j,k).
liveimage_srv/CImg.h:       \param axes Cumulation axes, as a C-string.
liveimage_srv/CImg.h:       \param is_real Do the erosion in real (a.k.a 'non-flat') mode (\c true) rather than binary mode (\c false).
liveimage_srv/CImg.h:        mx1 = kernel.width() - mx2 - 1, my1 = kernel.height() - my2 - 1, mz1 = kernel.depth() - mz2 - 1,
liveimage_srv/CImg.h:        mxe = width() - mx2, mye = height() - my2, mze = depth() - mz2,
liveimage_srv/CImg.h:                for (int zm = -mz1; zm<=mz2; ++zm)
liveimage_srv/CImg.h:                  for (int ym = -my1; ym<=my2; ++ym)
liveimage_srv/CImg.h:                    for (int xm = -mx1; xm<=mx2; ++xm) {
liveimage_srv/CImg.h:                      const Tt cval = (Tt)(img(x + xm,y + ym,z + zm) - mval);
liveimage_srv/CImg.h:            for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1 - 1 || x>=mxe)?++x:(x=mxe))) {
liveimage_srv/CImg.h:              for (int zm = -mz1; zm<=mz2; ++zm)
liveimage_srv/CImg.h:                for (int ym = -my1; ym<=my2; ++ym)
liveimage_srv/CImg.h:                  for (int xm = -mx1; xm<=mx2; ++xm) {
liveimage_srv/CImg.h:                    case 0 : cval = (Tt)(img.atXYZ(x + xm,y + ym,z + zm,0,(T)0) - mval); break;
liveimage_srv/CImg.h:                    case 1 : cval = (Tt)(img._atXYZ(x + xm,y + ym,z + zm) - mval); break;
liveimage_srv/CImg.h:                      cval = img(nx,ny,nz) - mval;
liveimage_srv/CImg.h:                        nx = tx<width()?tx:w2 - tx - 1,
liveimage_srv/CImg.h:                        ny = ty<height()?ty:h2 - ty - 1,
liveimage_srv/CImg.h:                        nz = tz<depth()?tz:d2 - tz - 1;
liveimage_srv/CImg.h:                      cval = img(nx,ny,nz) - mval;
liveimage_srv/CImg.h:                for (int zm = -mz1; zm<=mz2; ++zm)
liveimage_srv/CImg.h:                  for (int ym = -my1; ym<=my2; ++ym)
liveimage_srv/CImg.h:                    for (int xm = -mx1; xm<=mx2; ++xm)
liveimage_srv/CImg.h:            for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1 - 1 || x>=mxe)?++x:(x=mxe))) {
liveimage_srv/CImg.h:              for (int zm = -mz1; zm<=mz2; ++zm)
liveimage_srv/CImg.h:                for (int ym = -my1; ym<=my2; ++ym)
liveimage_srv/CImg.h:                  for (int xm = -mx1; xm<=mx2; ++xm) {
liveimage_srv/CImg.h:                          nx = tx<width()?tx:w2 - tx - 1,
liveimage_srv/CImg.h:                          ny = ty<height()?ty:h2 - ty - 1,
liveimage_srv/CImg.h:                          nz = tz<depth()?tz:d2 - tz - 1;
liveimage_srv/CImg.h:      if (sx>1 && _width>1) { // Along X-axis
liveimage_srv/CImg.h:        const int L = width(), off = 1, s = (int)sx, _s2 = s/2 + 1, _s1 = s - _s2, s1 = _s1>L?L:_s1, s2 = _s2>L?L:_s2;
liveimage_srv/CImg.h:          T *const ptrdb = buf._data, *ptrd = buf._data, *const ptrde = buf._data + L - 1;
liveimage_srv/CImg.h:          const T *const ptrsb = data(0,y,z,c), *ptrs = ptrsb, *const ptrse = ptrs + (ulongT)L*off - off;
liveimage_srv/CImg.h:          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
liveimage_srv/CImg.h:            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
liveimage_srv/CImg.h:            for (int p = L - s - 1; p>0; --p) {
liveimage_srv/CImg.h:                const T *nptrs = ptrs - off; cur = val;
liveimage_srv/CImg.h:                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval<cur) cur = nval; }
liveimage_srv/CImg.h:                nptrs-=off; const T nval = *nptrs; if (nval<cur) { cur = nval; is_first = true; } else is_first = false;
liveimage_srv/CImg.h:              } else { if (val<=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
liveimage_srv/CImg.h:            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
liveimage_srv/CImg.h:            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
liveimage_srv/CImg.h:              const T val = *ptrs; ptrs-=off; if (val<cur) cur = val;
liveimage_srv/CImg.h:            *(ptrd--) = cur;
liveimage_srv/CImg.h:            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
liveimage_srv/CImg.h:              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val<cur) cur = val; *(ptrd--) = cur;
liveimage_srv/CImg.h:      if (sy>1 && _height>1) { // Along Y-axis
liveimage_srv/CImg.h:        const int L = height(), off = width(), s = (int)sy, _s2 = s/2 + 1, _s1 = s - _s2, s1 = _s1>L?L:_s1,
liveimage_srv/CImg.h:          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
liveimage_srv/CImg.h:          const T *const ptrsb = data(x,0,z,c), *ptrs = ptrsb, *const ptrse = ptrs + (ulongT)L*off - off;
liveimage_srv/CImg.h:          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
liveimage_srv/CImg.h:            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
liveimage_srv/CImg.h:            for (int p = L - s - 1; p>0; --p) {
liveimage_srv/CImg.h:                const T *nptrs = ptrs - off; cur = val;
liveimage_srv/CImg.h:                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval<cur) cur = nval; }
liveimage_srv/CImg.h:                nptrs-=off; const T nval = *nptrs; if (nval<cur) { cur = nval; is_first = true; } else is_first = false;
liveimage_srv/CImg.h:              } else { if (val<=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
liveimage_srv/CImg.h:            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
liveimage_srv/CImg.h:            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
liveimage_srv/CImg.h:              const T val = *ptrs; ptrs-=off; if (val<cur) cur = val;
liveimage_srv/CImg.h:            *(ptrd--) = cur;
liveimage_srv/CImg.h:            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
liveimage_srv/CImg.h:              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val<cur) cur = val; *(ptrd--) = cur;
liveimage_srv/CImg.h:      if (sz>1 && _depth>1) { // Along Z-axis
liveimage_srv/CImg.h:        const int L = depth(), off = width()*height(), s = (int)sz, _s2 = s/2 + 1, _s1 = s - _s2, s1 = _s1>L?L:_s1,
liveimage_srv/CImg.h:          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
liveimage_srv/CImg.h:          const T *const ptrsb = data(x,y,0,c), *ptrs = ptrsb, *const ptrse = ptrs + (ulongT)L*off - off;
liveimage_srv/CImg.h:          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
liveimage_srv/CImg.h:            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
liveimage_srv/CImg.h:            for (int p = L - s - 1; p>0; --p) {
liveimage_srv/CImg.h:                const T *nptrs = ptrs - off; cur = val;
liveimage_srv/CImg.h:                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval<cur) cur = nval; }
liveimage_srv/CImg.h:                nptrs-=off; const T nval = *nptrs; if (nval<cur) { cur = nval; is_first = true; } else is_first = false;
liveimage_srv/CImg.h:              } else { if (val<=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
liveimage_srv/CImg.h:            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
liveimage_srv/CImg.h:            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
liveimage_srv/CImg.h:              const T val = *ptrs; ptrs-=off; if (val<cur) cur = val;
liveimage_srv/CImg.h:            *(ptrd--) = cur;
liveimage_srv/CImg.h:            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
liveimage_srv/CImg.h:              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val<cur) cur = val; *(ptrd--) = cur;
liveimage_srv/CImg.h:       \param is_real Do the dilation in real (a.k.a 'non-flat') mode (\c true) rather than binary mode (\c false).
liveimage_srv/CImg.h:        mx2 = kernel.width() - mx1 - 1, my2 = kernel.height() - my1 - 1, mz2 = kernel.depth() - mz1 - 1,
liveimage_srv/CImg.h:        mxe = width() - mx2, mye = height() - my2, mze = depth() - mz2,
liveimage_srv/CImg.h:                for (int zm = -mz1; zm<=mz2; ++zm)
liveimage_srv/CImg.h:                  for (int ym = -my1; ym<=my2; ++ym)
liveimage_srv/CImg.h:                    for (int xm = -mx1; xm<=mx2; ++xm) {
liveimage_srv/CImg.h:                      const t mval = K(mx2 - xm,my2 - ym,mz2 - zm);
liveimage_srv/CImg.h:            for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1 - 1 || x>=mxe)?++x:(x=mxe))) {
liveimage_srv/CImg.h:              for (int zm = -mz1; zm<=mz2; ++zm)
liveimage_srv/CImg.h:                for (int ym = -my1; ym<=my2; ++ym)
liveimage_srv/CImg.h:                  for (int xm = -mx1; xm<=mx2; ++xm) {
liveimage_srv/CImg.h:                    const t mval = K(mx2 - xm,my2 - ym,mz2 - zm);
liveimage_srv/CImg.h:                        nx = tx<width()?tx:w2 - tx - 1,
liveimage_srv/CImg.h:                        ny = ty<height()?ty:h2 - ty - 1,
liveimage_srv/CImg.h:                        nz = tz<depth()?tz:d2 - tz - 1;
liveimage_srv/CImg.h:                for (int zm = -mz1; zm<=mz2; ++zm)
liveimage_srv/CImg.h:                  for (int ym = -my1; ym<=my2; ++ym)
liveimage_srv/CImg.h:                    for (int xm = -mx1; xm<=mx2; ++xm)
liveimage_srv/CImg.h:                      if (K(mx2 - xm,my2 - ym,mz2 - zm)) {
liveimage_srv/CImg.h:            for (int x = 0; x<width(); (y<my1 || y>=mye || z<mz1 || z>=mze)?++x:((x<mx1 - 1 || x>=mxe)?++x:(x=mxe))) {
liveimage_srv/CImg.h:              for (int zm = -mz1; zm<=mz2; ++zm)
liveimage_srv/CImg.h:                for (int ym = -my1; ym<=my2; ++ym)
liveimage_srv/CImg.h:                  for (int xm = -mx1; xm<=mx2; ++xm) {
liveimage_srv/CImg.h:                    if (K(mx2 - xm,my2 - ym,mz2 - zm)) {
liveimage_srv/CImg.h:                          nx = tx<width()?tx:w2 - tx - 1,
liveimage_srv/CImg.h:                          ny = ty<height()?ty:h2 - ty - 1,
liveimage_srv/CImg.h:                          nz = tz<depth()?tz:d2 - tz - 1;
liveimage_srv/CImg.h:      if (sx>1 && _width>1) { // Along X-axis
liveimage_srv/CImg.h:        const int L = width(), off = 1, s = (int)sx, _s1 = s/2, _s2 = s - _s1, s1 = _s1>L?L:_s1, s2 = _s2>L?L:_s2;
liveimage_srv/CImg.h:          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
liveimage_srv/CImg.h:          const T *const ptrsb = data(0,y,z,c), *ptrs = ptrsb, *const ptrse = ptrs + (ulongT)L*off - off;
liveimage_srv/CImg.h:          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
liveimage_srv/CImg.h:            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
liveimage_srv/CImg.h:            for (int p = L - s - 1; p>0; --p) {
liveimage_srv/CImg.h:                const T *nptrs = ptrs - off; cur = val;
liveimage_srv/CImg.h:                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval>cur) cur = nval; }
liveimage_srv/CImg.h:                nptrs-=off; const T nval = *nptrs; if (nval>cur) { cur = nval; is_first = true; } else is_first = false;
liveimage_srv/CImg.h:              } else { if (val>=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
liveimage_srv/CImg.h:            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
liveimage_srv/CImg.h:            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
liveimage_srv/CImg.h:              const T val = *ptrs; ptrs-=off; if (val>cur) cur = val;
liveimage_srv/CImg.h:            *(ptrd--) = cur;
liveimage_srv/CImg.h:            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
liveimage_srv/CImg.h:              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val>cur) cur = val; *(ptrd--) = cur;
liveimage_srv/CImg.h:      if (sy>1 && _height>1) { // Along Y-axis
liveimage_srv/CImg.h:        const int L = height(), off = width(), s = (int)sy, _s1 = s/2, _s2 = s - _s1, s1 = _s1>L?L:_s1,
liveimage_srv/CImg.h:          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
liveimage_srv/CImg.h:          const T *const ptrsb = data(x,0,z,c), *ptrs = ptrsb, *const ptrse = ptrs + (ulongT)L*off - off;
liveimage_srv/CImg.h:          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
liveimage_srv/CImg.h:            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
liveimage_srv/CImg.h:            for (int p = L - s - 1; p>0; --p) {
liveimage_srv/CImg.h:                const T *nptrs = ptrs - off; cur = val;
liveimage_srv/CImg.h:                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval>cur) cur = nval; }
liveimage_srv/CImg.h:                nptrs-=off; const T nval = *nptrs; if (nval>cur) { cur = nval; is_first = true; } else is_first = false;
liveimage_srv/CImg.h:              } else { if (val>=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
liveimage_srv/CImg.h:            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
liveimage_srv/CImg.h:            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
liveimage_srv/CImg.h:              const T val = *ptrs; ptrs-=off; if (val>cur) cur = val;
liveimage_srv/CImg.h:            *(ptrd--) = cur;
liveimage_srv/CImg.h:            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
liveimage_srv/CImg.h:              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val>cur) cur = val; *(ptrd--) = cur;
liveimage_srv/CImg.h:      if (sz>1 && _depth>1) { // Along Z-axis
liveimage_srv/CImg.h:        const int L = depth(), off = width()*height(), s = (int)sz, _s1 = s/2, _s2 = s - _s1, s1 = _s1>L?L:_s1,
liveimage_srv/CImg.h:          T *const ptrdb = buf._data, *ptrd = ptrdb, *const ptrde = buf._data + L - 1;
liveimage_srv/CImg.h:          const T *const ptrsb = data(x,y,0,c), *ptrs = ptrsb, *const ptrse = ptrs + (ulongT)L*off - off;
liveimage_srv/CImg.h:          for (int p = s2 - 1; p>0 && ptrs<=ptrse; --p) {
liveimage_srv/CImg.h:            for (int p = s1; p>0 && ptrd<=ptrde; --p) {
liveimage_srv/CImg.h:            for (int p = L - s - 1; p>0; --p) {
liveimage_srv/CImg.h:                const T *nptrs = ptrs - off; cur = val;
liveimage_srv/CImg.h:                for (int q = s - 2; q>0; --q) { nptrs-=off; const T nval = *nptrs; if (nval>cur) cur = nval; }
liveimage_srv/CImg.h:                nptrs-=off; const T nval = *nptrs; if (nval>cur) { cur = nval; is_first = true; } else is_first = false;
liveimage_srv/CImg.h:              } else { if (val>=cur) cur = val; else if (cur==*(ptrs-s*off)) is_first = true; }
liveimage_srv/CImg.h:            ptrd = ptrde; ptrs = ptrse; cur = *ptrs; ptrs-=off;
liveimage_srv/CImg.h:            for (int p = s1; p>0 && ptrs>=ptrsb; --p) {
liveimage_srv/CImg.h:              const T val = *ptrs; ptrs-=off; if (val>cur) cur = val;
liveimage_srv/CImg.h:            *(ptrd--) = cur;
liveimage_srv/CImg.h:            for (int p = s2 - 1; p>0 && ptrd>=ptrdb; --p) {
liveimage_srv/CImg.h:              const T val = *ptrs; if (ptrs>ptrsb) ptrs-=off; if (val>cur) cur = val; *(ptrd--) = cur;
liveimage_srv/CImg.h:       \param is_real Do the closing in real (a.k.a 'non-flat') mode (\c true) rather than binary mode (\c false).
liveimage_srv/CImg.h:      const int sx1 = (int)(sx - 1)/2, sy1 = (int)(sy - 1)/2, sz1 = (int)(sz - 1)/2;
liveimage_srv/CImg.h:      const int sx1 = (int)(sx - 1)/2, sy1 = (int)(sy - 1)/2, sz1 = (int)(sz - 1)/2;
liveimage_srv/CImg.h:       \param is_real Do the opening in real (a.k.a 'non-flat') mode (\c true) rather than binary mode (\c false).
liveimage_srv/CImg.h:      const int sx1 = (int)(sx - 1)/2, sy1 = (int)(sy - 1)/2, sz1 = (int)(sz - 1)/2;
liveimage_srv/CImg.h:      const int sx1 = (int)(sx - 1)/2, sy1 = (int)(sy - 1)/2, sz1 = (int)(sz - 1)/2;
liveimage_srv/CImg.h:       \param is_high_connectivity Boolean that choose between 4(false)- or 8(true)-connectivity
liveimage_srv/CImg.h:       in 2D case, and between 6(false)- or 26(true)-connectivity in 3D case.
liveimage_srv/CImg.h:       \note Non-zero values of the instance instance are propagated to zero-valued ones according to
liveimage_srv/CImg.h:          ns = labels(X,Y,Z) - 1; xs = seeds(ns,0); ys = seeds(ns,1); zs = seeds(ns,2); \
liveimage_srv/CImg.h:          d = cimg::sqr((float)x - xs) + cimg::sqr((float)y - ys) + cimg::sqr((float)z - zs); \
liveimage_srv/CImg.h:        px = x - 1; nx = x + 1;
liveimage_srv/CImg.h:        py = y - 1; ny = y + 1;
liveimage_srv/CImg.h:        pz = z - 1; nz = z + 1;
liveimage_srv/CImg.h:        px = x - 1; nx = x + 1;
liveimage_srv/CImg.h:        py = y - 1; ny = y + 1;
liveimage_srv/CImg.h:        pz = z - 1; nz = z + 1;
liveimage_srv/CImg.h:      (*this)(siz - 1,0) = (T)value;
liveimage_srv/CImg.h:      (*this)(siz - 1,1) = (T)x;
liveimage_srv/CImg.h:      (*this)(siz - 1,2) = (T)y;
liveimage_srv/CImg.h:      (*this)(siz - 1,3) = (T)z;
liveimage_srv/CImg.h:      for (unsigned int pos = siz - 1, par = 0; pos && value>(tv)(*this)(par=(pos + 1)/2 - 1,0); pos = par) {
liveimage_srv/CImg.h:      (*this)(0,0) = (*this)(--siz,0);
liveimage_srv/CImg.h:       \param order Order of the filter. Can be <tt>{ 0=smooth-filter | 1=1st-derivative | 2=2nd-derivative }</tt>.
liveimage_srv/CImg.h:    const double yc = *(ptrY++) = (double)(a0*xc + a1*xp - b1*yp - b2*yb); \
liveimage_srv/CImg.h:  if (boundary_conditions) { xn = xa = *(ptrX - off); yn = ya = (double)coefn*xn; } \
liveimage_srv/CImg.h:  for (int n = N - 1; n>=0; --n) { \
liveimage_srv/CImg.h:    const T xc = *(ptrX-=off); \
liveimage_srv/CImg.h:    const double yc = (double)(a2*xn + a3*xa - b1*yn - b2*ya); \
liveimage_srv/CImg.h:    *ptrX = (T)(*(--ptrY)+yc); \
liveimage_srv/CImg.h:                                    "('order' can be { 0=smoothing | 1=1st-derivative | 2=2nd-derivative }).",
liveimage_srv/CImg.h:        nsigma = sigma>=0?sigma:-sigma*(naxis=='x'?_width:
liveimage_srv/CImg.h:                            deriche(nnsigma,order,naxis,1).columns(border,w - 1 + border));
liveimage_srv/CImg.h:                            deriche(nnsigma,order,naxis,1).rows(border,h - 1 + border));
liveimage_srv/CImg.h:                            deriche(nnsigma,order,naxis,1).slices(border,d - 1 + border));
liveimage_srv/CImg.h:                            deriche(nnsigma,order,naxis,1).channels(border,d - 1 + border));
liveimage_srv/CImg.h:        ema = std::exp(-alpha),
liveimage_srv/CImg.h:        ema2 = std::exp(-2*alpha),
liveimage_srv/CImg.h:        b1 = -2*ema,
liveimage_srv/CImg.h:        const double k = (1-ema)*(1-ema)/(1 + 2*alpha*ema-ema2);
liveimage_srv/CImg.h:        a1 = k*(alpha - 1)*ema;
liveimage_srv/CImg.h:        a3 = -k*ema2;
liveimage_srv/CImg.h:        const double k = -(1-ema)*(1-ema)*(1-ema)/(2*(ema + 1)*ema);
liveimage_srv/CImg.h:        a2 = -a1;
liveimage_srv/CImg.h:          ea = std::exp(-alpha),
liveimage_srv/CImg.h:          k = -(ema2 - 1)/(2*alpha*ema),
liveimage_srv/CImg.h:          kn = (-2*(-1 + 3*ea - 3*ea*ea + ea*ea*ea)/(3*ea + 1 + 3*ea*ea + ea*ea*ea));
liveimage_srv/CImg.h:        a1 = -kn*(1 + k*alpha)*ema;
liveimage_srv/CImg.h:        a2 = kn*(1 - k*alpha)*ema;
liveimage_srv/CImg.h:        a3 = -kn*ema2;
liveimage_srv/CImg.h:       \param filter the coefficient of the filter in the following order [n,n - 1,n - 2,n - 3].
liveimage_srv/CImg.h:      double val[4] = { 0 };  // res[n,n - 1,n - 2,n - 3,..] or res[n,n + 1,n + 2,n + 3,..]
liveimage_srv/CImg.h:        scaleM = 1. / ( (1. + a1 - a2 + a3) * (1. - a1 - a2 - a3) * (1. + a2 + (a1 - a3) * a3) );
liveimage_srv/CImg.h:      M[0] = scaleM * (-a3 * a1 + 1. - a3 * a3 - a2);
liveimage_srv/CImg.h:      M[4] = -scaleM * (a2 - 1.) * (a2 + a3 * a1);
liveimage_srv/CImg.h:      M[5] = -scaleM * a3 * (a3 * a1 + a3 * a3 + a2 - 1.);
liveimage_srv/CImg.h:      M[6] = scaleM * (a3 * a1 + a2 + a1 * a1 - a2 * a2);
liveimage_srv/CImg.h:      M[7] = scaleM * (a1 * a2 + a3 * a2 * a2 - a1 * a3 * a3 - a3 * a3 * a3 - a3 * a2 + a3);
liveimage_srv/CImg.h:        const double iplus = (boundary_conditions?data[(N - 1)*off]:(T)0);
liveimage_srv/CImg.h:              uplus = iplus/(1. - a1 - a2 - a3), vplus = uplus/(1. - a1 - a2 - a3),
liveimage_srv/CImg.h:              unp  = val[1] - uplus, unp1 = val[2] - uplus, unp2 = val[3] - uplus;
liveimage_srv/CImg.h:            data -= off;
liveimage_srv/CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
liveimage_srv/CImg.h:            if (!pass) data += off; else data -= off;
liveimage_srv/CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
liveimage_srv/CImg.h:          if (!pass) data -= off;
liveimage_srv/CImg.h:            data -= off;
liveimage_srv/CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
liveimage_srv/CImg.h:          for (int n = pass; n<N - 1; ++n) {
liveimage_srv/CImg.h:              val[0] = 0.5f * (x[0] - x[2]);
liveimage_srv/CImg.h:              for (int k = 2; k>0; --k) x[k] = x[k - 1];
liveimage_srv/CImg.h:            } else { data-=off;}
liveimage_srv/CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
liveimage_srv/CImg.h:            data -= off;
liveimage_srv/CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
liveimage_srv/CImg.h:          for (int n = pass; n<N - 1; ++n) {
liveimage_srv/CImg.h:            if (!pass) { x[0] = *(data + off); val[0] = (x[1] - x[2]); }
liveimage_srv/CImg.h:            else { x[0] = *(data - off); val[0] = (x[2] - x[1]) * sum; }
liveimage_srv/CImg.h:            if (!pass) data += off; else data -= off;
liveimage_srv/CImg.h:            for (int k = 2; k>0; --k) x[k] = x[k - 1];
liveimage_srv/CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
liveimage_srv/CImg.h:            data -= off;
liveimage_srv/CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
liveimage_srv/CImg.h:          for (int n = pass; n<N - 1; ++n) {
liveimage_srv/CImg.h:            if (!pass) { x[0] = *(data + off); val[0] = (x[0] - 2*x[1] + x[2]); }
liveimage_srv/CImg.h:            else { x[0] = *(data - off); val[0] = 0.5f * (x[2] - x[0]) * sum; }
liveimage_srv/CImg.h:            if (!pass) data += off; else data -= off;
liveimage_srv/CImg.h:            for (int k = 2; k>0; --k) x[k] = x[k - 1];
liveimage_srv/CImg.h:            for (int k = 3; k>0; --k) val[k] = val[k - 1];
liveimage_srv/CImg.h:       IEEE Trans. Sig. Proc., vol. 50, pp. 2799-2805, 2002.
liveimage_srv/CImg.h:       (this is an improvement over Young-Van Vliet, Sig. Proc. 44, 1995)
liveimage_srv/CImg.h:       B. Triggs and M. Sdika. Boundary conditions for Young-van Vliet
liveimage_srv/CImg.h:       vol. 54, pp. 2365-2367, 2006.
liveimage_srv/CImg.h:                                    "('order' can be { 0=smoothing | 1=1st-derivative | 2=2nd-derivative }).",
liveimage_srv/CImg.h:        nsigma = sigma>=0?sigma:-sigma*(naxis=='x'?_width:
liveimage_srv/CImg.h:                            vanvliet(nnsigma,order,naxis,1).columns(border,w - 1 + border));
liveimage_srv/CImg.h:                            vanvliet(nnsigma,order,naxis,1).rows(border,h - 1 + border));
liveimage_srv/CImg.h:                            vanvliet(nnsigma,order,naxis,1).slices(border,d - 1 + border));
liveimage_srv/CImg.h:                            vanvliet(nnsigma,order,naxis,1).channels(border,d - 1 + border));
liveimage_srv/CImg.h:        q = (nnsigma<3.556?-0.2568 + 0.5784*nnsigma + 0.0561*nnsigma*nnsigma:2.5091 + 0.9804*(nnsigma - 3.556)),
liveimage_srv/CImg.h:        b1 = -q * (2 * m0 * m1 + m1sq + m2sq + (2 * m0 + 4 * m1) * q + 3 * qsq) / scale,
liveimage_srv/CImg.h:        b3 = -qsq * q / scale,
liveimage_srv/CImg.h:      filter[0] = B; filter[1] = -b1; filter[2] = -b2; filter[3] = -b3;
liveimage_srv/CImg.h:       \param sigma_x Standard deviation of the blur, along the X-axis.
liveimage_srv/CImg.h:       \param sigma_y Standard deviation of the blur, along the Y-axis.
liveimage_srv/CImg.h:       \param sigma_z Standard deviation of the blur, along the Z-axis.
liveimage_srv/CImg.h:       \param is_gaussian Tells if the blur uses a gaussian (\c true) or quasi-gaussian (\c false) kernel.
liveimage_srv/CImg.h:       - The blur is computed as a 0-order Vanvliet (gaussian) or Deriche filter (quasi-gaussian).
liveimage_srv/CImg.h:       - This is a recursive algorithm, not depending on the values of the standard deviations.
liveimage_srv/CImg.h:       \param is_gaussian Use a gaussian kernel (VanVliet) is set, a quasi-gaussian (Deriche) otherwise.
liveimage_srv/CImg.h:      const float nsigma = sigma>=0?sigma:-sigma*cimg::max(_width,_height,_depth)/100;
liveimage_srv/CImg.h:         Can be <tt>{ 0=nearest-neighbor | 1=linear | 2=Runge-Kutta }</tt>.
liveimage_srv/CImg.h:      const float namplitude = amplitude>=0?amplitude:-amplitude*cimg::max(_width,_height,_depth)/100;
liveimage_srv/CImg.h:                  ixx = Incc + Ipcc - 2*Iccc,
liveimage_srv/CImg.h:                  ixy = (Innc + Ippc - Inpc - Ipnc)/4,
liveimage_srv/CImg.h:                  ixz = (Incn + Ipcp - Incp - Ipcn)/4,
liveimage_srv/CImg.h:                  iyy = Icnc + Icpc - 2*Iccc,
liveimage_srv/CImg.h:                  iyz = (Icnn + Icpp - Icnp - Icpn)/4,
liveimage_srv/CImg.h:                  izz = Iccn + Iccp - 2*Iccc,
liveimage_srv/CImg.h:                if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
liveimage_srv/CImg.h:                  ixx = Inc + Ipc - 2*Icc,
liveimage_srv/CImg.h:                  ixy = (Inn + Ipp - Inp - Ipn)/4,
liveimage_srv/CImg.h:                  iyy = Icn + Icp - 2*Icc,
liveimage_srv/CImg.h:                if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
liveimage_srv/CImg.h:      } else { // LIC-based smoothing
liveimage_srv/CImg.h:        const int dx1 = width() - 1, dy1 = height() - 1, dz1 = depth() - 1;
liveimage_srv/CImg.h:                  n = 1e-5f + cimg::hypot(u,v,w),
liveimage_srv/CImg.h:                        const float coef = (float)std::exp(-l*l/fsigma2);
liveimage_srv/CImg.h:                        const float coef = (float)std::exp(-l*l/fsigma2);
liveimage_srv/CImg.h:                        const float coef = (float)std::exp(-l*l/fsigma2);
liveimage_srv/CImg.h:                n = std::max(1e-5f,cimg::hypot(u,v)),
liveimage_srv/CImg.h:                case 0 : { // Nearest-neighbor
liveimage_srv/CImg.h:                      const float coef = (float)std::exp(-l*l/fsigma2);
liveimage_srv/CImg.h:                      const float coef = (float)std::exp(-l*l/fsigma2);
liveimage_srv/CImg.h:                default : { // 2nd-order Runge-kutta interpolation
liveimage_srv/CImg.h:                      const float coef = (float)std::exp(-l*l/fsigma2);
liveimage_srv/CImg.h:    //! Blur image anisotropically, in an edge-preserving way.
liveimage_srv/CImg.h:         Can be <tt>{ 0=nearest-neighbor | 1=linear | 2=Runge-Kutta }</tt>.
liveimage_srv/CImg.h:      const float nalpha = alpha>=0?alpha:-alpha*cimg::max(_width,_height,_depth)/100;
liveimage_srv/CImg.h:      const float nsigma = sigma>=0?sigma:-sigma*cimg::max(_width,_height,_depth)/100;
liveimage_srv/CImg.h:    //! Blur image anisotropically, in an edge-preserving way \newinstance.
liveimage_srv/CImg.h:       \param sigma_x Amount of blur along the X-axis.
liveimage_srv/CImg.h:       \param sigma_y Amount of blur along the Y-axis.
liveimage_srv/CImg.h:       \param sigma_z Amount of blur along the Z-axis.
liveimage_srv/CImg.h:       \param sampling_x Amount of downsampling along the X-axis used for the approximation.
liveimage_srv/CImg.h:       \param sampling_y Amount of downsampling along the Y-axis used for the approximation.
liveimage_srv/CImg.h:       \param sampling_z Amount of downsampling along the Z-axis used for the approximation.
liveimage_srv/CImg.h:        edge_delta = (float)(edge_max - edge_min),
liveimage_srv/CImg.h:        _sigma_x = sigma_x>=0?sigma_x:-sigma_x*_width/100,
liveimage_srv/CImg.h:        _sigma_y = sigma_y>=0?sigma_y:-sigma_y*_height/100,
liveimage_srv/CImg.h:        _sigma_z = sigma_z>=0?sigma_z:-sigma_z*_depth/100,
liveimage_srv/CImg.h:        _sigma_r = sigma_r>=0?sigma_r:-sigma_r*edge_delta/100,
liveimage_srv/CImg.h:        bx = (unsigned int)((_width  - 1)/_sampling_x + 1 + 2*padding_x),
liveimage_srv/CImg.h:        by = (unsigned int)((_height - 1)/_sampling_y + 1 + 2*padding_y),
liveimage_srv/CImg.h:        bz = (unsigned int)((_depth  - 1)/_sampling_z + 1 + 2*padding_z),
liveimage_srv/CImg.h:                R = (int)cimg::round((edge - edge_min)/_sampling_r) + padding_r;
liveimage_srv/CImg.h:                R = (edge - edge_min)/_sampling_r + padding_r;
liveimage_srv/CImg.h:                R = (int)cimg::round((edge - edge_min)/_sampling_r) + padding_r;
liveimage_srv/CImg.h:                R = (edge - edge_min)/_sampling_r + padding_r;
liveimage_srv/CImg.h:       \param sigma_s Amount of blur along the XYZ-axes.
liveimage_srv/CImg.h:       \param sampling_s Amount of downsampling along the XYZ-axes used for the approximation. Defaults to sigma_s.
liveimage_srv/CImg.h:      const float _sigma_s = sigma_s>=0?sigma_s:-sigma_s*cimg::max(_width,_height,_depth)/100;
liveimage_srv/CImg.h:        const int w2 = (int)(boxsize - 1)/2;
liveimage_srv/CImg.h:        const double frac = (boxsize - winsize)/2.;
liveimage_srv/CImg.h:          for (int x = -w2; x<=w2; ++x) {
liveimage_srv/CImg.h:            prev = __cimg_blur_box_apply(ptr,N,off,nboundary_conditions,-w2 - 1),
liveimage_srv/CImg.h:          for (int x = 0; x < N - 1; ++x) {
liveimage_srv/CImg.h:            sum-=prev;
liveimage_srv/CImg.h:          ptr[(N - 1)*off] = (T)(sum2/boxsize);
liveimage_srv/CImg.h:          p = __cimg_blur_box_apply(ptr,N,off,nboundary_conditions,-1),
liveimage_srv/CImg.h:        for (int x = 0; x<N - 1; ++x) {
liveimage_srv/CImg.h:          ptr[x*off] = (T)((n-p)/2.);
liveimage_srv/CImg.h:        ptr[(N - 1)*off] = (T)((n-p)/2.);
liveimage_srv/CImg.h:          p = __cimg_blur_box_apply(ptr,N,off,nboundary_conditions,-1),
liveimage_srv/CImg.h:        for (int x = 0; x<N - 1; ++x) {
liveimage_srv/CImg.h:          ptr[x*off] = (T)(n - 2*c + p);
liveimage_srv/CImg.h:        ptr[(N - 1)*off] = (T)(n - 2*c + p);
liveimage_srv/CImg.h:        const int nx = x<0?0:x>=N?N - 1:x;
liveimage_srv/CImg.h:          nx = tx<N?tx:N2 - tx - 1;
liveimage_srv/CImg.h:      const float nboxsize = boxsize>=0?boxsize:-boxsize*
liveimage_srv/CImg.h:       \param boxsize_x Size of the box window, along the X-axis (can be subpixel).
liveimage_srv/CImg.h:       \param boxsize_y Size of the box window, along the Y-axis (can be subpixel).
liveimage_srv/CImg.h:       \param boxsize_z Size of the box window, along the Z-axis (can be subpixel).
liveimage_srv/CImg.h:       - This is a recursive algorithm, not depending on the values of the box kernel size.
liveimage_srv/CImg.h:      const float nboxsize = boxsize>=0?boxsize:-boxsize*cimg::max(_width,_height,_depth)/100;
liveimage_srv/CImg.h:      const int _radius = radius>=0?(int)radius:(int)(-radius*cimg::max(_width,_height,_depth)/100);
liveimage_srv/CImg.h:        _regularization = -regularization*(edge_max - edge_min)/100;
liveimage_srv/CImg.h:        cov_Ip = get_mul(guide).blur_box(psize,true)-=mean_p.get_mul(mean_I),
liveimage_srv/CImg.h:        var_I = guide.get_sqr().blur_box(psize,true)-=mean_I.get_sqr(),
liveimage_srv/CImg.h:        &b = mean_p-=a.get_mul(mean_I);
liveimage_srv/CImg.h:    //! Blur image using patch-based space.
liveimage_srv/CImg.h:       \param sigma_s Amount of blur along the XYZ-axes.
liveimage_srv/CImg.h:    //! Blur image using patch-based space \newinstance.
liveimage_srv/CImg.h:        const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1, \
liveimage_srv/CImg.h:          if (cimg::abs(_guide(x,y,z,0) - _guide(p,q,r,0))<sigma_r3) { \
liveimage_srv/CImg.h:            pQ = Q._data; cimg_for(P,_pP,tfloat) { const tfloat dI = *_pP - *(pQ++); distance2+=dI*dI; } \
liveimage_srv/CImg.h:            const tfloat dx = (tfloat)p - x, dy = (tfloat)q - y, dz = (tfloat)r - z, \
liveimage_srv/CImg.h:        if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,z,c)/=(Tfloat)sum_weights; \
liveimage_srv/CImg.h:        const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1, \
liveimage_srv/CImg.h:          pQ = Q._data; cimg_for(P,_pP,tfloat) { const tfloat dI = *_pP - *(pQ++); distance2+=dI*dI; } \
liveimage_srv/CImg.h:          const tfloat dx = (tfloat)p - x, dy = (tfloat)q - y, dz = (tfloat)r - z, \
liveimage_srv/CImg.h:            alldist = distance2 + (dx*dx + dy*dy + dz*dz)/sigma_s2, weight = std::exp(-alldist); \
liveimage_srv/CImg.h:        if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,z,c)/=(Tfloat)sum_weights; \
liveimage_srv/CImg.h:          const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; \
liveimage_srv/CImg.h:            if (cimg::abs(_guide(x,y,0,0) - _guide(p,q,0,0))<sigma_r3) { \
liveimage_srv/CImg.h:              pQ = Q._data; cimg_for(P,_pP,tfloat) { const tfloat dI = *_pP - *(pQ++); distance2+=dI*dI; } \
liveimage_srv/CImg.h:              const tfloat dx = (tfloat)p - x, dy = (tfloat)q - y, \
liveimage_srv/CImg.h:          if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,c)/=(Tfloat)sum_weights; \
liveimage_srv/CImg.h:          const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2; \
liveimage_srv/CImg.h:            pQ = Q._data; cimg_for(P,_pP,tfloat) { const tfloat dI = *_pP - *(pQ++); distance2+=dI*dI; } \
liveimage_srv/CImg.h:            const tfloat dx = (tfloat)p - x, dy = (tfloat)q - y, \
liveimage_srv/CImg.h:              alldist = distance2 + (dx*dx+dy*dy)/sigma_s2, weight = std::exp(-alldist); \
liveimage_srv/CImg.h:          if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,c)/=(Tfloat)sum_weights; \
liveimage_srv/CImg.h:        guide_delta = (float)(guide_max - guide_min),
liveimage_srv/CImg.h:        _sigma_s = sigma_s>=0?sigma_s:-sigma_s*cimg::max(_width,_height,_depth)/100,
liveimage_srv/CImg.h:        _sigma_r = sigma_r>=0?sigma_r:-sigma_r*guide_delta/100,
liveimage_srv/CImg.h:      const int rsize2 = (int)lookup_size/2, rsize1 = (int)lookup_size - rsize2 - 1;
liveimage_srv/CImg.h:          const int psize2 = (int)patch_size/2, psize1 = (int)patch_size - psize2 - 1;
liveimage_srv/CImg.h:              P = _guide.get_crop(x - psize1,y - psize1,z - psize1,x + psize2,y + psize2,z + psize2,true);
liveimage_srv/CImg.h:              const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1,
liveimage_srv/CImg.h:                if (cimg::abs(_guide(x,y,z,0) - _guide(p,q,r,0))<sigma_r3) {
liveimage_srv/CImg.h:                  (Q = _guide.get_crop(p - psize1,q - psize1,r - psize1,p + psize2,q + psize2,r + psize2,true))-=P;
liveimage_srv/CImg.h:                    dx = (tfloat)x - p, dy = (tfloat)y - q, dz = (tfloat)z - r,
liveimage_srv/CImg.h:              if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,z,c)/=(Tfloat)sum_weights;
liveimage_srv/CImg.h:              P = _guide.get_crop(x - psize1,y - psize1,z - psize1,x + psize2,y + psize2,z + psize2,true);
liveimage_srv/CImg.h:              const int x0 = x - rsize1, y0 = y - rsize1, z0 = z - rsize1,
liveimage_srv/CImg.h:                (Q = _guide.get_crop(p - psize1,q - psize1,r - psize1,p + psize2,q + psize2,r + psize2,true))-=P;
liveimage_srv/CImg.h:                  dx = (tfloat)x - p, dy = (tfloat)y - q, dz = (tfloat)z - r,
liveimage_srv/CImg.h:                  weight = std::exp(-distance2);
liveimage_srv/CImg.h:              if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,z,c)/=(Tfloat)sum_weights;
liveimage_srv/CImg.h:          const int psize2 = (int)patch_size/2, psize1 = (int)patch_size - psize2 - 1;
liveimage_srv/CImg.h:              P = _guide.get_crop(x - psize1,y - psize1,x + psize2,y + psize2,true);
liveimage_srv/CImg.h:              const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2;
liveimage_srv/CImg.h:                if (cimg::abs(_guide(x,y,0) - _guide(p,q,0))<sigma_r3) {
liveimage_srv/CImg.h:                  (Q = _guide.get_crop(p - psize1,q - psize1,p + psize2,q + psize2,true))-=P;
liveimage_srv/CImg.h:                    dx = (tfloat)x - p, dy = (tfloat)y - q,
liveimage_srv/CImg.h:              if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,c)/=(Tfloat)sum_weights;
liveimage_srv/CImg.h:              P = _guide.get_crop(x - psize1,y - psize1,x + psize2,y + psize2,true);
liveimage_srv/CImg.h:              const int x0 = x - rsize1, y0 = y - rsize1, x1 = x + rsize2, y1 = y + rsize2;
liveimage_srv/CImg.h:                (Q = _guide.get_crop(p - psize1,q - psize1,p + psize2,q + psize2,true))-=P;
liveimage_srv/CImg.h:                  dx = (tfloat)x - p, dy = (tfloat)y - q,
liveimage_srv/CImg.h:                  weight = std::exp(-distance2);
liveimage_srv/CImg.h:              if (sum_weights>1e-10) cimg_forC(res,c) res(x,y,c)/=(Tfloat)sum_weights;
liveimage_srv/CImg.h:    //! Blur image using patch-based space \simplification.
liveimage_srv/CImg.h:    //! Blur image using patch-based space \simplification \newinstance.
liveimage_srv/CImg.h:      const int hr = (int)n/2, hl = n - hr - 1;
liveimage_srv/CImg.h:              x0 = x - hl, y0 = y - hl, z0 = z - hl, x1 = x + hr, y1 = y + hr, z1 = z + hr,
liveimage_srv/CImg.h:              nx1 = x1>=width()?width() - 1:x1, ny1 = y1>=height()?height() - 1:y1, nz1 = z1>=depth()?depth() - 1:z1;
liveimage_srv/CImg.h:              if (cimg::abs((*this)(p,q,r,c) - val0)<=threshold) { *(_ptrd++) = (*this)(p,q,r,c); ++nb_values; }
liveimage_srv/CImg.h:            res(x,y,z,c) = nb_values?values.get_shared_points(0,nb_values - 1).median():(*this)(x,y,z,c);
liveimage_srv/CImg.h:              x0 = x - hl, y0 = y - hl, z0 = z - hl, x1 = x + hr, y1 = y + hr, z1 = z + hr,
liveimage_srv/CImg.h:              nx1 = x1>=width()?width() - 1:x1, ny1 = y1>=height()?height() - 1:y1, nz1 = z1>=depth()?depth() - 1:z1;
liveimage_srv/CImg.h:              x0 = x - hl, y0 = y - hl, x1 = x + hr, y1 = y + hr,
liveimage_srv/CImg.h:                                        nx1 = x1>=width()?width() - 1:x1, ny1 = y1>=height()?height() - 1:y1;
liveimage_srv/CImg.h:              if (cimg::abs((*this)(p,q,c) - val0)<=threshold) { *(_ptrd++) = (*this)(p,q,c); ++nb_values; }
liveimage_srv/CImg.h:            res(x,y,c) = nb_values?values.get_shared_points(0,nb_values - 1).median():(*this)(x,y,c);
liveimage_srv/CImg.h:            w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:            w2 = width() - 2, h2 = height() - 2,
liveimage_srv/CImg.h:            w3 = width() - 3, h3 = height() - 3,
liveimage_srv/CImg.h:            w4 = width() - 4, h4 = height() - 4;
liveimage_srv/CImg.h:                res(x,y,c) = get_crop(std::max(0,x - 1),std::max(0,y - 1),0,c,
liveimage_srv/CImg.h:                res(x,y,c) = get_crop(std::max(0,x - 2),std::max(0,y - 2),0,c,
liveimage_srv/CImg.h:                res(x,y,c) = get_crop(std::max(0,x - 3),std::max(0,y - 3),0,c,
liveimage_srv/CImg.h:                x0 = x - hl, y0 = y - hl, x1 = x + hr, y1 = y + hr,
liveimage_srv/CImg.h:                                          nx1 = x1>=width()?width() - 1:x1, ny1 = y1>=height()?height() - 1:y1;
liveimage_srv/CImg.h:              *(ptrG3++) = 1 - (Tfloat)std::pow(1 + val[0] + val[1] + val[2],-(Tfloat)nedge);
liveimage_srv/CImg.h:                ixx = Incc + Ipcc - 2*Iccc,
liveimage_srv/CImg.h:                ixy = (Innc + Ippc - Inpc - Ipnc)/4,
liveimage_srv/CImg.h:                ixz = (Incn + Ipcp - Incp - Ipcn)/4,
liveimage_srv/CImg.h:                iyy = Icnc + Icpc - 2*Iccc,
liveimage_srv/CImg.h:                iyz = (Icnn + Icpp - Icnp - Icpn)/4,
liveimage_srv/CImg.h:                izz = Iccn + Iccp - 2*Iccc,
liveimage_srv/CImg.h:                ixf = Incc - Iccc,
liveimage_srv/CImg.h:                ixb = Iccc - Ipcc,
liveimage_srv/CImg.h:                iyf = Icnc - Iccc,
liveimage_srv/CImg.h:                iyb = Iccc - Icpc,
liveimage_srv/CImg.h:                izf = Iccn - Iccc,
liveimage_srv/CImg.h:                izb = Iccc - Iccp,
liveimage_srv/CImg.h:                veloc = -amp*cimg::sign(itt)*cimg::abs(it);
liveimage_srv/CImg.h:              if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
liveimage_srv/CImg.h:              const Tfloat veloc = -Ipcc - Incc - Icpc - Icnc - Iccp - Iccn + 6*Iccc;
liveimage_srv/CImg.h:              if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
liveimage_srv/CImg.h:              *(ptrG2++) = 1 - (Tfloat)std::pow(1 + val[0] + val[1],-(Tfloat)nedge);
liveimage_srv/CImg.h:                ixx = Inc + Ipc - 2*Icc,
liveimage_srv/CImg.h:                ixy = (Inn + Ipp - Inp - Ipn)/4,
liveimage_srv/CImg.h:                iyy = Icn + Icp - 2*Icc,
liveimage_srv/CImg.h:                ixf = Inc - Icc,
liveimage_srv/CImg.h:                ixb = Icc - Ipc,
liveimage_srv/CImg.h:                iyf = Icn - Icc,
liveimage_srv/CImg.h:                iyb = Icc - Icp,
liveimage_srv/CImg.h:                veloc = -amp*cimg::sign(itt)*cimg::abs(it);
liveimage_srv/CImg.h:              if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
liveimage_srv/CImg.h:              const Tfloat veloc = -Ipc - Inc - Icp - Icn + 4*Icc;
liveimage_srv/CImg.h:              if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
liveimage_srv/CImg.h:       \param axes Axes considered for the gradient computation, as a C-string (e.g "xy").
liveimage_srv/CImg.h:       - -1 = Backward finite differences
liveimage_srv/CImg.h:       - 0 = Centered finite differences (default)
liveimage_srv/CImg.h:       - 1 = Forward finite differences
liveimage_srv/CImg.h:       - 2 = Using Sobel kernels
liveimage_srv/CImg.h:       - 3 = Using rotation invariant kernels
liveimage_srv/CImg.h:       - 4 = Using Deriche recursive filter.
liveimage_srv/CImg.h:       - 5 = Using Van Vliet recursive filter.
liveimage_srv/CImg.h:        case -1 : { // Backward finite differences
liveimage_srv/CImg.h:              grad[pos] = (Tfloat)_data[pos] - _data[pos - off];
liveimage_srv/CImg.h:            if ((axis=='x' && x==width() - 1) || (axis=='y' && y==height() - 1) || (axis=='z' && z==depth() - 1))
liveimage_srv/CImg.h:              grad[pos] = (Tfloat)_data[pos + off] - _data[pos];
liveimage_srv/CImg.h:          if (axis=='x') // X-axis
liveimage_srv/CImg.h:              cimg_for3x3(*this,x,y,z,c,I,Tfloat) grad(x,y,z,c) = - Ipp + Inp - 2*Ipc + 2*Inc - Ipn + Inn;
liveimage_srv/CImg.h:          else // Y-axis
liveimage_srv/CImg.h:              cimg_for3x3(*this,x,y,z,c,I,Tfloat) grad(x,y,z,c) = - Ipp - 2*Icp - Inp + Ipn + 2*Icn + Inn;
liveimage_srv/CImg.h:          const Tfloat a = (Tfloat)(0.25f*(2 - std::sqrt(2.f))), b = (Tfloat)(0.5f*(std::sqrt(2.f) - 1));
liveimage_srv/CImg.h:          if (axis=='x') // X-axis
liveimage_srv/CImg.h:              cimg_for3x3(*this,x,y,z,c,I,Tfloat) grad(x,y,z,c) = -a*Ipp - b*Ipc - a*Ipn + a*Inp + b*Inc + a*Inn;
liveimage_srv/CImg.h:          else // Y-axis
liveimage_srv/CImg.h:              cimg_for3x3(*this,x,y,z,c,I,Tfloat) grad(x,y,z,c) = -a*Ipp - b*Icp - a*Inp + a*Ipn + b*Icn + a*Inn;
liveimage_srv/CImg.h:              grad[pos] = ((Tfloat)_data[pos + off] - _data[pos])/2;
liveimage_srv/CImg.h:            else if ((axis=='x' && x==width() - 1) || (axis=='y' && y==height() - 1) || (axis=='z' && z==depth() - 1))
liveimage_srv/CImg.h:              grad[pos] = ((Tfloat)_data[pos] - _data[pos - off])/2;
liveimage_srv/CImg.h:              grad[pos] = ((Tfloat)_data[pos + off] - _data[pos - off])/2;
liveimage_srv/CImg.h:       \param axes Axes considered for the hessian computation, as a C-string (e.g "xy").
liveimage_srv/CImg.h:              hess[pos] = (Tfloat)_data[pos + off] - _data[pos];
liveimage_srv/CImg.h:            else if ((axis1=='x' && x==width() - 1) ||
liveimage_srv/CImg.h:                     (axis1=='y' && y==height() - 1) ||
liveimage_srv/CImg.h:                     (axis1=='z' && z==depth() - 1))
liveimage_srv/CImg.h:              hess[pos] = (Tfloat)_data[pos - off] - _data[pos];
liveimage_srv/CImg.h:              hess[pos] = (Tfloat)_data[pos + off] + _data[pos - off] - 2*_data[pos];
liveimage_srv/CImg.h:            cimg_for3x3(*this,x,y,z,c,I,Tfloat) hess(x,y,z,c) = (Inn + Ipp - Inp - Ipn)/4;
liveimage_srv/CImg.h:            cimg_for3x3x3(*this,x,y,z,c,I,Tfloat) hess(x,y,z,c) = (Incn + Ipcp - Incp - Ipcn)/4;
liveimage_srv/CImg.h:            cimg_for3x3x3(*this,x,y,z,c,I,Tfloat) hess(x,y,z,c) = (Icnn + Icpp - Icnp - Icpn)/4;
liveimage_srv/CImg.h:          cimg_for3x3x3(*this,x,y,z,c,I,Tfloat) *(ptrd++) = Incc + Ipcc + Icnc + Icpc + Iccn + Iccp - 6*Iccc;
liveimage_srv/CImg.h:          cimg_for3x3(*this,x,y,0,c,I,Tfloat) *(ptrd++) = Inc + Ipc + Icn + Icp - 4*Icc;
liveimage_srv/CImg.h:          cimg_for3x3(*this,x,y,0,c,I,Tfloat) *(ptrd++) = Inc + Ipc - 2*Icc;
liveimage_srv/CImg.h:       \param is_fwbw_scheme scheme. Can be <tt>{ false=centered | true=forward-backward }</tt>
liveimage_srv/CImg.h:                ix = (Incc - Ipcc)/2,
liveimage_srv/CImg.h:                iy = (Icnc - Icpc)/2,
liveimage_srv/CImg.h:                iz = (Iccn - Iccp)/2;
liveimage_srv/CImg.h:                ixf = Incc - Iccc, ixb = Iccc - Ipcc, ixc = (Incc - Ipcc)/2,
liveimage_srv/CImg.h:                iyf = Icnc - Iccc, iyb = Iccc - Icpc, iyc = (Icnc - Icpc)/2,
liveimage_srv/CImg.h:                izf = Iccn - Iccc, izb = Iccc - Iccp, izc = (Iccn - Iccp)/2;
liveimage_srv/CImg.h:                ix = (Inc - Ipc)/2,
liveimage_srv/CImg.h:                iy = (Icn - Icp)/2;
liveimage_srv/CImg.h:                ixf = Inc - Icc, ixb = Icc - Ipc, ixc = (Inc - Ipc)/2,
liveimage_srv/CImg.h:                iyf = Icn - Icc, iyb = Icc - Icp, iyc = (Icn - Icp)/2;
liveimage_srv/CImg.h:    //! Compute field of diffusion tensors for edge-preserving smoothing.
liveimage_srv/CImg.h:        nsharpness = std::max(sharpness,1e-5f),
liveimage_srv/CImg.h:        power2 = power1/(1e-7f + 1 - anisotropy);
liveimage_srv/CImg.h:              n1 = (float)std::pow(1 + l1 + l2 + l3,-power1),
liveimage_srv/CImg.h:              n2 = (float)std::pow(1 + l1 + l2 + l3,-power2);
liveimage_srv/CImg.h:              n1 = (float)std::pow(1 + l1 + l2,-power1),
liveimage_srv/CImg.h:              n2 = (float)std::pow(1 + l1 + l2,-power2);
liveimage_srv/CImg.h:    //! Compute field of diffusion tensors for edge-preserving smoothing \newinstance.
liveimage_srv/CImg.h:       \param is_backward If false, match I2(X + U(X)) = I1(X), else match I2(X) = I1(X - U(X)).
liveimage_srv/CImg.h:      const float _precision = (float)std::pow(10.,-(double)precision);
liveimage_srv/CImg.h:      const float sdelta = sm==sM?1:(sM - sm), tdelta = tm==tM?1:(tM - tm);
liveimage_srv/CImg.h:      for (int scale = (int)_nb_scales - 1; scale>=0; --scale) {
liveimage_srv/CImg.h:          I1 = (source.get_resize(sw,sh,sd,-100,2)-=sm)/=sdelta,
liveimage_srv/CImg.h:          I2 = (get_resize(I1,2)-=tm)/=tdelta;
liveimage_srv/CImg.h:        if (guide._spectrum>constraint) guide.get_resize(I2._width,I2._height,I2._depth,-100,1).move_to(V);
liveimage_srv/CImg.h:        if (U) (U*=1.5f).resize(I2._width,I2._height,I2._depth,-100,3);
liveimage_srv/CImg.h:            guide.get_shared_channels(0,is_3d?2:1).get_resize(I2._width,I2._height,I2._depth,-100,2).move_to(U);
liveimage_srv/CImg.h:                  _p1y = y?y - 1:0, _n1y = y<U.height() - 1?y + 1:y,
liveimage_srv/CImg.h:                  _p1z = z?z - 1:0, _n1z = z<U.depth() - 1?z + 1:z;
liveimage_srv/CImg.h:                    X = is_backward?x - U(x,y,z,0):x + U(x,y,z,0),
liveimage_srv/CImg.h:                    Y = is_backward?y - U(x,y,z,1):y + U(x,y,z,1),
liveimage_srv/CImg.h:                    Z = is_backward?z - U(x,y,z,2):z + U(x,y,z,2);
liveimage_srv/CImg.h:                  if (is_backward) cimg_forC(I2,c) delta_I+=(float)(I1._linear_atXYZ(X,Y,Z,c) - I2(x,y,z,c));
liveimage_srv/CImg.h:                  else cimg_forC(I2,c) delta_I+=(float)(I1(x,y,z,c) - I2._linear_atXYZ(X,Y,Z,c));
liveimage_srv/CImg.h:                      Ux = 0.5f*(U(_n1x,y,z,c) - U(_p1x,y,z,c)),
liveimage_srv/CImg.h:                      Uy = 0.5f*(U(x,_n1y,z,c) - U(x,_p1y,z,c)),
liveimage_srv/CImg.h:                      Uz = 0.5f*(U(x,y,_n1z,c) - U(x,y,_p1z,c)),
liveimage_srv/CImg.h:                    bound = (float)x - _width; if (U(x,y,z,0)<=bound) U(x,y,z,0) = bound;
liveimage_srv/CImg.h:                    bound = (float)y - _height; if (U(x,y,z,1)<=bound) U(x,y,z,1) = bound;
liveimage_srv/CImg.h:                    bound = (float)z - _depth; if (U(x,y,z,2)<=bound) U(x,y,z,2) = bound;
liveimage_srv/CImg.h:                    if (U(x,y,z,0)<-x) U(x,y,z,0) = -(float)x;
liveimage_srv/CImg.h:                    if (U(x,y,z,1)<-y) U(x,y,z,1) = -(float)y;
liveimage_srv/CImg.h:                    if (U(x,y,z,2)<-z) U(x,y,z,2) = -(float)z;
liveimage_srv/CImg.h:                    bound = (float)_width - x; if (U(x,y,z,0)>=bound) U(x,y,z,0) = bound;
liveimage_srv/CImg.h:                    bound = (float)_height - y; if (U(x,y,z,1)>=bound) U(x,y,z,1) = bound;
liveimage_srv/CImg.h:                    bound = (float)_depth - z; if (U(x,y,z,2)>=bound) U(x,y,z,2) = bound;
liveimage_srv/CImg.h:              const float nsmoothness = -smoothness;
liveimage_srv/CImg.h:                  _p1y = y?y - 1:0, _n1y = y<U.height() - 1?y + 1:y,
liveimage_srv/CImg.h:                  _p1z = z?z - 1:0, _n1z = z<U.depth() - 1?z + 1:z;
liveimage_srv/CImg.h:                    X = is_backward?x - U(x,y,z,0):x + U(x,y,z,0),
liveimage_srv/CImg.h:                    Y = is_backward?y - U(x,y,z,1):y + U(x,y,z,1),
liveimage_srv/CImg.h:                    Z = is_backward?z - U(x,y,z,2):z + U(x,y,z,2);
liveimage_srv/CImg.h:                  if (is_backward) cimg_forC(I2,c) delta_I+=(float)(I1._linear_atXYZ(X,Y,Z,c) - I2(x,y,z,c));
liveimage_srv/CImg.h:                  else cimg_forC(I2,c) delta_I+=(float)(I1(x,y,z,c) - I2._linear_atXYZ(X,Y,Z,c));
liveimage_srv/CImg.h:                      Ux = 0.5f*(U(_n1x,y,z,c) - U(_p1x,y,z,c)),
liveimage_srv/CImg.h:                      Uy = 0.5f*(U(x,_n1y,z,c) - U(x,_p1y,z,c)),
liveimage_srv/CImg.h:                      Uz = 0.5f*(U(x,y,_n1z,c) - U(x,y,_p1z,c)),
liveimage_srv/CImg.h:                      N3 = 1e-5f + N2*N,
liveimage_srv/CImg.h:                      coef_a = (1 - Ux*Ux/N2)/N,
liveimage_srv/CImg.h:                      coef_b = -2*Ux*Uy/N3,
liveimage_srv/CImg.h:                      coef_c = -2*Ux*Uz/N3,
liveimage_srv/CImg.h:                      coef_d = (1 - Uy*Uy/N2)/N,
liveimage_srv/CImg.h:                      coef_e = -2*Uy*Uz/N3,
liveimage_srv/CImg.h:                      coef_f = (1 - Uz*Uz/N2)/N,
liveimage_srv/CImg.h:                      Uxy = 0.25f*(U(_n1x,_n1y,z,c) + U(_p1x,_p1y,z,c) - U(_n1x,_p1y,z,c) - U(_n1x,_p1y,z,c)),
liveimage_srv/CImg.h:                      Uxz = 0.25f*(U(_n1x,y,_n1z,c) + U(_p1x,y,_p1z,c) - U(_n1x,y,_p1z,c) - U(_n1x,y,_p1z,c)),
liveimage_srv/CImg.h:                      Uyz = 0.25f*(U(x,_n1y,_n1z,c) + U(x,_p1y,_p1z,c) - U(x,_n1y,_p1z,c) - U(x,_n1y,_p1z,c));
liveimage_srv/CImg.h:                    bound = (float)x - _width; if (U(x,y,z,0)<=bound) U(x,y,z,0) = bound;
liveimage_srv/CImg.h:                    bound = (float)y - _height; if (U(x,y,z,1)<=bound) U(x,y,z,1) = bound;
liveimage_srv/CImg.h:                    bound = (float)z - _depth; if (U(x,y,z,2)<=bound) U(x,y,z,2) = bound;
liveimage_srv/CImg.h:                    if (U(x,y,z,0)<-x) U(x,y,z,0) = -(float)x;
liveimage_srv/CImg.h:                    if (U(x,y,z,1)<-y) U(x,y,z,1) = -(float)y;
liveimage_srv/CImg.h:                    if (U(x,y,z,2)<-z) U(x,y,z,2) = -(float)z;
liveimage_srv/CImg.h:                    bound = (float)_width - x; if (U(x,y,z,0)>=bound) U(x,y,z,0) = bound;
liveimage_srv/CImg.h:                    bound = (float)_height - y; if (U(x,y,z,1)>=bound) U(x,y,z,1) = bound;
liveimage_srv/CImg.h:                    bound = (float)_depth - z; if (U(x,y,z,2)>=bound) U(x,y,z,2) = bound;
liveimage_srv/CImg.h:                const int _p1y = y?y - 1:0, _n1y = y<U.height() - 1?y + 1:y;
liveimage_srv/CImg.h:                    X = is_backward?x - U(x,y,0):x + U(x,y,0),
liveimage_srv/CImg.h:                    Y = is_backward?y - U(x,y,1):y + U(x,y,1);
liveimage_srv/CImg.h:                  if (is_backward) cimg_forC(I2,c) delta_I+=(float)(I1._linear_atXY(X,Y,c) - I2(x,y,c));
liveimage_srv/CImg.h:                  else cimg_forC(I2,c) delta_I+=(float)(I1(x,y,c) - I2._linear_atXY(X,Y,c));
liveimage_srv/CImg.h:                      Ux = 0.5f*(U(_n1x,y,c) - U(_p1x,y,c)),
liveimage_srv/CImg.h:                      Uy = 0.5f*(U(x,_n1y,c) - U(x,_p1y,c)),
liveimage_srv/CImg.h:                    bound = (float)x - _width; if (U(x,y,0)<=bound) U(x,y,0) = bound;
liveimage_srv/CImg.h:                    bound = (float)y - _height; if (U(x,y,1)<=bound) U(x,y,1) = bound;
liveimage_srv/CImg.h:                    if (U(x,y,0)<-x) U(x,y,0) = -(float)x;
liveimage_srv/CImg.h:                    if (U(x,y,1)<-y) U(x,y,1) = -(float)y;
liveimage_srv/CImg.h:                    bound = (float)_width - x; if (U(x,y,0)>=bound) U(x,y,0) = bound;
liveimage_srv/CImg.h:                    bound = (float)_height - y; if (U(x,y,1)>=bound) U(x,y,1) = bound;
liveimage_srv/CImg.h:              const float nsmoothness = -smoothness;
liveimage_srv/CImg.h:                const int _p1y = y?y - 1:0, _n1y = y<U.height() - 1?y + 1:y;
liveimage_srv/CImg.h:                    X = is_backward?x - U(x,y,0):x + U(x,y,0),
liveimage_srv/CImg.h:                    Y = is_backward?y - U(x,y,1):y + U(x,y,1);
liveimage_srv/CImg.h:                  if (is_backward) cimg_forC(I2,c) delta_I+=(float)(I1._linear_atXY(X,Y,c) - I2(x,y,c));
liveimage_srv/CImg.h:                  else cimg_forC(I2,c) delta_I+=(float)(I1(x,y,c) - I2._linear_atXY(X,Y,c));
liveimage_srv/CImg.h:                      Ux = 0.5f*(U(_n1x,y,c) - U(_p1x,y,c)),
liveimage_srv/CImg.h:                      Uy = 0.5f*(U(x,_n1y,c) - U(x,_p1y,c)),
liveimage_srv/CImg.h:                      N3 = 1e-5f + N2*N,
liveimage_srv/CImg.h:                      coef_b = -2*Ux*Uy/N3,
liveimage_srv/CImg.h:                      Uxy = 0.25f*(U(_n1x,_n1y,c) + U(_p1x,_p1y,c) - U(_n1x,_p1y,c) - U(_n1x,_p1y,c));
liveimage_srv/CImg.h:                    bound = (float)x - _width; if (U(x,y,0)<=bound) U(x,y,0) = bound;
liveimage_srv/CImg.h:                    bound = (float)y - _height; if (U(x,y,1)<=bound) U(x,y,1) = bound;
liveimage_srv/CImg.h:                    if (U(x,y,0)<-x) U(x,y,0) = -(float)x;
liveimage_srv/CImg.h:                    if (U(x,y,1)<-y) U(x,y,1) = -(float)y;
liveimage_srv/CImg.h:                    bound = (float)_width - x; if (U(x,y,0)>=bound) U(x,y,0) = bound;
liveimage_srv/CImg.h:                    bound = (float)_height - y; if (U(x,y,1)>=bound) U(x,y,1) = bound;
liveimage_srv/CImg.h:          const float d_energy = (_energy - energy)/(sw*sh*sd);
liveimage_srv/CImg.h:          if (d_energy<=0 && -d_energy<_precision) break;
liveimage_srv/CImg.h:    //! Compute correspondence map between two images, using a patch-matching algorithm.
liveimage_srv/CImg.h:        \param nb_iterations Number of patch-match iterations.
liveimage_srv/CImg.h:    //! Compute correspondence map between two images, using the patch-match algorithm \newinstance.
liveimage_srv/CImg.h:    //! Compute correspondence map between two images, using the patch-match algorithm \overloading.
liveimage_srv/CImg.h:    //! Compute correspondence map between two images, using the patch-match algorithm \overloading.
liveimage_srv/CImg.h:        psizew = (int)patch_width,  psizew1 = psizew/2, psizew2 = psizew - psizew1 - 1,
liveimage_srv/CImg.h:        psizeh = (int)patch_height, psizeh1 = psizeh/2, psizeh2 = psizeh - psizeh1 - 1,
liveimage_srv/CImg.h:        psized = (int)patch_depth,  psized1 = psized/2, psized2 = psized - psized1 - 1;
liveimage_srv/CImg.h:      // Interleave image buffers to speed up patch comparison (more cache-friendly).
liveimage_srv/CImg.h:            cimg_forXYZ(*this,x,y,z) { // User-defined initialization
liveimage_srv/CImg.h:              cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),  cx2 = psizew - cx1 - 1,
liveimage_srv/CImg.h:              cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()), cy2 = psizeh - cy1 - 1,
liveimage_srv/CImg.h:              cz1 = z<=psized1?z:(z<depth()  - psized2?psized1:psized + z - depth()),  cz2 = psized - cz1 - 1,
liveimage_srv/CImg.h:              u = cimg::cut((int)guide(x,y,z,0),cx1,patch_image.width() - 1 - cx2),
liveimage_srv/CImg.h:              v = cimg::cut((int)guide(x,y,z,1),cy1,patch_image.height() - 1 - cy2),
liveimage_srv/CImg.h:              w = cimg::cut((int)guide(x,y,z,2),cz1,patch_image.depth() - 1 - cz2);
liveimage_srv/CImg.h:                                       x - cx1,y - cy1,z - cz1,
liveimage_srv/CImg.h:                                       u - cx1,v - cy1,w - cz1,
liveimage_srv/CImg.h:                cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),  cx2 = psizew - cx1 - 1,
liveimage_srv/CImg.h:                cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()), cy2 = psizeh - cy1 - 1,
liveimage_srv/CImg.h:                cz1 = z<=psized1?z:(z<depth()  - psized2?psized1:psized + z - depth()),  cz2 = psized - cz1 - 1,
liveimage_srv/CImg.h:                u = (int)cimg::round(cimg::rand(cx1,patch_image.width() - 1 - cx2,&rng)),
liveimage_srv/CImg.h:                v = (int)cimg::round(cimg::rand(cy1,patch_image.height() - 1 - cy2,&rng)),
liveimage_srv/CImg.h:                w = (int)cimg::round(cimg::rand(cz1,patch_image.depth() - 1 - cz2,&rng));
liveimage_srv/CImg.h:                                         x - cx1,y - cy1,z - cz1,
liveimage_srv/CImg.h:                                         u - cx1,v - cy1,w - cz1,
liveimage_srv/CImg.h:          const unsigned int cmask = is_backward?1:2, nmask = 3 - cmask;
liveimage_srv/CImg.h:                x = is_backward?width() - 1 - X:X,
liveimage_srv/CImg.h:                y = is_backward?height() - 1 - Y:Y,
liveimage_srv/CImg.h:                z = is_backward?depth() - 1 - Z:Z;
liveimage_srv/CImg.h:              if (score(x,y,z)<=1e-5 || (constraint && guide(x,y,z,constraint)!=0)) continue;
liveimage_srv/CImg.h:                cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),  cx2 = psizew - cx1 - 1,
liveimage_srv/CImg.h:                cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()), cy2 = psizeh - cy1 - 1,
liveimage_srv/CImg.h:                cz1 = z<=psized1?z:(z<depth()  - psized2?psized1:psized + z - depth()),  cz2 = psized - cz1 - 1,
liveimage_srv/CImg.h:                xp = x - cx1,
liveimage_srv/CImg.h:                yp = y - cy1,
liveimage_srv/CImg.h:                zp = z - cz1;
liveimage_srv/CImg.h:              if (is_forward && x>0 && (is_updated(x - 1,y,z)&cmask)) { // Compare with left neighbor
liveimage_srv/CImg.h:                u = a_map(x - 1,y,z,0);
liveimage_srv/CImg.h:                v = a_map(x - 1,y,z,1);
liveimage_srv/CImg.h:                w = a_map(x - 1,y,z,2);
liveimage_srv/CImg.h:                if (u>=cx1 - 1 && u<patch_image.width() - 1 - cx2 &&
liveimage_srv/CImg.h:                    v>=cy1 && v<patch_image.height() - cy2 &&
liveimage_srv/CImg.h:                    w>=cz1 && w<patch_image.depth() - cz2) {
liveimage_srv/CImg.h:                                  xp,yp,zp,u + 1 - cx1,v - cy1,w - cz1,
liveimage_srv/CImg.h:              if (is_forward && y>0 && (is_updated(x,y - 1,z)&cmask)) { // Compare with up neighbor
liveimage_srv/CImg.h:                u = a_map(x,y - 1,z,0);
liveimage_srv/CImg.h:                v = a_map(x,y - 1,z,1);
liveimage_srv/CImg.h:                w = a_map(x,y - 1,z,2);
liveimage_srv/CImg.h:                if (u>=cx1 && u<patch_image.width() - cx2 &&
liveimage_srv/CImg.h:                    v>=cy1 - 1 && v<patch_image.height() - 1 - cy2 &&
liveimage_srv/CImg.h:                    w>=cz1 && w<patch_image.depth() - cz2) {
liveimage_srv/CImg.h:                                  xp,yp,zp,u - cx1,v + 1 - cy1,w - cz1,
liveimage_srv/CImg.h:              if (is_forward && z>0 && (is_updated(x,y,z - 1)&cmask)) { // Compare with backward neighbor
liveimage_srv/CImg.h:                u = a_map(x,y,z - 1,0);
liveimage_srv/CImg.h:                v = a_map(x,y,z - 1,1);
liveimage_srv/CImg.h:                w = a_map(x,y,z - 1,2);
liveimage_srv/CImg.h:                if (u>=cx1 && u<patch_image.width() - cx2 &&
liveimage_srv/CImg.h:                    v>=cy1 && v<patch_image.height() - cy2 &&
liveimage_srv/CImg.h:                    w>=cz1 - 1 && w<patch_image.depth() - 1 - cz2) {
liveimage_srv/CImg.h:                                  xp,yp,zp,u - cx1,v - cy1,w + 1 - cz1,
liveimage_srv/CImg.h:              if (is_backward && x<width() - 1 && (is_updated(x + 1,y,z)&cmask)) { // Compare with right neighbor
liveimage_srv/CImg.h:                if (u>=cx1 + 1 && u<patch_image.width() + 1 - cx2 &&
liveimage_srv/CImg.h:                    v>=cy1 && v<patch_image.height() - cy2 &&
liveimage_srv/CImg.h:                    w>=cz1 && w<patch_image.depth() - cz2) {
liveimage_srv/CImg.h:                                  xp,yp,zp,u - 1 - cx1,v - cy1,w - cz1,
liveimage_srv/CImg.h:                  if (s<best_score) { best_u = u - 1; best_v = v; best_w = w; best_score = s; }
liveimage_srv/CImg.h:              if (is_backward && y<height() - 1 && (is_updated(x,y + 1,z)&cmask)) { // Compare with bottom neighbor
liveimage_srv/CImg.h:                if (u>=cx1 && u<patch_image.width() - cx2 &&
liveimage_srv/CImg.h:                    v>=cy1 + 1 && v<patch_image.height() + 1 - cy2 &&
liveimage_srv/CImg.h:                    w>=cz1 && w<patch_image.depth() - cz2) {
liveimage_srv/CImg.h:                                  xp,yp,zp,u - cx1,v - 1 - cy1,w - cz1,
liveimage_srv/CImg.h:                  if (s<best_score) { best_u = u; best_v = v - 1; best_w = w; best_score = s; }
liveimage_srv/CImg.h:              if (is_backward && z<depth() - 1 && (is_updated(x,y,z + 1)&cmask)) { // Compare with forward neighbor
liveimage_srv/CImg.h:                if (u>=cx1 && u<patch_image.width() - cx2 &&
liveimage_srv/CImg.h:                    v>=cy1 && v<patch_image.height() - cy2 &&
liveimage_srv/CImg.h:                    w>=cz1 + 1 && w<patch_image.depth() + 1 - cz2) {
liveimage_srv/CImg.h:                                  xp,yp,zp,u - cx1,v - cy1,w - 1 - cz1,
liveimage_srv/CImg.h:                  if (s<best_score) { best_u = u; best_v = v; best_w = w - 1; best_score = s; }
liveimage_srv/CImg.h:                u = (int)cimg::round(cimg::rand(std::max((float)cx1,best_u - dw),
liveimage_srv/CImg.h:                                                std::min(patch_image.width() - 1.f - cx2,best_u + dw),&rng));
liveimage_srv/CImg.h:                v = (int)cimg::round(cimg::rand(std::max((float)cy1,best_v - dh),
liveimage_srv/CImg.h:                                                std::min(patch_image.height() - 1.f - cy2,best_v + dh),&rng));
liveimage_srv/CImg.h:                w = (int)cimg::round(cimg::rand(std::max((float)cz1,best_w - dd),
liveimage_srv/CImg.h:                                                std::min(patch_image.depth() - 1.f - cz2,best_w + dd),&rng));
liveimage_srv/CImg.h:                                  xp,yp,zp,u - cx1,v - cy1,w - cz1,
liveimage_srv/CImg.h:                  if (p_penalty) cimg_pragma_openmp(atomic) --p_penalty;
liveimage_srv/CImg.h:                cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),
liveimage_srv/CImg.h:                cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()),
liveimage_srv/CImg.h:                cz1 = z<=psized1?z:(z<depth()  - psized2?psized1:psized + z - depth()),
liveimage_srv/CImg.h:                xp = x - cx1,
liveimage_srv/CImg.h:                yp = y - cy1,
liveimage_srv/CImg.h:                zp = z - cz1,
liveimage_srv/CImg.h:                                                xp,yp,zp,u - cx1,v - cy1,w - cz1,
liveimage_srv/CImg.h:            cimg_forXY(*this,x,y) { // User-defined initialization
liveimage_srv/CImg.h:              cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),  cx2 = psizew - cx1 - 1,
liveimage_srv/CImg.h:              cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()), cy2 = psizeh - cy1 - 1,
liveimage_srv/CImg.h:              u = cimg::cut((int)guide(x,y,0),cx1,patch_image.width() - 1 - cx2),
liveimage_srv/CImg.h:              v = cimg::cut((int)guide(x,y,1),cy1,patch_image.height() - 1 - cy2);
liveimage_srv/CImg.h:                                     x - cx1,y - cy1,u - cx1,v - cy1,
liveimage_srv/CImg.h:                cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),  cx2 = psizew - cx1 - 1,
liveimage_srv/CImg.h:                cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()), cy2 = psizeh - cy1 - 1,
liveimage_srv/CImg.h:                u = (int)cimg::round(cimg::rand(cx1,patch_image.width() - 1 - cx2,&rng)),
liveimage_srv/CImg.h:                v = (int)cimg::round(cimg::rand(cy1,patch_image.height() - 1 - cy2,&rng));
liveimage_srv/CImg.h:                                       x - cx1,y - cy1,u - cx1,v - cy1,
liveimage_srv/CImg.h:          const unsigned int cmask = is_backward?1:2, nmask = 3 - cmask;
liveimage_srv/CImg.h:                x = is_backward?width() - 1 - X:X,
liveimage_srv/CImg.h:                y = is_backward?height() - 1 - Y:Y;
liveimage_srv/CImg.h:              if (score(x,y)<=1e-5 || (constraint && guide(x,y,constraint)!=0)) continue;
liveimage_srv/CImg.h:                cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),  cx2 = psizew - cx1 - 1,
liveimage_srv/CImg.h:                cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()), cy2 = psizeh - cy1 - 1,
liveimage_srv/CImg.h:                xp = x - cx1,
liveimage_srv/CImg.h:                yp = y - cy1;
liveimage_srv/CImg.h:              if (is_forward && x>0 && (is_updated(x - 1,y)&cmask)) { // Compare with left neighbor
liveimage_srv/CImg.h:                u = a_map(x - 1,y,0);
liveimage_srv/CImg.h:                v = a_map(x - 1,y,1);
liveimage_srv/CImg.h:                if (u>=cx1 - 1 && u<patch_image.width() - 1 - cx2 &&
liveimage_srv/CImg.h:                    v>=cy1 && v<patch_image.height() - cy2) {
liveimage_srv/CImg.h:                                  xp,yp,u + 1 - cx1,v - cy1,
liveimage_srv/CImg.h:              if (is_forward && y>0 && (is_updated(x,y - 1)&cmask)) { // Compare with up neighbor
liveimage_srv/CImg.h:                u = a_map(x,y - 1,0);
liveimage_srv/CImg.h:                v = a_map(x,y - 1,1);
liveimage_srv/CImg.h:                if (u>=cx1 && u<patch_image.width() - cx2 &&
liveimage_srv/CImg.h:                    v>=cy1 - 1 && v<patch_image.height() - 1 - cy2) {
liveimage_srv/CImg.h:                                  xp,yp,u - cx1,v + 1 - cy1,
liveimage_srv/CImg.h:              if (is_backward && x<width() - 1 && (is_updated(x + 1,y)&cmask)) { // Compare with right neighbor
liveimage_srv/CImg.h:                if (u>=cx1 + 1 && u<patch_image.width() + 1 - cx2 &&
liveimage_srv/CImg.h:                    v>=cy1 && v<patch_image.height() - cy2) {
liveimage_srv/CImg.h:                                  xp,yp,u - 1 - cx1,v - cy1,
liveimage_srv/CImg.h:                  if (s<best_score) { best_u = u - 1; best_v = v; best_score = s; }
liveimage_srv/CImg.h:              if (is_backward && y<height() - 1 && (is_updated(x,y + 1)&cmask)) { // Compare with bottom neighbor
liveimage_srv/CImg.h:                if (u>=cx1 && u<patch_image.width() - cx2 &&
liveimage_srv/CImg.h:                    v>=cy1 + 1 && v<patch_image.height() + 1 - cy2) {
liveimage_srv/CImg.h:                                  xp,yp,u - cx1,v - 1 - cy1,
liveimage_srv/CImg.h:                  if (s<best_score) { best_u = u; best_v = v - 1; best_score = s; }
liveimage_srv/CImg.h:                u = (int)cimg::round(cimg::rand(std::max((float)cx1,best_u - dw),
liveimage_srv/CImg.h:                                                std::min(patch_image.width() - 1.f - cx2,best_u + dw),&rng));
liveimage_srv/CImg.h:                v = (int)cimg::round(cimg::rand(std::max((float)cy1,best_v - dh),
liveimage_srv/CImg.h:                                                std::min(patch_image.height() - 1.f - cy2,best_v + dh),&rng));
liveimage_srv/CImg.h:                                  xp,yp,u - cx1,v - cy1,
liveimage_srv/CImg.h:                  if (p_penalty) cimg_pragma_openmp(atomic) --p_penalty;
liveimage_srv/CImg.h:                cx1 = x<=psizew1?x:(x<width()  - psizew2?psizew1:psizew + x - width()),
liveimage_srv/CImg.h:                cy1 = y<=psizeh1?y:(y<height() - psizeh2?psizeh1:psizeh + y - height()),
liveimage_srv/CImg.h:                xp = x - cx1,
liveimage_srv/CImg.h:                yp = y - cy1,
liveimage_srv/CImg.h:                                                xp,yp,u - cx1,v - cy1,
liveimage_srv/CImg.h:      if (!allow_identity && cimg::hypot((float)x1 - x2,(float)y1 - y2,(float)z1 - z2)<patch_penalization)
liveimage_srv/CImg.h:        offx1 = (ulongT)img1._width - psizewc,
liveimage_srv/CImg.h:        offx2 = (ulongT)img2._width - psizewc,
liveimage_srv/CImg.h:        offy1 = (ulongT)img1._width*img1._height - (ulongT)psizeh*img1._width,
liveimage_srv/CImg.h:        offy2 = (ulongT)img2._width*img2._height - (ulongT)psizeh*img2._width;
liveimage_srv/CImg.h:            ssd += cimg::sqr((Tfloat)*(p1++) - *(p2++));
liveimage_srv/CImg.h:      if (!allow_identity && cimg::hypot((float)x1-x2,(float)y1-y2)<patch_penalization)
liveimage_srv/CImg.h:        offx1 = (ulongT)img1._width - psizewc,
liveimage_srv/CImg.h:        offx2 = (ulongT)img2._width - psizewc;
liveimage_srv/CImg.h:          ssd += cimg::sqr((Tfloat)*(p1++) - *(p2++));
liveimage_srv/CImg.h:        \param metric Type of metric. Can be <tt>{ 0=Chebyshev | 1=Manhattan | 2=Euclidean | 3=Squared-euclidean }</tt>.
liveimage_srv/CImg.h:                     J. Goutsias, L. Vincent, and D.S. Bloomberg (eds.), Kluwer, 2000, pp. 331-340.'
liveimage_srv/CImg.h:      return (u*u - i*i + g[u] - g[i])/(2*(u - i));
liveimage_srv/CImg.h:      return (x - i)*(x - i) + g[i];
liveimage_srv/CImg.h:      return (u - i<=g[u] - g[i]?999999999:(g[u] - g[i] + u + i)/2);
liveimage_srv/CImg.h:      return (x<i?i - x:x - i) + g[i];
liveimage_srv/CImg.h:      return h<u - g[i]?h:u - g[i];
liveimage_srv/CImg.h:      const longT d = x<i?i - x:x - i;
liveimage_srv/CImg.h:        while ((q>=0) && f(t[q],s[q],g)>f(t[q],u,g)) { --q; }
liveimage_srv/CImg.h:      for (int u = (int)len - 1; u>=0; --u) { dt[u] = f(u,s[q],g); if (u==t[q]) --q; } // Backward scan
liveimage_srv/CImg.h:        cimg_forYZ(*this,y,z) { // Over X-direction
liveimage_srv/CImg.h:          cimg_forXZ(*this,x,z) { // Over Y-direction
liveimage_srv/CImg.h:          cimg_forXY(*this,x,y) { // Over Z-direction
liveimage_srv/CImg.h:            for (int z = depth() - 1 - dz, nz = depth() - 1; z>=0; --z,--nz) { // Backward scan
liveimage_srv/CImg.h:              for (int y = height() - 1 - dy, ny = height() - 1; y>=0; --y,--ny) {
liveimage_srv/CImg.h:                for (int x = width() - 1 - dx, nx = width() - 1; x>=0; --x,--nx) {
liveimage_srv/CImg.h:          const td P = (td)-Q(0,0);
liveimage_srv/CImg.h:          if (x - 1>=0 && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x - 1,y,z) + P),x - 1,y,z)) {
liveimage_srv/CImg.h:            res(x - 1,y,z) = npot; if (path) path(x - 1,y,z) = (to)2;
liveimage_srv/CImg.h:          if (x + 1<width() && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x + 1,y,z) + P),x + 1,y,z)) {
liveimage_srv/CImg.h:          if (y - 1>=0 && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x,y - 1,z) + P),x,y - 1,z)) {
liveimage_srv/CImg.h:            res(x,y - 1,z) = npot; if (path) path(x,y - 1,z) = (to)8;
liveimage_srv/CImg.h:          if (y + 1<height() && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x,y + 1,z) + P),x,y + 1,z)) {
liveimage_srv/CImg.h:          if (z - 1>=0 && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x,y,z - 1) + P),x,y,z - 1)) {
liveimage_srv/CImg.h:            res(x,y,z - 1) = npot; if (path) path(x,y,z - 1) = (to)32;
liveimage_srv/CImg.h:          if (z + 1<depth() && Q._priority_queue_insert(is_queued,sizeQ,-(npot=met(x,y,z + 1) + P),x,y,z + 1)) {
liveimage_srv/CImg.h:            if (x - 1>=0 && y - 1>=0 &&
liveimage_srv/CImg.h:                Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x - 1,y - 1,z) + P)),x - 1,y - 1,z)) {
liveimage_srv/CImg.h:              res(x - 1,y - 1,z) = npot; if (path) path(x - 1,y - 1,z) = (to)10;
liveimage_srv/CImg.h:            if (x + 1<width() && y - 1>=0 &&
liveimage_srv/CImg.h:                Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x + 1,y - 1,z) + P)),x + 1,y - 1,z)) {
liveimage_srv/CImg.h:              res(x + 1,y - 1,z) = npot; if (path) path(x + 1,y - 1,z) = (to)9;
liveimage_srv/CImg.h:            if (x - 1>=0 && y + 1<height() &&
liveimage_srv/CImg.h:                Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x - 1,y + 1,z) + P)),x - 1,y + 1,z)) {
liveimage_srv/CImg.h:              res(x - 1,y + 1,z) = npot; if (path) path(x - 1,y + 1,z) = (to)6;
liveimage_srv/CImg.h:                Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x + 1,y + 1,z) + P)),x + 1,y + 1,z)) {
liveimage_srv/CImg.h:            if (z - 1>=0) { // Diagonal neighbors on slice z - 1
liveimage_srv/CImg.h:              if (x - 1>=0 &&
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x - 1,y,z - 1) + P)),x - 1,y,z - 1)) {
liveimage_srv/CImg.h:                res(x - 1,y,z - 1) = npot; if (path) path(x - 1,y,z - 1) = (to)34;
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x + 1,y,z - 1) + P)),x + 1,y,z - 1)) {
liveimage_srv/CImg.h:                res(x + 1,y,z - 1) = npot; if (path) path(x + 1,y,z - 1) = (to)33;
liveimage_srv/CImg.h:              if (y - 1>=0 &&
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x,y - 1,z - 1) + P)),x,y - 1,z - 1)) {
liveimage_srv/CImg.h:                res(x,y - 1,z - 1) = npot; if (path) path(x,y - 1,z - 1) = (to)40;
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x,y + 1,z - 1) + P)),x,y + 1,z - 1)) {
liveimage_srv/CImg.h:                res(x,y + 1,z - 1) = npot; if (path) path(x,y + 1,z - 1) = (to)36;
liveimage_srv/CImg.h:              if (x - 1>=0 && y - 1>=0 &&
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x - 1,y - 1,z - 1) + P)),
liveimage_srv/CImg.h:                                           x - 1,y - 1,z - 1)) {
liveimage_srv/CImg.h:                res(x - 1,y - 1,z - 1) = npot; if (path) path(x - 1,y - 1,z - 1) = (to)42;
liveimage_srv/CImg.h:              if (x + 1<width() && y - 1>=0 &&
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x + 1,y - 1,z - 1) + P)),
liveimage_srv/CImg.h:                                           x + 1,y - 1,z - 1)) {
liveimage_srv/CImg.h:                res(x + 1,y - 1,z - 1) = npot; if (path) path(x + 1,y - 1,z - 1) = (to)41;
liveimage_srv/CImg.h:              if (x - 1>=0 && y + 1<height() &&
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x - 1,y + 1,z - 1) + P)),
liveimage_srv/CImg.h:                                           x - 1,y + 1,z - 1)) {
liveimage_srv/CImg.h:                res(x - 1,y + 1,z - 1) = npot; if (path) path(x - 1,y + 1,z - 1) = (to)38;
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x + 1,y + 1,z - 1) + P)),
liveimage_srv/CImg.h:                                           x + 1,y + 1,z - 1)) {
liveimage_srv/CImg.h:                res(x + 1,y + 1,z - 1) = npot; if (path) path(x + 1,y + 1,z - 1) = (to)37;
liveimage_srv/CImg.h:              if (x - 1>=0 &&
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x - 1,y,z + 1) + P)),x - 1,y,z + 1)) {
liveimage_srv/CImg.h:                res(x - 1,y,z + 1) = npot; if (path) path(x - 1,y,z + 1) = (to)18;
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x + 1,y,z + 1) + P)),x + 1,y,z + 1)) {
liveimage_srv/CImg.h:              if (y - 1>=0 &&
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x,y - 1,z + 1) + P)),x,y - 1,z + 1)) {
liveimage_srv/CImg.h:                res(x,y - 1,z + 1) = npot; if (path) path(x,y - 1,z + 1) = (to)24;
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt2*met(x,y + 1,z + 1) + P)),x,y + 1,z + 1)) {
liveimage_srv/CImg.h:              if (x - 1>=0 && y - 1>=0 &&
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x - 1,y - 1,z + 1) + P)),
liveimage_srv/CImg.h:                                           x - 1,y - 1,z + 1)) {
liveimage_srv/CImg.h:                res(x - 1,y - 1,z + 1) = npot; if (path) path(x - 1,y - 1,z + 1) = (to)26;
liveimage_srv/CImg.h:              if (x + 1<width() && y - 1>=0 &&
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x + 1,y - 1,z + 1) + P)),
liveimage_srv/CImg.h:                                           x + 1,y - 1,z + 1)) {
liveimage_srv/CImg.h:                res(x + 1,y - 1,z + 1) = npot; if (path) path(x + 1,y - 1,z + 1) = (to)25;
liveimage_srv/CImg.h:              if (x - 1>=0 && y + 1<height() &&
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x - 1,y + 1,z + 1) + P)),
liveimage_srv/CImg.h:                                           x - 1,y + 1,z + 1)) {
liveimage_srv/CImg.h:                res(x - 1,y + 1,z + 1) = npot; if (path) path(x - 1,y + 1,z + 1) = (to)22;
liveimage_srv/CImg.h:                  Q._priority_queue_insert(is_queued,sizeQ,-(npot=(td)(sqrt3*met(x + 1,y + 1,z + 1) + P)),
liveimage_srv/CImg.h:      CImg<charT> state(_width,_height,_depth); // -1=far away, 0=narrow, 1=frozen
liveimage_srv/CImg.h:        state.fill(-1);
liveimage_srv/CImg.h:          if (x - 1>=0 && state(x - 1,y,z)==-1) {
liveimage_srv/CImg.h:            const Tfloat dist = res(x - 1,y,z) = __distance_eikonal(res,met(x - 1,y,z),x - 1,y,z);
liveimage_srv/CImg.h:            Q._eik_priority_queue_insert(state,sizeQ,-dist,x - 1,y,z);
liveimage_srv/CImg.h:          if (x + 1<width() && state(x + 1,y,z)==-1) {
liveimage_srv/CImg.h:            Q._eik_priority_queue_insert(state,sizeQ,-dist,x + 1,y,z);
liveimage_srv/CImg.h:          if (y - 1>=0 && state(x,y - 1,z)==-1) {
liveimage_srv/CImg.h:            const Tfloat dist = res(x,y - 1,z) = __distance_eikonal(res,met(x,y - 1,z),x,y - 1,z);
liveimage_srv/CImg.h:            Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y - 1,z);
liveimage_srv/CImg.h:          if (y + 1<height() && state(x,y + 1,z)==-1) {
liveimage_srv/CImg.h:            Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y + 1,z);
liveimage_srv/CImg.h:          if (z - 1>=0 && state(x,y,z - 1)==-1) {
liveimage_srv/CImg.h:            const Tfloat dist = res(x,y,z - 1) = __distance_eikonal(res,met(x,y,z - 1),x,y,z - 1);
liveimage_srv/CImg.h:            Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y,z - 1);
liveimage_srv/CImg.h:          if (z + 1<depth() && state(x,y,z + 1)==-1) {
liveimage_srv/CImg.h:            Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y,z + 1);
liveimage_srv/CImg.h:          int x = -1, y = -1, z = -1;
liveimage_srv/CImg.h:            if (state(x,y,z)==1) x = -1; else state(x,y,z) = 1;
liveimage_srv/CImg.h:            if (x - 1>=0 && state(x - 1,y,z)!=1) {
liveimage_srv/CImg.h:              const Tfloat dist = __distance_eikonal(res,met(x - 1,y,z),x - 1,y,z);
liveimage_srv/CImg.h:              if (dist<res(x - 1,y,z)) {
liveimage_srv/CImg.h:                res(x - 1,y,z) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x - 1,y,z);
liveimage_srv/CImg.h:                res(x + 1,y,z) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x + 1,y,z);
liveimage_srv/CImg.h:            if (y - 1>=0 && state(x,y - 1,z)!=1) {
liveimage_srv/CImg.h:              const Tfloat dist = __distance_eikonal(res,met(x,y - 1,z),x,y - 1,z);
liveimage_srv/CImg.h:              if (dist<res(x,y - 1,z)) {
liveimage_srv/CImg.h:                res(x,y - 1,z) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y - 1,z);
liveimage_srv/CImg.h:                res(x,y + 1,z) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y + 1,z);
liveimage_srv/CImg.h:            if (z - 1>=0 && state(x,y,z - 1)!=1) {
liveimage_srv/CImg.h:              const Tfloat dist = __distance_eikonal(res,met(x,y,z - 1),x,y,z - 1);
liveimage_srv/CImg.h:              if (dist<res(x,y,z - 1)) {
liveimage_srv/CImg.h:                res(x,y,z - 1) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y,z - 1);
liveimage_srv/CImg.h:                res(x,y,z + 1) = dist; Q._eik_priority_queue_insert(state,sizeQ,-dist,x,y,z + 1);
liveimage_srv/CImg.h:      T T1 = (T)std::min(x - 1>=0?res(x - 1,y,z):M,x + 1<width()?res(x + 1,y,z):M);
liveimage_srv/CImg.h:          T2 = (T)std::min(y - 1>=0?res(x,y - 1,z):M,y + 1<height()?res(x,y + 1,z):M),
liveimage_srv/CImg.h:          T3 = (T)std::min(z - 1>=0?res(x,y,z - 1):M,z + 1<depth()?res(x,y,z + 1):M);
liveimage_srv/CImg.h:        if (T3<M && ___distance_eikonal(3,-2*(T1 + T2 + T3),T1*T1 + T2*T2 + T3*T3 - P*P,root))
liveimage_srv/CImg.h:        if (T2<M && ___distance_eikonal(2,-2*(T1 + T2),T1*T1 + T2*T2 - P*P,root))
liveimage_srv/CImg.h:        T T2 = (T)std::min(y - 1>=0?res(x,y - 1,z):M,y + 1<height()?res(x,y + 1,z):M);
liveimage_srv/CImg.h:        if (T2<M && ___distance_eikonal(2,-2*(T1 + T2),T1*T1 + T2*T2 - P*P,root))
liveimage_srv/CImg.h:    // Find max root of a 2nd-order polynomial.
liveimage_srv/CImg.h:      const Tfloat delta = b*b - 4*a*c;
liveimage_srv/CImg.h:      root = 0.5f*(-b + std::sqrt(delta))/a;
liveimage_srv/CImg.h:      (*this)(siz - 1,0) = (T)value; (*this)(siz - 1,1) = (T)x; (*this)(siz - 1,2) = (T)y; (*this)(siz - 1,3) = (T)z;
liveimage_srv/CImg.h:      for (unsigned int pos = siz - 1, par = 0; pos && value>(t)(*this)(par=(pos + 1)/2 - 1,0); pos = par) {
liveimage_srv/CImg.h:    //! Compute distance function to 0-valued isophotes, using the Eikonal PDE.
liveimage_srv/CImg.h:              gx = (Incc - Ipcc)/2,
liveimage_srv/CImg.h:              gy = (Icnc - Icpc)/2,
liveimage_srv/CImg.h:              gz = (Iccn - Iccp)/2,
liveimage_srv/CImg.h:              sgn = -cimg::sign(Iccc),
liveimage_srv/CImg.h:              ix = gx*sgn>0?(Incc - Iccc):(Iccc - Ipcc),
liveimage_srv/CImg.h:              iy = gy*sgn>0?(Icnc - Iccc):(Iccc - Icpc),
liveimage_srv/CImg.h:              iz = gz*sgn>0?(Iccn - Iccc):(Iccc - Iccp),
liveimage_srv/CImg.h:              ng = 1e-5f + cimg::hypot(gx,gy,gz),
liveimage_srv/CImg.h:              veloc = sgn*(ngx*ix + ngy*iy + ngz*iz - 1);
liveimage_srv/CImg.h:            if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
liveimage_srv/CImg.h:              gx = (Inc - Ipc)/2,
liveimage_srv/CImg.h:              gy = (Icn - Icp)/2,
liveimage_srv/CImg.h:              sgn = -cimg::sign(Icc),
liveimage_srv/CImg.h:              ix = gx*sgn>0?(Inc - Icc):(Icc - Ipc),
liveimage_srv/CImg.h:              iy = gy*sgn>0?(Icn - Icc):(Icc - Icp),
liveimage_srv/CImg.h:              ng = std::max((Tfloat)1e-5,cimg::hypot(gx,gy)),
liveimage_srv/CImg.h:              veloc = sgn*(ngx*ix + ngy*iy - 1);
liveimage_srv/CImg.h:            if (veloc>veloc_max) veloc_max = veloc; else if (-veloc>veloc_max) veloc_max = -veloc;
liveimage_srv/CImg.h:    //! Compute distance function to 0-valued isophotes, using the Eikonal PDE \newinstance.
liveimage_srv/CImg.h:                                          "haar(): Sub-image width %u is not even.",
liveimage_srv/CImg.h:                res(x2++,y,z,c) = (val0 - val1)/sqrt2;
liveimage_srv/CImg.h:                res(xw,y,z,c) = (val1 - val0)/sqrt2;
liveimage_srv/CImg.h:                                          "haar(): Sub-image height %u is not even.",
liveimage_srv/CImg.h:                res(x,y2++,z,c) = (val0 - val1)/sqrt2;
liveimage_srv/CImg.h:                res(x,yh,z,c) = (val1 - val0)/sqrt2;
liveimage_srv/CImg.h:                                          "haar(): Sub-image depth %u is not even.",
liveimage_srv/CImg.h:                res(x,y,z2++,c) = (val0 - val1)/sqrt2;
liveimage_srv/CImg.h:                res(x,y,zd,c) = (val1 - val0)/sqrt2;
liveimage_srv/CImg.h:      } else { // Multi-scale version
liveimage_srv/CImg.h:            for (w = w?w:1; w<=_width; w*=2) res.draw_image(res.get_crop(0,w - 1).get_haar('x',true,1));
liveimage_srv/CImg.h:            for (h = h?h:1; h<=_height; h*=2) res.draw_image(res.get_crop(0,0,_width - 1,h - 1).get_haar('y',true,1));
liveimage_srv/CImg.h:              res.draw_image(res.get_crop(0,0,0,_width - 1,_height - 1,d - 1).get_haar('z',true,1));
liveimage_srv/CImg.h:              res.draw_image(res.get_crop(0,w - 1).get_haar('x',false,1));
liveimage_srv/CImg.h:              res.draw_image(res.get_crop(0,0,_width - 1,h - 1).get_haar('y',false,1));
liveimage_srv/CImg.h:              res.draw_image(res.get_crop(0,0,0,_width - 1,_height - 1,d - 1).get_haar('z',false,1));
liveimage_srv/CImg.h:      } else { // Multi-scale transform
liveimage_srv/CImg.h:                  res.draw_image(res.get_crop(0,0,0,w - 1,h - 1,d - 1).get_haar(true,1));
liveimage_srv/CImg.h:                  res.draw_image(res.get_crop(0,0,0,w - 1,h - 1,0).get_haar(true,1));
liveimage_srv/CImg.h:                  res.draw_image(res.get_crop(0,0,0,w - 1,0,d - 1).get_haar(true,1));
liveimage_srv/CImg.h:                  res.draw_image(res.get_crop(0,0,0,w - 1,0,0).get_haar(true,1));
liveimage_srv/CImg.h:                  res.draw_image(res.get_crop(0,0,0,0,h - 1,d - 1).get_haar(true,1));
liveimage_srv/CImg.h:                  res.draw_image(res.get_crop(0,0,0,0,h - 1,0).get_haar(true,1));
liveimage_srv/CImg.h:                  res.draw_image(res.get_crop(0,0,0,0,0,d - 1).get_haar(true,1));
liveimage_srv/CImg.h:                  res.draw_image(res.get_crop(0,0,0,w - 1,h - 1,d - 1).haar(false,1));
liveimage_srv/CImg.h:                     res.draw_image(res.get_crop(0,0,0,w - 1,h - 1,0).haar(false,1));
liveimage_srv/CImg.h:                              res.draw_image(res.get_crop(0,0,0,w - 1,0,d - 1).haar(false,1));
liveimage_srv/CImg.h:                     res.draw_image(res.get_crop(0,0,0,w - 1,0,0).haar(false,1));
liveimage_srv/CImg.h:                  res.draw_image(res.get_crop(0,0,0,0,h - 1,d - 1).haar(false,1));
liveimage_srv/CImg.h:                     res.draw_image(res.get_crop(0,0,0,0,h - 1,0).haar(false,1));
liveimage_srv/CImg.h:                              res.draw_image(res.get_crop(0,0,0,0,0,d - 1).haar(false,1));
liveimage_srv/CImg.h:    //! Compute n-D Fast Fourier Transform.
liveimage_srv/CImg.h:                                    "for computing FFT of image (%u,%u,%u,%u) along the X-axis.",
liveimage_srv/CImg.h:      case 'x' : { // Fourier along X, using built-in functions
liveimage_srv/CImg.h:        if (((N - 1)&N) && N!=1)
liveimage_srv/CImg.h:                                      "have non 2^N dimension along the X-axis.",
liveimage_srv/CImg.h:                const unsigned int ri = N - 1 - i, rj = N - 1 - j;
liveimage_srv/CImg.h:          for (unsigned int m = N, n = N2; (j+=n)>=m; j-=m, m = n, n>>=1) {}
liveimage_srv/CImg.h:              angle = (float)((is_inverse?+1:-1)*2*cimg::PI/delta),
liveimage_srv/CImg.h:                const float tmpr = (float)(wr*nir - wi*nii), tmpi = (float)(wr*nii + wi*nir);
liveimage_srv/CImg.h:                nir = (T)(ir - tmpr);
liveimage_srv/CImg.h:                nii = (T)(ii - tmpi);
liveimage_srv/CImg.h:              const float nwr = wr*ca-wi*sa;
liveimage_srv/CImg.h:      case 'y' : { // Fourier along Y, using built-in functions
liveimage_srv/CImg.h:        if (((N - 1)&N) && N!=1)
liveimage_srv/CImg.h:                                      "have non 2^N dimension along the Y-axis.",
liveimage_srv/CImg.h:                const unsigned int ri = N - 1 - i, rj = N - 1 - j;
liveimage_srv/CImg.h:          for (unsigned int m = N, n = N2; (j+=n)>=m; j-=m, m = n, n>>=1) {}
liveimage_srv/CImg.h:              angle = (float)((is_inverse?+1:-1)*2*cimg::PI/delta),
liveimage_srv/CImg.h:                const float tmpr = (float)(wr*nir - wi*nii), tmpi = (float)(wr*nii + wi*nir);
liveimage_srv/CImg.h:                nir = (T)(ir - tmpr);
liveimage_srv/CImg.h:                nii = (T)(ii - tmpi);
liveimage_srv/CImg.h:              const float nwr = wr*ca-wi*sa;
liveimage_srv/CImg.h:      default : { // Fourier along Z, using built-in functions
liveimage_srv/CImg.h:        if (((N - 1)&N) && N!=1)
liveimage_srv/CImg.h:                                      "have non 2^N dimension along the Z-axis.",
liveimage_srv/CImg.h:                const unsigned int ri = N - 1 - i, rj = N - 1 - j;
liveimage_srv/CImg.h:          for (unsigned int m = N, n = N2; (j+=n)>=m; j-=m, m = n, n>>=1) {}
liveimage_srv/CImg.h:              angle = (float)((is_inverse?+1:-1)*2*cimg::PI/delta),
liveimage_srv/CImg.h:                const float tmpr = (float)(wr*nir - wi*nii), tmpi = (float)(wr*nii + wi*nir);
liveimage_srv/CImg.h:                nir = (T)(ir - tmpr);
liveimage_srv/CImg.h:                nii = (T)(ii - tmpi);
liveimage_srv/CImg.h:              const float nwr = wr*ca-wi*sa;
liveimage_srv/CImg.h:    //! Compute n-D Fast Fourier Transform.
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:       \param x X-coordinate of the rotation axis, or first quaternion coordinate.
liveimage_srv/CImg.h:       \param y Y-coordinate of the rotation axis, or second quaternion coordinate.
liveimage_srv/CImg.h:       \param z Z-coordinate of the rotation axis, or second quaternion coordinate.
liveimage_srv/CImg.h:       \param tx X-coordinate of the 3D displacement vector.
liveimage_srv/CImg.h:       \param ty Y-coordinate of the 3D displacement vector.
liveimage_srv/CImg.h:       \param tz Z-coordinate of the 3D displacement vector.
liveimage_srv/CImg.h:      xcoords-=(xm + xM)/2; ycoords-=(ym + yM)/2; zcoords-=(zm + zM)/2;
liveimage_srv/CImg.h:    CImg<T>& resize_object3d(const float sx, const float sy=-100, const float sz=-100) {
liveimage_srv/CImg.h:      if (xm<xM) { if (sx>0) xcoords*=sx/(xM-xm); else xcoords*=-sx/100; }
liveimage_srv/CImg.h:      if (ym<yM) { if (sy>0) ycoords*=sy/(yM-ym); else ycoords*=-sy/100; }
liveimage_srv/CImg.h:      if (zm<zM) { if (sz>0) zcoords*=sz/(zM-zm); else zcoords*=-sz/100; }
liveimage_srv/CImg.h:    CImg<Tfloat> get_resize_object3d(const float sx, const float sy=-100, const float sz=-100) const {
liveimage_srv/CImg.h:      const float dx = xM - xm, dy = yM - ym, dz = zM - zm, dmax = cimg::max(dx,dy,dz);
liveimage_srv/CImg.h:       \param coords Texture-mapping coordinates.
liveimage_srv/CImg.h:      if (!coords) { // If no texture coordinates specified, do a default XY-projection
liveimage_srv/CImg.h:          dx = xmax>xmin?xmax-xmin:1,
liveimage_srv/CImg.h:          dy = ymax>ymin?ymax-ymin:1;
liveimage_srv/CImg.h:          _coords(p,0) = (int)(((*this)(p,0) - xmin)*texture._width/dx);
liveimage_srv/CImg.h:          _coords(p,1) = (int)(((*this)(p,1) - ymin)*texture._height/dy);
liveimage_srv/CImg.h:      int texture_ind = -1;
liveimage_srv/CImg.h:          texture.get_vector_at(x0<=0?0:x0>=texture.width()?texture.width() - 1:x0,
liveimage_srv/CImg.h:                                y0<=0?0:y0>=texture.height()?texture.height() - 1:y0).move_to(colors[l]);
liveimage_srv/CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
liveimage_srv/CImg.h:      const unsigned int size_x1 = _width - 1, size_y1 = _height - 1;
liveimage_srv/CImg.h:            r = (unsigned char)(((*this)(x,y,0) - m)*255/(M-m)),
liveimage_srv/CImg.h:            g = (unsigned char)(_spectrum>1?((*this)(x,y,1) - m)*255/(M-m):r),
liveimage_srv/CImg.h:            b = (unsigned char)(_spectrum>2?((*this)(x,y,2) - m)*255/(M-m):_spectrum>1?0:r);
liveimage_srv/CImg.h:      return elevation3d(primitives,func,0,0,_width - 1.f,_height - 1.f,_width,_height);
liveimage_srv/CImg.h:       \param x0 X-coordinate of the projection point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the projection point.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the projection point.
liveimage_srv/CImg.h:      if (normalize_colors) { m = (float)min_max(M); delta = 255/(m==M?1:M-m); }
liveimage_srv/CImg.h:        _x0 = (x0>=_width)?_width - 1:x0,
liveimage_srv/CImg.h:        _y0 = (y0>=_height)?_height - 1:y0,
liveimage_srv/CImg.h:        _z0 = (z0>=_depth)?_depth - 1:z0;
liveimage_srv/CImg.h:        ((get_crop(0,0,_z0,0,_width - 1,_height - 1,_z0,_spectrum - 1)-=m)*=delta).move_to(img_xy);
liveimage_srv/CImg.h:        ((get_crop(0,_y0,0,0,_width - 1,_y0,_depth - 1,_spectrum - 1)-=m)*=delta).resize(_width,_depth,1,-100,-1).
liveimage_srv/CImg.h:        ((get_crop(_x0,0,0,0,_x0,_height - 1,_depth - 1,_spectrum - 1)-=m)*=delta).resize(_height,_depth,1,-100,-1).
liveimage_srv/CImg.h:        get_crop(0,0,_z0,0,_width - 1,_height - 1,_z0,_spectrum - 1).move_to(img_xy);
liveimage_srv/CImg.h:        get_crop(0,_y0,0,0,_width - 1,_y0,_depth - 1,_spectrum - 1).resize(_width,_depth,1,-100,-1).move_to(img_xz);
liveimage_srv/CImg.h:        get_crop(_x0,0,0,0,_x0,_height - 1,_depth - 1,_spectrum - 1).resize(_height,_depth,1,-100,-1).move_to(img_yz);
liveimage_srv/CImg.h:                          0,_width - 1,_width - 1,0,   0,_width - 1,_width - 1,0, _x0,_x0,_x0,_x0,
liveimage_srv/CImg.h:                          0,0,_height - 1,_height - 1, _y0,_y0,_y0,_y0,       0,_height - 1,_height - 1,0,
liveimage_srv/CImg.h:                          _z0,_z0,_z0,_z0,         0,0,_depth - 1,_depth - 1, 0,0,_depth - 1,_depth - 1);
liveimage_srv/CImg.h:      CImg<tf>::vector(0,1,2,3,0,0,img_xy._width - 1,0,img_xy._width - 1,img_xy._height - 1,0,img_xy._height - 1).
liveimage_srv/CImg.h:      CImg<tf>::vector(4,5,6,7,0,0,img_xz._width - 1,0,img_xz._width - 1,img_xz._height - 1,0,img_xz._height - 1).
liveimage_srv/CImg.h:      CImg<tf>::vector(8,9,10,11,0,0,img_yz._width - 1,0,img_yz._width - 1,img_yz._height - 1,0,img_yz._height - 1).
liveimage_srv/CImg.h:       \param size_x The number of subdivisions along the X-axis.
liveimage_srv/CImg.h:       \param size_y The number of subdisivions along the Y-axis.
liveimage_srv/CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
liveimage_srv/CImg.h:                               const int size_x=-100, const int size_y=-100) const {
liveimage_srv/CImg.h:      if ((size_x==-100 && size_y==-100) || (size_x==width() && size_y==height())) {
liveimage_srv/CImg.h:        vertices = isoline3d(primitives,func,isovalue,0,0,width() - 1.f,height() - 1.f,width(),height());
liveimage_srv/CImg.h:        vertices = isoline3d(primitives,func,isovalue,0,0,width() - 1.f,height() - 1.f,size_x,size_y);
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting point.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending point.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending point.
liveimage_srv/CImg.h:       \param size_x Resolution of the function along the X-axis.
liveimage_srv/CImg.h:       \param size_y Resolution of the function along the Y-axis.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting point.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending point.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending point.
liveimage_srv/CImg.h:       \param size_x Resolution of the function along the X-axis.
liveimage_srv/CImg.h:       \param size_y Resolution of the function along the Y-axis.
liveimage_srv/CImg.h:      static const int segments[16][4] = { { -1,-1,-1,-1 }, { 0,3,-1,-1 }, { 0,1,-1,-1 }, { 1,3,-1,-1 },
liveimage_srv/CImg.h:                                           { 1,2,-1,-1 },   { 0,1,2,3 },   { 0,2,-1,-1 }, { 2,3,-1,-1 },
liveimage_srv/CImg.h:                                           { 2,3,-1,-1 },   { 0,2,-1,-1},  { 0,3,1,2 },   { 1,2,-1,-1 },
liveimage_srv/CImg.h:                                           { 1,3,-1,-1 },   { 0,1,-1,-1},  { 0,3,-1,-1},  { -1,-1,-1,-1 } };
liveimage_srv/CImg.h:        _nx = (unsigned int)(size_x>=0?size_x:cimg::round((x1-x0)*-size_x/100 + 1)),
liveimage_srv/CImg.h:        _ny = (unsigned int)(size_y>=0?size_y:cimg::round((y1-y0)*-size_y/100 + 1)),
liveimage_srv/CImg.h:        nxm1 = nx - 1,
liveimage_srv/CImg.h:        nym1 = ny - 1;
liveimage_srv/CImg.h:      const float dx = (x1 - x0)/nxm1, dy = (y1 - y0)/nym1;
liveimage_srv/CImg.h:      CImg<intT> indices1(nx,1,1,2,-1), indices2(nx,1,1,2);
liveimage_srv/CImg.h:        indices2.fill(-1);
liveimage_srv/CImg.h:              const float Xi = X + (isovalue-val0)*dx/(val1-val0);
liveimage_srv/CImg.h:              const float Yi = Y + (isovalue-val1)*dy/(val2-val1);
liveimage_srv/CImg.h:              const float Xi = X + (isovalue-val3)*dx/(val2-val3);
liveimage_srv/CImg.h:              const float Yi = Y + (isovalue-val0)*dy/(val3-val0);
liveimage_srv/CImg.h:            for (const int *segment = segments[configuration]; *segment!=-1; ) {
liveimage_srv/CImg.h:       \param size_x Number of subdivisions along the X-axis.
liveimage_srv/CImg.h:       \param size_y Number of subdisivions along the Y-axis.
liveimage_srv/CImg.h:       \param size_z Number of subdisivions along the Z-axis.
liveimage_srv/CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
liveimage_srv/CImg.h:       const CImg<float> img = CImg<unsigned char>("reference.jpg").resize(-100,-100,20);
liveimage_srv/CImg.h:                                  const int size_x=-100, const int size_y=-100, const int size_z=-100) const {
liveimage_srv/CImg.h:      if ((size_x==-100 && size_y==-100 && size_z==-100) || (size_x==width() && size_y==height() && size_z==depth())) {
liveimage_srv/CImg.h:        vertices = isosurface3d(primitives,func,isovalue,0,0,0,width() - 1.f,height() - 1.f,depth() - 1.f,
liveimage_srv/CImg.h:        vertices = isosurface3d(primitives,func,isovalue,0,0,0,width() - 1.f,height() - 1.f,depth() - 1.f,
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting point.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the starting point.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending point.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending point.
liveimage_srv/CImg.h:       \param z1 Z-coordinate of the ending point.
liveimage_srv/CImg.h:       \param size_x Resolution of the elevation function along the X-axis.
liveimage_srv/CImg.h:       \param size_y Resolution of the elevation function along the Y-axis.
liveimage_srv/CImg.h:       \param size_z Resolution of the elevation function along the Z-axis.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting point.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the starting point.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending point.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending point.
liveimage_srv/CImg.h:       \param z1 Z-coordinate of the ending point.
liveimage_srv/CImg.h:       \param size_x Resolution of the elevation function along the X-axis.
liveimage_srv/CImg.h:       \param size_y Resolution of the elevation function along the Y-axis.
liveimage_srv/CImg.h:       \param size_z Resolution of the elevation function along the Z-axis.
liveimage_srv/CImg.h:        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1 },
liveimage_srv/CImg.h:        { 11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1 },
liveimage_srv/CImg.h:        { 11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1 },
liveimage_srv/CImg.h:        { 3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1 },
liveimage_srv/CImg.h:        { 8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1 },
liveimage_srv/CImg.h:        { 0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1 },
liveimage_srv/CImg.h:        { 6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1 },
liveimage_srv/CImg.h:        { 9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1 },
liveimage_srv/CImg.h:        { 3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1 },
liveimage_srv/CImg.h:        { 7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1 },
liveimage_srv/CImg.h:        { 1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1 },
liveimage_srv/CImg.h:        { 11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1 },
liveimage_srv/CImg.h:        { 0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1 },
liveimage_srv/CImg.h:        { 8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1 },
liveimage_srv/CImg.h:        { 10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1 },
liveimage_srv/CImg.h:        { 7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1 },
liveimage_srv/CImg.h:        { 9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1 },
liveimage_srv/CImg.h:        { 4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1 },
liveimage_srv/CImg.h:        { 7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1 },
liveimage_srv/CImg.h:        { 11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1 },
liveimage_srv/CImg.h:        { 6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1 },
liveimage_srv/CImg.h:        { 1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1 },
liveimage_srv/CImg.h:        { 10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1 },
liveimage_srv/CImg.h:        { 2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1 },
liveimage_srv/CImg.h:        { 1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1 },
liveimage_srv/CImg.h:        { 2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1 },
liveimage_srv/CImg.h:        { 0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1 },
liveimage_srv/CImg.h:        { 9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1 },
liveimage_srv/CImg.h:        { 5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1 },
liveimage_srv/CImg.h:        { 4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1 },
liveimage_srv/CImg.h:        { 11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1 },
liveimage_srv/CImg.h:        { 3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1 },
liveimage_srv/CImg.h:        { 1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { 0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 },
liveimage_srv/CImg.h:        { -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 }
liveimage_srv/CImg.h:        _nx = (unsigned int)(size_x>=0?size_x:cimg::round((x1-x0)*-size_x/100 + 1)),
liveimage_srv/CImg.h:        _ny = (unsigned int)(size_y>=0?size_y:cimg::round((y1-y0)*-size_y/100 + 1)),
liveimage_srv/CImg.h:        _nz = (unsigned int)(size_z>=0?size_z:cimg::round((z1-z0)*-size_z/100 + 1)),
liveimage_srv/CImg.h:        nxm1 = nx - 1,
liveimage_srv/CImg.h:        nym1 = ny - 1,
liveimage_srv/CImg.h:        nzm1 = nz - 1;
liveimage_srv/CImg.h:      const float dx = (x1 - x0)/nxm1, dy = (y1 - y0)/nym1, dz = (z1 - z0)/nzm1;
liveimage_srv/CImg.h:      CImg<intT> indices1(nx,ny,1,3,-1), indices2(indices1);
liveimage_srv/CImg.h:        indices2.fill(-1);
liveimage_srv/CImg.h:                const float Xi = X + (isovalue-val0)*dx/(val1-val0);
liveimage_srv/CImg.h:                const float Yi = Y + (isovalue-val1)*dy/(val2-val1);
liveimage_srv/CImg.h:                const float Xi = X + (isovalue-val3)*dx/(val2-val3);
liveimage_srv/CImg.h:                const float Yi = Y + (isovalue-val0)*dy/(val3-val0);
liveimage_srv/CImg.h:                const float Xi = X + (isovalue-val4)*dx/(val5-val4);
liveimage_srv/CImg.h:                const float Yi = Y + (isovalue-val5)*dy/(val6-val5);
liveimage_srv/CImg.h:                const float Xi = X + (isovalue-val7)*dx/(val6-val7);
liveimage_srv/CImg.h:                const float Yi = Y + (isovalue-val4)*dy/(val7-val4);
liveimage_srv/CImg.h:                const float Zi = Z+ (isovalue-val0)*dz/(val4-val0);
liveimage_srv/CImg.h:                const float Zi = Z + (isovalue-val1)*dz/(val5-val1);
liveimage_srv/CImg.h:                const float Zi = Z + (isovalue-val2)*dz/(val6-val2);
liveimage_srv/CImg.h:                const float Zi = Z + (isovalue-val3)*dz/(val7-val3);
liveimage_srv/CImg.h:              for (const int *triangle = triangles[configuration]; *triangle!=-1; ) {
liveimage_srv/CImg.h:      ~_functor2d_expr() { mp->end(); delete mp; }
liveimage_srv/CImg.h:      ~_functor3d_expr() { mp->end(); delete mp; }
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting point.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending point.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending point.
liveimage_srv/CImg.h:       \param size_x Resolution of the function along the X-axis.
liveimage_srv/CImg.h:       \param size_y Resolution of the function along the Y-axis.
liveimage_srv/CImg.h:        _nsize_x = (unsigned int)(size_x>=0?size_x:(nx1-nx0)*-size_x/100),
liveimage_srv/CImg.h:        nsize_x = _nsize_x?_nsize_x:1, nsize_x1 = nsize_x - 1,
liveimage_srv/CImg.h:        _nsize_y = (unsigned int)(size_y>=0?size_y:(ny1-ny0)*-size_y/100),
liveimage_srv/CImg.h:        nsize_y = _nsize_y?_nsize_y:1, nsize_y1 = nsize_y - 1;
liveimage_srv/CImg.h:        const float Y = ny0 + y*(ny1-ny0)/nsize_y1;
liveimage_srv/CImg.h:          const float X = nx0 + x*(nx1-nx0)/nsize_x1;
liveimage_srv/CImg.h:       \param size_x The width of the box (dimension along the X-axis).
liveimage_srv/CImg.h:       \param size_y The height of the box (dimension along the Y-axis).
liveimage_srv/CImg.h:       \param size_z The depth of the box (dimension along the Z-axis).
liveimage_srv/CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
liveimage_srv/CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
liveimage_srv/CImg.h:      const unsigned int nbr = vertices._width - 2;
liveimage_srv/CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
liveimage_srv/CImg.h:      const unsigned int nbr = (vertices._width - 2)/2;
liveimage_srv/CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
liveimage_srv/CImg.h:    //! Generate a 3D XY-plane.
liveimage_srv/CImg.h:       \param size_x The width of the plane (dimension along the X-axis).
liveimage_srv/CImg.h:       \param size_y The height of the plane (dimensions along the Y-axis).
liveimage_srv/CImg.h:       \param subdivisions_x The number of planar subdivisions along the X-axis.
liveimage_srv/CImg.h:       \param subdivisions_y The number of planar subdivisions along the Y-axis.
liveimage_srv/CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
liveimage_srv/CImg.h:       \param radius The radius of the sphere (dimension along the X-axis).
liveimage_srv/CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
liveimage_srv/CImg.h:      CImgList<floatT> vertices(12,1,3,1,1, b,a,0., -b,a,0., -b,-a,0., b,-a,0., a,0.,b, a,0.,-b,
liveimage_srv/CImg.h:                                -a,0.,-b, -a,0.,b, 0.,b,a, 0.,-b,a, 0.,-b,-a, 0.,b,-a);
liveimage_srv/CImg.h:      // edge - length/2
liveimage_srv/CImg.h:          int i0 = -1, i1 = -1, i2 = -1;
liveimage_srv/CImg.h:            if (cimg::sqr(x-nx0) + cimg::sqr(y-ny0) + cimg::sqr(z-nz0)<he2) i0 = p;
liveimage_srv/CImg.h:            if (cimg::sqr(x-nx1) + cimg::sqr(y-ny1) + cimg::sqr(z-nz1)<he2) i1 = p;
liveimage_srv/CImg.h:            if (cimg::sqr(x-nx2) + cimg::sqr(y-ny2) + cimg::sqr(z-nz2)<he2) i2 = p;
liveimage_srv/CImg.h:          if (i0<0) { CImg<floatT>::vector(nx0,ny0,nz0).move_to(vertices); i0 = vertices.width() - 1; }
liveimage_srv/CImg.h:          if (i1<0) { CImg<floatT>::vector(nx1,ny1,nz1).move_to(vertices); i1 = vertices.width() - 1; }
liveimage_srv/CImg.h:          if (i2<0) { CImg<floatT>::vector(nx2,ny2,nz2).move_to(vertices); i2 = vertices.width() - 1; }
liveimage_srv/CImg.h:       \return The N vertices (xi,yi,zi) of the 3D object as a Nx3 CImg<float> image (0<=i<=N - 1).
liveimage_srv/CImg.h:        (V(0,1)*V(1,2) - V(0,2)*V(1,1))*V(2,0) +
liveimage_srv/CImg.h:        (V(0,2)*V(1,0) - V(0,0)*V(1,2))*V(2,1) +
liveimage_srv/CImg.h:        (V(0,0)*V(1,1) - V(0,1)*V(1,0))*V(2,2);
liveimage_srv/CImg.h:      if (orient<0) { V(2,0) = -V(2,0); V(2,1) = -V(2,1); V(2,2) = -V(2,2); }
liveimage_srv/CImg.h:          *(ptrd++) = -128.f;
liveimage_srv/CImg.h:          int shared_ind = -1;
liveimage_srv/CImg.h:      const int csiz2 = primitives.width() - colors.width();
liveimage_srv/CImg.h:          *(ptrd++) = -128.f;
liveimage_srv/CImg.h:          int shared_ind = -1;
liveimage_srv/CImg.h:      for (int c = std::min(primitives.width(),colors.width()) - 1; c>=0; --c) {
liveimage_srv/CImg.h:      if (colors._width<primitives._width) siz+=3*(primitives._width - colors._width);
liveimage_srv/CImg.h:      siz+=primitives._width - opacities._width;
liveimage_srv/CImg.h:      for (int c = std::min(primitives.width(),colors.width()) - 1; c>=0; --c) {
liveimage_srv/CImg.h:      if (colors._width<primitives._width) siz+=3*(primitives._width - colors._width);
liveimage_srv/CImg.h:        if (*ptrs==(T)-128) {
liveimage_srv/CImg.h:        if (*ptrs==(T)-128) {
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:    const float _sc_nopacity = cimg::abs((float)opacity), _sc_copacity = 1 - std::max((float)opacity,0.f); \
liveimage_srv/CImg.h:    // [internal] The following _draw_scanline() routines are *non user-friendly functions*,
liveimage_srv/CImg.h:    // Pre-requisites: x0<=x1, y-coordinate is valid, col is valid.
liveimage_srv/CImg.h:      const int nx0 = x0>0?x0:0, nx1 = x1<width()?x1:width() - 1, dx = nx1 - nx0;
liveimage_srv/CImg.h:        const ulongT off = whd - dx - 1;
liveimage_srv/CImg.h:                for (int x = dx; x>=0; --x) *(ptrd++) = val;
liveimage_srv/CImg.h:                for (int x = dx; x>=0; --x) *(ptrd++) = val;
liveimage_srv/CImg.h:                const T val = (T)((2-brightness)**(col++) + (brightness - 1)*_sc_maxval);
liveimage_srv/CImg.h:                for (int x = dx; x>=0; --x) *(ptrd++) = val;
liveimage_srv/CImg.h:                const T val = (T)((2-brightness)**(col++) + (brightness - 1)*_sc_maxval);
liveimage_srv/CImg.h:              for (int x = dx; x>=0; --x) { *ptrd = (T)(val + *ptrd*copacity); ++ptrd; }
liveimage_srv/CImg.h:              for (int x = dx; x>=0; --x) { *ptrd = (T)(val + *ptrd*copacity); ++ptrd; }
liveimage_srv/CImg.h:              const Tfloat val = ((2-brightness)**(col++) + (brightness - 1)*_sc_maxval)*nopacity;
liveimage_srv/CImg.h:              for (int x = dx; x>=0; --x) { *ptrd = (T)(val + *ptrd*copacity); ++ptrd; }
liveimage_srv/CImg.h:       \param x0 X-coordinate of the point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the point.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the point.
liveimage_srv/CImg.h:       - To set pixel values without clipping needs, you should use the faster CImg::operator()() function.
liveimage_srv/CImg.h:        const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting line point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting line point.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending line point.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending line point.
liveimage_srv/CImg.h:       - Line routine uses Bresenham's algorithm.
liveimage_srv/CImg.h:       - Set \p init_hatch = false to draw consecutive hatched segments without breaking the line pattern.
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dy01 = y1 - y0;
liveimage_srv/CImg.h:        dx01*=-1; dy01*=-1;
liveimage_srv/CImg.h:      static unsigned int hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:      if (init_hatch) hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:        step = y0<=y1?1:-1,hdy01 = dy01*cimg::sign(dx01)/2,
liveimage_srv/CImg.h:          yy0 = y - y0,
liveimage_srv/CImg.h:        if (!(hatch>>=1)) hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:    //! Draw a 2D line, with z-buffering.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting point.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the starting point
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending point.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending point.
liveimage_srv/CImg.h:       \param z1 Z-coordinate of the ending point.
liveimage_srv/CImg.h:                                    "draw_line(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dy01 = y1 - y0;
liveimage_srv/CImg.h:      float diz01 = iz1 - iz0;
liveimage_srv/CImg.h:        dx01*=-1; dy01*=-1; diz01*=-1;
liveimage_srv/CImg.h:      static unsigned int hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:      if (init_hatch) hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:        step = y0<=y1?1:-1, hdy01 = dy01*cimg::sign(dx01)/2,
liveimage_srv/CImg.h:          yy0 = y - y0,
liveimage_srv/CImg.h:        if (!(hatch>>=1)) hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting line point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting line point.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending line point.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending line point.
liveimage_srv/CImg.h:       \param tx0 X-coordinate of the starting texture point.
liveimage_srv/CImg.h:       \param ty0 Y-coordinate of the starting texture point.
liveimage_srv/CImg.h:       \param tx1 X-coordinate of the ending texture point.
liveimage_srv/CImg.h:       \param ty1 Y-coordinate of the ending texture point.
liveimage_srv/CImg.h:       - Line routine uses the well known Bresenham's algorithm.
liveimage_srv/CImg.h:      int w1 = width() - 1, h1 = height() - 1;
liveimage_srv/CImg.h:        dx01 = (longT)x1 - x0, dy01 = (longT)y1 - y0,
liveimage_srv/CImg.h:        dtx01 = (longT)tx1 - tx0, dty01 = (longT)ty1 - ty0;
liveimage_srv/CImg.h:        dx01*=-1; dy01*=-1; dtx01*=-1; dty01*=-1;
liveimage_srv/CImg.h:      static unsigned int hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:      if (init_hatch) hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:      const int step = y0<=y1?1:-1, cy0 = cimg::cut(y0,0,h1), cy1 = cimg::cut(y1,0,h1) + step;
liveimage_srv/CImg.h:          yy0 = (longT)y - y0,
liveimage_srv/CImg.h:        if (!(hatch>>=1)) hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting point.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the starting point
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending point.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending point.
liveimage_srv/CImg.h:       \param z1 Z-coordinate of the ending point.
liveimage_srv/CImg.h:       \param tx0 X-coordinate of the starting texture point.
liveimage_srv/CImg.h:       \param ty0 Y-coordinate of the starting texture point.
liveimage_srv/CImg.h:       \param tx1 X-coordinate of the ending texture point.
liveimage_srv/CImg.h:       \param ty1 Y-coordinate of the ending texture point.
liveimage_srv/CImg.h:      int w1 = width() - 1, h1 = height() - 1;
liveimage_srv/CImg.h:      longT dx01 = (longT)x1 - x0, dy01 = (longT)y1 - y0;
liveimage_srv/CImg.h:        diz01 = iz1 - iz0,
liveimage_srv/CImg.h:        dtxz01 = txz1 - txz0, dtyz01 = tyz1 - tyz0;
liveimage_srv/CImg.h:        dx01*=-1; dy01*=-1; diz01*=-1; dtxz01*=-1; dtyz01*=-1;
liveimage_srv/CImg.h:      static unsigned int hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:      if (init_hatch) hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:      const int step = y0<=y1?1:-1, cy0 = cimg::cut(y0,0,h1), cy1 = cimg::cut(y1,0,h1) + step;
liveimage_srv/CImg.h:          yy0 = (longT)y - y0,
liveimage_srv/CImg.h:        if (!(hatch>>=1)) hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:    //! Draw a textured 2D line, with perspective correction and z-buffering.
liveimage_srv/CImg.h:       \param zbuffer Z-buffer image.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting point.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting point.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the starting point
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending point.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending point.
liveimage_srv/CImg.h:       \param z1 Z-coordinate of the ending point.
liveimage_srv/CImg.h:       \param tx0 X-coordinate of the starting texture point.
liveimage_srv/CImg.h:       \param ty0 Y-coordinate of the starting texture point.
liveimage_srv/CImg.h:       \param tx1 X-coordinate of the ending texture point.
liveimage_srv/CImg.h:       \param ty1 Y-coordinate of the ending texture point.
liveimage_srv/CImg.h:                                    "draw_line(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
liveimage_srv/CImg.h:      int w1 = width() - 1, h1 = height() - 1;
liveimage_srv/CImg.h:      longT dx01 = (longT)x1 - x0, dy01 = (longT)y1 - y0;
liveimage_srv/CImg.h:        diz01 = iz1 - iz0,
liveimage_srv/CImg.h:        dtxz01 = txz1 - txz0, dtyz01 = tyz1 - tyz0;
liveimage_srv/CImg.h:        dx01*=-1; dy01*=-1; diz01*=-1; dtxz01*=-1; dtyz01*=-1;
liveimage_srv/CImg.h:      static unsigned int hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:      if (init_hatch) hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:      const int step = y0<=y1?1:-1, cy0 = cimg::cut(y0,0,h1), cy1 = cimg::cut(y1,0,h1) + step;
liveimage_srv/CImg.h:          yy0 = (longT)y - y0,
liveimage_srv/CImg.h:        if (!(hatch>>=1)) hatch = ~0U - (~0U>>1);
liveimage_srv/CImg.h:       - This function uses several call to the single CImg::draw_line() procedure,
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting arrow point (tail).
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting arrow point (tail).
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending arrow point (head).
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending arrow point (head).
liveimage_srv/CImg.h:                        const float angle=30, const float length=-10,
liveimage_srv/CImg.h:      const float u = (float)(x0 - x1), v = (float)(y0 - y1), sq = u*u + v*v,
liveimage_srv/CImg.h:        l = (length>=0)?length:-length*(float)std::sqrt(sq)/100;
liveimage_srv/CImg.h:            cl = (float)std::cos(ang - deg), sl = (float)std::sin(ang - deg),
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting curve point
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting curve point
liveimage_srv/CImg.h:       \param u0 X-coordinate of the starting velocity
liveimage_srv/CImg.h:       \param v0 Y-coordinate of the starting velocity
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending curve point
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending curve point
liveimage_srv/CImg.h:       \param u1 X-coordinate of the ending velocity
liveimage_srv/CImg.h:       \param v1 Y-coordinate of the ending velocity
liveimage_srv/CImg.h:       - The curve is a 2D cubic Bezier spline, from the set of specified starting/ending points
liveimage_srv/CImg.h:       - The spline is drawn as a sequence of connected segments. The \p precision parameter sets the
liveimage_srv/CImg.h:       - A cubic Bezier curve is sometimes defined by a set of 4 points { (\p x0,\p y0), (\p xa,\p ya),
liveimage_srv/CImg.h:       \p u0 = (\p xa - \p x0), \p v0 = (\p ya - \p y0), \p u1 = (\p x1 - \p xb) and \p v1 = (\p y1 - \p yb).
liveimage_srv/CImg.h:       img.draw_spline(30,30,0,100,90,40,0,-100,color);
liveimage_srv/CImg.h:        ax = u0 + u1 + 2*(x0 - x1),
liveimage_srv/CImg.h:        bx = 3*(x1 - x0) - 2*u0 - u1,
liveimage_srv/CImg.h:        ay = v0 + v1 + 2*(y0 - y1),
liveimage_srv/CImg.h:        by = 3*(y1 - y0) - 2*v0 - v1,
liveimage_srv/CImg.h:        _precision = 1/(cimg::hypot((float)x0 - x1,(float)y0 - y1)*(precision>0?precision:1));
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting curve point
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting curve point
liveimage_srv/CImg.h:       \param u0 X-coordinate of the starting velocity
liveimage_srv/CImg.h:       \param v0 Y-coordinate of the starting velocity
liveimage_srv/CImg.h:       \param x1 X-coordinate of the ending curve point
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the ending curve point
liveimage_srv/CImg.h:       \param u1 X-coordinate of the ending velocity
liveimage_srv/CImg.h:       \param v1 Y-coordinate of the ending velocity
liveimage_srv/CImg.h:       \param tx0 X-coordinate of the starting texture point.
liveimage_srv/CImg.h:       \param ty0 Y-coordinate of the starting texture point.
liveimage_srv/CImg.h:       \param tx1 X-coordinate of the ending texture point.
liveimage_srv/CImg.h:       \param ty1 Y-coordinate of the ending texture point.
liveimage_srv/CImg.h:        return draw_point(x0,y0,texture.get_vector_at(x0<=0?0:x0>=texture.width()?texture.width() - 1:x0,
liveimage_srv/CImg.h:                                                      y0<=0?0:y0>=texture.height()?texture.height() - 1:y0).data(),
liveimage_srv/CImg.h:        ax = u0 + u1 + 2*(x0 - x1),
liveimage_srv/CImg.h:        bx = 3*(x1 - x0) - 2*u0 - u1,
liveimage_srv/CImg.h:        ay = v0 + v1 + 2*(y0 - y1),
liveimage_srv/CImg.h:        by = 3*(y1 - y0) - 2*v0 - v1,
liveimage_srv/CImg.h:        _precision = 1/(cimg::hypot((float)x0 - x1,(float)y0 - y1)*(precision>0?precision:1));
liveimage_srv/CImg.h:          ntx = tx0 + (int)((tx1 - tx0)*t1),
liveimage_srv/CImg.h:          nty = ty0 + (int)((ty1 - ty0)*t1);
liveimage_srv/CImg.h:            p0 = is_closed_set?(p + points.width() - 1)%points.width():(p?p - 1:0),
liveimage_srv/CImg.h:            u0 = x - x0,
liveimage_srv/CImg.h:            v0 = y - y0,
liveimage_srv/CImg.h:            n0 = 1e-8f + cimg::hypot(u0,v0),
liveimage_srv/CImg.h:            u1 = x1 - x,
liveimage_srv/CImg.h:            v1 = y1 - y,
liveimage_srv/CImg.h:            n1 = 1e-8f + cimg::hypot(u1,v1),
liveimage_srv/CImg.h:            n = 1e-8f + cimg::hypot(u,v),
liveimage_srv/CImg.h:            p0 = is_closed_set?(p + points.width() - 1)%points.width():(p?p - 1:0),
liveimage_srv/CImg.h:            u0 = x - x0,
liveimage_srv/CImg.h:            v0 = y - y0,
liveimage_srv/CImg.h:            w0 = z - z0,
liveimage_srv/CImg.h:            n0 = 1e-8f + cimg::hypot(u0,v0,w0),
liveimage_srv/CImg.h:            u1 = x1 - x,
liveimage_srv/CImg.h:            v1 = y1 - y,
liveimage_srv/CImg.h:            w1 = z1 - z,
liveimage_srv/CImg.h:            n1 = 1e-8f + cimg::hypot(u1,v1,w1),
liveimage_srv/CImg.h:            n = 1e-8f + cimg::hypot(u,v,w),
liveimage_srv/CImg.h:        h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = (longT)x1 - x0, dx02 = (longT)x2 - x0, dx12 = (longT)x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max((longT)1,(longT)y1 - y0),
liveimage_srv/CImg.h:        dy02 = std::max((longT)1,(longT)y2 - y0),
liveimage_srv/CImg.h:        dy12 = std::max((longT)1,(longT)y2 - y1),
liveimage_srv/CImg.h:        const longT yy0 = (longT)y - y0, yy1 = (longT)y - y1;
liveimage_srv/CImg.h:       \param x0 X-coordinate of the first vertex.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the first vertex.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the second vertex.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the second vertex.
liveimage_srv/CImg.h:       \param x2 X-coordinate of the third vertex.
liveimage_srv/CImg.h:       \param y2 Y-coordinate of the third vertex.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the first vertex.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the first vertex.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the second vertex.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the second vertex.
liveimage_srv/CImg.h:       \param x2 X-coordinate of the third vertex.
liveimage_srv/CImg.h:       \param y2 Y-coordinate of the third vertex.
liveimage_srv/CImg.h:    //! Draw a filled 2D triangle, with z-buffering.
liveimage_srv/CImg.h:       \param zbuffer Z-buffer image.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the first vertex.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the first vertex.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the first vertex.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the second vertex.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the second vertex.
liveimage_srv/CImg.h:       \param z1 Z-coordinate of the second vertex.
liveimage_srv/CImg.h:       \param x2 X-coordinate of the third vertex.
liveimage_srv/CImg.h:       \param y2 Y-coordinate of the third vertex.
liveimage_srv/CImg.h:       \param z2 Z-coordinate of the third vertex.
liveimage_srv/CImg.h:                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
liveimage_srv/CImg.h:      const int w1 = width() - 1, h1 = height() - 1, cy0 = cimg::cut(y0,0,h1), cy2 = cimg::cut(y2,0,h1);
liveimage_srv/CImg.h:        dx01 = (longT)x1 - x0, dx02 = (longT)x2 - x0, dx12 = (longT)x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max((longT)1,(longT)y1 - y0),
liveimage_srv/CImg.h:        dy02 = std::max((longT)1,(longT)y2 - y0),
liveimage_srv/CImg.h:        dy12 = std::max((longT)1,(longT)y2 - y1),
liveimage_srv/CImg.h:      const float diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1;
liveimage_srv/CImg.h:        const longT yy0 = (longT)y - y0, yy1 = (longT)y - y1;
liveimage_srv/CImg.h:          const longT dxmM = std::max((longT)1,xM - xm);
liveimage_srv/CImg.h:          const float dizmM = izM - izm;
liveimage_srv/CImg.h:            const longT xxm = x - xm;
liveimage_srv/CImg.h:                const Tfloat val = cbs<=1?color[c]*cbs:(2 - cbs)*color[c] + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:    //! Draw a Gouraud-shaded 2D triangle.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the first vertex in the image instance.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the first vertex in the image instance.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the second vertex in the image instance.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the second vertex in the image instance.
liveimage_srv/CImg.h:       \param x2 X-coordinate of the third vertex in the image instance.
liveimage_srv/CImg.h:       \param y2 Y-coordinate of the third vertex in the image instance.
liveimage_srv/CImg.h:      const int w1 = width() - 1, h1 = height() - 1, cy0 = cimg::cut(y0,0,h1), cy2 = cimg::cut(y2,0,h1);
liveimage_srv/CImg.h:        dx01 = (longT)x1 - x0, dx02 = (longT)x2 - x0, dx12 = (longT)x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max((longT)1,(longT)y1 - y0),
liveimage_srv/CImg.h:        dy02 = std::max((longT)1,(longT)y2 - y0),
liveimage_srv/CImg.h:        dy12 = std::max((longT)1,(longT)y2 - y1),
liveimage_srv/CImg.h:      const float dbs01 = bs1 - bs0, dbs02 = bs2 - bs0, dbs12 = bs2 - bs1;
liveimage_srv/CImg.h:        const longT yy0 = (longT)y - y0, yy1 = (longT)y - y1;
liveimage_srv/CImg.h:          const longT dxmM = std::max((longT)1,xM - xm);
liveimage_srv/CImg.h:          const float dbsmM = bsM - bsm;
liveimage_srv/CImg.h:            const longT xxm = (longT)x - xm;
liveimage_srv/CImg.h:              const Tfloat val = cbs<=1?color[c]*cbs:(2 - cbs)*color[c] + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:    //! Draw a Gouraud-shaded 2D triangle, with z-buffering \overloading.
liveimage_srv/CImg.h:                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
liveimage_srv/CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
liveimage_srv/CImg.h:        dbs01 = bs1 - bs0, dbs02 = bs2 - bs0, dbs12 = bs2 - bs1;
liveimage_srv/CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
liveimage_srv/CImg.h:          const int dxmM = std::max(1,xM - xm);
liveimage_srv/CImg.h:          const float dizmM = izM - izm, dbsmM = bsM - bsm;
liveimage_srv/CImg.h:            const int xxm = x - xm;
liveimage_srv/CImg.h:                const Tfloat val = cbs<=1?color[c]*cbs:(2 - cbs)*color[c] + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:    //! Draw a color-interpolated 2D triangle.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the first vertex in the image instance.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the first vertex in the image instance.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the second vertex in the image instance.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the second vertex in the image instance.
liveimage_srv/CImg.h:       \param x2 X-coordinate of the third vertex in the image instance.
liveimage_srv/CImg.h:       \param y2 Y-coordinate of the third vertex in the image instance.
liveimage_srv/CImg.h:      const int w1 = width() - 1, h1 = height() - 1, cy0 = cimg::cut(y0,0,h1), cy2 = cimg::cut(y2,0,h1);
liveimage_srv/CImg.h:        dx01 = (longT)x1 - x0, dx02 = (longT)x2 - x0, dx12 = (longT)x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max((longT)1,(longT)y1 - y0),
liveimage_srv/CImg.h:        dy02 = std::max((longT)1,(longT)y2 - y0),
liveimage_srv/CImg.h:        dy12 = std::max((longT)1,(longT)y2 - y1),
liveimage_srv/CImg.h:        const stc dcolor01 = color1[c] - color0[c], dcolor02 = color2[c] - color0[c], dcolor12 = color2[c] - color1[c];
liveimage_srv/CImg.h:          const longT yy0 = (longT)y - y0, yy1 = (longT)y - y1;
liveimage_srv/CImg.h:            const longT dxmM = std::max((longT)1,xM - xm);
liveimage_srv/CImg.h:            const stc dcolormM = colorM - colorm;
liveimage_srv/CImg.h:              const longT xxm = (longT)x - xm;
liveimage_srv/CImg.h:       \param x0 X-coordinate of the first vertex in the image instance.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the first vertex in the image instance.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the second vertex in the image instance.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the second vertex in the image instance.
liveimage_srv/CImg.h:       \param x2 X-coordinate of the third vertex in the image instance.
liveimage_srv/CImg.h:       \param y2 Y-coordinate of the third vertex in the image instance.
liveimage_srv/CImg.h:       \param tx0 X-coordinate of the first vertex in the texture image.
liveimage_srv/CImg.h:       \param ty0 Y-coordinate of the first vertex in the texture image.
liveimage_srv/CImg.h:       \param tx1 X-coordinate of the second vertex in the texture image.
liveimage_srv/CImg.h:       \param ty1 Y-coordinate of the second vertex in the texture image.
liveimage_srv/CImg.h:       \param tx2 X-coordinate of the third vertex in the texture image.
liveimage_srv/CImg.h:       \param ty2 Y-coordinate of the third vertex in the texture image.
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
liveimage_srv/CImg.h:        dtx01 = tx1 - tx0, dtx02 = tx2 - tx0, dtx12 = tx2 - tx1,
liveimage_srv/CImg.h:        dty01 = ty1 - ty0, dty02 = ty2 - ty0, dty12 = ty2 - ty1,
liveimage_srv/CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
liveimage_srv/CImg.h:            dxmM = std::max(1,xM - xm), hdxmM = dxmM/2,
liveimage_srv/CImg.h:            dtxmM = txM - txm, dtymM = tyM - tym;
liveimage_srv/CImg.h:              xxm = x - xm,
liveimage_srv/CImg.h:              const Tfloat val = cbs<=1?color[c*twhd]*cbs:(2 - cbs)*color[c*twhd] + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
liveimage_srv/CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
liveimage_srv/CImg.h:        dtxz01 = txz1 - txz0, dtxz02 = txz2 - txz0, dtxz12 = txz2 - txz1,
liveimage_srv/CImg.h:        dtyz01 = tyz1 - tyz0, dtyz02 = tyz2 - tyz0, dtyz12 = tyz2 - tyz1;
liveimage_srv/CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
liveimage_srv/CImg.h:          const int dxmM = std::max(1,xM - xm);
liveimage_srv/CImg.h:          const float dizmM = izM - izm, dtxzmM = txzM - txzm, dtyzmM = tyzM - tyzm;
liveimage_srv/CImg.h:            const int xxm = x - xm;
liveimage_srv/CImg.h:              const Tfloat val = cbs<=1?color[c*twhd]*cbs:(2 - cbs)*color[c*twhd] + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:    //! Draw a textured 2D triangle, with perspective correction and z-buffering.
liveimage_srv/CImg.h:                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
liveimage_srv/CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
liveimage_srv/CImg.h:        dtxz01 = txz1 - txz0, dtxz02 = txz2 - txz0, dtxz12 = txz2 - txz1,
liveimage_srv/CImg.h:        dtyz01 = tyz1 - tyz0, dtyz02 = tyz2 - tyz0, dtyz12 = tyz2 - tyz1;
liveimage_srv/CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
liveimage_srv/CImg.h:          const int dxmM = std::max(1,xM - xm);
liveimage_srv/CImg.h:          const float dizmM = izM - izm, dtxzmM = txzM - txzm, dtyzmM = tyzM - tyzm;
liveimage_srv/CImg.h:            const int xxm = x - xm;
liveimage_srv/CImg.h:                const Tfloat val = cbs<=1?color[c*twhd]*cbs:(2 - cbs)*color[c*twhd] + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:    //! Draw a Phong-shaded 2D triangle.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the first vertex in the image instance.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the first vertex in the image instance.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the second vertex in the image instance.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the second vertex in the image instance.
liveimage_srv/CImg.h:       \param x2 X-coordinate of the third vertex in the image instance.
liveimage_srv/CImg.h:       \param y2 Y-coordinate of the third vertex in the image instance.
liveimage_srv/CImg.h:       \param lx0 X-coordinate of the first vertex in the light image.
liveimage_srv/CImg.h:       \param ly0 Y-coordinate of the first vertex in the light image.
liveimage_srv/CImg.h:       \param lx1 X-coordinate of the second vertex in the light image.
liveimage_srv/CImg.h:       \param ly1 Y-coordinate of the second vertex in the light image.
liveimage_srv/CImg.h:       \param lx2 X-coordinate of the third vertex in the light image.
liveimage_srv/CImg.h:       \param ly2 Y-coordinate of the third vertex in the light image.
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
liveimage_srv/CImg.h:        dlx01 = lx1 - lx0, dlx02 = lx2 - lx0, dlx12 = lx2 - lx1,
liveimage_srv/CImg.h:        dly01 = ly1 - ly0, dly02 = ly2 - ly0, dly12 = ly2 - ly1,
liveimage_srv/CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
liveimage_srv/CImg.h:            dxmM = std::max(1,xM - xm), hdxmM = dxmM/2,
liveimage_srv/CImg.h:            dlxmM = lxM - lxm, dlymM = lyM - lym;
liveimage_srv/CImg.h:              xxm = x - xm,
liveimage_srv/CImg.h:              const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:    //! Draw a Phong-shaded 2D triangle, with z-buffering.
liveimage_srv/CImg.h:                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
liveimage_srv/CImg.h:        dlx01 = lx1 - lx0, dlx02 = lx2 - lx0, dlx12 = lx2 - lx1,
liveimage_srv/CImg.h:        dly01 = ly1 - ly0, dly02 = ly2 - ly0, dly12 = ly2 - ly1,
liveimage_srv/CImg.h:      const float diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1;
liveimage_srv/CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
liveimage_srv/CImg.h:            dxmM = std::max(1,xM - xm), hdxmM = dxmM/2,
liveimage_srv/CImg.h:            dlxmM = lxM - lxm, dlymM = lyM - lym;
liveimage_srv/CImg.h:          const float dizmM = izM - izm;
liveimage_srv/CImg.h:            const int xxm = x - xm;
liveimage_srv/CImg.h:                const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:    //! Draw a textured Gouraud-shaded 2D triangle.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the first vertex in the image instance.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the first vertex in the image instance.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the second vertex in the image instance.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the second vertex in the image instance.
liveimage_srv/CImg.h:       \param x2 X-coordinate of the third vertex in the image instance.
liveimage_srv/CImg.h:       \param y2 Y-coordinate of the third vertex in the image instance.
liveimage_srv/CImg.h:       \param tx0 X-coordinate of the first vertex in the texture image.
liveimage_srv/CImg.h:       \param ty0 Y-coordinate of the first vertex in the texture image.
liveimage_srv/CImg.h:       \param tx1 X-coordinate of the second vertex in the texture image.
liveimage_srv/CImg.h:       \param ty1 Y-coordinate of the second vertex in the texture image.
liveimage_srv/CImg.h:       \param tx2 X-coordinate of the third vertex in the texture image.
liveimage_srv/CImg.h:       \param ty2 Y-coordinate of the third vertex in the texture image.
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
liveimage_srv/CImg.h:        dtx01 = tx1 - tx0, dtx02 = tx2 - tx0, dtx12 = tx2 - tx1,
liveimage_srv/CImg.h:        dty01 = ty1 - ty0, dty02 = ty2 - ty0, dty12 = ty2 - ty1,
liveimage_srv/CImg.h:      const float dbs01 = bs1 - bs0, dbs02 = bs2 - bs0, dbs12 = bs2 - bs1;
liveimage_srv/CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
liveimage_srv/CImg.h:            dxmM = std::max(1,xM - xm), hdxmM = dxmM/2,
liveimage_srv/CImg.h:            dtxmM = txM - txm, dtymM = tyM - tym;
liveimage_srv/CImg.h:          const float dbsmM = bsM - bsm;
liveimage_srv/CImg.h:              xxm = x - xm,
liveimage_srv/CImg.h:              const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:    //! Draw a textured Gouraud-shaded 2D triangle, with perspective correction \overloading.
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
liveimage_srv/CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
liveimage_srv/CImg.h:        dtxz01 = txz1 - txz0, dtxz02 = txz2 - txz0, dtxz12 = txz2 - txz1,
liveimage_srv/CImg.h:        dtyz01 = tyz1 - tyz0, dtyz02 = tyz2 - tyz0, dtyz12 = tyz2 - tyz1,
liveimage_srv/CImg.h:        dbs01 = bs1 - bs0, dbs02 = bs2 - bs0, dbs12 = bs2 - bs1;
liveimage_srv/CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
liveimage_srv/CImg.h:          const int dxmM = std::max(1,xM - xm);
liveimage_srv/CImg.h:          const float dizmM = izM - izm, dtxzmM = txzM - txzm, dtyzmM = tyzM - tyzm, dbsmM = bsM - bsm;
liveimage_srv/CImg.h:            const int xxm = x - xm;
liveimage_srv/CImg.h:              const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:    //! Draw a textured Gouraud-shaded 2D triangle, with perspective correction and z-buffering \overloading.
liveimage_srv/CImg.h:                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
liveimage_srv/CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
liveimage_srv/CImg.h:        dtxz01 = txz1 - txz0, dtxz02 = txz2 - txz0, dtxz12 = txz2 - txz1,
liveimage_srv/CImg.h:        dtyz01 = tyz1 - tyz0, dtyz02 = tyz2 - tyz0, dtyz12 = tyz2 - tyz1,
liveimage_srv/CImg.h:        dbs01 = bs1 - bs0, dbs02 = bs2 - bs0, dbs12 = bs2 - bs1;
liveimage_srv/CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
liveimage_srv/CImg.h:          const int dxmM = std::max(1,xM - xm);
liveimage_srv/CImg.h:          const float dizmM = izM - izm, dtxzmM = txzM - txzm, dtyzmM = tyzM - tyzm, dbsmM = bsM - bsm;
liveimage_srv/CImg.h:            const int xxm = x - xm;
liveimage_srv/CImg.h:                const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:    //! Draw a textured Phong-shaded 2D triangle.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the first vertex in the image instance.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the first vertex in the image instance.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the second vertex in the image instance.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the second vertex in the image instance.
liveimage_srv/CImg.h:       \param x2 X-coordinate of the third vertex in the image instance.
liveimage_srv/CImg.h:       \param y2 Y-coordinate of the third vertex in the image instance.
liveimage_srv/CImg.h:       \param tx0 X-coordinate of the first vertex in the texture image.
liveimage_srv/CImg.h:       \param ty0 Y-coordinate of the first vertex in the texture image.
liveimage_srv/CImg.h:       \param tx1 X-coordinate of the second vertex in the texture image.
liveimage_srv/CImg.h:       \param ty1 Y-coordinate of the second vertex in the texture image.
liveimage_srv/CImg.h:       \param tx2 X-coordinate of the third vertex in the texture image.
liveimage_srv/CImg.h:       \param ty2 Y-coordinate of the third vertex in the texture image.
liveimage_srv/CImg.h:       \param lx0 X-coordinate of the first vertex in the light image.
liveimage_srv/CImg.h:       \param ly0 Y-coordinate of the first vertex in the light image.
liveimage_srv/CImg.h:       \param lx1 X-coordinate of the second vertex in the light image.
liveimage_srv/CImg.h:       \param ly1 Y-coordinate of the second vertex in the light image.
liveimage_srv/CImg.h:       \param lx2 X-coordinate of the third vertex in the light image.
liveimage_srv/CImg.h:       \param ly2 Y-coordinate of the third vertex in the light image.
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
liveimage_srv/CImg.h:        dtx01 = tx1 - tx0, dtx02 = tx2 - tx0, dtx12 = tx2 - tx1,
liveimage_srv/CImg.h:        dty01 = ty1 - ty0, dty02 = ty2 - ty0, dty12 = ty2 - ty1,
liveimage_srv/CImg.h:        dlx01 = lx1 - lx0, dlx02 = lx2 - lx0, dlx12 = lx2 - lx1,
liveimage_srv/CImg.h:        dly01 = ly1 - ly0, dly02 = ly2 - ly0, dly12 = ly2 - ly1,
liveimage_srv/CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
liveimage_srv/CImg.h:            dxmM = std::max(1,xM - xm), hdxmM = dxmM/2,
liveimage_srv/CImg.h:            dtxmM = txM - txm, dtymM = tyM - tym,
liveimage_srv/CImg.h:            dlxmM = lxM - lxm, dlymM = lyM - lym;
liveimage_srv/CImg.h:              xxm = x - xm,
liveimage_srv/CImg.h:              const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:    //! Draw a textured Phong-shaded 2D triangle, with perspective correction.
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
liveimage_srv/CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
liveimage_srv/CImg.h:        dtxz01 = txz1 - txz0, dtxz02 = txz2 - txz0, dtxz12 = txz2 - txz1,
liveimage_srv/CImg.h:        dtyz01 = tyz1 - tyz0, dtyz02 = tyz2 - tyz0, dtyz12 = tyz2 - tyz1,
liveimage_srv/CImg.h:        dlxz01 = lxz1 - lxz0, dlxz02 = lxz2 - lxz0, dlxz12 = lxz2 - lxz1,
liveimage_srv/CImg.h:        dlyz01 = lyz1 - lyz0, dlyz02 = lyz2 - lyz0, dlyz12 = lyz2 - lyz1;
liveimage_srv/CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
liveimage_srv/CImg.h:          const int dxmM = std::max(1,xM - xm);
liveimage_srv/CImg.h:            dizmM = izM - izm,
liveimage_srv/CImg.h:            dtxzmM = txzM - txzm, dtyzmM = tyzM - tyzm,
liveimage_srv/CImg.h:            dlxzmM = lxzM - lxzm, dlyzmM = lyzM - lyzm;
liveimage_srv/CImg.h:            const int xxm = x - xm;
liveimage_srv/CImg.h:              const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:    //! Draw a textured Phong-shaded 2D triangle, with perspective correction and z-buffering.
liveimage_srv/CImg.h:                                    "draw_triangle(): Instance and specified Z-buffer (%u,%u,%u,%u,%p) have "
liveimage_srv/CImg.h:        w1 = width() - 1, h1 = height() - 1,
liveimage_srv/CImg.h:        dx01 = x1 - x0, dx02 = x2 - x0, dx12 = x2 - x1,
liveimage_srv/CImg.h:        dy01 = std::max(1,y1 - y0), dy02 = std::max(1,y2 - y0), dy12 = std::max(1,y2 - y1),
liveimage_srv/CImg.h:        diz01 = iz1 - iz0, diz02 = iz2 - iz0, diz12 = iz2 - iz1,
liveimage_srv/CImg.h:        dtxz01 = txz1 - txz0, dtxz02 = txz2 - txz0, dtxz12 = txz2 - txz1,
liveimage_srv/CImg.h:        dtyz01 = tyz1 - tyz0, dtyz02 = tyz2 - tyz0, dtyz12 = tyz2 - tyz1,
liveimage_srv/CImg.h:        dlxz01 = lxz1 - lxz0, dlxz02 = lxz2 - lxz0, dlxz12 = lxz2 - lxz1,
liveimage_srv/CImg.h:        dlyz01 = lyz1 - lyz0, dlyz02 = lyz2 - lyz0, dlyz12 = lyz2 - lyz1;
liveimage_srv/CImg.h:        const int yy0 = y - y0, yy1 = y - y1;
liveimage_srv/CImg.h:          const int dxmM = std::max(1,xM - xm);
liveimage_srv/CImg.h:            dizmM = izM - izm,
liveimage_srv/CImg.h:            dtxzmM = txzM - txzm, dtyzmM = tyzM - tyzm,
liveimage_srv/CImg.h:            dlxzmM = lxzM - lxzm, dlyzmM = lyzM - lyzm;
liveimage_srv/CImg.h:            const int xxm = x - xm;
liveimage_srv/CImg.h:                const Tfloat val = cbs<=1?cbs*col:(2 - cbs)*col + (cbs - 1)*_sc_maxval;
liveimage_srv/CImg.h:       \param x0 X-coordinate of the upper-left rectangle corner.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the upper-left rectangle corner.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the upper-left rectangle corner.
liveimage_srv/CImg.h:       \param c0 C-coordinate of the upper-left rectangle corner.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the lower-right rectangle corner.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the lower-right rectangle corner.
liveimage_srv/CImg.h:       \param z1 Z-coordinate of the lower-right rectangle corner.
liveimage_srv/CImg.h:       \param c1 C-coordinate of the lower-right rectangle corner.
liveimage_srv/CImg.h:        lx = (1 + nx1 - nx0) + (nx1>=width()?width() - 1 - nx1:0) + (nx0<0?nx0:0),
liveimage_srv/CImg.h:        ly = (1 + ny1 - ny0) + (ny1>=height()?height() - 1 - ny1:0) + (ny0<0?ny0:0),
liveimage_srv/CImg.h:        lz = (1 + nz1 - nz0) + (nz1>=depth()?depth() - 1 - nz1:0) + (nz0<0?nz0:0),
liveimage_srv/CImg.h:        lc = (1 + nc1 - nc0) + (nc1>=spectrum()?spectrum() - 1 - nc1:0) + (nc0<0?nc0:0);
liveimage_srv/CImg.h:        offX = (ulongT)_width - lx,
liveimage_srv/CImg.h:        offY = (ulongT)_width*(_height - ly),
liveimage_srv/CImg.h:        offZ = (ulongT)_width*_height*(_depth - lz);
liveimage_srv/CImg.h:      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
liveimage_srv/CImg.h:       \param x0 X-coordinate of the upper-left rectangle corner.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the upper-left rectangle corner.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the upper-left rectangle corner.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the lower-right rectangle corner.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the lower-right rectangle corner.
liveimage_srv/CImg.h:       \param z1 Z-coordinate of the lower-right rectangle corner.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the upper-left rectangle corner.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the upper-left rectangle corner.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the lower-right rectangle corner.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the lower-right rectangle corner.
liveimage_srv/CImg.h:      return draw_rectangle(x0,y0,0,x1,y1,_depth - 1,color,opacity);
liveimage_srv/CImg.h:        draw_line(nx1,ny0 + 1,nx1,ny1 - 1,color,opacity,pattern,false).
liveimage_srv/CImg.h:        draw_line(nx0,ny1 - 1,nx0,ny0 + 1,color,opacity,pattern,false);
liveimage_srv/CImg.h:      ymax = std::min(height() - 1,ymax);
liveimage_srv/CImg.h:      CImg<intT> Xs(points._width,ymax - ymin + 1);
liveimage_srv/CImg.h:            x01 = x1 - x0, y01 = y1 - y0, y12 = y2 - y1,
liveimage_srv/CImg.h:            tend = tmax - (step==cimg::sign(y12));
liveimage_srv/CImg.h:          unsigned int y = (unsigned int)y0 - ymin;
liveimage_srv/CImg.h:        const CImg<intT> Xsy = Xs.get_shared_points(0,count[y] - 1,y).sort();
liveimage_srv/CImg.h:       \param x0 X-coordinate of the ellipse center.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the ellipse center.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the ellipse center.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the ellipse center.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the ellipse center.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the ellipse center.
liveimage_srv/CImg.h:       \param x0 X-coordinate of the ellipse center.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the ellipse center.
liveimage_srv/CImg.h:      if (radius1<0 || radius2<0 || x0 - radiusM>=width() || y0 + radiusM<0 || y0 - radiusM>=height()) return *this;
liveimage_srv/CImg.h:          points(k,0) = (int)cimg::round(x0 + (X*ca - Y*sa));
liveimage_srv/CImg.h:          sa = -std::sin(ang),
liveimage_srv/CImg.h:          t2 = (i2 - i1)*casa,
liveimage_srv/CImg.h:          _ymin = (int)std::floor(y0 - radiusM),
liveimage_srv/CImg.h:          ymax = _ymax>=height()?height() - 1:_ymax;
liveimage_srv/CImg.h:            Y = y - y0 + 0.5f,
liveimage_srv/CImg.h:            C = t3*Y*Y - 1,
liveimage_srv/CImg.h:            D = B*B - 4*t1*C;
liveimage_srv/CImg.h:              xmin = (int)(x0 + cimg::round((-B - sD)/t12)),
liveimage_srv/CImg.h:              xmax = (int)(x0 + cimg::round((-B + sD)/t12));
liveimage_srv/CImg.h:       \param x0 X-coordinate of the circle center.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the circle center.
liveimage_srv/CImg.h:       - Circle version of the Bresenham's algorithm is used.
liveimage_srv/CImg.h:      if (radius<0 || x0 - radius>=width() || y0 + radius<0 || y0 - radius>=height()) return *this;
liveimage_srv/CImg.h:      if (y0>=0 && y0<height()) cimg_draw_scanline(x0 - radius,x0 + radius,y0,color,opacity,1);
liveimage_srv/CImg.h:      for (int f = 1 - radius, ddFx = 0, ddFy = -(radius<<1), x = 0, y = radius; x<y; ) {
liveimage_srv/CImg.h:          const int x1 = x0 - x, x2 = x0 + x, y1 = y0 - y, y2 = y0 + y;
liveimage_srv/CImg.h:          f+=(ddFy+=2); --y;
liveimage_srv/CImg.h:        const int x1 = x0 - y, x2 = x0 + y, y1 = y0 - x, y2 = y0 + x;
liveimage_srv/CImg.h:       \param x0 X-coordinate of the circle center.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the circle center.
liveimage_srv/CImg.h:      if (radius<0 || x0 - radius>=width() || y0 + radius<0 || y0 - radius>=height()) return *this;
liveimage_srv/CImg.h:      draw_point(x0 - radius,y0,color,opacity).draw_point(x0 + radius,y0,color,opacity).
liveimage_srv/CImg.h:        draw_point(x0,y0 - radius,color,opacity).draw_point(x0,y0 + radius,color,opacity);
liveimage_srv/CImg.h:      for (int f = 1 - radius, ddFx = 0, ddFy = -(radius<<1), x = 0, y = radius; x<y; ) {
liveimage_srv/CImg.h:        if (f>=0) { f+=(ddFy+=2); --y; }
liveimage_srv/CImg.h:          const int x1 = x0 - y, x2 = x0 + y, y1 = y0 - x, y2 = y0 + x,
liveimage_srv/CImg.h:            x3 = x0 - x, x4 = x0 + x, y3 = y0 - y, y4 = y0 + y;
liveimage_srv/CImg.h:       \param x0 X-coordinate of the sprite position.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the sprite position.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the sprite position.
liveimage_srv/CImg.h:       \param c0 C-coordinate of the sprite position.
liveimage_srv/CImg.h:        sx0 = dx0 - x0,  sy0 = dy0 - y0, sz0 = dz0 - z0, sc0 = dc0 - c0,
liveimage_srv/CImg.h:        lx = sprite.width() - sx0 - (x0 + sprite.width()>width()?x0 + sprite.width() - width():0),
liveimage_srv/CImg.h:        ly = sprite.height() - sy0 - (y0 + sprite.height()>height()?y0 + sprite.height() - height():0),
liveimage_srv/CImg.h:        lz = sprite.depth() - sz0 - (z0 + sprite.depth()>depth()?z0 + sprite.depth() - depth():0),
liveimage_srv/CImg.h:        lc = sprite.spectrum() - sc0 - (c0 + sprite.spectrum()>spectrum()?c0 + sprite.spectrum() - spectrum():0);
liveimage_srv/CImg.h:      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
liveimage_srv/CImg.h:        sx0 = dx0 - x0,  sy0 = dy0 - y0, sz0 = dz0 - z0, sc0 = dc0 - c0,
liveimage_srv/CImg.h:        lx = sprite.width() - sx0 - (x0 + sprite.width()>width()?x0 + sprite.width() - width():0),
liveimage_srv/CImg.h:        ly = sprite.height() - sy0 - (y0 + sprite.height()>height()?y0 + sprite.height() - height():0),
liveimage_srv/CImg.h:        lz = sprite.depth() - sz0 - (z0 + sprite.depth()>depth()?z0 + sprite.depth() - depth():0),
liveimage_srv/CImg.h:        lc = sprite.spectrum() - sc0 - (c0 + sprite.spectrum()>spectrum()?c0 + sprite.spectrum() - spectrum():0);
liveimage_srv/CImg.h:      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
liveimage_srv/CImg.h:       \param x0 X-coordinate of the sprite position in the image instance.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the sprite position in the image instance.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the sprite position in the image instance.
liveimage_srv/CImg.h:       \param c0 C-coordinate of the sprite position in the image instance.
liveimage_srv/CImg.h:       - Pixel values of \c mask set the opacity of the corresponding pixels in \c sprite.
liveimage_srv/CImg.h:       - Dimensions along x,y and z of \p sprite and \p mask must be the same.
liveimage_srv/CImg.h:        sx0 = dx0 - x0,  sy0 = dy0 - y0, sz0 = dz0 - z0, sc0 = dc0 - c0,
liveimage_srv/CImg.h:        lx = sprite.width() - sx0 - (x0 + sprite.width()>width()?x0 + sprite.width() - width():0),
liveimage_srv/CImg.h:        ly = sprite.height() - sy0 - (y0 + sprite.height()>height()?y0 + sprite.height() - height():0),
liveimage_srv/CImg.h:        lz = sprite.depth() - sz0 - (z0 + sprite.depth()>depth()?z0 + sprite.depth() - depth():0),
liveimage_srv/CImg.h:        lc = sprite.spectrum() - sc0 - (c0 + sprite.spectrum()>spectrum()?c0 + sprite.spectrum() - spectrum():0);
liveimage_srv/CImg.h:                  nopacity = cimg::abs(mopacity), copacity = mask_max_value - std::max(mopacity,0.f);
liveimage_srv/CImg.h:       \param x0 X-coordinate of the text in the image instance.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the text in the image instance.
liveimage_srv/CImg.h:       \param text Format of the text ('printf'-style format string).
liveimage_srv/CImg.h:       \param x0 X-coordinate of the text in the image instance.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the text in the image instance.
liveimage_srv/CImg.h:       \param text Format of the text ('printf'-style format string).
liveimage_srv/CImg.h:        // Pre-compute necessary size of the image as well as left paddings of each character.
liveimage_srv/CImg.h:                else if ((o_ch<'0' || o_ch>'9') && ch!='-') {
liveimage_srv/CImg.h:                      const int w1 = mask.width()>0?o_mask.width() - 1:0, w2 = w1>1?w1 - 1:0, w3 = w2>1?w2 - 1:0;
liveimage_srv/CImg.h:                      left_padding = -10;
liveimage_srv/CImg.h:                                 o_mask._width<=2 || o_mask(w2,k)>=8?-1:
liveimage_srv/CImg.h:                                 o_mask._width<=3 || o_mask(w3,k)>=8?-2:-3,
liveimage_srv/CImg.h:                                 mask._width<=2 || mask(1,k)>=8?-1:
liveimage_srv/CImg.h:                                 mask._width<=3 || mask(2,k)>=8?-2:-3;
liveimage_srv/CImg.h:          if (background_color) draw_rectangle(x,y,x + lw - 1,y + lh - 1,background_color,opacity);
liveimage_srv/CImg.h:                letter.assign(letter.get_resize(-100,-100,1,_spectrum,0,2),false);
liveimage_srv/CImg.h:                    draw_rectangle(x,y,0,c,posx + letter._width - 1,y + letter._height - 1,0,c,
liveimage_srv/CImg.h:      a_label+=(255 - a_label.get_dilate(3)).normalize(0,80);
liveimage_srv/CImg.h:      a_label.resize(-100,-100,1,3,1);
liveimage_srv/CImg.h:      return draw_image(0,is_down?height() - a_label.height():0,a_label,0.85f);
liveimage_srv/CImg.h:                         const unsigned int sampling=25, const float factor=-20,
liveimage_srv/CImg.h:       \param color Image of spectrum()-D vectors corresponding to the color of each arrow.
liveimage_srv/CImg.h:                         const unsigned int sampling=25, const float factor=-20,
liveimage_srv/CImg.h:        fact = -factor;
liveimage_srv/CImg.h:              draw_line((int)(x - 0.5*u),(int)(y - 0.5*v),(int)(x + 0.5*u),(int)(y + 0.5*v),
liveimage_srv/CImg.h:            else draw_line((int)(x - 0.5*u),(int)(y - 0.5*v),(int)(x + 0.5*u),(int)(y + 0.5*v),
liveimage_srv/CImg.h:       \param y Y-coordinate of the horizontal axis in the image instance.
liveimage_srv/CImg.h:      const int yt = (y + 3 + font_height)<_height?y + 3:y - 2 - (int)font_height;
liveimage_srv/CImg.h:      const int siz = (int)values_x.size() - 1;
liveimage_srv/CImg.h:        draw_line(0,y,_width - 1,y,color,opacity,pattern);
liveimage_srv/CImg.h:            _xt = (width() - a_label.width())/2,
liveimage_srv/CImg.h:            xt = _xt<3?3:_xt + a_label.width()>=width() - 2?width() - 3 - a_label.width():_xt;
liveimage_srv/CImg.h:          draw_point(width()/2,y - 1,color,opacity).draw_point(width()/2,y + 1,color,opacity);
liveimage_srv/CImg.h:        if (values_x[0]<values_x[siz]) draw_arrow(0,y,_width - 1,y,color,opacity,30,5,pattern);
liveimage_srv/CImg.h:        else draw_arrow(_width - 1,y,0,y,color,opacity,30,5,pattern);
liveimage_srv/CImg.h:            xi = (int)(x*(_width - 1)/siz),
liveimage_srv/CImg.h:            _xt = xi - a_label.width()/2,
liveimage_srv/CImg.h:            xt = _xt<3?3:_xt + a_label.width()>=width() - 2?width() - 3 - a_label.width():_xt;
liveimage_srv/CImg.h:          draw_point(xi,y - 1,color,opacity).draw_point(xi,y + 1,color,opacity);
liveimage_srv/CImg.h:       \param x X-coordinate of the vertical axis in the image instance.
liveimage_srv/CImg.h:       \param values_y Values along the Y-axis.
liveimage_srv/CImg.h:      int siz = (int)values_y.size() - 1;
liveimage_srv/CImg.h:        draw_line(x,0,x,_height - 1,color,opacity,pattern);
liveimage_srv/CImg.h:            _yt = (height() - a_label.height())/2,
liveimage_srv/CImg.h:            yt = _yt<0?0:_yt + a_label.height()>=height()?height() - 1 - a_label.height():_yt,
liveimage_srv/CImg.h:            _xt = x - 2 - a_label.width(),
liveimage_srv/CImg.h:          draw_point(x - 1,height()/2,color,opacity).draw_point(x + 1,height()/2,color,opacity);
liveimage_srv/CImg.h:        if (values_y[0]<values_y[siz]) draw_arrow(x,0,x,_height - 1,color,opacity,30,5,pattern);
liveimage_srv/CImg.h:        else draw_arrow(x,_height - 1,x,0,color,opacity,30,5,pattern);
liveimage_srv/CImg.h:            yi = (int)(y*(_height - 1)/siz),
liveimage_srv/CImg.h:            _yt = yi - a_label.height()/2,
liveimage_srv/CImg.h:            yt = _yt<0?0:_yt + a_label.height()>=height()?height() - 1 - a_label.height():_yt,
liveimage_srv/CImg.h:            _xt = x - 2 - a_label.width(),
liveimage_srv/CImg.h:          draw_point(x - 1,yi,color,opacity).draw_point(x + 1,yi,color,opacity);
liveimage_srv/CImg.h:       \param values_x Values along the X-axis.
liveimage_srv/CImg.h:       \param values_y Values along the Y-axis.
liveimage_srv/CImg.h:       \param pattern_x Drawing pattern for the X-axis.
liveimage_srv/CImg.h:       \param pattern_y Drawing pattern for the Y-axis.
liveimage_srv/CImg.h:      const int sizx = (int)values_x.size() - 1, wm1 = width() - 1;
liveimage_srv/CImg.h:            draw_axis(nx==0?x:x - 1,values_y,color,opacity,pattern_y,font_height,allow_zero,round_y);
liveimage_srv/CImg.h:      const int sizy = (int)values_y.size() - 1, hm1 = height() - 1;
liveimage_srv/CImg.h:            draw_axis(values_x,ny==0?y:y - 1,color,opacity,pattern_x,font_height,allow_zero,round_x);
liveimage_srv/CImg.h:                       const int subdivisionx=-60, const int subdivisiony=-60,
liveimage_srv/CImg.h:        dx = cimg::abs(x1 - x0), dy = cimg::abs(y1 - y0),
liveimage_srv/CImg.h:        px = dx<=0?1:precisionx==0?(float)std::pow(10.,(int)std::log10(dx) - 2.):precisionx,
liveimage_srv/CImg.h:        py = dy<=0?1:precisiony==0?(float)std::pow(10.,(int)std::log10(dy) - 2.):precisiony;
liveimage_srv/CImg.h:        draw_axes(CImg<floatT>::sequence(subdivisionx>0?subdivisionx:1-width()/subdivisionx,x0,x1),
liveimage_srv/CImg.h:                  CImg<floatT>::sequence(subdivisiony>0?subdivisiony:1-height()/subdivisiony,y0,y1),
liveimage_srv/CImg.h:        draw_axis((int)x0,CImg<floatT>::sequence(subdivisiony>0?subdivisiony:1-height()/subdivisiony,y0,y1),
liveimage_srv/CImg.h:        draw_axis(CImg<floatT>::sequence(subdivisionx>0?subdivisionx:1-width()/subdivisionx,x0,x1),(int)y0,
liveimage_srv/CImg.h:       \param values_x X-coordinates of the vertical lines.
liveimage_srv/CImg.h:       \param values_y Y-coordinates of the horizontal lines.
liveimage_srv/CImg.h:          if (xi>=0 && xi<width()) draw_line(xi,0,xi,_height - 1,color,opacity,pattern_x);
liveimage_srv/CImg.h:          if (yi>=0 && yi<height()) draw_line(0,yi,_width - 1,yi,color,opacity,pattern_y);
liveimage_srv/CImg.h:        const float dx = delta_x>0?delta_x:_width*-delta_x/100;
liveimage_srv/CImg.h:        if (invertx) cimg_foroff(seqx,x) seqx(x) = _width - 1 - seqx(x);
liveimage_srv/CImg.h:        const float dy = delta_y>0?delta_y:_height*-delta_y/100;
liveimage_srv/CImg.h:        if (inverty) cimg_foroff(seqy,y) seqy(y) = _height - 1 - seqy(y);
liveimage_srv/CImg.h:                      - 0 = No plot.
liveimage_srv/CImg.h:                      - 1 = Plot using segments.
liveimage_srv/CImg.h:                      - 2 = Plot using cubic splines.
liveimage_srv/CImg.h:                      - 3 = Plot with bars.
liveimage_srv/CImg.h:                      - 0 = No points.
liveimage_srv/CImg.h:                      - 1 = Point.
liveimage_srv/CImg.h:                      - 2 = Straight cross.
liveimage_srv/CImg.h:                      - 3 = Diagonal cross.
liveimage_srv/CImg.h:                      - 4 = Filled circle.
liveimage_srv/CImg.h:                      - 5 = Outlined circle.
liveimage_srv/CImg.h:                      - 6 = Square.
liveimage_srv/CImg.h:                      - 7 = Diamond.
liveimage_srv/CImg.h:       \param ymin Lower bound of the y-range.
liveimage_srv/CImg.h:       \param ymax Upper bound of the y-range.
liveimage_srv/CImg.h:         - if \c ymin==ymax==0, the y-range is computed automatically from the input samples.
liveimage_srv/CImg.h:        _siz1 = siz - (plot_type!=3),
liveimage_srv/CImg.h:        _width1 = _width - (plot_type!=3),
liveimage_srv/CImg.h:      if (m==M) { --m; ++M; }
liveimage_srv/CImg.h:      const float ca = (float)(M-m)/(_height - 1);
liveimage_srv/CImg.h:        int oX = 0, oY = (int)cimg::round((data[0] - m)/ca);
liveimage_srv/CImg.h:          const int Y = (int)cimg::round((*data - m)/ca);
liveimage_srv/CImg.h:          draw_line(0,Y,width() - 1,Y,color,opacity,pattern);
liveimage_srv/CImg.h:              X = (int)cimg::round(off*fx) - 1,
liveimage_srv/CImg.h:              Y = (int)cimg::round((data[off]-m)/ca);
liveimage_srv/CImg.h:        int oY = (int)cimg::round((data[0] - m)/ca);
liveimage_srv/CImg.h:          const int Y = (int)cimg::round((ndata._cubic_atX((float)x*siz1/width1)-m)/ca);
liveimage_srv/CImg.h:        const int Y0 = (int)cimg::round(-m/ca);
liveimage_srv/CImg.h:            X = (int)cimg::round((off + 1)*fx) - 1,
liveimage_srv/CImg.h:            Y = (int)cimg::round((data[off] - m)/ca);
liveimage_srv/CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
liveimage_srv/CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
liveimage_srv/CImg.h:          draw_line(X - 3,Y,X + 3,Y,color,opacity).draw_line(X,Y - 3,X,Y + 3,color,opacity);
liveimage_srv/CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
liveimage_srv/CImg.h:          draw_line(X - 3,Y - 3,X + 3,Y + 3,color,opacity).draw_line(X - 3,Y + 3,X + 3,Y - 3,color,opacity);
liveimage_srv/CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
liveimage_srv/CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
liveimage_srv/CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
liveimage_srv/CImg.h:          draw_rectangle(X - 3,Y - 3,X + 3,Y + 3,color,opacity,~0U);
liveimage_srv/CImg.h:            Y = (int)cimg::round((data[off]-m)/ca);
liveimage_srv/CImg.h:          draw_line(X,Y - 4,X + 4,Y,color,opacity).
liveimage_srv/CImg.h:            draw_line(X,Y + 4,X - 4,Y,color,opacity).
liveimage_srv/CImg.h:            draw_line(X - 4,Y,X,Y - 4,color,opacity);
liveimage_srv/CImg.h:      cimg_forC(*this,c) { diff += cimg::sqr(*ptr1 - *(ptr2++)); ptr1+=off; }
liveimage_srv/CImg.h:       \param x0 X-coordinate of the starting point of the region to fill.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the starting point of the region to fill.
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the starting point of the region to fill.
liveimage_srv/CImg.h:       \param is_high_connectivity Tells if 8-connexity must be used.
liveimage_srv/CImg.h:#define _draw_fill_pop(x,y,z) x = stack[--N]; y = stack(N,1); z = stack(N,2)
liveimage_srv/CImg.h:      const float nopacity = cimg::abs((float)opacity), copacity = 1 - std::max((float)opacity,0.f);
liveimage_srv/CImg.h:          const int yp = y - 1, yn = y + 1, zp = z - 1, zn = z + 1;
liveimage_srv/CImg.h:          for (int step = -1; step<2; step+=2) {
liveimage_srv/CImg.h:                const int xp = x - 1, xn = x + 1;
liveimage_srv/CImg.h:            else xr = --x;
liveimage_srv/CImg.h:          std::memset(_region.data(xl,y,z),1,xr - xl + 1);
liveimage_srv/CImg.h:              const int dx = xr - xl + 1;
liveimage_srv/CImg.h:       \param alpha Alpha-parameter.
liveimage_srv/CImg.h:       \param beta Beta-parameter.
liveimage_srv/CImg.h:       \param scale Scale-parameter.
liveimage_srv/CImg.h:       \note Use the mid-point algorithm to render.
liveimage_srv/CImg.h:                                          r*cimg::rand(-1,1,&rng));
liveimage_srv/CImg.h:          for (int y = -delta2; y<h; y+=delta)
liveimage_srv/CImg.h:                                          r*cimg::rand(-1,1,&rng));
liveimage_srv/CImg.h:            for (int x = -delta2; x<w; x+=delta) {
liveimage_srv/CImg.h:                                          r*cimg::rand(-1,1,&rng));
liveimage_srv/CImg.h:          for (int y = -delta2; y<h; y+=delta)
liveimage_srv/CImg.h:            for (int x = -delta2; x<w; x+=delta) {
liveimage_srv/CImg.h:                                          r*cimg::rand(-1,1,&rng));
liveimage_srv/CImg.h:       \param x0 X-coordinate of the upper-left pixel.
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the upper-left pixel.
liveimage_srv/CImg.h:       \param x1 X-coordinate of the lower-right pixel.
liveimage_srv/CImg.h:       \param y1 Y-coordinate of the lower-right pixel.
liveimage_srv/CImg.h:       \param z0r Real part of the upper-left fractal vertex.
liveimage_srv/CImg.h:       \param z0i Imaginary part of the upper-left fractal vertex.
liveimage_srv/CImg.h:       \param z1r Real part of the lower-right fractal vertex.
liveimage_srv/CImg.h:       \param z1i Imaginary part of the lower-right fractal vertex.
liveimage_srv/CImg.h:                             const double z0r=-2, const double z0i=-2, const double z1r=2, const double z1i=2,
liveimage_srv/CImg.h:      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f), ln2 = (float)std::log(2.);
liveimage_srv/CImg.h:        _x0 = cimg::cut(x0,0,width() - 1),
liveimage_srv/CImg.h:        _y0 = cimg::cut(y0,0,height() - 1),
liveimage_srv/CImg.h:        _x1 = cimg::cut(x1,0,width() - 1),
liveimage_srv/CImg.h:        _y1 = cimg::cut(y1,0,height() - 1);
liveimage_srv/CImg.h:                         cimg_openmp_if((1 + _x1 - _x0)*(1 + _y1 - _y0)>=(cimg_openmp_sizefactor)*2048))
liveimage_srv/CImg.h:          const double x = z0r + p*(z1r-z0r)/_width, y = z0i + q*(z1i-z0i)/_height;
liveimage_srv/CImg.h:            const double temp = zr*zr - zi*zi + cr;
liveimage_srv/CImg.h:              niteration = (float)(iteration + 1 - std::log(std::log(normz))/ln2);
liveimage_srv/CImg.h:                             const double z0r=-2, const double z0i=-2, const double z1r=2, const double z1i=2,
liveimage_srv/CImg.h:      return draw_mandelbrot(0,0,_width - 1,_height - 1,colormap,opacity,
liveimage_srv/CImg.h:       \param xc X-coordinate of the gaussian center.
liveimage_srv/CImg.h:      const float sigma2 = 2*sigma*sigma, nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
liveimage_srv/CImg.h:        const float dx = (x - xc), val = (float)std::exp(-dx*dx/sigma2);
liveimage_srv/CImg.h:        col-=_spectrum;
liveimage_srv/CImg.h:       \param xc X-coordinate of the gaussian center.
liveimage_srv/CImg.h:       \param yc Y-coordinate of the gaussian center.
liveimage_srv/CImg.h:      const CImg<tfloat> invT = tensor.get_invert(), invT2 = (invT*invT)/=-2.;
liveimage_srv/CImg.h:      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
liveimage_srv/CImg.h:      float dy = -yc;
liveimage_srv/CImg.h:        float dx = -xc;
liveimage_srv/CImg.h:          col-=_spectrum;
liveimage_srv/CImg.h:        b = (r1-r2)*ru*rv,
liveimage_srv/CImg.h:      const CImg<tfloat> invT = tensor.get_invert(), invT2 = (invT*invT)/=-2.;
liveimage_srv/CImg.h:      const float nopacity = cimg::abs(opacity), copacity = 1 - std::max(opacity,0.f);
liveimage_srv/CImg.h:          dx = (x - xc), dy = (y - yc), dz = (z - zc),
liveimage_srv/CImg.h:        col-=_spectrum;
liveimage_srv/CImg.h:       \param x0 X-coordinate of the 3D object position
liveimage_srv/CImg.h:       \param y0 Y-coordinate of the 3D object position
liveimage_srv/CImg.h:       \param z0 Z-coordinate of the 3D object position
liveimage_srv/CImg.h:       \param lightx X-coordinate of the light
liveimage_srv/CImg.h:       \param lighty Y-coordinate of the light
liveimage_srv/CImg.h:       \param lightz Z-coordinate of the light
liveimage_srv/CImg.h:                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
liveimage_srv/CImg.h:                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
liveimage_srv/CImg.h:                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
liveimage_srv/CImg.h:                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
liveimage_srv/CImg.h:                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
liveimage_srv/CImg.h:                           const float lightx=0, const float lighty=0, const float lightz=-5e8,
liveimage_srv/CImg.h:      if (render_type==5) cimg::mutex(10); // Static variable used in this case, breaks thread-safety
liveimage_srv/CImg.h:        nspec = 1 - (specular_lightness<0.f?0.f:(specular_lightness>1.f?1.f:specular_lightness)),
liveimage_srv/CImg.h:        nsl1 = (nspec2 - 1)/cimg::sqr(nspec - 1),
liveimage_srv/CImg.h:        nsl2 = 1 - 2*nsl1*nspec,
liveimage_srv/CImg.h:        nsl3 = nspec2 - nsl1 - nsl2;
liveimage_srv/CImg.h:      // Create light texture for phong-like rendering.
liveimage_srv/CImg.h:            (default_light_texture.assign(img,false)/=255).resize(-100,-100,1,_spectrum);
liveimage_srv/CImg.h:              dlx = lightx - X,
liveimage_srv/CImg.h:              dly = lighty - Y,
liveimage_srv/CImg.h:              dlz = lightz - Z,
liveimage_srv/CImg.h:              nlx = (default_light_texture._width - 1)/2*(1 + dlx/nl),
liveimage_srv/CImg.h:              nly = (default_light_texture._height - 1)/2*(1 + dly/nl),
liveimage_srv/CImg.h:            default_light_texture.resize(-100,-100,1,_spectrum);
liveimage_srv/CImg.h:      const float _focale = absfocale?absfocale:(1e5f-parallzmin);
liveimage_srv/CImg.h:      const tpfloat zmin = absfocale?(tpfloat)(1.5f - absfocale):cimg::type<tpfloat>::min();
liveimage_srv/CImg.h:            radius = 0.5f*cimg::hypot(vertices(i1,0) - vertices(i0,0),
liveimage_srv/CImg.h:                                      vertices(i1,1) - vertices(i0,1),
liveimage_srv/CImg.h:                                      vertices(i1,2) - vertices(i0,2))*(absfocale?absfocale/zc:1),
liveimage_srv/CImg.h:            xm = xc - radius,
liveimage_srv/CImg.h:            ym = yc - radius,
liveimage_srv/CImg.h:            const tpfloat d = (x1-x0)*(y2-y0) - (x2-x0)*(y1-y0);
liveimage_srv/CImg.h:            const float d = (x1 - x0)*(y2 - y0) - (x2 - x0)*(y1 - y0);
liveimage_srv/CImg.h:          if (___draw_object3d(opacities,l)!=1) zrange(l) = 2*zmax - zrange(l);
liveimage_srv/CImg.h:      const unsigned int nb_visibles = (unsigned int)(p_zrange - zrange._data);
liveimage_srv/CImg.h:              dx1 = x1 - x0, dy1 = y1 - y0, dz1 = z1 - z0,
liveimage_srv/CImg.h:              dx2 = x2 - x0, dy2 = y2 - y0, dz2 = z2 - z0,
liveimage_srv/CImg.h:              nx = dy1*dz2 - dz1*dy2,
liveimage_srv/CImg.h:              ny = dz1*dx2 - dx1*dz2,
liveimage_srv/CImg.h:              nz = dx1*dy2 - dy1*dx2,
liveimage_srv/CImg.h:              norm = 1e-5f + cimg::hypot(nx,ny,nz),
liveimage_srv/CImg.h:              lx = X + (x0 + x1 + x2)/3 - lightx,
liveimage_srv/CImg.h:              ly = Y + (y0 + y1 + y2)/3 - lighty,
liveimage_srv/CImg.h:              lz = Z + (z0 + z1 + z2)/3 - lightz,
liveimage_srv/CImg.h:              nl = 1e-5f + cimg::hypot(lx,ly,lz),
liveimage_srv/CImg.h:              factor = std::max(cimg::abs(-lx*nx - ly*ny - lz*nz)/(norm*nl),(tpfloat)0);
liveimage_srv/CImg.h:      case 5 : { // Phong-Shading
liveimage_srv/CImg.h:              dx1 = x1 - x0, dy1 = y1 - y0, dz1 = z1 - z0,
liveimage_srv/CImg.h:              dx2 = x2 - x0, dy2 = y2 - y0, dz2 = z2 - z0,
liveimage_srv/CImg.h:              nnx = dy1*dz2 - dz1*dy2,
liveimage_srv/CImg.h:              nny = dz1*dx2 - dx1*dz2,
liveimage_srv/CImg.h:              nnz = dx1*dy2 - dy1*dx2,
liveimage_srv/CImg.h:              norm = 1e-5f + cimg::hypot(nnx,nny,nnz),
liveimage_srv/CImg.h:              vertices_normals(p,0) = -nx1;
liveimage_srv/CImg.h:              vertices_normals(p,1) = -ny1;
liveimage_srv/CImg.h:              vertices_normals(p,2) = -nz1;
liveimage_srv/CImg.h:              norm = 1e-5f + cimg::hypot(nx,ny,nz),
liveimage_srv/CImg.h:              lx = X + vertices(l,0) - lightx,
liveimage_srv/CImg.h:              ly = Y + vertices(l,1) - lighty,
liveimage_srv/CImg.h:              lz = Z + vertices(l,2) - lightz,
liveimage_srv/CImg.h:              nl = 1e-5f + cimg::hypot(lx,ly,lz),
liveimage_srv/CImg.h:              factor = std::max((-lx*nx - ly*ny - lz*nz)/(norm*nl),(tpfloat)0);
liveimage_srv/CImg.h:            lw2 = light_texture._width/2 - 1,
liveimage_srv/CImg.h:            lh2 = light_texture._height/2 - 1;
liveimage_srv/CImg.h:              norm = 1e-5f + cimg::hypot(nx,ny,nz),
liveimage_srv/CImg.h:            __color.get_resize(-100,-100,-100,_spectrum,0):CImg<tc>(),
liveimage_srv/CImg.h:                board.drawDot((float)x0,height()-(float)y0);
liveimage_srv/CImg.h:              const int nx0 = x0 - (int)sw/2, ny0 = y0 - (int)sh/2;
liveimage_srv/CImg.h:                  (nx0 + (int)sw/2>=0 || nx0 - (int)sw/2<width() || ny0 + (int)sh/2>=0 || ny0 - (int)sh/2<height())) {
liveimage_srv/CImg.h:                    color.get_resize(sw,sh,1,-100,render_type<=3?1:3):CImg<tc>(),
liveimage_srv/CImg.h:                  board.drawRectangle((float)nx0,height() - (float)ny0,sw,sh);
liveimage_srv/CImg.h:            const int nx0 = x0 - (int)sw/2, ny0 = y0 - (int)sh/2;
liveimage_srv/CImg.h:                (nx0 + (int)sw/2>=0 || nx0 - (int)sw/2<width() || ny0 + (int)sh/2>=0 || ny0 - (int)sh/2<height())) {
liveimage_srv/CImg.h:                  color.get_resize(sw,sh,1,-100,render_type<=3?1:3):CImg<tc>(),
liveimage_srv/CImg.h:                  _opacity.get_resize(sw,sh,1,-100,render_type<=3?1:3):CImg<_to>(),
liveimage_srv/CImg.h:                board.drawRectangle((float)nx0,height() - (float)ny0,sw,sh);
liveimage_srv/CImg.h:              board.drawLine((float)x0,height() - (float)y0,x1,height() - (float)y1);
liveimage_srv/CImg.h:              board.drawDot((float)x0,height() - (float)y0);
liveimage_srv/CImg.h:              board.drawDot((float)x1,height() - (float)y1);
liveimage_srv/CImg.h:            radius = cimg::hypot(vertices(n1,0) - vertices(n0,0),
liveimage_srv/CImg.h:                                 vertices(n1,1) - vertices(n0,1),
liveimage_srv/CImg.h:                                 vertices(n1,2) - vertices(n0,2));
liveimage_srv/CImg.h:            radius = 0.5f*cimg::hypot(vertices(n1,0) - vertices(n0,0),
liveimage_srv/CImg.h:                                      vertices(n1,1) - vertices(n0,1),
liveimage_srv/CImg.h:                                      vertices(n1,2) - vertices(n0,2));
liveimage_srv/CImg.h:              board.drawDot(xc,height() - yc);
liveimage_srv/CImg.h:              board.drawCircle(xc,height() - yc,radius);
liveimage_srv/CImg.h:              if (!is_wireframe) board.fillCircle(xc,height() - yc,radius);
liveimage_srv/CImg.h:                board.drawCircle(xc,height() - yc,radius);
liveimage_srv/CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x1,height() - (float)y1);
liveimage_srv/CImg.h:            draw_point(x0,y0,color.get_vector_at(tx0<=0?0:tx0>=color.width()?color.width() - 1:tx0,
liveimage_srv/CImg.h:                                                 ty0<=0?0:ty0>=color.height()?color.height() - 1:ty0)._data,opacity).
liveimage_srv/CImg.h:              draw_point(x1,y1,color.get_vector_at(tx1<=0?0:tx1>=color.width()?color.width() - 1:tx1,
liveimage_srv/CImg.h:                                                   ty1<=0?0:ty1>=color.height()?color.height() - 1:ty1)._data,opacity);
liveimage_srv/CImg.h:              board.drawDot((float)x0,height() - (float)y0);
liveimage_srv/CImg.h:              board.drawDot((float)x1,height() - (float)y1);
liveimage_srv/CImg.h:              board.drawDot((float)x0,height() - (float)y0);
liveimage_srv/CImg.h:              board.drawDot((float)x1,height() - (float)y1);
liveimage_srv/CImg.h:              board.drawDot((float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x1,height() - (float)y1);
liveimage_srv/CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.drawLine((float)x1,height() - (float)y1,(float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
liveimage_srv/CImg.h:                                 (float)x1,height() - (float)y1,
liveimage_srv/CImg.h:                                 (float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
liveimage_srv/CImg.h:                                 (float)x1,height() - (float)y1,
liveimage_srv/CImg.h:                                 (float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,lightprops(n0),
liveimage_srv/CImg.h:                                         (float)x1,height() - (float)y1,lightprops(n1),
liveimage_srv/CImg.h:                                         (float)x2,height() - (float)y2,lightprops(n2));
liveimage_srv/CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,l0,
liveimage_srv/CImg.h:                                         (float)x1,height() - (float)y1,l1,
liveimage_srv/CImg.h:                                         (float)x2,height() - (float)y2,l2);
liveimage_srv/CImg.h:              board.drawDot((float)x0,height() - (float)y0);
liveimage_srv/CImg.h:              board.drawDot((float)x1,height() - (float)y1);
liveimage_srv/CImg.h:              board.drawDot((float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.drawDot((float)x3,height() - (float)y3);
liveimage_srv/CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x1,height() - (float)y1);
liveimage_srv/CImg.h:              board.drawLine((float)x1,height() - (float)y1,(float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.drawLine((float)x2,height() - (float)y2,(float)x3,height() - (float)y3);
liveimage_srv/CImg.h:              board.drawLine((float)x3,height() - (float)y3,(float)x0,height() - (float)y0);
liveimage_srv/CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
liveimage_srv/CImg.h:                                 (float)x1,height() - (float)y1,
liveimage_srv/CImg.h:                                 (float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
liveimage_srv/CImg.h:                                 (float)x2,height() - (float)y2,
liveimage_srv/CImg.h:                                 (float)x3,height() - (float)y3);
liveimage_srv/CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
liveimage_srv/CImg.h:                                 (float)x1,height() - (float)y1,
liveimage_srv/CImg.h:                                 (float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
liveimage_srv/CImg.h:                                 (float)x2,height() - (float)y2,
liveimage_srv/CImg.h:                                 (float)x3,height() - (float)y3);
liveimage_srv/CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,lightprop0,
liveimage_srv/CImg.h:                                         (float)x1,height() - (float)y1,lightprop1,
liveimage_srv/CImg.h:                                         (float)x2,height() - (float)y2,lightprop2);
liveimage_srv/CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,lightprop0,
liveimage_srv/CImg.h:                                         (float)x2,height() - (float)y2,lightprop2,
liveimage_srv/CImg.h:                                         (float)x3,height() - (float)y3,lightprop3);
liveimage_srv/CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,l0,
liveimage_srv/CImg.h:                                         (float)x1,height() - (float)y1,l1,
liveimage_srv/CImg.h:                                         (float)x2,height() - (float)y2,l2);
liveimage_srv/CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,l0,
liveimage_srv/CImg.h:                                         (float)x2,height() - (float)y2,l2,
liveimage_srv/CImg.h:                                         (float)x3,height() - (float)y3,l3);
liveimage_srv/CImg.h:            draw_point(x0,y0,color.get_vector_at(tx0<=0?0:tx0>=color.width()?color.width() - 1:tx0,
liveimage_srv/CImg.h:                                                 ty0<=0?0:ty0>=color.height()?color.height() - 1:ty0)._data,opacity).
liveimage_srv/CImg.h:              draw_point(x1,y1,color.get_vector_at(tx1<=0?0:tx1>=color.width()?color.width() - 1:tx1,
liveimage_srv/CImg.h:                                                   ty1<=0?0:ty1>=color.height()?color.height() - 1:ty1)._data,opacity).
liveimage_srv/CImg.h:              draw_point(x2,y2,color.get_vector_at(tx2<=0?0:tx2>=color.width()?color.width() - 1:tx2,
liveimage_srv/CImg.h:                                                   ty2<=0?0:ty2>=color.height()?color.height() - 1:ty2)._data,opacity);
liveimage_srv/CImg.h:              board.drawDot((float)x0,height() - (float)y0);
liveimage_srv/CImg.h:              board.drawDot((float)x1,height() - (float)y1);
liveimage_srv/CImg.h:              board.drawDot((float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x1,height() - (float)y1);
liveimage_srv/CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.drawLine((float)x1,height() - (float)y1,(float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
liveimage_srv/CImg.h:                                 (float)x1,height() - (float)y1,
liveimage_srv/CImg.h:                                 (float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
liveimage_srv/CImg.h:                                 (float)x1,height() - (float)y1,
liveimage_srv/CImg.h:                                 (float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,lightprops(n0),
liveimage_srv/CImg.h:                                        (float)x1,height() - (float)y1,lightprops(n1),
liveimage_srv/CImg.h:                                        (float)x2,height() - (float)y2,lightprops(n2));
liveimage_srv/CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,l0,
liveimage_srv/CImg.h:                                        (float)x1,height() - (float)y1,l1,
liveimage_srv/CImg.h:                                        (float)x2,height() - (float)y2,l2);
liveimage_srv/CImg.h:            draw_point(x0,y0,color.get_vector_at(tx0<=0?0:tx0>=color.width()?color.width() - 1:tx0,
liveimage_srv/CImg.h:                                                 ty0<=0?0:ty0>=color.height()?color.height() - 1:ty0)._data,opacity).
liveimage_srv/CImg.h:              draw_point(x1,y1,color.get_vector_at(tx1<=0?0:tx1>=color.width()?color.width() - 1:tx1,
liveimage_srv/CImg.h:                                                   ty1<=0?0:ty1>=color.height()?color.height() - 1:ty1)._data,opacity).
liveimage_srv/CImg.h:              draw_point(x2,y2,color.get_vector_at(tx2<=0?0:tx2>=color.width()?color.width() - 1:tx2,
liveimage_srv/CImg.h:                                                   ty2<=0?0:ty2>=color.height()?color.height() - 1:ty2)._data,opacity).
liveimage_srv/CImg.h:              draw_point(x3,y3,color.get_vector_at(tx3<=0?0:tx3>=color.width()?color.width() - 1:tx3,
liveimage_srv/CImg.h:                                                   ty3<=0?0:ty3>=color.height()?color.height() - 1:ty3)._data,opacity);
liveimage_srv/CImg.h:              board.drawDot((float)x0,height() - (float)y0);
liveimage_srv/CImg.h:              board.drawDot((float)x1,height() - (float)y1);
liveimage_srv/CImg.h:              board.drawDot((float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.drawDot((float)x3,height() - (float)y3);
liveimage_srv/CImg.h:              board.drawLine((float)x0,height() - (float)y0,(float)x1,height() - (float)y1);
liveimage_srv/CImg.h:              board.drawLine((float)x1,height() - (float)y1,(float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.drawLine((float)x2,height() - (float)y2,(float)x3,height() - (float)y3);
liveimage_srv/CImg.h:              board.drawLine((float)x3,height() - (float)y3,(float)x0,height() - (float)y0);
liveimage_srv/CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
liveimage_srv/CImg.h:                                 (float)x1,height() - (float)y1,
liveimage_srv/CImg.h:                                 (float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
liveimage_srv/CImg.h:                                 (float)x2,height() - (float)y2,
liveimage_srv/CImg.h:                                 (float)x3,height() - (float)y3);
liveimage_srv/CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
liveimage_srv/CImg.h:                                 (float)x1,height() - (float)y1,
liveimage_srv/CImg.h:                                 (float)x2,height() - (float)y2);
liveimage_srv/CImg.h:              board.fillTriangle((float)x0,height() - (float)y0,
liveimage_srv/CImg.h:                                 (float)x2,height() - (float)y2,
liveimage_srv/CImg.h:                                 (float)x3,height() - (float)y3);
liveimage_srv/CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,lightprop0,
liveimage_srv/CImg.h:                                         (float)x1,height() - (float)y1,lightprop1,
liveimage_srv/CImg.h:                                         (float)x2,height() - (float)y2,lightprop2);
liveimage_srv/CImg.h:              board.fillGouraudTriangle((float)x0,height()  -(float)y0,lightprop0,
liveimage_srv/CImg.h:                                         (float)x2,height() - (float)y2,lightprop2,
liveimage_srv/CImg.h:                                         (float)x3,height() - (float)y3,lightprop3);
liveimage_srv/CImg.h:              board.fillGouraudTriangle((float)x0,height() - (float)y0,l0,
liveimage_srv/CImg.h:                                         (float)x1,height() - (float)y1,l1,
liveimage_srv/CImg.h:                                         (float)x2,height() - (float)y2,l2);
liveimage_srv/CImg.h:              board.fillGouraudTriangle((float)x0,height()  -(float)y0,l0,
liveimage_srv/CImg.h:                                         (float)x2,height() - (float)y2,l2,
liveimage_srv/CImg.h:                                         (float)x3,height() - (float)y3,l3);
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:      if (is_empty()) return CImg<intT>(1,feature_type==0?3:6,1,1,-1);
liveimage_srv/CImg.h:        get_resize(cimg_fitscreen(width(),height(),depth()),depth(),-100).move_to(thumb);
liveimage_srv/CImg.h:        X1 =-1, Y1 = -1, Z1 = -1,
liveimage_srv/CImg.h:        X3d = -1, Y3d = -1,
liveimage_srv/CImg.h:        oX3d = X3d, oY3d = -1,
liveimage_srv/CImg.h:        omx = -1, omy = -1;
liveimage_srv/CImg.h:      float X = -1, Y = -1, Z = -1;
liveimage_srv/CImg.h:          mX = mx<0?-1.f:(float)mx*(width() + (depth()>1?depth():0))/disp.width(),
liveimage_srv/CImg.h:          mY = my<0?-1.f:(float)my*(height() + (depth()>1?depth():0))/disp.height();
liveimage_srv/CImg.h:        if (mX>=0 && mX<width() && mY>=height()) { area = 2; X = mX; Z = mY - _height; Y = (float)(phase?Y1:Y0); }
liveimage_srv/CImg.h:        if (mY>=0 && mX>=width() && mY<height()) { area = 3; Y = mY; Z = mX - _width; X = (float)(phase?X1:X0); }
liveimage_srv/CImg.h:          if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) { disp.set_wheel(-1); key = 0; } break;
liveimage_srv/CImg.h:              resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
liveimage_srv/CImg.h:                     CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false).
liveimage_srv/CImg.h:          mx = my = -1; X = Y = Z = -1;
liveimage_srv/CImg.h:            X3d = mx - width()*disp.width()/(width() + (depth()>1?depth():0));
liveimage_srv/CImg.h:            Y3d = my - height()*disp.height()/(height() + (depth()>1?depth():0));
liveimage_srv/CImg.h:            if ((disp.button()&3)==3) { pose3d.assign(); view3d.assign(); oX3d = oY3d = X3d = Y3d = -1; }
liveimage_srv/CImg.h:                u0 = (float)(oX3d - view3d.width()/2),
liveimage_srv/CImg.h:                v0 = (float)(oY3d - view3d.height()/2),
liveimage_srv/CImg.h:                u1 = (float)(X3d - view3d.width()/2),
liveimage_srv/CImg.h:                v1 = (float)(Y3d - view3d.height()/2),
liveimage_srv/CImg.h:                nw0 = (float)std::sqrt(std::max(0.f,R2 - nu0*nu0 - nv0*nv0)),
liveimage_srv/CImg.h:                nw1 = (float)std::sqrt(std::max(0.f,R2 - nu1*nu1 - nv1*nv1)),
liveimage_srv/CImg.h:                u = nv0*nw1 - nw0*nv1,
liveimage_srv/CImg.h:                v = nw0*nu1 - nu0*nw1,
liveimage_srv/CImg.h:                w = nv0*nu1 - nu0*nv1,
liveimage_srv/CImg.h:              pose3d.draw_image(CImg<floatT>::rotation_matrix(u,v,w,-alpha)*pose3d.get_crop(0,0,2,2));
liveimage_srv/CImg.h:              pose3d(3,2)+=(Y3d - oY3d)*1.5f; view3d.assign();
liveimage_srv/CImg.h:              pose3d(3,2)-=disp.wheel()*15; view3d.assign(); disp.set_wheel();
liveimage_srv/CImg.h:              pose3d(3,0)-=oX3d - X3d; pose3d(3,1)-=oY3d - Y3d; view3d.assign();
liveimage_srv/CImg.h:          mx = my = -1; X = Y = Z = -1;
liveimage_srv/CImg.h:        if (X0>=width()) X0 = width() - 1;
liveimage_srv/CImg.h:        if (Y0>=height()) Y0 = height() - 1;
liveimage_srv/CImg.h:        if (Z0>=depth()) Z0 = depth() - 1;
liveimage_srv/CImg.h:        if (X1>=width()) X1 = width() - 1;
liveimage_srv/CImg.h:        if (Y1>=height()) Y1 = height() - 1;
liveimage_srv/CImg.h:        if (Z1>=depth()) Z1 = depth() - 1;
liveimage_srv/CImg.h:              x3d = _x3d>=visu0._width?visu0._width - 1:_x3d,
liveimage_srv/CImg.h:              y3d = _y3d>=visu0._height?visu0._height - 1:_y3d;
liveimage_srv/CImg.h:            CImg<ucharT>(1,2,1,1,64,128).resize(visu0._width - x3d,visu0._height - y3d,1,visu0._spectrum,3).
liveimage_srv/CImg.h:                                           0,_width - 1,_width - 1,0,0,_width - 1,_width - 1,0,
liveimage_srv/CImg.h:                                           0,0,_height - 1,_height - 1,0,0,_height - 1,_height - 1,
liveimage_srv/CImg.h:                                           0,0,0,0,_depth - 1,_depth - 1,_depth - 1,_depth - 1),'x');
liveimage_srv/CImg.h:              points3d.shift_object3d(-0.5f*(_width - 1),-0.5f*(_height - 1),-0.5f*(_depth - 1)).resize_object3d();
liveimage_srv/CImg.h:              _xn = (int)((_vX + 1.f)*w/W - 1), xn = _xn + ((int)((_xn + 1.f)*W/w)!=_vX + 1),
liveimage_srv/CImg.h:              _yn = (int)((_vY + 1.f)*h/H - 1), yn = _yn + ((int)((_yn + 1.f)*H/h)!=_vY + 1),
liveimage_srv/CImg.h:              _zxn = (int)((_vZ + width() + 1.f)*w/W - 1),
liveimage_srv/CImg.h:              _zyn = (int)((_vZ + height() + 1.f)*h/H - 1),
liveimage_srv/CImg.h:              _xM = (int)(width()*(float)w/W - 1), xM = _xM + ((int)((_xM + 1.f)*W/w)!=width()),
liveimage_srv/CImg.h:              _yM = (int)(height()*(float)h/H - 1), yM = _yM + ((int)((_yM + 1.f)*H/h)!=height()),
liveimage_srv/CImg.h:              visu.draw_line(0,yf,visu.width() - 1,yf,foreground_color,0.7f,0xFF00FF00).
liveimage_srv/CImg.h:                draw_line(0,yf,visu.width() - 1,yf,background_color,0.7f,0x00FF00FF).
liveimage_srv/CImg.h:                draw_line(xf,0,xf,visu.height() - 1,foreground_color,0.7f,0xFF00FF00).
liveimage_srv/CImg.h:                draw_line(xf,0,xf,visu.height() - 1,background_color,0.7f,0x00FF00FF);
liveimage_srv/CImg.h:            if (xn - xp>=4 && yn - yp>=4)
liveimage_srv/CImg.h:              if (yn - yp>=4 && zxn - zxp>=4)
liveimage_srv/CImg.h:              if (xn - xp>=4 && zyn - zyp>=4)
liveimage_srv/CImg.h:                _xn0 = (int)((X0 + 1.f)*w/W - 1), xn0 = _xn0 + ((int)((_xn0 + 1.f)*W/w)!=X0 + 1),
liveimage_srv/CImg.h:                _yn0 = (int)((Y0 + 1.f)*h/H - 1), yn0 = _yn0 + ((int)((_yn0 + 1.f)*H/h)!=Y0 + 1),
liveimage_srv/CImg.h:                _zxn0 = (int)((Z0 + width() + 1.f)*w/W - 1),
liveimage_srv/CImg.h:                _zyn0 = (int)((Z0 + height() + 1.f)*h/H - 1),
liveimage_srv/CImg.h:                                  (float)cimg::abs(xc - xc0),
liveimage_srv/CImg.h:                                  (float)cimg::abs(yc - yc0),0,background_color,0.2f).
liveimage_srv/CImg.h:                               (float)cimg::abs(xc - xc0),
liveimage_srv/CImg.h:                               (float)cimg::abs(yc - yc0),0,foreground_color,0.9f,~0U).
liveimage_srv/CImg.h:                  visu.draw_ellipse(zxc0,yc0,(float)cimg::abs(zxc - zxc0),(float)cimg::abs(yc - yc0),0,
liveimage_srv/CImg.h:                    draw_ellipse(zxc0,yc0,(float)cimg::abs(zxc - zxc0),(float)cimg::abs(yc - yc0),0,
liveimage_srv/CImg.h:                    draw_ellipse(xc0,zyc0,(float)cimg::abs(xc - xc0),(float)cimg::abs(zyc - zyc0),0,
liveimage_srv/CImg.h:                    draw_ellipse(xc0,zyc0,(float)cimg::abs(xc - xc0),(float)cimg::abs(zyc - zyc0),0,
liveimage_srv/CImg.h:            if (my>=0 && my<13) text_down = true; else if (my>=visu.height() - 13) text_down = false;
liveimage_srv/CImg.h:                  values.draw_image(0,4,values.get_rows(values._height - 4,values._height - 1)).resize(1,8,1,1,0);
liveimage_srv/CImg.h:                const double dX = (double)(X0 - X1), dY = (double)(Y0 - Y1), dZ = (double)(Z0 - Z1),
liveimage_srv/CImg.h:                  cimg_snprintf(text,text._width," Vect (%d,%d,%d)-(%d,%d,%d), Length = %g ",
liveimage_srv/CImg.h:                  cimg_snprintf(text,text._width," Vect (%d,%d)-(%d,%d), Length = %g, Angle = %g\260 ",
liveimage_srv/CImg.h:                                cimg::round(cimg::mod(180*std::atan2(-dY,-dX)/cimg::PI,360.),0.1));
liveimage_srv/CImg.h:                  cimg_snprintf(text,text._width," Vect (%d,%d)-(%d,%d), Length = %g ",
liveimage_srv/CImg.h:                const double dX = (double)(X0 - X1), dY = (double)(Y0 - Y1), dZ = (double)(Z0 - Z1),
liveimage_srv/CImg.h:                                " Box ( %d,%d,%d ) - ( %d,%d,%d )\n Size = ( %d,%d,%d ), Length = %g ",
liveimage_srv/CImg.h:                                1 + cimg::abs(X0 - X1),1 + cimg::abs(Y0 - Y1),1 + cimg::abs(Z0 - Z1),length);
liveimage_srv/CImg.h:                                " Box ( %d,%d ) - ( %d,%d )\n Size = ( %d,%d ), Length = %g \n Angle = %g\260 ",
liveimage_srv/CImg.h:                                1 + cimg::abs(X0 - X1),1 + cimg::abs(Y0 - Y1),length,
liveimage_srv/CImg.h:                                cimg::round(cimg::mod(180*std::atan2(-dY,-dX)/cimg::PI,360.),0.1));
liveimage_srv/CImg.h:                                " Box ( %d,%d ) - ( %d,%d )\n Size = (%d,%d), Length = %g ",
liveimage_srv/CImg.h:                                1 + cimg::abs(X0 - X1),1 + cimg::abs(Y0 - Y1),length);
liveimage_srv/CImg.h:                  cimg_snprintf(text,text._width," Ellipse ( %d,%d,%d ) - ( %d,%d,%d ), Radii = ( %d,%d,%d ) ",
liveimage_srv/CImg.h:                                1 + cimg::abs(X0 - X1),1 + cimg::abs(Y0 - Y1),1 + cimg::abs(Z0 - Z1));
liveimage_srv/CImg.h:                else cimg_snprintf(text,text._width," Ellipse ( %d,%d ) - ( %d,%d ), Radii = ( %d,%d ) ",
liveimage_srv/CImg.h:                                   1 + cimg::abs(X0 - X1),1 + cimg::abs(Y0 - Y1));
liveimage_srv/CImg.h:      CImg<intT> res(1,feature_type==0?3:6,1,1,-1);
liveimage_srv/CImg.h:            case 1 : Z0 = 0; Z1 = _depth - 1; break;
liveimage_srv/CImg.h:            case 2 : Y0 = 0; Y1 = _height - 1; break;
liveimage_srv/CImg.h:            case 3 : X0 = 0; X1 = _width - 1; break;
liveimage_srv/CImg.h:        if (X1<0 || Y1<0 || Z1<0) X0 = Y0 = Z0 = X1 = Y1 = Z1 = -1;
liveimage_srv/CImg.h:          res[3] = cimg::abs(X1 - X0); res[4] = cimg::abs(Y1 - Y0); res[5] = cimg::abs(Z1 - Z0);
liveimage_srv/CImg.h:      const CImg<T> crop = get_shared_channels(0,std::min(2,spectrum() - 1));
liveimage_srv/CImg.h:          crop.get_resize(-100,-100,mdisp,-100,0).move_to(img2d);
liveimage_srv/CImg.h:            val_minf = (T)(normalization==1 || normalization==3?m0 - cimg::abs(m0):m0),
liveimage_srv/CImg.h:              if (cimg::type<T>::is_inf(*ptr)) *ptr = (float)*ptr<0?val_minf:val_pinf; // Replace +-inf values
liveimage_srv/CImg.h:        (img2d-=m)*=255.f/(M - m>0?M - m:1);
liveimage_srv/CImg.h:          (img2d-=m)*=255.f/(M - m>0?M - m:1);
liveimage_srv/CImg.h:    //! Select sub-graph in a graph.
liveimage_srv/CImg.h:      if (nymin==nymax) { nymin = (Tfloat)min_max(nymax); const double dy = nymax - nymin; nymin-=dy/20; nymax+=dy/20; }
liveimage_srv/CImg.h:      if (nymin==nymax) { --nymin; ++nymax; }
liveimage_srv/CImg.h:      if (nxmin==nxmax && nxmin==0) { nxmin = 0; nxmax = siz - 1.; }
liveimage_srv/CImg.h:          cimg_for_inY(colormap,6,colormap.height()-1,k) {
liveimage_srv/CImg.h:            colormap(0,k) = (unsigned char)(120 + cimg::rand(-100.f,100.f,&rng));
liveimage_srv/CImg.h:            colormap(1,k) = (unsigned char)(120 + cimg::rand(-100.f,100.f,&rng));
liveimage_srv/CImg.h:            colormap(2,k) = (unsigned char)(120 + cimg::rand(-100.f,100.f,&rng));
liveimage_srv/CImg.h:      int x0 = -1, x1 = -1, y0 = -1, y1 = -1, omouse_x = -2, omouse_y = -2;
liveimage_srv/CImg.h:          const int gdimx = disp.width() - 32, gdimy = disp.height() - 32;
liveimage_srv/CImg.h:              if (siz>1) graph.draw_grid(gdimx/(float)(siz - one),gdimy/(float)(siz - one),0,0,
liveimage_srv/CImg.h:            } else graph.draw_grid(-10,-10,0,0,false,true,black,0.2f,0x33333333,0x33333333);
liveimage_srv/CImg.h:              dx = (float)cimg::abs(nxmax - nxmin), dy = (float)cimg::abs(nymax - nymin),
liveimage_srv/CImg.h:              px = (float)std::pow(10.,(int)std::log10(dx?dx:1) - 2.),
liveimage_srv/CImg.h:              py = (float)std::pow(10.,(int)std::log10(dy?dy:1) - 2.);
liveimage_srv/CImg.h:                CImg<Tdouble>::sequence(1 + gdimx/60,nxmin,one?nxmax:nxmin + (nxmax - nxmin)*(siz + 1)/siz),
liveimage_srv/CImg.h:            if (nymin>0) axes.draw_axis(seqx,gdimy - 1,gray,1,~0U,13,allow_zero,px);
liveimage_srv/CImg.h:            if (nxmax<0) axes.draw_axis(gdimx - 1,seqy,gray,1,~0U,13,allow_zero,py);
liveimage_srv/CImg.h:          text.assign().draw_text(0,0,labelx?labelx:"X-axis",white,ngray,1,13).resize(-100,-100,1,3);
liveimage_srv/CImg.h:          visu0.draw_image((visu0.width() - text.width())/2,visu0.height() - 14,~text);
liveimage_srv/CImg.h:          text.assign().draw_text(0,0,labely?labely:"Y-axis",white,ngray,1,13).rotate(-90).resize(-100,-100,1,3);
liveimage_srv/CImg.h:          visu0.draw_image(1,(visu0.height() - text.height())/2,~text);
liveimage_srv/CImg.h:              sx0 = (int)(16 + nx0*(visu.width() - 32)/std::max((ulongT)1,siz - one)),
liveimage_srv/CImg.h:              sx1 = (int)(15 + (nx1 + 1)*(visu.width() - 32)/std::max((ulongT)1,siz - one)),
liveimage_srv/CImg.h:            else visu.draw_rectangle(sx0,0,sx1,visu.height() - 17,gray,0.5f).
liveimage_srv/CImg.h:                   draw_line(sx0,16,sx0,visu.height() - 17,black,0.5f,0xCCCCCCCCU).
liveimage_srv/CImg.h:                   draw_line(sx1,16,sx1,visu.height() - 17,black,0.5f,0xCCCCCCCCU);
liveimage_srv/CImg.h:          if (mouse_x>=16 && mouse_y>=16 && mouse_x<visu.width() - 16 && mouse_y<visu.height() - 16) {
liveimage_srv/CImg.h:            if (graph) visu.draw_line(mouse_x,16,mouse_x,visu.height() - 17,black,0.5f,0x55555555U);
liveimage_srv/CImg.h:              x = (unsigned int)cimg::round((mouse_x - 16.f)*(siz - one)/(disp.width() - 32),1,one?0:-1);
liveimage_srv/CImg.h:            const double cx = nxmin + x*(nxmax - nxmin)/std::max((ulongT)1,siz - 1);
liveimage_srv/CImg.h:                            (double)(*this)(x,0,0,_spectrum - 4),(double)(*this)(x,0,0,_spectrum - 3),
liveimage_srv/CImg.h:                            (double)(*this)(x,0,0,_spectrum - 1));
liveimage_srv/CImg.h:                cx0 = nxmin + nx0*(nxmax - nxmin)/std::max((ulongT)1,siz - 1),
liveimage_srv/CImg.h:                cx1 = nxmin + (nx1 + one)*(nxmax - nxmin)/std::max((ulongT)1,siz - 1),
liveimage_srv/CImg.h:                cy0 = nymax - ny0*(nymax - nymin)/(visu._height - 32),
liveimage_srv/CImg.h:                cy1 = nymax - ny1*(nymax - nymin)/(visu._height - 32);
liveimage_srv/CImg.h:                cimg_sprintf(message._data + std::strlen(message)," - Range ( %u:%g, %g ) - ( %u:%g, %g )",
liveimage_srv/CImg.h:                cimg_sprintf(message._data + std::strlen(message)," - Range [ %u:%g - %u:%g ]",
liveimage_srv/CImg.h:            text.assign().draw_text(0,0,message,white,ngray,1,13).resize(-100,-100,1,3);
liveimage_srv/CImg.h:            visu.draw_image((visu.width() - text.width())/2,1,~text);
liveimage_srv/CImg.h:            resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
liveimage_srv/CImg.h:                   CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false).
liveimage_srv/CImg.h:              mx = (mouse_x - 16)*(int)(siz - one)/(disp.width() - 32),
liveimage_srv/CImg.h:              cx = cimg::cut(mx,0,(int)(siz - 1 - one)),
liveimage_srv/CImg.h:              my = mouse_y - 16,
liveimage_srv/CImg.h:              cy = cimg::cut(my,0,disp.height() - 32);
liveimage_srv/CImg.h:              if (!obutton) { x0 = cx; y0 = -1; } else { x1 = cx; y1 = -1; }
liveimage_srv/CImg.h:            else if (obutton) { x1 = x1>=0?cx:-1; y1 = y1>=0?cy:-1; selected = true; }
liveimage_srv/CImg.h:      return CImg<intT>(4,1,1,1,x0,y0,x1>=0?x1 + (int)one:-1,y1);
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       \param filename Filename, as a C -string.
liveimage_srv/CImg.h:      err = std::fscanf(nfile,"%*[^0-9.eEinfa+-]");
liveimage_srv/CImg.h:        err = std::fscanf(nfile,"%lf%*[^0-9.eEinfa+-]",&val);
liveimage_srv/CImg.h:                   off - 1,siz,filename?filename:"(FILE*)");
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      while ((err = std::fscanf(nfile,"%lf%255[^0-9eEinfa.+-]",&val,delimiter._data))>0) {
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      if (header_size>40) cimg::fseek(nfile,header_size - 40,SEEK_CUR);
liveimage_srv/CImg.h:        align_bytes = (4 - dx_bytes%4)%4;
liveimage_srv/CImg.h:      const int xoffset = offset - 14 - header_size - 4*nb_colors;
liveimage_srv/CImg.h:        if (colormap._width>=2) for (int y = height() - 1; y>=0; --y) {
liveimage_srv/CImg.h:        if (colormap._width>=16) for (int y = height() - 1; y>=0; --y) {
liveimage_srv/CImg.h:        if (colormap._width>=256) for (int y = height() - 1; y>=0; --y) {
liveimage_srv/CImg.h:        for (int y = height() - 1; y>=0; --y) {
liveimage_srv/CImg.h:        for (int y = height() - 1; y>=0; --y) {
liveimage_srv/CImg.h:        for (int y = height() - 1; y>=0; --y) {
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      _cimg_error_ptr c_err = (_cimg_error_ptr) cinfo->err;  // Return control to the setjmp point
liveimage_srv/CImg.h:      (*cinfo->err->format_message)(cinfo,c_err->message);
liveimage_srv/CImg.h:      longjmp(c_err->setjmp_buffer,1);
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        for (ulongT off = (ulongT)W*H; off; --off) {
liveimage_srv/CImg.h:          *(ptr_r++) = (T)(pixels->red);
liveimage_srv/CImg.h:          *(ptr_g++) = (T)(pixels->green);
liveimage_srv/CImg.h:          *(ptr_b++) = (T)(pixels->blue);
liveimage_srv/CImg.h:          *(ptr_a++) = (T)(pixels->opacity);
liveimage_srv/CImg.h:        for (ulongT off = (ulongT)W*H; off; --off) {
liveimage_srv/CImg.h:          *(ptr_r++) = (T)(pixels->red);
liveimage_srv/CImg.h:          *(ptr_g++) = (T)(pixels->green);
liveimage_srv/CImg.h:          *(ptr_b++) = (T)(pixels->blue);
liveimage_srv/CImg.h:        for (ulongT off = (ulongT)W*H; off; --off) {
liveimage_srv/CImg.h:          *(ptr_r++) = (T)(pixels->red);
liveimage_srv/CImg.h:          *(ptr_a++) = (T)(pixels->opacity);
liveimage_srv/CImg.h:        for (ulongT off = (ulongT)W*H; off; --off) {
liveimage_srv/CImg.h:          *(ptr_r++) = (T)(pixels->red);
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:          to_read-=raw._width;
liveimage_srv/CImg.h:            if (!mask) { if (off--) val = *(ptrs++); mask = 128; }
liveimage_srv/CImg.h:            to_read-=raw._width;
liveimage_srv/CImg.h:            for (ulongT off = (ulongT)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++);
liveimage_srv/CImg.h:            to_read-=raw._width;
liveimage_srv/CImg.h:            for (ulongT off = (ulongT)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++);
liveimage_srv/CImg.h:            to_read-=raw._width;
liveimage_srv/CImg.h:            for (ulongT off = (ulongT)raw._width/3; off; --off) {
liveimage_srv/CImg.h:            to_read-=raw._width;
liveimage_srv/CImg.h:            for (ulongT off = (ulongT)raw._width/3; off; --off) {
liveimage_srv/CImg.h:          to_read-=raw._width;
liveimage_srv/CImg.h:          for (ulongT off = (ulongT)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++);
liveimage_srv/CImg.h:          to_read-=raw._width;
liveimage_srv/CImg.h:          for (ulongT off = (ulongT)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++);
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      return mirror('y');  // Most of the .pfm files are flipped along the y-axis
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        to_read-=raw._width;
liveimage_srv/CImg.h:        for (ulongT off = raw._width/3UL; off; --off) {
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        to_read-=raw._width;
liveimage_srv/CImg.h:        for (ulongT off = raw._width/4UL; off; --off) {
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       \param first_frame First frame to read (for multi-pages tiff).
liveimage_srv/CImg.h:       \param last_frame Last frame to read (for multi-pages tiff).
liveimage_srv/CImg.h:       - libtiff support is enabled by defining the precompilation
liveimage_srv/CImg.h:       - When libtiff is enabled, 2D and 3D (multipage) several
liveimage_srv/CImg.h:       - If \c cimg_use_tiff is not defined at compile time the
liveimage_srv/CImg.h:                                    "load_tiff(): Unable to read sub-images from file '%s' unless libtiff is enabled.",
liveimage_srv/CImg.h:        if (nlast_frame>=nb_images) nlast_frame = nb_images - 1;
liveimage_srv/CImg.h:            assign(frame._width,frame._height,1 + (nlast_frame - nfirst_frame)/nstep_frame,frame._spectrum);
liveimage_srv/CImg.h:                   std::max(frame._height,_height),-100,
liveimage_srv/CImg.h:          draw_image(0,0,(l - nfirst_frame)/nstep_frame,frame);
liveimage_srv/CImg.h:                  (*this)(cc,rr,vv) = (T)(ptr[(rr - row)*th*samplesperpixel + (cc - col)*samplesperpixel + vv]);
liveimage_srv/CImg.h:        cimg_uint32 row, rowsperstrip = (cimg_uint32)-1;
liveimage_srv/CImg.h:          cimg_uint32 nrow = (row + rowsperstrip>ny?ny - row:rowsperstrip);
liveimage_srv/CImg.h:          if ((TIFFReadEncodedStrip(tif,strip,buf,-1))<0) {
liveimage_srv/CImg.h:        cimg_uint32 row, rowsperstrip = (cimg_uint32)-1;
liveimage_srv/CImg.h:            cimg_uint32 nrow = (row + rowsperstrip>ny?ny - row:rowsperstrip);
liveimage_srv/CImg.h:            if ((TIFFReadEncodedStrip(tif,strip,buf,-1))<0) {
liveimage_srv/CImg.h:            (*this)(x,y,0) = (T)(float)TIFFGetR(raster[nx*(ny - 1 -y) + x]);
liveimage_srv/CImg.h:            (*this)(x,y,0) = (T)(float)TIFFGetR(raster[nx*(ny - 1 - y) + x]);
liveimage_srv/CImg.h:            (*this)(x,y,1) = (T)(float)TIFFGetG(raster[nx*(ny - 1 - y) + x]);
liveimage_srv/CImg.h:            (*this)(x,y,2) = (T)(float)TIFFGetB(raster[nx*(ny - 1 - y) + x]);
liveimage_srv/CImg.h:            (*this)(x,y,0) = (T)(float)TIFFGetR(raster[nx*(ny - 1 - y) + x]);
liveimage_srv/CImg.h:            (*this)(x,y,1) = (T)(float)TIFFGetG(raster[nx*(ny - 1 - y) + x]);
liveimage_srv/CImg.h:            (*this)(x,y,2) = (T)(float)TIFFGetB(raster[nx*(ny - 1 - y) + x]);
liveimage_srv/CImg.h:            (*this)(x,y,3) = (T)(float)TIFFGetA(raster[nx*(ny - 1 - y) + x]);
liveimage_srv/CImg.h:        \param filename Filename, as a C-string.
liveimage_srv/CImg.h:    // (Original code by Haz-Edine Assemlal).
liveimage_srv/CImg.h:      minc::load_standard_volume(rdr,this->_data);
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:                              "load_analyze(): Invalid zero-size header in file '%s'.",
liveimage_srv/CImg.h:      cimg::fread(header + 4,header_size - 4,nfile_header);
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:    //! Load sub-images of a .cimg file.
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      \param x0 X-coordinate of the starting sub-image vertex.
liveimage_srv/CImg.h:      \param y0 Y-coordinate of the starting sub-image vertex.
liveimage_srv/CImg.h:      \param z0 Z-coordinate of the starting sub-image vertex.
liveimage_srv/CImg.h:      \param c0 C-coordinate of the starting sub-image vertex.
liveimage_srv/CImg.h:      \param x1 X-coordinate of the ending sub-image vertex (~0U for max).
liveimage_srv/CImg.h:      \param y1 Y-coordinate of the ending sub-image vertex (~0U for max).
liveimage_srv/CImg.h:      \param z1 Z-coordinate of the ending sub-image vertex (~0U for max).
liveimage_srv/CImg.h:      \param c1 C-coordinate of the ending sub-image vertex (~0U for max).
liveimage_srv/CImg.h:    //! Load sub-images of a .cimg file \newinstance.
liveimage_srv/CImg.h:    //! Load sub-images of a .cimg file \overloading.
liveimage_srv/CImg.h:    //! Load sub-images of a .cimg file \newinstance.
liveimage_srv/CImg.h:    //! Load image from an INRIMAGE-4 file.
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:    //! Load image from an INRIMAGE-4 file \newinstance.
liveimage_srv/CImg.h:    //! Load image from an INRIMAGE-4 file \overloading.
liveimage_srv/CImg.h:    //! Load image from an INRIMAGE-4 file \newinstance.
liveimage_srv/CImg.h:      out[0] = out[1] = out[2] = out[3] = out[5] = 1; out[4] = out[6] = out[7] = -1;
liveimage_srv/CImg.h:      if (cimg::strncasecmp(item,"#INRIMAGE-4#{",13)!=0)
liveimage_srv/CImg.h:        throw CImgIOException("CImg<%s>::load_inr(): INRIMAGE-4 header not found.",
liveimage_srv/CImg.h:        cimg_sscanf(item," XDIM%*[^0-9]%d",out);
liveimage_srv/CImg.h:        cimg_sscanf(item," YDIM%*[^0-9]%d",out + 1);
liveimage_srv/CImg.h:        cimg_sscanf(item," ZDIM%*[^0-9]%d",out + 2);
liveimage_srv/CImg.h:        cimg_sscanf(item," VDIM%*[^0-9]%d",out + 3);
liveimage_srv/CImg.h:        cimg_sscanf(item," PIXSIZE%*[^0-9]%d",out + 6);
liveimage_srv/CImg.h:          cimg_sscanf(item," VX%*[^0-9.+-]%f",voxel_size);
liveimage_srv/CImg.h:          cimg_sscanf(item," VY%*[^0-9.+-]%f",voxel_size + 1);
liveimage_srv/CImg.h:          cimg_sscanf(item," VZ%*[^0-9.+-]%f",voxel_size + 2);
liveimage_srv/CImg.h:          std::strncpy(tmp1,tmp2,tmp1._width - 1); // fallthrough
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        inwidth = dw.max.x - dw.min.x + 1,
liveimage_srv/CImg.h:        inheight = dw.max.y - dw.min.y + 1;
liveimage_srv/CImg.h:      file.setFrameBuffer(&pixels[0][0] - dw.min.x - dw.min.y*inwidth, 1, inwidth);
liveimage_srv/CImg.h:    //! Load image from a PANDORE-5 file.
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:    //! Load image from a PANDORE-5 file \newinstance.
liveimage_srv/CImg.h:    //! Load image from a PANDORE-5 file \overloading.
liveimage_srv/CImg.h:    //! Load image from a PANDORE-5 file \newinstance.
liveimage_srv/CImg.h:        buffer-=siz; \
liveimage_srv/CImg.h:          buffer-=siz;
liveimage_srv/CImg.h:            buffer-=siz;
liveimage_srv/CImg.h:            buffer-=siz;
liveimage_srv/CImg.h:          buffer-=siz;
liveimage_srv/CImg.h:            buffer-=siz;
liveimage_srv/CImg.h:            buffer-=siz;
liveimage_srv/CImg.h:          buffer-=siz;
liveimage_srv/CImg.h:            buffer-=siz;
liveimage_srv/CImg.h:            buffer-=siz;
liveimage_srv/CImg.h:    //! Load image from a PAR-REC (Philips) file.
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:    //! Load image from a PAR-REC (Philips) file \newinstance.
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      \param is_multiplexed Tells if the image values are multiplexed along the C-axis.
liveimage_srv/CImg.h:      } else { // Non-boolean data
liveimage_srv/CImg.h:        if (siz && (!is_multiplexed || size_c==1)) { // Non-multiplexed
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        cimg_snprintf(command,command._width,"%s convert \"%s\" %s:-",
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -c \"%s\" > \"%s\"",
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        cimg_snprintf(command,command._width,"%s%s \"%s\" %s:-",
liveimage_srv/CImg.h:                      !cimg::strcasecmp(cimg::split_filename(filename),"pdf")?" -density 400x400":"",
liveimage_srv/CImg.h:                    !cimg::strcasecmp(cimg::split_filename(filename),"pdf")?" -density 400x400":"",
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -w -c anlz -o \"%s\" -f \"%s\"",
liveimage_srv/CImg.h:        cimg_snprintf(command,command._width,"m000-%s.hdr",body._data);
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"gs -q -dNOPAUSE -sDEVICE=ppmraw -o - -r%u \"%s\"",
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"gs -q -dNOPAUSE -sDEVICE=ppmraw -o \"%s\" -r%u \"%s\"",
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"%s -w -4 -c \"%s\"",
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -w -4 -c \"%s\" > \"%s\"",
liveimage_srv/CImg.h:      int mat_type = -1;
liveimage_srv/CImg.h:          channels[c] = cv::Mat(_height,_width,mat_type,_data + _width*_height*(_spectrum - 1 - c));
liveimage_srv/CImg.h:        if (captures[camera_index]) captures[camera_index]->release();
liveimage_srv/CImg.h:        if (!captures[camera_index]->isOpened()) {
liveimage_srv/CImg.h:        captures[camera_index]->set(_cimg_cap_prop_frame_width,capture_width);
liveimage_srv/CImg.h:        captures[camera_index]->set(_cimg_cap_prop_frame_height,capture_height);
liveimage_srv/CImg.h:      for (unsigned int i = 0; i<skip_frames; ++i) captures[camera_index]->grab();
liveimage_srv/CImg.h:      captures[camera_index]->read(cvimg);
liveimage_srv/CImg.h:                            "('-Dcimg_use_opencv' must be defined).",
liveimage_srv/CImg.h:    //! Load image using various non-native ways.
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:    //! Load image using various non-native ways \newinstance.
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:      const ulongT siz = size(), msiz = siz*sizeof(T), siz1 = siz - 1,
liveimage_srv/CImg.h:        mdisp = msiz<8*1024?0U:msiz<8*1024*1024?1U:2U, width1 = _width - 1;
liveimage_srv/CImg.h:        std::fprintf(cimg::output(),"..%p (%s) = [ ",(void*)((char*)end() - 1),_is_shared?"shared":"non-shared");
liveimage_srv/CImg.h:      else std::fprintf(cimg::output()," (%s) = [ ",_is_shared?"shared":"non-shared");
liveimage_srv/CImg.h:        if (off==7 && siz>16) { off = siz1 - 8; std::fprintf(cimg::output(),"... "); }
liveimage_srv/CImg.h:      int x0 = 0, y0 = 0, z0 = 0, x1 = width() - 1, y1 = height() - 1, z1 = depth() - 1,
liveimage_srv/CImg.h:        old_mouse_x = -1, old_mouse_y = -1;
liveimage_srv/CImg.h:          x0 = 0; y0 = 0; z0 = 0; x1 = width() - 1; y1 = height() - 1; z1 = depth() - 1;
liveimage_srv/CImg.h:        if (!x0 && !y0 && !z0 && x1==width() - 1 && y1==height() - 1 && z1==depth() - 1) {
liveimage_srv/CImg.h:          dx = 1U + x1 - x0, dy = 1U + y1 - y0, dz = 1U + z1 - z0,
liveimage_srv/CImg.h:                if (disp.wheel()) { frame_timing-=disp.wheel()/3.f; disp.set_wheel(); }
liveimage_srv/CImg.h:                case cimg::keyPAGEUP : frame_timing-=0.3f; key = 0; break;
liveimage_srv/CImg.h:                  (_XYZ[2]+=visu._depth - 2)%=visu._depth; timer = 0; key = 0; break;
liveimage_srv/CImg.h:                      resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
liveimage_srv/CImg.h:                             CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false);
liveimage_srv/CImg.h:            X = x0 + mX*(1 + x1 - x0)/width(); Y = y0 + mY*(1 + y1 - y0)/height();
liveimage_srv/CImg.h:            X = x0 + mX*(1 + x1 - x0)/width(); Z = z0 + (mY - height())*(1 + z1 - z0)/depth();
liveimage_srv/CImg.h:            Y = y0 + mY*(1 + y1 - y0)/height(); Z = z0 + (mX - width())*(1 + z1 - z0)/depth();
liveimage_srv/CImg.h:          if (x1 - x0>4) { x0 = X - 3*(X - x0)/4; x1 = X + 3*(x1 - X)/4; }
liveimage_srv/CImg.h:          if (y1 - y0>4) { y0 = Y - 3*(Y - y0)/4; y1 = Y + 3*(y1 - Y)/4; }
liveimage_srv/CImg.h:          if (z1 - z0>4) { z0 = Z - 3*(Z - z0)/4; z1 = Z + 3*(z1 - Z)/4; }
liveimage_srv/CImg.h:            delta_x = (x1 - x0)/8, delta_y = (y1 - y0)/8, delta_z = (z1 - z0)/8,
liveimage_srv/CImg.h:          x0-=ndelta_x; y0-=ndelta_y; z0-=ndelta_z;
liveimage_srv/CImg.h:          if (x0<0) { x1-=x0; x0 = 0; if (x1>=width()) x1 = width() - 1; }
liveimage_srv/CImg.h:          if (y0<0) { y1-=y0; y0 = 0; if (y1>=height()) y1 = height() - 1; }
liveimage_srv/CImg.h:          if (z0<0) { z1-=z0; z0 = 0; if (z1>=depth()) z1 = depth() - 1; }
liveimage_srv/CImg.h:          if (x1>=width()) { x0-=(x1 - width() + 1); x1 = width() - 1; if (x0<0) x0 = 0; }
liveimage_srv/CImg.h:          if (y1>=height()) { y0-=(y1 - height() + 1); y1 = height() - 1; if (y0<0) y0 = 0; }
liveimage_srv/CImg.h:          if (z1>=depth()) { z0-=(z1 - depth() + 1); z1 = depth() - 1; if (z0<0) z0 = 0; }
liveimage_srv/CImg.h:            ratio = (float)(x1-x0)/(y1-y0),
liveimage_srv/CImg.h:            sub = std::min(cimg::abs(ratio - ratiow),cimg::abs(1/ratio-1/ratiow));
liveimage_srv/CImg.h:          const int delta = (x1 - x0)/4, ndelta = delta?delta:(_width>1);
liveimage_srv/CImg.h:          if (x0 - ndelta>=0) { x0-=ndelta; x1-=ndelta; }
liveimage_srv/CImg.h:          else { x1-=x0; x0 = 0; }
liveimage_srv/CImg.h:          const int delta = (x1 - x0)/4, ndelta = delta?delta:(_width>1);
liveimage_srv/CImg.h:          else { x0+=(width() - 1 - x1); x1 = width() - 1; }
liveimage_srv/CImg.h:          const int delta = (y1 - y0)/4, ndelta = delta?delta:(_height>1);
liveimage_srv/CImg.h:          if (y0 - ndelta>=0) { y0-=ndelta; y1-=ndelta; }
liveimage_srv/CImg.h:          else { y1-=y0; y0 = 0; }
liveimage_srv/CImg.h:          const int delta = (y1 - y0)/4, ndelta = delta?delta:(_height>1);
liveimage_srv/CImg.h:          else { y0+=(height() - 1 - y1); y1 = height() - 1; }
liveimage_srv/CImg.h:          const int delta = (z1 - z0)/4, ndelta = delta?delta:(_depth>1);
liveimage_srv/CImg.h:          if (z0 - ndelta>=0) { z0-=ndelta; z1-=ndelta; }
liveimage_srv/CImg.h:          else { z1-=z0; z0 = 0; }
liveimage_srv/CImg.h:          const int delta = (z1 - z0)/4, ndelta = delta?delta:(_depth>1);
liveimage_srv/CImg.h:          else { z0+=(depth() - 1 - z1); z1 = depth() - 1; }
liveimage_srv/CImg.h:       \param is_double_sided Tells if the object primitives are double-sided.
liveimage_srv/CImg.h:       \param light_x X-coordinate of the light source.
liveimage_srv/CImg.h:       \param light_y Y-coordinate of the light source.
liveimage_srv/CImg.h:       \param light_z Z-coordinate of the light source.
liveimage_srv/CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
liveimage_srv/CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
liveimage_srv/CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
liveimage_srv/CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
liveimage_srv/CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
liveimage_srv/CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
liveimage_srv/CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
liveimage_srv/CImg.h:                                    const float light_x=0, const float light_y=0, const float light_z=-5e8f,
liveimage_srv/CImg.h:        if (disp) background.resize(disp.width(),disp.height(),1,-100,3);
liveimage_srv/CImg.h:                                              CImgDisplay::screen_height()/2,1),1,-100,3);
liveimage_srv/CImg.h:      const float delta = cimg::max(xM - xm,yM - ym,zM - zm);
liveimage_srv/CImg.h:                                                   0,20,0,0,22,-6,-6,
liveimage_srv/CImg.h:                                                   0,0,20,0,-6,22,-6,
liveimage_srv/CImg.h:            CImg<floatT>(4,3,1,1, ratio,0.,0.,-ratio*dx, 0.,ratio,0.,-ratio*dy, 0.,0.,ratio,-ratio*dz).move_to(pose);
liveimage_srv/CImg.h:              n = 1e-8f + cimg::hypot(r00,r01,r02),
liveimage_srv/CImg.h:              Xaxes = 25, Yaxes = visu._height - 38.f;
liveimage_srv/CImg.h:              u0 = (float)(x0 - disp.width()/2),
liveimage_srv/CImg.h:              v0 = (float)(y0 - disp.height()/2),
liveimage_srv/CImg.h:              u1 = (float)(x1 - disp.width()/2),
liveimage_srv/CImg.h:              v1 = (float)(y1 - disp.height()/2),
liveimage_srv/CImg.h:              nw0 = (float)std::sqrt(std::max(0.f,R2 - nu0*nu0 - nv0*nv0)),
liveimage_srv/CImg.h:              nw1 = (float)std::sqrt(std::max(0.f,R2 - nu1*nu1 - nv1*nv1)),
liveimage_srv/CImg.h:              u = nv0*nw1 - nw0*nv1,
liveimage_srv/CImg.h:              v = nw0*nu1 - nu0*nw1,
liveimage_srv/CImg.h:              w = nv0*nu1 - nu0*nv1,
liveimage_srv/CImg.h:            (CImg<floatT>::rotation_matrix(u,v,w,-alpha)*pose).move_to(pose);
liveimage_srv/CImg.h:            if (focale>0) Zoff-=(y0 - y1)*focale/400;
liveimage_srv/CImg.h:            else { const float s = std::exp((y0 - y1)/400.f); pose*=s; sprite_scale*=s; }
liveimage_srv/CImg.h:            if (focale>0) Zoff-=disp.wheel()*focale/20;
liveimage_srv/CImg.h:            Xoff+=(x1 - x0); Yoff+=(y1 - y0); x0 = x1; y0 = y1;
liveimage_srv/CImg.h:              resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
liveimage_srv/CImg.h:                     CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false).
liveimage_srv/CImg.h:            // Switch single/double-sided primitives.
liveimage_srv/CImg.h:            if (--_is_double_sided==-2) _is_double_sided = 1;
liveimage_srv/CImg.h:        case cimg::keyZ : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) { // Enable/disable Z-buffer
liveimage_srv/CImg.h:            nrender_motion = (nrender_static==0 && nrender_motion!=0)?0:-1; nrender_static = 0;
liveimage_srv/CImg.h:            nrender_motion = (nrender_static==1 && nrender_motion!=1)?1:-1; nrender_static = 1;
liveimage_srv/CImg.h:            nrender_motion = (nrender_static==2 && nrender_motion!=2)?2:-1; nrender_static = 2;
liveimage_srv/CImg.h:        case cimg::keyF4 : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) { // Set rendering mode to flat-shaded
liveimage_srv/CImg.h:            nrender_motion = (nrender_static==3 && nrender_motion!=3)?3:-1; nrender_static = 3;
liveimage_srv/CImg.h:            // Set rendering mode to gouraud-shaded.
liveimage_srv/CImg.h:            nrender_motion = (nrender_static==4 && nrender_motion!=4)?4:-1; nrender_static = 4;
liveimage_srv/CImg.h:        case cimg::keyF6 : if (disp.is_keyCTRLLEFT() || disp.is_keyCTRLRIGHT()) { // Set rendering mode to phong-shaded
liveimage_srv/CImg.h:            nrender_motion = (nrender_static==5 && nrender_motion!=5)?5:-1; nrender_static = 5;
liveimage_srv/CImg.h:       \param labelx Title for the horizontal axis, as a C-string.
liveimage_srv/CImg.h:       \param xmin Minimum value along the X-axis.
liveimage_srv/CImg.h:       \param xmax Maximum value along the X-axis.
liveimage_srv/CImg.h:       \param labely Title for the vertical axis, as a C-string.
liveimage_srv/CImg.h:       \param ymin Minimum value along the X-axis.
liveimage_srv/CImg.h:       \param ymax Maximum value along the X-axis.
liveimage_srv/CImg.h:      const ulongT siz = (ulongT)_width*_height*_depth, siz1 = std::max((ulongT)1,siz - 1);
liveimage_srv/CImg.h:      int x0 = 0, x1 = width()*height()*depth() - 1, key = 0;
liveimage_srv/CImg.h:        if (reset_view) { x0 = 0; x1 = width()*height()*depth() - 1; y0 = ymin; y1 = ymax; reset_view = false; }
liveimage_srv/CImg.h:        CImg<T> zoom(x1 - x0 + 1,1,1,spectrum());
liveimage_srv/CImg.h:        cimg_forC(*this,c) zoom.get_shared_channel(c) = CImg<T>(data(x0,0,0,c),x1 - x0 + 1,1,1,1,true);
liveimage_srv/CImg.h:        if (y0==y1) { y0 = zoom.min_max(y1); const double dy = y1 - y0; y0-=dy/20; y1+=dy/20; }
liveimage_srv/CImg.h:        if (y0==y1) { --y0; ++y1; }
liveimage_srv/CImg.h:                                                           nxmin + x0*(nxmax - nxmin)/siz1,
liveimage_srv/CImg.h:                                                           nxmin + x1*(nxmax - nxmin)/siz1,
liveimage_srv/CImg.h:              y0 = y1 - selection[3]*(y1 - y0)/(disp.height() - 32);
liveimage_srv/CImg.h:              y1-=selection[1]*(y1 - y0)/(disp.height() - 32);
liveimage_srv/CImg.h:              xsiz = x1 - x0,
liveimage_srv/CImg.h:              mx = (mouse_x - 16)*xsiz/(disp.width() - 32),
liveimage_srv/CImg.h:            if (x1 - x0>4) {
liveimage_srv/CImg.h:              x0 = cx - 7*(cx - x0)/8; x1 = cx + 7*(x1 - cx)/8;
liveimage_srv/CImg.h:                  ysiz = y1 - y0,
liveimage_srv/CImg.h:                  my = (mouse_y - 16)*ysiz/(disp.height() - 32),
liveimage_srv/CImg.h:                  cy = y1 - cimg::cut(my,0.,ysiz);
liveimage_srv/CImg.h:                y0 = cy - 7*(cy - y0)/8; y1 = cy + 7*(y1 - cy)/8;
liveimage_srv/CImg.h:              const int delta_x = (x1 - x0)/8, ndelta_x = delta_x?delta_x:(siz>1);
liveimage_srv/CImg.h:              const double ndelta_y = (y1 - y0)/8;
liveimage_srv/CImg.h:              x0-=ndelta_x; x1+=ndelta_x;
liveimage_srv/CImg.h:              y0-=ndelta_y; y1+=ndelta_y;
liveimage_srv/CImg.h:              if (x0<0) { x1-=x0; x0 = 0; if (x1>=(int)siz) x1 = (int)siz1; }
liveimage_srv/CImg.h:              if (x1>=(int)siz) { x0-=(x1 - siz1); x1 = (int)siz1; if (x0<0) x0 = 0; }
liveimage_srv/CImg.h:            const int delta = (x1 - x0)/5, ndelta = delta?delta:1;
liveimage_srv/CImg.h:            if (x0 - ndelta>=0) { x0-=ndelta; x1-=ndelta; }
liveimage_srv/CImg.h:            else { x1-=x0; x0 = 0; }
liveimage_srv/CImg.h:            const int delta = (x1 - x0)/5, ndelta = delta?delta:1;
liveimage_srv/CImg.h:            else { x0+=(siz1 - x1); x1 = (int)siz1; }
liveimage_srv/CImg.h:            const double delta = (y1 - y0)/10, ndelta = delta?delta:1;
liveimage_srv/CImg.h:            const double delta = (y1 - y0)/10, ndelta = delta?delta:1;
liveimage_srv/CImg.h:            y0-=ndelta; y1-=ndelta;
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       - The used file format is defined by the file extension in the filename \p filename.
liveimage_srv/CImg.h:       - Parameter \p number can be used to add a 6-digit number to the filename before saving.
liveimage_srv/CImg.h:    const CImg<T>& save(const char *const filename, const int number=-1, const unsigned int digits=6) const {
liveimage_srv/CImg.h:      const bool is_stdout = *filename=='-' && (!filename[1] || filename[1]=='.');
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      if (filename) cimg_sscanf(cimg::basename(filename),"%1023[a-zA-Z0-9_]",varname._data);
liveimage_srv/CImg.h:      if (!is_empty()) for (ulongT off = 0, siz = size() - 1; off<=siz; ++off) {
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        cimg_forX(*this,x) std::fprintf(nfile,"%.17g%s",(double)*(ptrs++),(x==width() - 1)?"":",");
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        align = (4 - (3*_width)%4)%4,
liveimage_srv/CImg.h:        *ptr_r = data(0,_height - 1,0,0),
liveimage_srv/CImg.h:        *ptr_g = (_spectrum>=2)?data(0,_height - 1,0,1):0,
liveimage_srv/CImg.h:        *ptr_b = (_spectrum>=3)?data(0,_height - 1,0,2):0;
liveimage_srv/CImg.h:          ptr_r-=2*_width;
liveimage_srv/CImg.h:          ptr_r-=2*_width; ptr_g-=2*_width;
liveimage_srv/CImg.h:          ptr_r-=2*_width; ptr_g-=2*_width; ptr_b-=2*_width;
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:    //! Save image, using built-in ImageMagick++ library.
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        for (ulongT off = (ulongT)_width*_height; off; --off) {
liveimage_srv/CImg.h:          pixels->red = pixels->green = pixels->blue = (Magick::Quantum)*(ptr_r++);
liveimage_srv/CImg.h:        for (ulongT off = (ulongT)_width*_height; off; --off) {
liveimage_srv/CImg.h:          pixels->red = (Magick::Quantum)*(ptr_r++);
liveimage_srv/CImg.h:          pixels->green = (Magick::Quantum)*(ptr_g++);
liveimage_srv/CImg.h:          pixels->blue = 0; ++pixels;
liveimage_srv/CImg.h:        for (ulongT off = (ulongT)_width*_height; off; --off) {
liveimage_srv/CImg.h:          pixels->red = (Magick::Quantum)*(ptr_r++);
liveimage_srv/CImg.h:          pixels->green = (Magick::Quantum)*(ptr_g++);
liveimage_srv/CImg.h:          pixels->blue = (Magick::Quantum)*(ptr_b++);
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      const int pixel_bit_depth_flag = numChan * (bit_depth - 1);
liveimage_srv/CImg.h:      case 7 :  { // Gray 8-bit
liveimage_srv/CImg.h:      case 14 : { // Gray w/ Alpha 8-bit
liveimage_srv/CImg.h:      case 21 :  { // RGB 8-bit
liveimage_srv/CImg.h:      case 28 : { // RGB x/ Alpha 8-bit
liveimage_srv/CImg.h:      case 15 : { // Gray 16-bit
liveimage_srv/CImg.h:      case 30 : { // Gray w/ Alpha 16-bit
liveimage_srv/CImg.h:      case 45 : { // RGB 16-bit
liveimage_srv/CImg.h:      case 60 : { // RGB w/ Alpha 16-bit
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:            for (ulongT i = N; i>0; --i) *(ptrd++) = (unsigned char)*(ptr_r++);
liveimage_srv/CImg.h:            to_write-=N;
liveimage_srv/CImg.h:            for (ulongT i = N; i>0; --i) *(ptrd++) = (unsigned short)*(ptr_r++);
liveimage_srv/CImg.h:            to_write-=N;
liveimage_srv/CImg.h:            for (ulongT i = N; i>0; --i) {
liveimage_srv/CImg.h:            to_write-=N;
liveimage_srv/CImg.h:            for (ulongT i = N; i>0; --i) {
liveimage_srv/CImg.h:            to_write-=N;
liveimage_srv/CImg.h:            for (ulongT i = N; i>0; --i) {
liveimage_srv/CImg.h:            to_write-=N;
liveimage_srv/CImg.h:            for (ulongT i = N; i>0; --i) {
liveimage_srv/CImg.h:            to_write-=N;
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      else if (!cimg::type<T>::is_float() && sizeof(T)==1) { // Save as extended P5 file: Binary byte-valued 3D
liveimage_srv/CImg.h:          for (ulongT i = N; i>0; --i) *(ptrd++) = (unsigned char)*(ptr++);
liveimage_srv/CImg.h:          to_write-=N;
liveimage_srv/CImg.h:      } else if (!cimg::type<T>::is_float()) { // Save as P8: Binary int32-valued 3D
liveimage_srv/CImg.h:          for (ulongT i = N; i>0; --i) *(ptrd++) = (int)*(ptr++);
liveimage_srv/CImg.h:          to_write-=N;
liveimage_srv/CImg.h:      } else { // Save as P9: Binary float-valued 3D
liveimage_srv/CImg.h:          for (ulongT i = N; i>0; --i) *(ptrd++) = (float)*(ptr++);
liveimage_srv/CImg.h:          to_write-=N;
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:          for (ulongT i = N; i>0; --i) *(ptrd++) = (float)*(ptr_r++);
liveimage_srv/CImg.h:          to_write-=N;
liveimage_srv/CImg.h:          for (ulongT i = N; i>0; --i) {
liveimage_srv/CImg.h:          to_write-=N;
liveimage_srv/CImg.h:          for (ulongT i = N; i>0; --i) {
liveimage_srv/CImg.h:          to_write-=N;
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       - libtiff support is enabled by defining the precompilation
liveimage_srv/CImg.h:       - When libtiff is enabled, 2D and 3D (multipage) several
liveimage_srv/CImg.h:       - If \c cimg_use_tiff is not defined at compile time the
liveimage_srv/CImg.h:      cimg_uint32 rowsperstrip = (cimg_uint32)-1;
liveimage_srv/CImg.h:          cimg_uint32 nrow = (row + rowsperstrip>_height?_height - row:rowsperstrip);
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       \param imitate_file If non-zero, reference filename, as a C-string, to borrow header from.
liveimage_srv/CImg.h:       if (width()) di.push_back(minc::dim_info(width(),width()*0.5,-1,minc::dim_info::DIM_X));
liveimage_srv/CImg.h:       if (height()) di.push_back(minc::dim_info(height(),height()*0.5,-1,minc::dim_info::DIM_Y));
liveimage_srv/CImg.h:       if (depth()) di.push_back(minc::dim_info(depth(),depth()*0.5,-1,minc::dim_info::DIM_Z));
liveimage_srv/CImg.h:       if (spectrum()) di.push_back(minc::dim_info(spectrum(),spectrum()*0.5,-1,minc::dim_info::DIM_TIME));
liveimage_srv/CImg.h:     minc::save_standard_volume(wtr, this->_data);
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      short datatype = -1;
liveimage_srv/CImg.h:        std::strncpy(iname,filename,iname._width - 1);
liveimage_srv/CImg.h:        cimg_sprintf(iname._data + std::strlen(iname) - 3,"img");
liveimage_srv/CImg.h:        std::strncpy(iname,filename,iname._width - 1);
liveimage_srv/CImg.h:        cimg_sprintf(hname._data + std::strlen(iname) - 3,"hdr");
liveimage_srv/CImg.h:        std::strncpy(hname,filename,hname._width - 1); *iname = 0;
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:    //! Save image as a sub-image into an existing .cimg file.
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      \param x0 X-coordinate of the sub-image location.
liveimage_srv/CImg.h:      \param y0 Y-coordinate of the sub-image location.
liveimage_srv/CImg.h:      \param z0 Z-coordinate of the sub-image location.
liveimage_srv/CImg.h:      \param c0 C-coordinate of the sub-image location.
liveimage_srv/CImg.h:    //! Save image as a sub-image into an existing .cimg file \overloading.
liveimage_srv/CImg.h:        \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        - All pixel values of the saved image are set to \c 0.
liveimage_srv/CImg.h:        - Use this method to save large images without having to instantiate and allocate them.
liveimage_srv/CImg.h:    //! Save image as an INRIMAGE-4 file.
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:    //! Save image as an INRIMAGE-4 file \overloading.
liveimage_srv/CImg.h:      int inrpixsize = -1;
liveimage_srv/CImg.h:      int err = cimg_snprintf(header,header._width,"#INRIMAGE-4#{\nXDIM=%u\nYDIM=%u\nZDIM=%u\nVDIM=%u\n",
liveimage_srv/CImg.h:      std::memset(header._data + err,'\n',252 - err);
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:    //! Save image as a Pandore-5 file.
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:    //! Save image as a Pandore-5 file \overloading.
liveimage_srv/CImg.h:       buffer-=size(); \
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        if (!is_multiplexed || _spectrum==1) cimg::fwrite(_data,size(),nfile); // Non-multiplexed
liveimage_srv/CImg.h:      if (!is_multiplexed || _spectrum==1) // Non-multiplexed
liveimage_srv/CImg.h:      if (S && (!is_multiplexed || _spectrum==1)) // Non-multiplexed
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       \param is_rgb Tells if pixel values of the instance image are RGB-coded (\c true) or YUV-coded (\c false).
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       - Instance image contains the vertices data of the 3D object.
liveimage_srv/CImg.h:       - Textured, transparent or sphere-shaped primitives cannot be managed by the .off file format.
liveimage_srv/CImg.h:       - The .off file format is <a href="http://people.sc.fsu.edu/~jburkardt/html/off_format.html">described here</a>.
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       \param codec Video codec, as a C-string.
liveimage_srv/CImg.h:       - Each slice of the instance image is considered to be a single frame of the output video file.
liveimage_srv/CImg.h:       - This method uses \c ffmpeg, an external executable binary provided by
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -c \"%s\" > \"%s\"",
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"\"%s\" convert -quality %u \"%s\" \"%s\"",
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -quality %u \"%s\" \"%s\"",
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -w -c dicom -o \"%s\" -f \"%s\"",
liveimage_srv/CImg.h:        cimg_snprintf(command,command._width,"m000-%s",filename);
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:       - The filename extension tells about the desired file format.
liveimage_srv/CImg.h:       - This method tries to save the instance image as a file, using external tools from
liveimage_srv/CImg.h:       - It is recommended to use the generic method save(const char*, int) const instead,
liveimage_srv/CImg.h:   #-----------------------------------------
liveimage_srv/CImg.h:   #------------------------------------------
liveimage_srv/CImg.h:       - The \c CImgList<T>::iterator type is defined as a <tt>CImg<T>*</tt>.
liveimage_srv/CImg.h:       - You may use it like this:
liveimage_srv/CImg.h:       - Using the loop macro \c cimglist_for is another (more concise) alternative:
liveimage_srv/CImg.h:       - The \c CImgList<T>::const_iterator type is defined to be a <tt>const CImg<T>*</tt>.
liveimage_srv/CImg.h:       - Similar to CImgList<T>::iterator, but for constant list instances.
liveimage_srv/CImg.h:       - The \c CImgList<T>::value_type type of a \c CImgList<T> is defined to be a \c T.
liveimage_srv/CImg.h:       - \c CImgList<T>::value_type is actually not used in %CImg methods. It has been mainly defined for
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:    //--------------------------------------------------------
liveimage_srv/CImg.h:    //--------------------------------------------------------
liveimage_srv/CImg.h:       - Any allocated buffer is deallocated.
liveimage_srv/CImg.h:       - Destroying an empty list does nothing actually.
liveimage_srv/CImg.h:       - An empty list has no pixel data and its dimension width() is set to \c 0, as well as its
liveimage_srv/CImg.h:       - An empty list may be reassigned afterwards, with the family of the assign() methods.
liveimage_srv/CImg.h:        T *ptrd = _data->_data; \
liveimage_srv/CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of \c img.
liveimage_srv/CImg.h:       \param is_shared Tells if the element of the list is a shared or non-shared copy of \c img.
liveimage_srv/CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
liveimage_srv/CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
liveimage_srv/CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
liveimage_srv/CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
liveimage_srv/CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
liveimage_srv/CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
liveimage_srv/CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
liveimage_srv/CImg.h:       \param is_shared Tells if the elements of the list are shared or non-shared copies of input images.
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:    //------------------------------------------
liveimage_srv/CImg.h:    //------------------------------------------
liveimage_srv/CImg.h:      return const_cast<CImgList<T>*>(this)->operator()(pos);
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:    //! Return a non-shared copy of a list.
liveimage_srv/CImg.h:          It forces the copy to have non-shared elements.
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:       - The returned string does not contain any spaces.
liveimage_srv/CImg.h:       - If the pixel type \c T does not correspond to a registered type, the string <tt>"unknown"</tt> is returned.
liveimage_srv/CImg.h:    //! Return pointer to the pos-th image of the list.
liveimage_srv/CImg.h:      return const_cast<CImgList<T>*>(this)->data(l);
liveimage_srv/CImg.h:    //! Return pointer to the pos-th image of the list \const.
liveimage_srv/CImg.h:      return *(_data + _width - 1);
liveimage_srv/CImg.h:      return *(_data + _width - 1);
liveimage_srv/CImg.h:    //! Return pos-th image of the list.
liveimage_srv/CImg.h:      return _data[cimg::cut(pos,0,width() - 1)];
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atXYZC(x,y,z,c);
liveimage_srv/CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atXYZC(x,y,z,c);
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atXYZ(x,y,z,c);
liveimage_srv/CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atXYZ(x,y,z,c);
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atXY(x,y,z,c);
liveimage_srv/CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atXY(x,y,z,c);
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atX(x,y,z,c);
liveimage_srv/CImg.h:      return _data[cimg::cut(pos,0,width() - 1)].atX(x,y,z,c);
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param x X-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the pixel value.
liveimage_srv/CImg.h:      return _data[cimg::cut(pos,0,width() - 1)](x,y,z,c);
liveimage_srv/CImg.h:      return _data[cimg::cut(pos,0,width() - 1)](x,y,z,c);
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:    // (cannot be documented because macro-generated).
liveimage_srv/CImg.h:       \param x X-coordinate of the checked pixel value.
liveimage_srv/CImg.h:       \param y Y-coordinate of the checked pixel value.
liveimage_srv/CImg.h:       \param z Z-coordinate of the checked pixel value.
liveimage_srv/CImg.h:       \param c C-coordinate of the checked pixel value.
liveimage_srv/CImg.h:       \param[out] x X-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       \param[out] y Y-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       \param[out] z Z-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       \param[out] c C-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       \param[out] x X-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       \param[out] y Y-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       \param[out] z Z-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       \param[out] x X-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       \param[out] y Y-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:       \param[out] x X-coordinate of the pixel value, if test succeeds.
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:    //-------------------------------------
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:    //---------------------------
liveimage_srv/CImg.h:        if (new_data) { // Insert with re-allocation
liveimage_srv/CImg.h:          if (npos!=_width - 1)
liveimage_srv/CImg.h:            std::memcpy((void*)(new_data + npos + 1),(void*)(_data + npos),sizeof(CImg<T>)*(_width - 1 - npos));
liveimage_srv/CImg.h:          std::memset((void*)_data,0,sizeof(CImg<T>)*(_width - 1));
liveimage_srv/CImg.h:        } else if (npos!=_width - 1) // Insert without re-allocation
liveimage_srv/CImg.h:          std::memmove((void*)(_data + npos + 1),(void*)(_data + npos),sizeof(CImg<T>)*(_width - 1 - npos));
liveimage_srv/CImg.h:          _data->_width = img._width;
liveimage_srv/CImg.h:          _data->_height = img._height;
liveimage_srv/CImg.h:          _data->_depth = img._depth;
liveimage_srv/CImg.h:          _data->_spectrum = img._spectrum;
liveimage_srv/CImg.h:          _data->_is_shared = true;
liveimage_srv/CImg.h:          _data->_data = img._data;
liveimage_srv/CImg.h:        if (new_data) { // Insert with re-allocation
liveimage_srv/CImg.h:          if (npos!=_width - 1)
liveimage_srv/CImg.h:            std::memcpy((void*)(new_data + npos + 1),(void*)(_data + npos),sizeof(CImg<T>)*(_width - 1 - npos));
liveimage_srv/CImg.h:          std::memset((void*)_data,0,sizeof(CImg<T>)*(_width - 1));
liveimage_srv/CImg.h:        } else { // Insert without re-allocation
liveimage_srv/CImg.h:          if (npos!=_width - 1)
liveimage_srv/CImg.h:            std::memmove((void*)(_data + npos + 1),(void*)(_data + npos),sizeof(CImg<T>)*(_width - 1 - npos));
liveimage_srv/CImg.h:        npos2 = tpos2<_width?tpos2:_width - 1;
liveimage_srv/CImg.h:                                    "remove(): Invalid remove request at positions %u->%u.",
liveimage_srv/CImg.h:                                      "remove(): Invalid remove request at positions %u->%u.",
liveimage_srv/CImg.h:        const unsigned int nb = 1 + npos2 - npos1;
liveimage_srv/CImg.h:        if (!(_width-=nb)) return assign();
liveimage_srv/CImg.h:            std::memmove((void*)(_data + npos1),(void*)(_data + npos2 + 1),sizeof(CImg<T>)*(_width - npos1));
liveimage_srv/CImg.h:            std::memcpy((void*)(new_data + npos1),(void*)(_data + npos2 + 1),sizeof(CImg<T>)*(_width - npos1));
liveimage_srv/CImg.h:            std::memset((void*)(new_data + _width),0,sizeof(CImg<T>)*(_allocated_width - _width));
liveimage_srv/CImg.h:      return remove(_width - 1);
liveimage_srv/CImg.h:      for (unsigned int l = 0; l<_width/2; ++l) (*this)[l].swap((*this)[_width - 1 - l]);
liveimage_srv/CImg.h:                                    "images(): Specified sub-list indices (%u->%u) are out of bounds.",
liveimage_srv/CImg.h:      CImgList<T> res(pos1 - pos0 + 1);
liveimage_srv/CImg.h:                                    "get_shared_images(): Specified sub-list indices (%u->%u) are out of bounds.",
liveimage_srv/CImg.h:      CImgList<T> res(pos1 - pos0 + 1);
liveimage_srv/CImg.h:                                    "get_shared_images(): Specified sub-list indices (%u->%u) are out of bounds.",
liveimage_srv/CImg.h:      CImgList<T> res(pos1 - pos0 + 1);
liveimage_srv/CImg.h:      case 'x' : { // Along the X-axis
liveimage_srv/CImg.h:                               (int)(align*(dy - img._height)),
liveimage_srv/CImg.h:                               (int)(align*(dz - img._depth)),
liveimage_srv/CImg.h:                               (int)(align*(dc - img._spectrum)),
liveimage_srv/CImg.h:      case 'y' : { // Along the Y-axis
liveimage_srv/CImg.h:                res.draw_image((int)(align*(dx - img._width)),
liveimage_srv/CImg.h:                               (int)(align*(dz - img._depth)),
liveimage_srv/CImg.h:                               (int)(align*(dc - img._spectrum)),
liveimage_srv/CImg.h:      case 'z' : { // Along the Z-axis
liveimage_srv/CImg.h:                res.draw_image((int)(align*(dx - img._width)),
liveimage_srv/CImg.h:                               (int)(align*(dy - img._height)),
liveimage_srv/CImg.h:                               (int)(align*(dc - img._spectrum)),
liveimage_srv/CImg.h:      default : { // Along the C-axis
liveimage_srv/CImg.h:                res.draw_image((int)(align*(dx - img._width)),
liveimage_srv/CImg.h:                               (int)(align*(dy - img._height)),
liveimage_srv/CImg.h:                               (int)(align*(dz - img._depth)),
liveimage_srv/CImg.h:    CImgList<T>& split(const char axis, const int nb=-1) {
liveimage_srv/CImg.h:    CImgList<T> get_split(const char axis, const int nb=-1) const {
liveimage_srv/CImg.h:      return remove(_width - 1);
liveimage_srv/CImg.h:      return remove(iter - _data);
liveimage_srv/CImg.h:    //----------------------------------
liveimage_srv/CImg.h:    //----------------------------------
liveimage_srv/CImg.h:       \return A one-column vector containing the selected image indexes.
liveimage_srv/CImg.h:       \return A one-column vector containing the selected image indexes.
liveimage_srv/CImg.h:          w = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,false),
liveimage_srv/CImg.h:          h = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,true);
liveimage_srv/CImg.h:      CImg<intT> positions(_width,4,1,1,-1);
liveimage_srv/CImg.h:      int oindex0 = -1, oindex1 = -1, index0 = -1, index1 = -1;
liveimage_srv/CImg.h:              const unsigned int h = CImgDisplay::_fitscreen(res._width,res._height,1,128,-85,true);
liveimage_srv/CImg.h:              res.resize(x1 - x0,std::max(32U,h*disp._height/max_height),1,res._spectrum==1?3:-100);
liveimage_srv/CImg.h:              positions(ind,1) = positions(ind,3) = (int)(align*(visu0.height() - res.height()));
liveimage_srv/CImg.h:              positions(ind,3)+=res._height - 1;
liveimage_srv/CImg.h:              src._get_select(disp,old_normalization,(src._width - 1)/2,(src._height - 1)/2,(src._depth - 1)/2).
liveimage_srv/CImg.h:              const unsigned int w = CImgDisplay::_fitscreen(res._width,res._height,1,128,-85,false);
liveimage_srv/CImg.h:              res.resize(std::max(32U,w*disp._width/max_width),y1 - y0,1,res._spectrum==1?3:-100);
liveimage_srv/CImg.h:              positions(ind,0) = positions(ind,2) = (int)(align*(visu0.width() - res.width()));
liveimage_srv/CImg.h:              positions(ind,2)+=res._width - 1;
liveimage_srv/CImg.h:          if (axis=='x') --positions(_ind,2); else --positions(_ind,3);
liveimage_srv/CImg.h:                if ((axis=='x' && positions(ind,2) - positions(ind,0)>=8) ||
liveimage_srv/CImg.h:                    (axis!='x' && positions(ind,3) - positions(ind,1)>=8))
liveimage_srv/CImg.h:            if (is_clicked) visu.__draw_text(" Images #%u - #%u, Size = %u ",font_size,(int)text_down,
liveimage_srv/CImg.h:                                             orig + indm,orig + indM,indM - indm + 1);
liveimage_srv/CImg.h:        int index = -1;
liveimage_srv/CImg.h:            if (!(disp.button()&1)) { is_clicked = is_selected = false; index0 = index1 = -1; }
liveimage_srv/CImg.h:            else index1 = -1;
liveimage_srv/CImg.h:          } else index0 = index1 = -1;
liveimage_srv/CImg.h:        if (disp.button()&4) { is_clicked = is_selected = false; index0 = index1 = -1; }
liveimage_srv/CImg.h:        if (disp.button()&2 && exit_on_rightbutton) { is_selected = true; index1 = index0 = -1; }
liveimage_srv/CImg.h:              resize(CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,false),
liveimage_srv/CImg.h:                     CImgDisplay::_fitscreen(3*disp.width()/2,3*disp.height()/2,1,128,-100,true),false).
liveimage_srv/CImg.h:        else if (ym>=visu.height() - 13) { if (text_down) { visu.assign(); text_down = false; }}
liveimage_srv/CImg.h:      CImg<intT> res(1,2,1,1,-1);
liveimage_srv/CImg.h:      const bool is_stdin = *filename=='-' && (!filename[1] || filename[1]=='.');
liveimage_srv/CImg.h:          _data->load(filename);
liveimage_srv/CImg.h:                  CImg<T>(ptrd,std::min(8*raw._width,(unsigned int)(img.end() - ptrd)),1,1,1,true).\
liveimage_srv/CImg.h:                  to_read-=raw._width; \
liveimage_srv/CImg.h:                  for (ulongT off = (ulongT)raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); \
liveimage_srv/CImg.h:                  to_read-=raw._width; \
liveimage_srv/CImg.h:      err = cimg_sscanf(tmp,"%u%*c%255[A-Za-z123468_]%*c%255[sA-Za-z_ ]",
liveimage_srv/CImg.h:      \param x0 Starting X-coordinates of image regions to read.
liveimage_srv/CImg.h:      \param y0 Starting Y-coordinates of image regions to read.
liveimage_srv/CImg.h:      \param z0 Starting Z-coordinates of image regions to read.
liveimage_srv/CImg.h:      \param c0 Starting C-coordinates of image regions to read.
liveimage_srv/CImg.h:      \param x1 Ending X-coordinates of image regions to read (~0U for max).
liveimage_srv/CImg.h:      \param y1 Ending Y-coordinates of image regions to read (~0U for max).
liveimage_srv/CImg.h:      \param z1 Ending Z-coordinates of image regions to read (~0U for max).
liveimage_srv/CImg.h:      \param c1 Ending C-coordinates of image regions to read (~0U for max).
liveimage_srv/CImg.h:    //! Load a sub-image list from a (non compressed) .cimg file \overloading.
liveimage_srv/CImg.h:    //! Load a sub-image list from a (non compressed) .cimg file \newinstance.
liveimage_srv/CImg.h:                _nx1 = nx1==~0U?W - 1:nx1, \
liveimage_srv/CImg.h:                _ny1 = ny1==~0U?H - 1:ny1, \
liveimage_srv/CImg.h:                _nz1 = nz1==~0U?D - 1:nz1, \
liveimage_srv/CImg.h:                _nc1 = nc1==~0U?C - 1:nc1; \
liveimage_srv/CImg.h:                                            "[%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) " \
liveimage_srv/CImg.h:              CImg<Tss> raw(1 + _nx1 - nx0); \
liveimage_srv/CImg.h:              CImg<T> &img = _data[l - nn0]; \
liveimage_srv/CImg.h:              img.assign(1 + _nx1 - nx0,1 + _ny1 - ny0,1 + _nz1 - nz0,1 + _nc1 - nc0); \
liveimage_srv/CImg.h:              for (unsigned int c = 1 + _nc1 - nc0; c; --c) { \
liveimage_srv/CImg.h:                for (unsigned int z = 1 + _nz1 - nz0; z; --z) { \
liveimage_srv/CImg.h:                  for (unsigned int y = 1 + _ny1 - ny0; y; --y) { \
liveimage_srv/CImg.h:                    for (unsigned int off = raw._width; off; --off) *(ptrd++) = (T)*(ptrs++); \
liveimage_srv/CImg.h:                    const ulongT skipxe = (W - 1 - _nx1)*sizeof(Tss); \
liveimage_srv/CImg.h:                  const ulongT skipye = (H - 1 - _ny1)*W*sizeof(Tss); \
liveimage_srv/CImg.h:                const ulongT skipze = (D - 1 - _nz1)*W*H*sizeof(Tss); \
liveimage_srv/CImg.h:              const ulongT skipve = (C - 1 - _nc1)*W*H*D*sizeof(Tss); \
liveimage_srv/CImg.h:      err = cimg_sscanf(tmp,"%u%*c%255[A-Za-z123468_]%*c%255[sA-Za-z_ ]",
liveimage_srv/CImg.h:      nn1 = n1==~0U?N - 1:n1;
liveimage_srv/CImg.h:                                    "load_cimg(): Invalid specified coordinates [%u](%u,%u,%u,%u) -> [%u](%u,%u,%u,%u) "
liveimage_srv/CImg.h:      assign(1 + nn1 - n0);
liveimage_srv/CImg.h:        std::strncpy(filenamepar,filename,filenamepar._width - 1);
liveimage_srv/CImg.h:        std::strncpy(filenamepar,filename,filenamepar._width - 1);
liveimage_srv/CImg.h:        std::strncpy(filenamerec,filename,filenamerec._width - 1);
liveimage_srv/CImg.h:        std::strncpy(filenamerec,filename,filenamerec._width - 1);
liveimage_srv/CImg.h:          st_slices[st_slices._width - 1][7] = (float)i;
liveimage_srv/CImg.h:          sn = (unsigned int)vec[0] - 1,
liveimage_srv/CImg.h:                                "load_parrec(): Unsupported %d-bits pixel type for file '%s'.",
liveimage_srv/CImg.h:                              "load_parrec(): Failed to recognize valid PAR-REC data in file '%s'.",
liveimage_srv/CImg.h:            if (nstep_frame>1) cimg::fseek(nfile,(uint64T)(nstep_frame - 1)*(size_x*size_y + size_x*size_y/2),SEEK_CUR);
liveimage_srv/CImg.h:                   nlast_frame,frame - 1,filename?filename:"(FILE*)");
liveimage_srv/CImg.h:      \param filename Filename, as a C-string.
liveimage_srv/CImg.h:                                    "('-Dcimg_use_opencv' must be defined).",
liveimage_srv/CImg.h:      static int last_used_index = -1;
liveimage_srv/CImg.h:      int index = -1;
liveimage_srv/CImg.h:          captures[index]->release();
liveimage_srv/CImg.h:          if (last_used_index==index) last_used_index = -1;
liveimage_srv/CImg.h:          index = -1;
liveimage_srv/CImg.h:                                      "non-(null) filename argument for the first call.",
liveimage_srv/CImg.h:        if (!captures[index]->isOpened()) {
liveimage_srv/CImg.h:      const unsigned int nb_frames = (unsigned int)std::max(0.,captures[index]->get(_cimg_cap_prop_frame_count));
liveimage_srv/CImg.h:        if (!captures[index]->grab()) { cimg::mutex(9,0); go_on = false; break; }
liveimage_srv/CImg.h:      const unsigned int _last_frame = std::min(nb_frames?nb_frames - 1:~0U,last_frame);
liveimage_srv/CImg.h:        if (captures[index]->read(cvimg)) { CImg<T>::_cvmat2cimg(cvimg).move_to(*this); ++pos; }
liveimage_srv/CImg.h:            if (!captures[index]->grab()) go_on = false;
liveimage_srv/CImg.h:        captures[index]->release();
liveimage_srv/CImg.h:        index = -1;
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -v -8 -i \"%s\" \"%s\"",
liveimage_srv/CImg.h:        else cimg_snprintf(filename_tmp2,filename_tmp2._width,"%s-0.png",filename_tmp._data);
liveimage_srv/CImg.h:      else cimg_snprintf(command,command._width,"\"%s\" -coalesce \"%s\" \"%s.png\"",
liveimage_srv/CImg.h:          else cimg_snprintf(filename_tmp2,filename_tmp2._width,"%s-%u.png",filename_tmp._data,i);
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -c \"%s\" > \"%s\"",
liveimage_srv/CImg.h:                                    "load_tiff(): Unable to load sub-images from file '%s' unless libtiff is enabled.",
liveimage_srv/CImg.h:        if (nlast_frame>=nb_images) nlast_frame = nb_images - 1;
liveimage_srv/CImg.h:        assign(1 + (nlast_frame - nfirst_frame)/nstep_frame);
liveimage_srv/CImg.h:    //! Load a multi-page TIFF file \newinstance.
liveimage_srv/CImg.h:    //----------------------------------
liveimage_srv/CImg.h:    //----------------------------------
liveimage_srv/CImg.h:      if (_data) std::fprintf(cimg::output(),"..%p.\n",(void*)((char*)end() - 1));
liveimage_srv/CImg.h:        if (ll==3 && width()>8) { ll = width() - 5; std::fprintf(cimg::output(),"  ...\n"); }
liveimage_srv/CImg.h:              w = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,false),
liveimage_srv/CImg.h:              h = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,true);
liveimage_srv/CImg.h:          disp.assign(cimg_fitscreen(sum_width,max_height,1),title?title:titles?titles->__display()._data:0,1);
liveimage_srv/CImg.h:              w = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,false),
liveimage_srv/CImg.h:              h = CImgDisplay::_fitscreen(img._width,img._height,img._depth,128,-85,true);
liveimage_srv/CImg.h:          disp.assign(cimg_fitscreen(max_width,sum_height,1),title?title:titles?titles->__display()._data:0,1);
liveimage_srv/CImg.h:      else if (titles) disp.set_title("%s",titles->__display()._data);
liveimage_srv/CImg.h:                ind0 = (unsigned int)std::max(0,s[0] - (int)delta),
liveimage_srv/CImg.h:                ind1 = (unsigned int)std::min(width() - 1,s[0] + (int)delta);
liveimage_srv/CImg.h:              if ((ind0!=0 || ind1!=_width - 1) && ind1 - ind0>=3) {
liveimage_srv/CImg.h:                if (titles) t_sublist = titles->get_shared_images(ind0,ind1);
liveimage_srv/CImg.h:          } else if (s[0]!=0 || s[1]!=width() - 1) {
liveimage_srv/CImg.h:            if (titles) t_sublist = titles->get_shared_images(s[0],s[1]);
liveimage_srv/CImg.h:        if (l!=width() - 1) {
liveimage_srv/CImg.h:          str[str._width - 2] = ',';
liveimage_srv/CImg.h:          str[str._width - 1] = ' ';
liveimage_srv/CImg.h:    const CImgList<T>& save(const char *const filename, const int number=-1, const unsigned int digits=6) const {
liveimage_srv/CImg.h:      const bool is_stdout = *filename=='-' && (!filename[1] || filename[1]=='.');
liveimage_srv/CImg.h:        if (_width==1) _data[0].save(fn,-1);
liveimage_srv/CImg.h:        else cimglist_for(*this,l) { _data[l].save(fn,is_stdout?-1:l); if (is_stdout) std::fputc(EOF,cimg::_stdout()); }
liveimage_srv/CImg.h:       \param filename Filename, as a C-string.
liveimage_srv/CImg.h:        if (_data[l]._depth>1 || _data[l]._spectrum!=3) _data[l].get_resize(-100,-100,1,3).save(filename_tmp2);
liveimage_srv/CImg.h:      cimg_snprintf(command,command._width,"\"%s\" -delay %u -loop %u",
liveimage_srv/CImg.h:      cimglist_for_in(*this,1,filenames._width - 1,l) std::remove(filenames[l]);
liveimage_srv/CImg.h:            if (YUV._width!=width0 || YUV._height!=height0) YUV.resize(width0,height0,1,-100,0);
liveimage_srv/CImg.h:            if (YUV._spectrum!=3) YUV.resize(-100,-100,1,3,YUV._spectrum==1?1:0);
liveimage_srv/CImg.h:            } else { // Non-boolean data
liveimage_srv/CImg.h:          if (failed_to_compress) { // Write non-compressed
liveimage_srv/CImg.h:            } else cimg::fwrite(ref._data,ref.size(),nfile); // Non-boolean data
liveimage_srv/CImg.h:              const CImg<T>& img = (*this)[l - n0]; \
liveimage_srv/CImg.h:                x1 = x0 + img._width - 1, \
liveimage_srv/CImg.h:                y1 = y0 + img._height - 1, \
liveimage_srv/CImg.h:                z1 = z0 + img._depth - 1, \
liveimage_srv/CImg.h:                c1 = c0 + img._spectrum - 1, \
liveimage_srv/CImg.h:                nx1 = x1>=W?W - 1:x1, \
liveimage_srv/CImg.h:                ny1 = y1>=H?H - 1:y1, \
liveimage_srv/CImg.h:                nz1 = z1>=D?D - 1:z1, \
liveimage_srv/CImg.h:                nc1 = c1>=C?C - 1:c1; \
liveimage_srv/CImg.h:              CImg<Tss> raw(1 + nx1 - x0); \
liveimage_srv/CImg.h:              for (unsigned int v = 1 + nc1 - c0; v; --v) { \
liveimage_srv/CImg.h:                for (unsigned int z = 1 + nz1 - z0; z; --z) { \
liveimage_srv/CImg.h:                  for (unsigned int y = 1 + ny1 - y0; y; --y) { \
liveimage_srv/CImg.h:                    const unsigned int skipxe = (W - 1 - nx1)*sizeof(Tss); \
liveimage_srv/CImg.h:                  const unsigned int skipye = (H - 1 - ny1)*W*sizeof(Tss); \
liveimage_srv/CImg.h:                const unsigned int skipze = (D - 1 - nz1)*W*H*sizeof(Tss); \
liveimage_srv/CImg.h:              const unsigned int skipve = (C - 1 - nc1)*W*H*D*sizeof(Tss); \
liveimage_srv/CImg.h:      err = cimg_sscanf(tmp,"%u%*c%255[A-Za-z123468_]%*c%255[sA-Za-z_ ]",&N,str_pixeltype._data,str_endian._data);
liveimage_srv/CImg.h:      \param x0 Starting X-coordinates of image regions to write.
liveimage_srv/CImg.h:      \param y0 Starting Y-coordinates of image regions to write.
liveimage_srv/CImg.h:      \param z0 Starting Z-coordinates of image regions to write.
liveimage_srv/CImg.h:      \param c0 Starting C-coordinates of image regions to write.
liveimage_srv/CImg.h:      \param x0 Starting X-coordinates of image regions to write.
liveimage_srv/CImg.h:      \param y0 Starting Y-coordinates of image regions to write.
liveimage_srv/CImg.h:      \param z0 Starting Z-coordinates of image regions to write.
liveimage_srv/CImg.h:      \param c0 Starting C-coordinates of image regions to write.
liveimage_srv/CImg.h:      for (unsigned int i=nb; i; --i) {
liveimage_srv/CImg.h:        for (ulongT off = siz; off; --off) std::fputc(0,nfile);
liveimage_srv/CImg.h:    //! Save empty (non-compressed) .cimg file with specified dimensions.
liveimage_srv/CImg.h:        cimg_snprintf(command,command._width,"\"%s\" -c \"%s\" > \"%s\"",
liveimage_srv/CImg.h:        static int last_used_index = -1;
liveimage_srv/CImg.h:        int index = -1;
liveimage_srv/CImg.h:                                        "non-(null) filename argument for the first call.",
liveimage_srv/CImg.h:          if (!writers[index]->isOpened()) {
liveimage_srv/CImg.h:                writers[index]->write(CImg<ucharT>(_src)._cimg2cvmat());
liveimage_srv/CImg.h:                __src.channels(0,std::min(__src._spectrum - 1,2U)).resize(W,H);
liveimage_srv/CImg.h:                writers[index]->write(__src._cimg2cvmat());
liveimage_srv/CImg.h:          last_used_index = -1;
liveimage_srv/CImg.h:            _src.assign(_src.get_resize(_src._width + (_src._width%2),_src._height + (_src._height%2),1,-100,0),false);
liveimage_srv/CImg.h:            _src.assign(_src.get_resize(-100,-100,1,3),false);
liveimage_srv/CImg.h:                    "\"%s\" -v -8 -y -i \"%s_%%6d.ppm\" -pix_fmt yuv420p -vcodec %s -b %uk -r %u \"%s\"",
liveimage_srv/CImg.h:          if (failed_to_compress) { // Write in a non-compressed way
liveimage_srv/CImg.h:      err = cimg_sscanf(tmp,"%u%*c%255[A-Za-z123468_]%*c%255[sA-Za-z_ ]",
liveimage_srv/CImg.h:    //----------------------------------
liveimage_srv/CImg.h:    //----------------------------------
liveimage_srv/CImg.h:    //! Return a CImg pre-defined font with requested height.
liveimage_srv/CImg.h:          dataf.append(CImg<char>::string(font_data[ind][k],k==font_chunk[ind] - 1,true),'x');
liveimage_srv/CImg.h:            const int _n = (int)(*ptrs - M - 32), v = _n>=0?255:0, n = _n>=0?_n:-_n;
liveimage_srv/CImg.h:            else { std::memset(ptrd,v,ptrde - ptrd); break; }
liveimage_srv/CImg.h:            int n = (int)*ptrs - M - 32, v = 0;
liveimage_srv/CImg.h:              n = -n;
liveimage_srv/CImg.h:              v = (int)*(++ptrs) - M - 32;
liveimage_srv/CImg.h:              if (v<0) { v = 0; --ptrs; } else v*=85;
liveimage_srv/CImg.h:            else { std::memset(ptrd,v,ptrde - ptrd); break; }
liveimage_srv/CImg.h:        fonts->assign();
liveimage_srv/CImg.h:            font[l].resize(std::max(1U,font[l]._width*requested_height/font[l]._height),requested_height,-100,-100,5);
liveimage_srv/CImg.h:            if (xmin<=xmax) letter.crop(xmin,0,xmax,letter._height - 1);
liveimage_srv/CImg.h:          font[(int)' '].resize(font[(int)'f']._width,-100,-100,-100,0);
liveimage_srv/CImg.h:          if (' ' + 256<font.size()) font[' ' + 256].resize(font[(int)'f']._width,-100,-100,-100,0);
liveimage_srv/CImg.h:    //! Compute a 1-D Fast Fourier Transform, along specified axis \newinstance.
liveimage_srv/CImg.h:    //! Compute n-D Fast Fourier Transform.
liveimage_srv/CImg.h:    //! Compute n-D Fast Fourier Transform \newinstance.
liveimage_srv/CImg.h:  //--------------------------------------------
liveimage_srv/CImg.h:      // Try alternative method, with wide-character string.
liveimage_srv/CImg.h:      int err = MultiByteToWideChar(CP_UTF8,0,path,-1,0,0);
liveimage_srv/CImg.h:        err = MultiByteToWideChar(CP_UTF8,0,path,-1,wpath,err);
liveimage_srv/CImg.h:        if (err) { // Convert 'mode' to a wide-character string
liveimage_srv/CImg.h:          err = MultiByteToWideChar(CP_UTF8,0,mode,-1,0,0);
liveimage_srv/CImg.h:            if (MultiByteToWideChar(CP_UTF8,0,mode,-1,wmode,err))
liveimage_srv/CImg.h:    //! Get the file or directory attributes with support for UTF-8 paths (Windows only).
liveimage_srv/CImg.h:        // Try alternative method, with wide-character string.
liveimage_srv/CImg.h:        int err = MultiByteToWideChar(CP_UTF8,0,path,-1,0,0);
liveimage_srv/CImg.h:          if (MultiByteToWideChar(CP_UTF8,0,path,-1,wpath,err)) res = GetFileAttributesW(wpath);
liveimage_srv/CImg.h:          if (pfPath) std::strncpy(s_path,pfPath,MAX_PATH - 1);
liveimage_srv/CImg.h:        for (int k = 32; k>=10 && !path_found; --k) {
liveimage_srv/CImg.h:          cimg_snprintf(s_path,s_path._width,"%s\\GRAPHI~1.%.2d-\\gm.exe",pf_path,k);
liveimage_srv/CImg.h:        for (int k = 9; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          cimg_snprintf(s_path,s_path._width,"%s\\GRAPHI~1.%d-Q\\gm.exe",pf_path,k);
liveimage_srv/CImg.h:        for (int k = 32; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:        for (int k = 32; k>=10 && !path_found; --k) {
liveimage_srv/CImg.h:          cimg_snprintf(s_path,s_path._width,"%s\\GRAPHI~1.%.2d-\\VISUA~1\\BIN\\gm.exe",pf_path,k);
liveimage_srv/CImg.h:        for (int k = 9; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          cimg_snprintf(s_path,s_path._width,"%s\\GRAPHI~1.%d-Q\\VISUA~1\\BIN\\gm.exe",pf_path,k);
liveimage_srv/CImg.h:        for (int k = 32; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:        for (int k = 32; k>=10 && !path_found; --k) {
liveimage_srv/CImg.h:          cimg_snprintf(s_path,s_path._width,"C:\\GRAPHI~1.%.2d-\\gm.exe",k);
liveimage_srv/CImg.h:        for (int k = 9; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          cimg_snprintf(s_path,s_path._width,"C:\\GRAPHI~1.%d-Q\\gm.exe",k);
liveimage_srv/CImg.h:        for (int k = 32; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:        for (int k = 32; k>=10 && !path_found; --k) {
liveimage_srv/CImg.h:          cimg_snprintf(s_path,s_path._width,"C:\\GRAPHI~1.%.2d-\\VISUA~1\\BIN\\gm.exe",k);
liveimage_srv/CImg.h:        for (int k = 9; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          cimg_snprintf(s_path,s_path._width,"C:\\GRAPHI~1.%d-Q\\VISUA~1\\BIN\\gm.exe",k);
liveimage_srv/CImg.h:        for (int k = 32; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:        for (int k = 32; k>=10 && !path_found; --k) {
liveimage_srv/CImg.h:          cimg_snprintf(s_path,s_path._width,"D:\\GRAPHI~1.%.2d-\\gm.exe",k);
liveimage_srv/CImg.h:        for (int k = 9; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          cimg_snprintf(s_path,s_path._width,"D:\\GRAPHI~1.%d-Q\\gm.exe",k);
liveimage_srv/CImg.h:        for (int k = 32; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:        for (int k = 32; k>=10 && !path_found; --k) {
liveimage_srv/CImg.h:          cimg_snprintf(s_path,s_path._width,"D:\\GRAPHI~1.%.2d-\\VISUA~1\\BIN\\gm.exe",k);
liveimage_srv/CImg.h:        for (int k = 9; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          cimg_snprintf(s_path,s_path._width,"D:\\GRAPHI~1.%d-Q\\VISUA~1\\BIN\\gm.exe",k);
liveimage_srv/CImg.h:        for (int k = 32; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          for (int k = 32; k>=10 && !path_found; --k) {
liveimage_srv/CImg.h:            cimg_snprintf(s_path,s_path._width,"%s\\IMAGEM~1.%.2d-\\%s.exe",pf_path,k,s_exe);
liveimage_srv/CImg.h:          for (int k = 9; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:            cimg_snprintf(s_path,s_path._width,"%s\\IMAGEM~1.%d-Q\\%s.exe",pf_path,k,s_exe);
liveimage_srv/CImg.h:          for (int k = 32; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          for (int k = 32; k>=10 && !path_found; --k) {
liveimage_srv/CImg.h:            cimg_snprintf(s_path,s_path._width,"%s\\IMAGEM~1.%.2d-\\VISUA~1\\BIN\\%s.exe",pf_path,k,s_exe);
liveimage_srv/CImg.h:          for (int k = 9; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:            cimg_snprintf(s_path,s_path._width,"%s\\IMAGEM~1.%d-Q\\VISUA~1\\BIN\\%s.exe",pf_path,k,s_exe);
liveimage_srv/CImg.h:          for (int k = 32; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          for (int k = 32; k>=10 && !path_found; --k) {
liveimage_srv/CImg.h:            cimg_snprintf(s_path,s_path._width,"C:\\IMAGEM~1.%.2d-\\%s.exe",k,s_exe);
liveimage_srv/CImg.h:          for (int k = 9; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:            cimg_snprintf(s_path,s_path._width,"C:\\IMAGEM~1.%d-Q\\%s.exe",k,s_exe);
liveimage_srv/CImg.h:          for (int k = 32; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          for (int k = 32; k>=10 && !path_found; --k) {
liveimage_srv/CImg.h:            cimg_snprintf(s_path,s_path._width,"C:\\IMAGEM~1.%.2d-\\VISUA~1\\BIN\\%s.exe",k,s_exe);
liveimage_srv/CImg.h:          for (int k = 9; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:            cimg_snprintf(s_path,s_path._width,"C:\\IMAGEM~1.%d-Q\\VISUA~1\\BIN\\%s.exe",k,s_exe);
liveimage_srv/CImg.h:          for (int k = 32; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          for (int k = 32; k>=10 && !path_found; --k) {
liveimage_srv/CImg.h:            cimg_snprintf(s_path,s_path._width,"D:\\IMAGEM~1.%.2d-\\%s.exe",k,s_exe);
liveimage_srv/CImg.h:          for (int k = 9; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:            cimg_snprintf(s_path,s_path._width,"D:\\IMAGEM~1.%d-Q\\%s.exe",k,s_exe);
liveimage_srv/CImg.h:          for (int k = 32; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          for (int k = 32; k>=10 && !path_found; --k) {
liveimage_srv/CImg.h:            cimg_snprintf(s_path,s_path._width,"D:\\IMAGEM~1.%.2d-\\VISUA~1\\BIN\\%s.exe",k,s_exe);
liveimage_srv/CImg.h:          for (int k = 9; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:            cimg_snprintf(s_path,s_path._width,"D:\\IMAGEM~1.%d-Q\\VISUA~1\\BIN\\%s.exe",k,s_exe);
liveimage_srv/CImg.h:          for (int k = 32; k>=0 && !path_found; --k) {
liveimage_srv/CImg.h:          std::strncpy(tmp,filename_tmp,tmp._width - 1);
liveimage_srv/CImg.h:      if (!_is_pattern && lp && _path[lp - 1]=='/') {
liveimage_srv/CImg.h:        _path[lp - 1] = 0; --lp;
liveimage_srv/CImg.h:        const unsigned int bpos = (unsigned int)(cimg::basename(_path,'/') - _path.data());
liveimage_srv/CImg.h:          _path[bpos - 1] = 0; // End 'path' at last slash
liveimage_srv/CImg.h:        const char *const filename = ent->d_name;
liveimage_srv/CImg.h:          if (stat(full_filename,&st)==-1) continue;
liveimage_srv/CImg.h:       \param filename Filename, as a C-string (can be \c 0 if \c file is set).
liveimage_srv/CImg.h:       \return C-string containing the guessed file format, or \c 0 if nothing has been guessed.
liveimage_srv/CImg.h:       \param url URL of the filename, as a C-string.
liveimage_srv/CImg.h:       \param[out] filename_local C-string containing the path to a local copy of \c filename.
liveimage_srv/CImg.h:       \param referer Referer used, as a C-string.
liveimage_srv/CImg.h:      const char *const __ext = cimg::split_filename(url), *const _ext = (*__ext && __ext>url)?__ext - 1:__ext;
liveimage_srv/CImg.h:          cimg_snprintf(command,command._width,"\"%s\" -e %s -m %u -f --silent --compressed -o \"%s\" \"%s\"",
liveimage_srv/CImg.h:          cimg_snprintf(command,command._width,"\"%s\" -m %u -f --silent --compressed -o \"%s\" \"%s\"",
liveimage_srv/CImg.h:          cimg_snprintf(command,command._width,"\"%s\" -e %s -f --silent --compressed -o \"%s\" \"%s\"",
liveimage_srv/CImg.h:          cimg_snprintf(command,command._width,"\"%s\" -f --silent --compressed -o \"%s\" \"%s\"",
liveimage_srv/CImg.h:                          "\"%s\" -NonInteractive -Command Invoke-WebRequest -Headers @{'Referer'='%s'} "
liveimage_srv/CImg.h:                          "-TimeoutSec %u -OutFile \"%s\" -Uri \"%s\"",
liveimage_srv/CImg.h:                          "\"%s\" -NonInteractive -Command Invoke-WebRequest "
liveimage_srv/CImg.h:                          "-TimeoutSec %u -OutFile \"%s\" -Uri \"%s\"",
liveimage_srv/CImg.h:            cimg_snprintf(command,command._width,"\"%s\" -NonInteractive -Command Invoke-WebRequest "
liveimage_srv/CImg.h:                          "-Headers @{'Referer'='%s'} -OutFile \"%s\" -Uri \"%s\"",
liveimage_srv/CImg.h:            cimg_snprintf(command,command._width,"\"%s\" -NonInteractive -Command Invoke-WebRequest "
liveimage_srv/CImg.h:                          "-OutFile \"%s\" -Uri \"%s\"",
liveimage_srv/CImg.h:            cimg_snprintf(command,command._width,"\"%s\" --referer=%s -T %u -q -r -l 0 --no-cache -O \"%s\" \"%s\"",
liveimage_srv/CImg.h:            cimg_snprintf(command,command._width,"\"%s\" -T %u -q -r -l 0 --no-cache -O \"%s\" \"%s\"",
liveimage_srv/CImg.h:            cimg_snprintf(command,command._width,"\"%s\" --referer=%s -q -r -l 0 --no-cache -O \"%s\" \"%s\"",
liveimage_srv/CImg.h:            cimg_snprintf(command,command._width,"\"%s\" -q -r -l 0 --no-cache -O \"%s\" \"%s\"",
liveimage_srv/CImg.h:        cimg_snprintf(command,command._width,"\"%s\" --quiet \"%s.gz\"",
liveimage_srv/CImg.h:        t0 = times[--pos],
liveimage_srv/CImg.h:        dt = t1>=t0?(t1 - t0):cimg::type<cimg_uint64>::max();
liveimage_srv/CImg.h:        ehours = (unsigned int)((dt - edays*86400000.)/3600000.),
liveimage_srv/CImg.h:        emin = (unsigned int)((dt - edays*86400000. - ehours*3600000.)/60000.),
liveimage_srv/CImg.h:        esec = (unsigned int)((dt - edays*86400000. - ehours*3600000. - emin*60000.)/1000.),
liveimage_srv/CImg.h:        ems = (unsigned int)(dt - edays*86400000. - ehours*3600000. - emin*60000. - esec*1000.);
liveimage_srv/CImg.h:       \return Index of clicked button (from \c 0 to \c 5), or \c -1 if the dialog window has been closed by the user.
liveimage_srv/CImg.h:       - Up to 6 buttons can be defined in the dialog window.
liveimage_srv/CImg.h:       - The function returns when a user clicked one of the button or closed the dialog window.
liveimage_srv/CImg.h:       - If a button text is set to 0, the corresponding button (and the following) will not appear in the dialog box.
liveimage_srv/CImg.h:      cimglist_for(buttons,l) buttons[l].resize(-100,-100,1,3);
liveimage_srv/CImg.h:      button.draw_rectangle(0,0,bw - 1,bh - 1,gray);
liveimage_srv/CImg.h:      button.draw_line(0,0,bw - 1,0,white).draw_line(0,bh - 1,0,0,white);
liveimage_srv/CImg.h:      button.draw_line(bw - 1,0,bw - 1,bh - 1,black).draw_line(bw - 1,bh - 1,0,bh - 1,black);
liveimage_srv/CImg.h:      button.draw_line(1,bh - 2,bw - 2,bh - 2,gray2).draw_line(bw - 2,bh - 2,bw - 2,1,gray2);
liveimage_srv/CImg.h:      sbutton.draw_rectangle(0,0,bw - 1,bh - 1,gray);
liveimage_srv/CImg.h:      sbutton.draw_line(0,0,bw - 1,0,black).draw_line(bw - 1,0,bw - 1,bh - 1,black);
liveimage_srv/CImg.h:      sbutton.draw_line(bw - 1,bh - 1,0,bh - 1,black).draw_line(0,bh - 1,0,0,black);
liveimage_srv/CImg.h:      sbutton.draw_line(1,1,bw - 2,1,white).draw_line(1,bh - 2,1,1,white);
liveimage_srv/CImg.h:      sbutton.draw_line(bw - 2,1,bw - 2,bh - 2,black).draw_line(bw - 2,bh - 2,1,bh - 2,black);
liveimage_srv/CImg.h:      sbutton.draw_line(2,bh - 3,bw - 3,bh - 3,gray2).draw_line(bw - 3,bh - 3,bw - 3,2,gray2);
liveimage_srv/CImg.h:      sbutton.draw_line(4,4,bw - 5,4,black,1,0xAAAAAAAA,true).
liveimage_srv/CImg.h:        draw_line(bw - 5,4,bw - 5,bh - 5,black,1,0xAAAAAAAA,false);
liveimage_srv/CImg.h:      sbutton.draw_line(bw - 5,bh - 5,4,bh - 5,black,1,0xAAAAAAAA,false).
liveimage_srv/CImg.h:        draw_line(4,bh - 5,4,4,black,1,0xAAAAAAAA,false);
liveimage_srv/CImg.h:      cbutton.draw_rectangle(0,0,bw - 1,bh - 1,black).draw_rectangle(1,1,bw - 2,bh - 2,gray2).
liveimage_srv/CImg.h:        draw_rectangle(2,2,bw - 3,bh - 3,gray);
liveimage_srv/CImg.h:      cbutton.draw_line(4,4,bw - 5,4,black,1,0xAAAAAAAA,true).
liveimage_srv/CImg.h:        draw_line(bw - 5,4,bw - 5,bh - 5,black,1,0xAAAAAAAA,false);
liveimage_srv/CImg.h:      cbutton.draw_line(bw - 5,bh - 5,4,bh - 5,black,1,0xAAAAAAAA,false).
liveimage_srv/CImg.h:        draw_line(4,bh - 5,4,4,black,1,0xAAAAAAAA,false);
liveimage_srv/CImg.h:          draw_image(1 + (bw  -buttons[ll].width())/2,1 + (bh - buttons[ll].height())/2,buttons[ll]).
liveimage_srv/CImg.h:          draw_image((bw - buttons[ll].width())/2,(bh - buttons[ll].height())/2,buttons[ll]).
liveimage_srv/CImg.h:          draw_image((bw - buttons[ll].width())/2,(bh - buttons[ll].height())/2,buttons[ll]).
liveimage_srv/CImg.h:        ((CImg<unsigned char>().draw_text(0,0,"%s",gray,0,1,13,msg)*=-1)+=200).resize(-100,-100,1,3).move_to(canvas);
liveimage_srv/CImg.h:        bwall = (buttons._width - 1)*(12 + bw) + bw,
liveimage_srv/CImg.h:        lx = 12 + (canvas._data?0:((w - 24 - logo._width)/2)),
liveimage_srv/CImg.h:        ly = (h - 12 - bh - logo._height)/2,
liveimage_srv/CImg.h:        ty = (h - 12 - bh - canvas._height)/2,
liveimage_srv/CImg.h:        bx = (w - bwall)/2,
liveimage_srv/CImg.h:        by = h - 12 - bh;
liveimage_srv/CImg.h:          draw_rectangle(0,0,w - 1,h - 1,gray).
liveimage_srv/CImg.h:          draw_line(0,0,w - 1,0,white).draw_line(0,h - 1,0,0,white).
liveimage_srv/CImg.h:          draw_line(w - 1,0,w - 1,h - 1,black).draw_line(w - 1,h - 1,0,h - 1,black).
liveimage_srv/CImg.h:          draw_rectangle(0,0,w - 1,h - 1,gray).
liveimage_srv/CImg.h:          draw_line(0,0,w - 1,0,white).draw_line(0,h - 1,0,0,white).
liveimage_srv/CImg.h:          draw_line(w - 1,0,w - 1,h - 1,black).draw_line(w - 1,h - 1,0,h - 1,black);
liveimage_srv/CImg.h:      if (is_centered) disp.move((CImgDisplay::screen_width() - disp.width())/2,
liveimage_srv/CImg.h:                                 (CImgDisplay::screen_height() - disp.height())/2);
liveimage_srv/CImg.h:      int oselected = -1, oclicked = -1, selected = -1, clicked = -1;
liveimage_srv/CImg.h:          clicked = -1;
liveimage_srv/CImg.h:          case cimg::keyESC : selected = -1; stop_flag = true; break;
liveimage_srv/CImg.h:          case cimg::keyARROWUP : selected = (selected + buttons.width() - 1)%buttons.width(); break;
liveimage_srv/CImg.h:      if (!disp) selected = -1;
liveimage_srv/CImg.h:       \param expression C-string describing the formula to evaluate.
liveimage_srv/CImg.h:       \param x Value of the pre-defined variable \c x.
liveimage_srv/CImg.h:       \param y Value of the pre-defined variable \c y.
liveimage_srv/CImg.h:       \param z Value of the pre-defined variable \c z.
liveimage_srv/CImg.h:       \param c Value of the pre-defined variable \c c.
liveimage_srv/tcpjpgmpartcam.cpp:    int by = this->receiveall(_data.buff,sizeof(LiFrmHdr));
liveimage_srv/tcpjpgmpartcam.cpp:        int len = ((LiFrmHdr*)_data.buff)->len;
liveimage_srv/tcpjpgmpartcam.cpp:        by = this->receiveall(_data.buff,len);
liveimage_srv/tcpjpgmpartcam.cpp:    this->destroy();
liveimage_srv/tcpjpgmpartcam.cpp:    int bytes = this->recdata();
liveimage_srv/tcpjpgmpartcam.cpp:    while(bytes>0 && antilock--)
liveimage_srv/tcpjpgmpartcam.cpp:            if(ph->magic==JPEG_MAGIC){
liveimage_srv/tcpjpgmpartcam.cpp:                _header.event = ph->event;
liveimage_srv/tcpjpgmpartcam.cpp:                _data.vfl = ph->len;
liveimage_srv/tcpjpgmpartcam.cpp:                if(ph->event.predicate & EVT_KEEP_ALIVE){
liveimage_srv/tcpjpgmpartcam.cpp:                bytes -= sizeof(LiFrmHdr);
liveimage_srv/tcpjpgmpartcam.cpp:                this->destroy();
liveimage_srv/tcpjpgmpartcam.cpp:                 bytes -= _data.vfl;
liveimage_srv/tcpjpgmpartcam.cpp:                if(_data.room() <= vfl - _data.left()){
liveimage_srv/tcpjpgmpartcam.cpp:                if(_data.room() > _data.vfl - _data.left())
liveimage_srv/tcpjpgmpartcam.cpp:        this->destroy();
liveimage_srv/jpeg_buffer.h: #                ( C++ header file - CImg plug-in )
liveimage_srv/jpeg_buffer.h: #  Description : This CImg plug-in provide functions to load and save jpeg images
liveimage_srv/jpeg_buffer.h: #                ( http://www.cecill.info/licences/Licence_CeCILL_V2-en.html )
liveimage_srv/jpeg_buffer.h: #  professionals having in-depth computer knowledge. Users are therefore
liveimage_srv/jpeg_buffer.h:/*-----------------------------------------------------------------------------------
liveimage_srv/jpeg_buffer.h:------------------------------------------------------------------------------------*/
liveimage_srv/jpeg_buffer.h:  my_src_mptr src = (my_src_mptr) cinfo->src;
liveimage_srv/jpeg_buffer.h:  if (src->indexinmem + INPUT_BUF_SIZE>src->lenght) nbytes=src->lenght - src->indexinmem;
liveimage_srv/jpeg_buffer.h:  std::memcpy(src->buffer,src->inmem,nbytes);
liveimage_srv/jpeg_buffer.h:  src->inmem += nbytes;
liveimage_srv/jpeg_buffer.h:  src->indexinmem += (int)nbytes;
liveimage_srv/jpeg_buffer.h:  src->pub.next_input_byte = src->buffer;
liveimage_srv/jpeg_buffer.h:  src->pub.bytes_in_buffer = INPUT_BUF_SIZE;
liveimage_srv/jpeg_buffer.h:  src->start_of_file = FALSE;
liveimage_srv/jpeg_buffer.h:  my_src_ptr src = (my_src_ptr)cinfo->src;
liveimage_srv/jpeg_buffer.h:    while (num_bytes > (long) src->pub.bytes_in_buffer) {
liveimage_srv/jpeg_buffer.h:      num_bytes -= (long) src->pub.bytes_in_buffer;
liveimage_srv/jpeg_buffer.h:    src->pub.next_input_byte += (size_t) num_bytes;
liveimage_srv/jpeg_buffer.h:    src->pub.bytes_in_buffer -= (size_t) num_bytes;
liveimage_srv/jpeg_buffer.h:  my_src_mptr src = (my_src_mptr)cinfo->src;
liveimage_srv/jpeg_buffer.h:  src->start_of_file = TRUE;
liveimage_srv/jpeg_buffer.h:  if (cinfo->src == NULL) {
liveimage_srv/jpeg_buffer.h:    cinfo->src = (struct jpeg_source_mgr*)(*cinfo->mem->alloc_small)((j_common_ptr) cinfo,
liveimage_srv/jpeg_buffer.h:    src = (my_src_mptr) cinfo->src;
liveimage_srv/jpeg_buffer.h:    src->buffer = (JOCTET *)(*cinfo->mem->alloc_small) ((j_common_ptr) cinfo,
liveimage_srv/jpeg_buffer.h:  src = (my_src_mptr) cinfo->src;
liveimage_srv/jpeg_buffer.h:  src->pub.init_source = init_msource;
liveimage_srv/jpeg_buffer.h:  src->pub.fill_input_buffer = fill_minput_buffer;
liveimage_srv/jpeg_buffer.h:  src->pub.skip_input_data = skip_minput_data;
liveimage_srv/jpeg_buffer.h:  //src->pub.resync_to_restart = jpeg_resync_to_restart; // use default method
liveimage_srv/jpeg_buffer.h:  src->pub.term_source = term_source;
liveimage_srv/jpeg_buffer.h:  src->inmem = memptr;
liveimage_srv/jpeg_buffer.h:  src->indexinmem = 0;
liveimage_srv/jpeg_buffer.h:  src->lenght = lenght;
liveimage_srv/jpeg_buffer.h:  src->pub.bytes_in_buffer = 0; // forces fill_input_buffer on first read
liveimage_srv/jpeg_buffer.h:  src->pub.next_input_byte = NULL; // until buffer loaded
liveimage_srv/jpeg_buffer.h:  mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
liveimage_srv/jpeg_buffer.h:  dest->pub.next_output_byte = dest->buf;
liveimage_srv/jpeg_buffer.h:  dest->pub.free_in_buffer = dest->bufsize;
liveimage_srv/jpeg_buffer.h:  dest->jpegsize = 0;
liveimage_srv/jpeg_buffer.h:  mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
liveimage_srv/jpeg_buffer.h:  dest->pub.next_output_byte = dest->buf;
liveimage_srv/jpeg_buffer.h:  dest->pub.free_in_buffer = dest->bufsize;
liveimage_srv/jpeg_buffer.h:  mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
liveimage_srv/jpeg_buffer.h:  dest->jpegsize = dest->bufsize - dest->pub.free_in_buffer;
liveimage_srv/jpeg_buffer.h:  if (cinfo->dest == NULL) {
liveimage_srv/jpeg_buffer.h:    cinfo->dest = (struct jpeg_destination_mgr *)
liveimage_srv/jpeg_buffer.h:      (*cinfo->mem->alloc_small)((j_common_ptr)cinfo,JPOOL_PERMANENT,sizeof(mem_destination_mgr));
liveimage_srv/jpeg_buffer.h:  dest = (mem_dest_ptr) cinfo->dest;
liveimage_srv/jpeg_buffer.h:  dest->pub.init_destination = init_destination;
liveimage_srv/jpeg_buffer.h:  dest->pub.empty_output_buffer = empty_output_buffer;
liveimage_srv/jpeg_buffer.h:  dest->pub.term_destination = term_destination;
liveimage_srv/jpeg_buffer.h:  dest->buf = buf;
liveimage_srv/jpeg_buffer.h:  dest->bufsize = bufsize;
liveimage_srv/jpeg_buffer.h:  dest->jpegsize = 0;
liveimage_srv/jpeg_buffer.h:  mem_dest_ptr dest = (mem_dest_ptr) cinfo->dest;
liveimage_srv/jpeg_buffer.h:  return dest->jpegsize;
liveimage_srv/jpeg_buffer.h://! Load image from a jpeg-coded memory buffer.
liveimage_srv/jpeg_buffer.h:   \param buffer Memory buffer containing the jpeg-coded image data.
liveimage_srv/jpeg_buffer.h://! Load image from a jpeg-coded memory buffer (in-place version)
liveimage_srv/jpeg_buffer.h:   \param buffer Memory buffer containing the jpeg-coded image data.
liveimage_srv/jpeg_buffer.h://! Save image in a memory buffer, directly as a jpeg-coded file
liveimage_srv/jpeg_buffer.h:   \param buffer Memory buffer that will be written with the jpeg-coded image data.
liveimage_srv/jpeg_buffer.h:// End of the plug-in
liveimage_srv/jpeg_buffer.h://-------------------
liveimage_srv/mk_mov.sh:if [ ! -z ${2} ];then
liveimage_srv/mk_mov.sh:        echo "-----------------------------------------------------------------------------------------------------"
liveimage_srv/mk_mov.sh:        echo "ffmpeg -framerate 30 -pattern_type glob -i '*.jpg'  -c:v libx264 -pix_fmt yuv420p \"${fname}.mp4\""
liveimage_srv/mk_mov.sh:        echo "-----------------------------------------------------------------------------------------------------"
liveimage_srv/mk_mov.sh:        ffmpeg -framerate 30 -pattern_type glob -i '*.jpg'  -c:v libx264 -pix_fmt yuv420p "${fname}.mp4"
liveimage_srv/mk_mov.sh:        if [ -f "${fname}.mp4" ];then
liveimage_srv/tcpwebjpgcli.cpp:static char JpegHdr[]="Content-Type: image/jpeg\r\n"
liveimage_srv/tcpwebjpgcli.cpp:                       "Content-Length: %d\r\n"
liveimage_srv/tcpwebjpgcli.cpp:                       "X-Timestamp: %d.%d\r\n\r\n";
liveimage_srv/tcpwebjpgcli.cpp:static char JpegPart[] = "\r\n--thesupposexuniqueb\r\nContent-type: image/jpeg\r\n";
liveimage_srv/tcpwebjpgcli.cpp:                               "Cache-Control: no-cache\r\n"
liveimage_srv/tcpwebjpgcli.cpp:                               "Content-Type: multipart/x-mixed-replace;boundary=thesupposexuniqueb\r\n"
liveimage_srv/tcpwebjpgcli.cpp:                               "--thesupposexuniqueb\r\n";
liveimage_srv/b64.h:    int val=0, valb=-6;
liveimage_srv/b64.h:            valb-=6;
liveimage_srv/b64.h:    if (valb>-6) out.push_back("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[((val<<8)>>(valb+8))&0x3F]);
liveimage_srv/b64.h:    std::vector<int> T(256,-1);
liveimage_srv/b64.h:    int val=0, valb=-8;
liveimage_srv/b64.h:        if (T[c] == -1) break;
liveimage_srv/b64.h:            valb-=8;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:bio_unblock::bio_unblock(sock* sock,int bl):_sk(sock),_bl(_sk->_blocking){
liveimage_srv/sock.cpp:    sock->set_blocking(bl);
liveimage_srv/sock.cpp:    _sk->set_blocking(_bl);
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:        ::memcpy((char*)&(sin.sin_addr),hostent->h_addr,hostent->h_length);
liveimage_srv/sock.cpp:        strcpy(out,h->h_name);
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    _thesock     = -1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    return (SOCKET)-1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    return (SOCKET)-1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    if(-1 == gethostname((char*)szBuf,(int)dwSize))
liveimage_srv/sock.cpp:    ::memcpy((char*)&(locSin.sin_addr),pHe->h_addr,pHe->h_length);
liveimage_srv/sock.cpp:        if (ifAddrStruct->ifa_addr->sa_family==AF_INET && strcmp(ifAddrStruct->ifa_name,"lo0")!=0)
liveimage_srv/sock.cpp:            tmpAddrPtr = (void*)&((SADDR_46 *)ifAddrStruct->ifa_addr)->sin_addr;
liveimage_srv/sock.cpp:            inet_ntop(AF_INET,tmpAddrPtr,tmp,(sizeof(tmp)-1));
liveimage_srv/sock.cpp:            if(strlen(localip) + strlen(tmp) < (sizeof(localip)-1) )
liveimage_srv/sock.cpp:        ifAddrStruct = ifAddrStruct->ifa_next;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    return -1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    return -1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    int      bytes = -1;
liveimage_srv/sock.cpp:    return -1; // no data this time
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:        toreceive -= shot;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:                if(--toutnonblock < 0)
liveimage_srv/sock.cpp:            this->destroy();
liveimage_srv/sock.cpp:        length -= shot;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:            return -1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:            return -1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:        while(-1==::close(_thesock) && --k>0)
liveimage_srv/sock.cpp:    _thesock = -1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    if((int)-1 == rv)
liveimage_srv/sock.cpp:        return -1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:        return (SOCKET)-1;
liveimage_srv/sock.cpp:        return (SOCKET)-1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:        return (SOCKET)-1;
liveimage_srv/sock.cpp:        return (SOCKET)-1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:        return -1;
liveimage_srv/sock.cpp://as send -1 continue,0 closed -cannot 1 ok
liveimage_srv/sock.cpp:    ::memcpy((char*)&(_remote_sin.sin_addr),_hostent->h_addr,_hostent->h_length);
liveimage_srv/sock.cpp:    this->set_blocking(_blocking);
liveimage_srv/sock.cpp:    if(-1 == ::connect(_thesock,(const struct sockaddr*)&_remote_sin,_remote_sin.rsz()))
liveimage_srv/sock.cpp:    ::memcpy((char*)&(locSin.sin_addr),_hostent->h_addr,_hostent->h_length);
liveimage_srv/sock.cpp:// 0 no connection,>0 OK,-1 in progress
liveimage_srv/sock.cpp:    if(-1 == rv)
liveimage_srv/sock.cpp:                while(SECS() - t < tout)
liveimage_srv/sock.cpp:            return -1;
liveimage_srv/sock.cpp:    if(-1 == rv)
liveimage_srv/sock.cpp:            return -1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    if((int)_thesock != (int)-1)
liveimage_srv/sock.cpp:    if(err==-1 )
liveimage_srv/sock.cpp:        while(cbCall(pUser,SECS()-ti))
liveimage_srv/sock.cpp:    if(err==-1)
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    if((int)_thesock != (int)-1)
liveimage_srv/sock.cpp:    if(err==-1)
liveimage_srv/sock.cpp:        if(pUser==(void*)-1)
liveimage_srv/sock.cpp:            return -1;
liveimage_srv/sock.cpp:        int tdiff = SECS()-ti;
liveimage_srv/sock.cpp:            tdiff = SECS()-ti;
liveimage_srv/sock.cpp:    if(err==-1)
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:        ::memcpy((char*)&(locSin.sin_addr),_hostent->h_addr,_hostent->h_length);
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    if((int)-1 == (int)_thesock)
liveimage_srv/sock.cpp:        return -1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    if((int)-1 == (int)_thesock)
liveimage_srv/sock.cpp:        return -1;
liveimage_srv/sock.cpp:        printf("udp-sock-bind-error\n");
liveimage_srv/sock.cpp:        return -1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    int snd = -1;
liveimage_srv/sock.cpp:        ////printf("<-to %s : %d\n",IP2STR(_remote_sin.sin_addr.s_addr),htons(_remote_sin.sin_port));
liveimage_srv/sock.cpp:        ////printf("<-to %s : %d\n",IP2STR(_remote_sin.sin_addr.s_addr),htons(_remote_sin.sin_port));
liveimage_srv/sock.cpp:    if(-1 == snd)
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:        ////printf("<-to %s : %d\n",IP2STR(rsin.sin_addr.s_addr),htons(rsin.sin_port));
liveimage_srv/sock.cpp:    if(-1 == snd)
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    if(rcv==-1)
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    if(rcv==-1)
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    while(cbCall(pUser,SECS()-ti))
liveimage_srv/sock.cpp:    return -1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:              sizeof (_local_sin)) == -1)
liveimage_srv/sock.cpp:        return -1;
liveimage_srv/sock.cpp:                    (char  *)&iOptVal,sizeof (int)) == -1)
liveimage_srv/sock.cpp:        return -1;
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    if(i==-1)
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp://-----------------------------------------------------------------------------
liveimage_srv/sock.cpp:    if(_thesock != -1)
liveimage_srv/sock.cpp:        return -1;
liveimage_srv/sock.cpp:    if (bnd == -1)
liveimage_srv/sock.cpp:    if (bnd == -1)
liveimage_srv/parked/framequeue.cpp:    if(vf->length())
liveimage_srv/parked/videoframe.h:    bool     hasRoom(int r){return MAX_BUFF-(_accum)>r;}
liveimage_srv/parked/videoframe.h:    int      room()const{return (int)(MAX_BUFF-(_accum));}
liveimage_srv/parked/videoframe.cpp:    int room = _frmlen - _accum;
liveimage_srv/parked/videoframe.cpp:            --VideoFrame::_Free;
liveimage_srv/parked/videoframe.cpp:    pvf->reset();
Binary file liveimage_srv/liveimage_srv matches
liveimage_srv/main.cpp:    ulimit -S -c unlimited /home/ubuntu/na3_work/cameraisapi/srvvideosink/srvvideosink
liveimage_srv/main.cpp:    sysctl -w kernel.core_pattern=/home/ubuntu/isapi_crash/core-%e-%s-%u-%g-%p-%t
liveimage_srv/main.cpp:    gdb -c dump-file
liveimage_srv/main.cpp:        return -1;
liveimage_srv/main.cpp:        exit(-2);
liveimage_srv/main.cpp:    ::strncpy(__server_key,cdb["password"].value().c_str(),sizeof(__server_key)-1);
liveimage_srv/main.cpp:        exit(-2);
liveimage_srv/logfile.h://-----------------------------------------------------------------------------
liveimage_srv/logfile.h://-----------------------------------------------------------------------------
liveimage_srv/logfile.h://-----------------------------------------------------------------------------
liveimage_srv/logfile.h://-----------------------------------------------------------------------------
liveimage_srv/tcpcamcli.cpp:        strftime(buf,sizeof(buf),"%s%Y-%m-%d.%X",&tstruct);
liveimage_srv/tcpcamcli.cpp:    GLOGI("CAM CONNECTED "  << this->Rsin().c_str());
liveimage_srv/tcpcamcli.cpp:    ::snprintf(fnp,sizeof(fnp)-1,"%s%s",__files_recs,_recordname.c_str());
liveimage_srv/tcpcamcli.cpp:    GLOGI("CAM DIS_CONNECTED " << this->Rsin().c_str());
liveimage_srv/tcpcamcli.cpp:        GLOGD(" client" << a->name());
liveimage_srv/tcpcamcli.cpp:    if((_header.insync && tick_count()-_lastask>10000) || _ask_frame)
liveimage_srv/tcpcamcli.cpp:        this->snd((const uint8_t*)&_header,sizeof(_header),0);
liveimage_srv/tcpcamcli.cpp:    int bytes = this->recdata();
liveimage_srv/tcpcamcli.cpp:            if(cs->isopen()){
liveimage_srv/tcpcamcli.cpp:                cs->snd(vf,imgsz,_rtpseq);
liveimage_srv/tcpcamcli.cpp:        _pfpipe->stream(vf,imgsz);
liveimage_srv/tcpcamcli.cpp:                shell += this->name() + " &";
liveimage_srv/tcpcamcli.cpp:                //_tm->run( namex,_onmaxseq,where,namex); // thread is stopped
liveimage_srv/logger.cpp:        system("chown ubuntu:www-data /var/log/isapi/srvvideosink.log");
liveimage_srv/logger.cpp:        if(::strchr(fname,'-')!=0)
liveimage_srv/logger.cpp:            *(::strchr(fname,'-'))=0;
liveimage_srv/logger.cpp:            for(int k=Max_LogFiles; k>0; k-- )
liveimage_srv/logger.cpp:                ::snprintf(fps,sizeof(fps),"%s%s-%d",dir,fname,k);
liveimage_srv/logger.cpp:                ::snprintf(fp,sizeof(fp),"%s%s-%d",dir,fname,k-1);
liveimage_srv/logger.cpp:                system("chown popina:www-data /var/log/isapi/srvvidesink.log");
liveimage_srv/os.h:    static time_t ref = time(0)-100;
liveimage_srv/os.h:    return time(0)-ref;
liveimage_srv/os.h:        _init = -1;
liveimage_srv/os.h:        pT->_stopped = 0;
liveimage_srv/os.h:        pT->thread_main();
liveimage_srv/os.h:        pT->_stopped = 1;
liveimage_srv/os.h:        _init = -1;
liveimage_srv/os.h:        pT->_stopped = 0;
liveimage_srv/os.h:        pT->thread_main();
liveimage_srv/os.h:        pT->_stopped = 1;
liveimage_srv/os.h:    bool wait(int to=-1)
liveimage_srv/os.h:        if(to==-1)
liveimage_srv/os.h:         _mutex->mlock();
liveimage_srv/os.h:         _mutex->mlock();
liveimage_srv/os.h:        _mutex->munlock();
liveimage_srv/os.h:    U* ptr()const{return _c ? _c->p : 0;}
liveimage_srv/os.h:        return *_c->p;
liveimage_srv/os.h:    U* operator->() const throw()   {
liveimage_srv/os.h:        return _c->p;
liveimage_srv/os.h:        return *_c->p;
liveimage_srv/os.h:        U* p = _c->p;
liveimage_srv/os.h:        if (c) ++c->c;
liveimage_srv/os.h:            if (--_c->c == 0) {
liveimage_srv/os.h:                delete _c->p;
liveimage_srv/os.h:        millisec -=1000;
liveimage_srv/os.h:    strftime(buffer,sizeof(buffer)-1,"%a,%b %d %Y %H:%M:%S %Z",tm_info);
liveimage_srv/os.h:    sprintf(timestamp,"%d-%d-%d %d:%d:%d",st.wYear,st.wMonth,st.wDay,st.wHour,st.wMinute,st.wSecond);
liveimage_srv/requestparser.h:            stream << it->name << ": " << it->value << "\n";
liveimage_srv/requestparser.h:        stream << "+ keep-alive: " << keepAlive << "\n";;
liveimage_srv/requestparser.h:            if(phi->name==key)
liveimage_srv/requestparser.h:                return phi->value.c_str();
liveimage_srv/requestparser.h:                    req.versionMajor = input - '0';
liveimage_srv/requestparser.h:                    req.versionMajor = req.versionMajor * 10 + input - '0';
liveimage_srv/requestparser.h:                    req.versionMinor = input - '0';
liveimage_srv/requestparser.h:                    req.versionMinor = req.versionMinor * 10 + input - '0';
liveimage_srv/requestparser.h:                        if( strcasecmp(h.name.c_str(), "Content-Length") == 0 )
liveimage_srv/requestparser.h:                        else if( strcasecmp(h.name.c_str(), "Transfer-Encoding") == 0 )
liveimage_srv/requestparser.h:                    if( strcasecmp(it->value.c_str(), "Keep-Alive") == 0 )
liveimage_srv/requestparser.h:                --contentSize;
liveimage_srv/requestparser.h:                if( --chunkSize == 0 )
liveimage_srv/requestparser.h:                    stream << it->name << ": " << it->value << "\n";
liveimage_srv/requestparser.h:                stream << "+ keep-alive: " << keepAlive << "\n";;
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeDetermineSystem.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeSystem.cmake.in"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeSystemSpecificInitialize.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeDetermineCCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeDetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeDetermineCompilerId.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeCompilerIdDetection.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/ADSP-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/ARMCC-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/ARMClang-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/AppleClang-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Clang-DetermineCompilerInternal.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Borland-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Bruce-C-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Clang-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Clang-DetermineCompilerInternal.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Compaq-C-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Cray-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Embarcadero-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Fujitsu-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/FujitsuClang-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/GHS-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/GNU-C-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/HP-C-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/IAR-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Intel-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/IntelLLVM-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/MSVC-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/NVHPC-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/NVIDIA-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/OpenWatcom-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/PGI-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/PathScale-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/ROCMClang-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/SCO-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/SDCC-C-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/SunPro-C-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/TI-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/TinyCC-C-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/VisualAge-C-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/IBMCPP-C-DetermineVersionInternal.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Watcom-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/XL-C-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/IBMCPP-C-DetermineVersionInternal.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/XLClang-C-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/zOS-C-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/IBMCPP-C-DetermineVersionInternal.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeFindBinUtils.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/GNU-FindBinUtils.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeCCompiler.cmake.in"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeDetermineCXXCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeDetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Platform/Linux-Determine-CXX.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeDetermineCompilerId.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeCompilerIdDetection.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/ADSP-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/ARMCC-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/ARMClang-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/AppleClang-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Clang-DetermineCompilerInternal.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Borland-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Clang-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Clang-DetermineCompilerInternal.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Comeau-CXX-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Compaq-CXX-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Cray-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Embarcadero-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Fujitsu-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/FujitsuClang-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/GHS-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/GNU-CXX-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/HP-CXX-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/IAR-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Intel-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/IntelLLVM-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/MSVC-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/NVHPC-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/NVIDIA-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/OpenWatcom-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/PGI-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/PathScale-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/ROCMClang-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/SCO-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/SunPro-CXX-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/TI-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/VisualAge-CXX-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/IBMCPP-CXX-DetermineVersionInternal.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/Watcom-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/XL-CXX-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/IBMCPP-CXX-DetermineVersionInternal.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/XLClang-CXX-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/zOS-CXX-DetermineCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/IBMCPP-CXX-DetermineVersionInternal.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeFindBinUtils.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/GNU-FindBinUtils.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeCXXCompiler.cmake.in"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeSystemSpecificInformation.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeGenericSystem.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeInitializeConfigs.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Platform/Linux.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Platform/UnixPaths.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeCInformation.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeLanguageInformation.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/GNU-C.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/GNU.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/CMakeCommonCompilerMacros.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Platform/Linux-GNU-C.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Platform/Linux-GNU.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeCommonLanguageInclude.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeTestCCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeTestCompilerCommon.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeDetermineCompilerABI.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeParseImplicitIncludeInfo.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeParseImplicitLinkInfo.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeParseLibraryArchitecture.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeTestCompilerCommon.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeCCompilerABI.c"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeDetermineCompileFeatures.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Internal/FeatureTesting.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeCCompiler.cmake.in"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeCXXInformation.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeLanguageInformation.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/GNU-CXX.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Compiler/GNU.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Platform/Linux-GNU-CXX.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Platform/Linux-GNU.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeCommonLanguageInclude.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeTestCXXCompiler.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeTestCompilerCommon.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeDetermineCompilerABI.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeParseImplicitIncludeInfo.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeParseImplicitLinkInfo.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeParseLibraryArchitecture.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeTestCompilerCommon.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeCXXCompilerABI.cpp"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeDetermineCompileFeatures.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/Internal/FeatureTesting.cmake"
liveimage_srv/.cmake/api/v1/reply/cmakeFiles-v1-ec295d901a9edd952333.json:			"path" : "/opt/Qt/Tools/CMake/share/cmake-3.21/Modules/CMakeCXXCompiler.cmake.in"
liveimage_srv/.cmake/api/v1/reply/codemodel-v2-196cc98b56b03854e9e3.json:					"jsonFile" : "directory-.-f5ebdc15457944623624.json",
liveimage_srv/.cmake/api/v1/reply/codemodel-v2-196cc98b56b03854e9e3.json:					"jsonFile" : "target-liveimage_srv-01390913aa357ddaf627.json",
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:					"value" : "A wrapper around 'ar' adding the appropriate '--plugin' option for the GCC compiler"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "/usr/bin/gcc-ar-9"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:					"value" : "A wrapper around 'ranlib' adding the appropriate '--plugin' option for the GCC compiler"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "/usr/bin/gcc-ranlib-9"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "-g"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "-Os -DNDEBUG"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "-O3 -DNDEBUG"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "-O2 -g -DNDEBUG"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:					"value" : "A wrapper around 'ar' adding the appropriate '--plugin' option for the GCC compiler"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "/usr/bin/gcc-ar-9"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:					"value" : "A wrapper around 'ranlib' adding the appropriate '--plugin' option for the GCC compiler"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "/usr/bin/gcc-ranlib-9"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "-g"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "-Os -DNDEBUG"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "-O3 -DNDEBUG"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "-O2 -g -DNDEBUG"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "CMAKE_DLLTOOL-NOTFOUND"
liveimage_srv/.cmake/api/v1/reply/cache-v2-9a77721796bb5339b869.json:			"value" : "/opt/Qt/Tools/CMake/share/cmake-3.21"
liveimage_srv/.cmake/api/v1/reply/index-2022-06-20T21-13-58-0684.json:			"root" : "/opt/Qt/Tools/CMake/share/cmake-3.21"
liveimage_srv/.cmake/api/v1/reply/index-2022-06-20T21-13-58-0684.json:			"jsonFile" : "codemodel-v2-196cc98b56b03854e9e3.json",
liveimage_srv/.cmake/api/v1/reply/index-2022-06-20T21-13-58-0684.json:			"jsonFile" : "cache-v2-9a77721796bb5339b869.json",
liveimage_srv/.cmake/api/v1/reply/index-2022-06-20T21-13-58-0684.json:			"jsonFile" : "cmakeFiles-v1-ec295d901a9edd952333.json",
liveimage_srv/.cmake/api/v1/reply/index-2022-06-20T21-13-58-0684.json:		"cache-v2" : 
liveimage_srv/.cmake/api/v1/reply/index-2022-06-20T21-13-58-0684.json:			"jsonFile" : "cache-v2-9a77721796bb5339b869.json",
liveimage_srv/.cmake/api/v1/reply/index-2022-06-20T21-13-58-0684.json:		"cmakeFiles-v1" : 
liveimage_srv/.cmake/api/v1/reply/index-2022-06-20T21-13-58-0684.json:			"jsonFile" : "cmakeFiles-v1-ec295d901a9edd952333.json",
liveimage_srv/.cmake/api/v1/reply/index-2022-06-20T21-13-58-0684.json:		"codemodel-v2" : 
liveimage_srv/.cmake/api/v1/reply/index-2022-06-20T21-13-58-0684.json:			"jsonFile" : "codemodel-v2-196cc98b56b03854e9e3.json",
liveimage_srv/.cmake/api/v1/reply/target-liveimage_srv-01390913aa357ddaf627.json:					"fragment" : " -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0"
liveimage_srv/.cmake/api/v1/reply/target-liveimage_srv-01390913aa357ddaf627.json:				"fragment" : "-std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0",
liveimage_srv/.cmake/api/v1/reply/target-liveimage_srv-01390913aa357ddaf627.json:				"fragment" : "-rdynamic",
liveimage_srv/.cmake/api/v1/reply/target-liveimage_srv-01390913aa357ddaf627.json:				"fragment" : "-lpthread",
liveimage_srv/.cmake/api/v1/reply/target-liveimage_srv-01390913aa357ddaf627.json:				"fragment" : "-ljpeg",
liveimage_srv/logger.h://-----------------------------------------------------------------------------
liveimage_srv/logger.h://-----------------------------------------------------------------------------
liveimage_srv/logger.h://-----------------------------------------------------------------------------
liveimage_srv/logger.h://-----------------------------------------------------------------------------
liveimage_srv/main.h:        token = str.substr(prev,pos-prev);
liveimage_srv/main.h:    memcpy(urlinfo->path,(void *)"/\0",2);
liveimage_srv/main.h:        ret = sscanf(url,"%[^:]:%[^@]",urlinfo->username,urlinfo->password);
liveimage_srv/main.h:        if (ret < 2) return -1;
liveimage_srv/main.h:        urlinfo->username[0] = '\0';
liveimage_srv/main.h:        urlinfo->password[0] = '\0';
liveimage_srv/main.h:        ret = sscanf(url,"%[^:]:%hu/%s",urlinfo->host,
liveimage_srv/main.h:                     (short unsigned int*)&urlinfo->port,urlinfo->path+1);
liveimage_srv/main.h:        if (urlinfo->port < 1) return -1;
liveimage_srv/main.h:        ret -= 1;
liveimage_srv/main.h:        urlinfo->port = 80;
liveimage_srv/main.h:        ret = sscanf(url,"%[^/]/%s",urlinfo->host,urlinfo->path+1);
liveimage_srv/main.h:    if (ret < 1) return -1;
liveimage_srv/main.h:                    if(now - a.second > WD_TIME){
liveimage_srv/rawsock.cpp:    _data.cap=MAX_BUFF-1;
liveimage_srv/rawsock.cpp:    int bytes = this->receive(_data.rec_ptr(),_data.room());
liveimage_srv/rawsock.cpp:        this->destroy();
liveimage_srv/rawsock.cpp:    return (_data.rec_off - _data.prc_off);
liveimage_srv/rawsock.cpp:        bytes = this->receive(buff,rec_off);
liveimage_srv/rawsock.cpp:            this->destroy();
liveimage_srv/rawsock.cpp:    int rb = this->sendall(b,room);
liveimage_srv/rawsock.cpp:        this->destroy();
liveimage_srv/rawsock.cpp:    bytes = this->recdata();
liveimage_srv/rawsock.cpp:            css->snd(_data.buff,_data.rec_off,0);
liveimage_srv/liveimagesrv.pro:CONFIG   -= app_bundle
liveimage_srv/liveimagesrv.pro:QT       -= gui
liveimage_srv/liveimagesrv.pro:QMAKE_CXXFLAGS_RELEASE -= -O2
liveimage_srv/liveimagesrv.pro:QMAKE_CXXFLAGS_RELEASE += -O0  -Wno-unused-parameter
liveimage_srv/liveimagesrv.pro:QMAKE_CXXFLAGS_DEBUG -= -O2
liveimage_srv/liveimagesrv.pro:QMAKE_CXXFLAGS_DEBUG += -O0  -Wno-unused-parameter
liveimage_srv/liveimagesrv.pro:LIBS += -L$$usr/lib/x86_64-linux-gnu
liveimage_srv/liveimagesrv.pro:LIBS += -ljpeg
liveimage_srv/oneproc.h:            : socket_fd(-1)
liveimage_srv/oneproc.h:        if (socket_fd != -1)
liveimage_srv/oneproc.h:        if (socket_fd == -1 || rc)
liveimage_srv/oneproc.h:            socket_fd = -1;
liveimage_srv/oneproc.h:        return (socket_fd != -1 && rc == 0);
liveimage_srv/oneproc.h:    int socket_fd = -1;
localcam.cpp:        _dev->close();
localcam.cpp:        return _dev->open();
localcam.cpp:    if(now - _fetchtime >= _interval)
localcam.cpp:    i._camp = _dev->read(_img_size.x, _img_size.y, imgsz, fatal);
lilitypes.h:    size_t  room()const{return cap-len;}
lilitypes.h:enum EIMG_FMT{eNONE=-1, eFJPG=0, eNOTJPG, e422};
lilitypes.h:        _hdr->len = 0;
lilitypes.h:    if( maxSchemeLen < (size_t)(hostPtr - schemePtr + 1 )) //including NULL-terminating char
lilitypes.h:               hostPtr - schemePtr + 1);
lilitypes.h:    memcpy(scheme, schemePtr, hostPtr - schemePtr);
lilitypes.h:    scheme[hostPtr - schemePtr] = '\0';
lilitypes.h:        hostLen = portPtr - hostPtr;
lilitypes.h:        hostLen = pathPtr - hostPtr;
lilitypes.h:    if( maxHostLen < hostLen + 1 ) //including NULL-terminating char
lilitypes.h:        pathLen = fragmentPtr - pathPtr;
rtspcam.h-curl.h:    CURLcode res = this->_pcurl_easy_setopt((A), (B), (C));      \
rtspcam.h-curl.h:    CURLcode res = this->_pcurl_easy_perform(A);                      \
rtspcam.h-curl.h:#warning "RTSP EXPERIMENTAL FEATURE IS DISABLED Use -DWITH_RTSP"
deploymulti.sh:	is=$(ping -c 1 192.168.1.1 | grep 100)
CMakeLists.txt.user:<?xml version="1.0" encoding="UTF-8"?>
CMakeLists.txt.user:<!-- Written by QtCreator 5.0.1, 2022-04-11T16:59:50. -->
CMakeLists.txt.user:  <value type="QByteArray">{69a5c52f-fe65-469b-b7f3-2f417de34efc}</value>
CMakeLists.txt.user:   <value type="QByteArray" key="EditorConfiguration.Codec">UTF-8</value>
CMakeLists.txt.user:   <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">{b7bc31da-d0a3-448a-bb62-1d0c3330821c}</value>
CMakeLists.txt.user:    <value type="QString" key="CMake.Initial.Parameters">-GUnix Makefiles
CMakeLists.txt.user:-DCMAKE_BUILD_TYPE:STRING=Build
CMakeLists.txt.user:-DCMAKE_PROJECT_INCLUDE_BEFORE:PATH=%{IDE:ResourcePath}/package-manager/auto-setup.cmake
CMakeLists.txt.user:-DQT_QMAKE_EXECUTABLE:STRING=%{Qt:qmakeExecutable}
CMakeLists.txt.user:-DCMAKE_PREFIX_PATH:STRING=%{Qt:QT_INSTALL_PREFIX}
CMakeLists.txt.user:-DCMAKE_C_COMPILER:STRING=%{Compiler:Executable:C}
CMakeLists.txt.user:-DCMAKE_CXX_COMPILER:STRING=%{Compiler:Executable:Cxx}</value>
CMakeLists.txt.user:    <value type="QString" key="CMake.Initial.Parameters">-GUnix Makefiles
CMakeLists.txt.user:-DCMAKE_BUILD_TYPE:STRING=Build
CMakeLists.txt.user:-DCMAKE_PROJECT_INCLUDE_BEFORE:PATH=%{IDE:ResourcePath}/package-manager/auto-setup.cmake
CMakeLists.txt.user:-DQT_QMAKE_EXECUTABLE:STRING=%{Qt:qmakeExecutable}
CMakeLists.txt.user:-DCMAKE_PREFIX_PATH:STRING=%{Qt:QT_INSTALL_PREFIX}
CMakeLists.txt.user:-DCMAKE_C_COMPILER:STRING=%{Compiler:Executable:C}
CMakeLists.txt.user:-DCMAKE_CXX_COMPILER:STRING=%{Compiler:Executable:Cxx}</value>
CMakeLists.txt.user:    <value type="QString" key="CMake.Initial.Parameters">-GUnix Makefiles
CMakeLists.txt.user:-DCMAKE_BUILD_TYPE:STRING=Build
CMakeLists.txt.user:-DCMAKE_PROJECT_INCLUDE_BEFORE:PATH=%{IDE:ResourcePath}/package-manager/auto-setup.cmake
CMakeLists.txt.user:-DQT_QMAKE_EXECUTABLE:STRING=%{Qt:qmakeExecutable}
CMakeLists.txt.user:-DCMAKE_PREFIX_PATH:STRING=%{Qt:QT_INSTALL_PREFIX}
CMakeLists.txt.user:-DCMAKE_C_COMPILER:STRING=%{Compiler:Executable:C}
CMakeLists.txt.user:-DCMAKE_CXX_COMPILER:STRING=%{Compiler:Executable:Cxx}</value>
Binary file liveimage matches
strutils.h:# Copyright (C) 2006-2014 Chincisan Octavian-Marius(marrius9876@gmail.com)
strutils.h:# http://www.apache.org/licenses/LICENSE-2.0
strutils.h:    char* end = p + strlen(p)-1;
strutils.h:        *(end--)='\0';
strutils.h:    static char perms[]="xwrxwrxwr-";
strutils.h:            retval[j]='-';
strutils.h:#define DEC2INT(x) (isdigit(x) ? x - '0' : x - 'W')
strutils.h://-----------------------------------------------------------------------------
strutils.h://-----------------------------------------------------------------------------
strutils.h://-----------------------------------------------------------------------------
strutils.h://-----------------------------------------------------------------------------
strutils.h://-----------------------------------------------------------------------------
strutils.h://-----------------------------------------------------------------------------
strutils.h://-----------------------------------------------------------------------------
strutils.h://-----------------------------------------------------------------------------
strutils.h:    --ps;
strutils.h:        --ps;
strutils.h:        --FTR::TAB;
sockserver.cpp:    First Release: September 16 - 29 2016
sockserver.cpp:        if(!::strcmp(s->ssock_addrip(),pcli->ssock_addrip()))
sockserver.cpp:        pcliis->destroy();
sockserver.cpp:        if(s->socket()>0)
sockserver.cpp:            FD_SET(s->socket(), &rd);
sockserver.cpp:            ndfs = std::max(ndfs, s->socket());
sockserver.cpp:    if(is ==-1) {
sockserver.cpp:                cs->_needs=0;
sockserver.cpp:            if(s->socket()<=0)
sockserver.cpp:            if(FD_ISSET(s->socket(), &rd))
sockserver.cpp:                int rt = s->receive(req,511);
sockserver.cpp:                    s->destroy();
sockserver.cpp:                    if(s->_needs == 0 )
sockserver.cpp:                                s->_camname = a;
sockserver.cpp:                            s->_needs = WANTS_MOTION;
sockserver.cpp:                            s->_needs = WANTS_LIVE_IMAGE;
sockserver.cpp:                            s->_needs = WANTS_HTML;
sockserver.cpp:                            if(s->send(req,lrsp)==lrsp)
sockserver.cpp:                                s->send(r.c_str(), r.length());
sockserver.cpp:                            s->destroy();
sockserver.cpp:        if(a->_camname==camname){
sockserver.cpp:        needs |= s->_needs;
sockserver.cpp:            if((*s)->socket()<=0)
sockserver.cpp:    pcam->get_motion(dims, pixnoise, pixdiv, moscale);
sockserver.cpp:    ::sprintf(sett,"<li><a href='http://%s/?%s&mohilo=%d-%d'>MOTION-HI-LO</a>\
sockserver.cpp:                    <li><a href='http://%s/?%s&monoise=%d'>MOTION-NOISE</a>\
sockserver.cpp:                    <li><a href='http://%s/?%s&modiv=%d'>MOTION-DIV</a>\
sockserver.cpp:                    <li><a href='http://%s/?%s&moscale=%d'>MOTION-SCALE</a>",
sockserver.cpp:                    pc->_camname.c_str(),
sockserver.cpp:                    pc->_camname.c_str(),
sockserver.cpp:                    pc->_camname.c_str(),
sockserver.cpp:                    pc->_camname.c_str(),
sockserver.cpp:                        pc->_camname.c_str(),
sockserver.cpp:                        pc->_camname.c_str(),
sockserver.cpp:                    "Content-length: %d\r\n"
sockserver.cpp:                    "Content-Type: text/html\r\n\r\n%s",len, image);
sockserver.cpp:    pc->sendall(html, len);
sockserver.cpp:        switch(s->_needs)
sockserver.cpp:                    rv = this->_stream_jpeg(s, buff, sz);
sockserver.cpp:                    s->destroy();
sockserver.cpp:                rv = this->_stream_jpeg(s, buff, sz);
sockserver.cpp:                rv = this->_stream_video(s, buff, sz);
sockserver.cpp:            s->destroy();
sockserver.cpp:    if(!pc->_headered)
sockserver.cpp:        rv = pc->sendall(HEADER_JPG, strlen(HEADER_JPG),100);
sockserver.cpp:            pc->destroy();
sockserver.cpp:        pc->_headered=true;
sockserver.cpp:    sprintf(buffer, "Content-Type: %s\r\n" \
sockserver.cpp:                    "Content-Length: %d\r\n" \
sockserver.cpp:                    "X-Timestamp: %d.%06d\r\n" \
sockserver.cpp:    rv = pc->sendall(buffer,strlen(buffer),100);
sockserver.cpp:        pc->destroy();
sockserver.cpp:        pc->_headered = false;
sockserver.cpp:    rv = pc->sendall(buff,sz,4000);
sockserver.cpp:        pc->destroy();
sockserver.cpp:        pc->_headered = false;
sockserver.cpp:    ::sprintf(buffer, "\r\n--MY_BOUNDARY_STRING_NOONE_HAS\r\nContent-type: imagejpg\r\n");
sockserver.cpp:    rv = pc->sendall(buffer,strlen(buffer),100);
sockserver.cpp:        pc->destroy();
sockserver.cpp:        pc->_headered=false;
sockserver.cpp:    rv = pc->sendall(buff,sz,1000);
sockserver.cpp:        pc->destroy();
sockserver.cpp:        pc->_headered=false;
sockserver.cpp:        if(cli->_camname == a->name())
sockserver.cpp:            dims_t  mohilo = {-1,-1};
sockserver.cpp:            int     pixnoise = -1;
sockserver.cpp:            int     pixdiv = -1;
sockserver.cpp:            int     mscale = -1;
sockserver.cpp:            if(ptok){ ::sscanf((req+7),"%d-%d",&mohilo.x, &mohilo.y); }
sockserver.cpp:            a->set_motion(mohilo, pixnoise, pixdiv, mscale);
cbconf.cpp:    while (in_len--) {
jpeghttpcam.cpp:    "User-Agent: liveimage 1.0\r\n"                 \
jpeghttpcam.cpp:    "Pragma: no-cache\r\n"                          \
jpeghttpcam.cpp:    "Cache-Control: no-cache\r\n\r\n"
jpeghttpcam.cpp:    this->signal_to_stop();
jpeghttpcam.cpp:    this->stop_thread();
jpeghttpcam.cpp:        const Frame* frame = _frames->to_stream();
jpeghttpcam.cpp:            _frames->flip();
jpeghttpcam.cpp:            i._caml   = frame->ptr(&i._camp);
jpeghttpcam.cpp:            len = frame->length();
jpeghttpcam.cpp:    int             hdrlen;     // = (eoh  -  rec) + 4;
jpeghttpcam.cpp:    int             over_flow;  // = hlen - hdrlen;
jpeghttpcam.cpp:    while(!this->is_stopped() && __alive)
jpeghttpcam.cpp:            int hlen  = s.receive(rec, sizeof(rec)-32);
jpeghttpcam.cpp:            hdrlen = (eoh  -  rec) + 4;
jpeghttpcam.cpp:            over_flow = hlen - hdrlen;
jpeghttpcam.cpp:                Frame*     recfrm = _frames->to_load();
jpeghttpcam.cpp:                    recfrm->set_len(0);
jpeghttpcam.cpp:                        recfrm->copy(pafter, 0, over_flow);
jpeghttpcam.cpp:                        isjpg = ::is_jpeg(recfrm->buffer(), over_flow);
jpeghttpcam.cpp:                    scontent_lengh = strstr(rec,"Content-Length: ");
jpeghttpcam.cpp:                    content_lengh -= over_flow;
jpeghttpcam.cpp:                    if(recfrm->realloc(content_lengh + over_flow + SIG_LEN)==false)
jpeghttpcam.cpp:                    hlen = s.receiveall( recfrm->buffer(over_flow), content_lengh);
jpeghttpcam.cpp:                    isjpg = ::is_jpeg(recfrm->buffer(), content_lengh + over_flow);
jpeghttpcam.cpp:                        recfrm->set_len(content_lengh + over_flow);
jpeghttpcam.cpp:                        recfrm->_wh = _imgsz;
jpeghttpcam.cpp:                        recfrm->ready();
jpeghttpcam.cpp:                        recfrm->set_len(0);
Binary file i0315-000000.jpg matches
webcast_old.cpp:#define BOUNDARY        "----212367691630846570233068106084"
webcast_old.cpp:Content-Type: multipart/form-data; boundary=---------------------------212367691630846570233068106084
webcast_old.cpp:Content-Length: 453
webcast_old.cpp:Connection: keep-alive
webcast_old.cpp:        -----------------------------16645979773237131345183406155
webcast_old.cpp:        Content-Disposition: form-data; name="my_file0"; filename="f1"
webcast_old.cpp:        Content-Type: application/octet-stream
webcast_old.cpp:        -----------------------------16645979773237131345183406155
webcast_old.cpp:        Content-Disposition: form-data; name="my_file1"; filename="f2"
webcast_old.cpp:        Content-Type: application/octet-stream
webcast_old.cpp:        -----------------------------16645979773237131345183406155--
webcast_old.cpp:    std::string     web = GCFG->_glb.webcast;
webcast_old.cpp:    while(!this->OsThread::is_stopped())
webcast_old.cpp:        if(has && time(0)-ctime < 5)
webcast_old.cpp:        hdr += GCFG->_glb.wdoc;
webcast_old.cpp:        if((!GCFG->_glb.url.empty()))
webcast_old.cpp:            //hdr += "Host: "; hdr += GCFG->_glb.url + "\r\n";
webcast_old.cpp:        hdr += "Accept-Encoding: gzip, deflate\r\n";
webcast_old.cpp:        //hdr += "Liveimage: "; hdr += GCFG->_glb.webcastname + "\r\n";
webcast_old.cpp:        hdr += "Content-Type: multipart/form-data; ";
webcast_old.cpp:        hdr += "Content-Length:"; hdr +=std::to_string(_length); hdr += "\r\n";
webcast_old.cpp:        hdr += "Connection: keep-alive\r\n";
webcast_old.cpp:        hdr += "\r\n--";
webcast_old.cpp:    hdr += "Content-Disposition: form-data; name=\"file";
webcast_old.cpp:    hdr += "Content-Type: application/octet-stream\r\n";
webcast_old.cpp:            hdr = "\r\nboundary=--";
webcast_old.cpp:    if(time(0) - _last_clicheck > TIME_FOR_CLI)
webcast_old.cpp:        if((!GCFG->_glb.url.empty()))
webcast_old.cpp:            get += "Host: "; get += GCFG->_glb.url + "\r\n";
webcast_old.cpp:        get += "Liveimage: "; get += GCFG->_glb.webcastname + "\r\n";
webcast_old.cpp:            int bytes = cli.select_receive(rec,sizeof(rec)-1, 8000);
os.h:# Copyright (C) 2006-2014 Chincisan Octavian-Marius(mariuschincisan@gmail.com) - coinscode.com - N/A
os.h:# http://www.apache.org/licenses/LICENSE-2.0
os.h://-----------------------------------------------------------------------------
os.h://-------;----------------------------------------------------------------------
os.h://-----------------------------------------------------------------------------
os.h:    int swait(int to=-1) const
os.h:    int stry_wait(int to=-1) const
os.h:        int val = -1;
os.h:         _err = _mutex->try_lock();
os.h:         _err = _mutex->try_lock();
os.h:            _mutex->munlock();
os.h://-----------------------------------------------------------------------------
os.h:         _mutex->mlock();
os.h:         _mutex->mlock();
os.h:        _mutex->munlock();
os.h://-----------------------------------------------------------------------------
os.h:        while(rc == EBUSY && k--)
os.h://-----------------------------------------------------------------------------
os.h:        _init = -1;
os.h:        pT->_stopped = 0;
os.h:        pT->_start.snotify();
os.h:        if(pT-> _pre_thread_foo())
os.h:            pT->thread_main();
os.h:            pT->_stopped = 1;
os.h:            pT->_post_thread_foo();
rtspcam.cpp-curl.cpp:        _transport = "RTP/AVP/TCP;unicast;interleaved=0-1";
rtspcam.cpp-curl.cpp:    this->signal_to_stop();
rtspcam.cpp-curl.cpp:    this->stop_thread();
rtspcam.cpp-curl.cpp:    this->_pcurl_easy_perform(_curl);
rtspcam.cpp-curl.cpp:    while(!this->is_stopped() && __alive)
rtspcam.cpp-curl.cpp:                    _transport+="-";
rtspcam.cpp-curl.cpp:                        if(_pudpsink->ok())
rtspcam.cpp-curl.cpp:                    if(_pudpsink->ok()==false)
rtspcam.cpp-curl.cpp:                while(__alive && !this->is_stopped() && (bytes/=2) > 0)
rtspcam.cpp-curl.cpp:                        int bytes = _pudpsink->spin();
rtspcam.cpp-curl.cpp:                            frame.copy(_pudpsink->frame(), 0, bytes);
rtspcam.cpp-curl.cpp:        AutoLock    a(&pthis->_mut);
rtspcam.cpp-curl.cpp:        pthis-> _gotbytes = size * nmemb;
rtspcam.cpp-curl.cpp:        Frame& frame = pthis->_frames[pthis->_flip];
rtspcam.cpp-curl.cpp:    pthis->_describe.append(ptr);
rtspcam.cpp-curl.cpp:    if(pthis->_ontcp)
rtspcam.cpp-curl.cpp:        CURL* pcurl = pthis->_curl;
rtspcam.cpp-curl.cpp:            if(pthis->_ontcp)
rtspcam.cpp-curl.cpp:                pthis->_pcurl_easy_setopt(pcurl, CURLOPT_INTERLEAVEFUNCTION, rtspcam::_interleave_callback);
rtspcam.cpp-curl.cpp:                pthis->_pcurl_easy_setopt(pcurl, CURLOPT_RTSP_REQUEST, (long)CURL_RTSPREQ_RECEIVE);
rtspcam.cpp-curl.cpp:                pthis->_pcurl_easy_perform(pcurl);
rtspcam.cpp-curl.cpp:    const char *range = "0.000-";
rtspcam.cpp-curl.cpp:        while(fgets(s, sizeof(s)-2, sdp_fp)) {
mpeger.cpp:    delete[] _frame->data[0];
mpeger.cpp:    _pcodekCtx->time_base.den = 1;
mpeger.cpp:    _pcodekCtx->time_base.num = 1;
mpeger.cpp:    _pcodekCtx->width   = imgsz.x;
mpeger.cpp:    _pcodekCtx->height  = imgsz.y;
mpeger.cpp:    _pcodekCtx->pix_fmt = AV_PIX_FMT_YUVJ420P; //AV_PIX_FMT_YUV420P;
mpeger.cpp:    _frame->format = _pcodekCtx->pix_fmt;
mpeger.cpp:    _frame->width  = _pcodekCtx->width;
mpeger.cpp:    _frame->height = _pcodekCtx->height;
mpeger.cpp:    if(_frame->data[0] == nullptr)
mpeger.cpp:        _frame->data[0] = new uint8_t[w*h*6];
mpeger.cpp:                     fmt420, _pcodekCtx->pix_fmt, _pcodekCtx->width,
mpeger.cpp:                     _pcodekCtx->height);
fxxtojpg.h:    First Release: September 16 - 29 2016
v4ldevice.h:    First Release: September 16 - 29 2016
v4ldevice.h:    const uint8_t* read(int& w, int& h, int& sz, bool& fatal); // ret 0 fatal, 1 aquired, -1 continue
Binary file tmp/img.mpg matches
CMakeFiles/Makefile2:RM = /usr/bin/cmake -E remove -f
CMakeFiles/Makefile2:# The top-level source directory on which CMake was run.
CMakeFiles/Makefile2:# The top-level build directory on which CMake was run.
CMakeFiles/Makefile2:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/depend
CMakeFiles/Makefile2:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/build
CMakeFiles/Makefile2:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --progress-dir=/home/marius/lili/CMakeFiles --progress-num=1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19 "Built target liveimage"
CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/marius/lili/CMakeFiles 19
CMakeFiles/Makefile2:	$(MAKE) -f CMakeFiles/Makefile2 CMakeFiles/liveimage.dir/all
CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -E cmake_progress_start /home/marius/lili/CMakeFiles 0
CMakeFiles/Makefile2:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/clean
CMakeFiles/Makefile2:	$(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 0
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/CMakeCInformation.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/CMakeCXXInformation.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/CMakeCheckCompilerFlagCommonPatterns.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/CMakeCommonLanguageInclude.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/CMakeGenericSystem.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/CMakeInitializeConfigs.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/CMakeLanguageInformation.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/CMakeSystemSpecificInformation.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/CMakeSystemSpecificInitialize.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/Compiler/CMakeCommonCompilerMacros.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/Compiler/GNU-C.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/Compiler/GNU-CXX.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/Compiler/GNU.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/Internal/CMakeCheckCompilerFlag.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/Platform/Linux-GNU-C.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/Platform/Linux-GNU-CXX.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/Platform/Linux-GNU.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/Platform/Linux.cmake"
CMakeFiles/Makefile.cmake:  "/usr/share/cmake-3.16/Modules/Platform/UnixPaths.cmake"
Binary file CMakeFiles/3.16.3/CMakeDetermineCompilerABI_C.bin matches
CMakeFiles/3.16.3/CMakeCXXCompiler.cmake:set(CMAKE_CXX_COMPILER_AR "/usr/bin/gcc-ar-8")
CMakeFiles/3.16.3/CMakeCXXCompiler.cmake:set(CMAKE_CXX_COMPILER_RANLIB "/usr/bin/gcc-ranlib-8")
CMakeFiles/3.16.3/CMakeCXXCompiler.cmake:set(CMAKE_CXX_LIBRARY_ARCHITECTURE "arm-linux-gnueabihf")
CMakeFiles/3.16.3/CMakeCXXCompiler.cmake:  set(CMAKE_LIBRARY_ARCHITECTURE "arm-linux-gnueabihf")
CMakeFiles/3.16.3/CMakeCXXCompiler.cmake:set(CMAKE_CXX_IMPLICIT_INCLUDE_DIRECTORIES "/usr/include/c++/8;/usr/include/arm-linux-gnueabihf/c++/8;/usr/include/c++/8/backward;/usr/lib/gcc/arm-linux-gnueabihf/8/include;/usr/local/include;/usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed;/usr/include/arm-linux-gnueabihf;/usr/include")
CMakeFiles/3.16.3/CMakeCXXCompiler.cmake:set(CMAKE_CXX_IMPLICIT_LINK_DIRECTORIES "/usr/lib/gcc/arm-linux-gnueabihf/8;/usr/lib/arm-linux-gnueabihf;/usr/lib;/lib/arm-linux-gnueabihf")
Binary file CMakeFiles/3.16.3/CompilerIdC/a.out matches
CMakeFiles/3.16.3/CompilerIdC/CMakeCCompilerId.c:/* cv-qualifiers did not exist in K&R C */
CMakeFiles/3.16.3/CompilerIdC/CMakeCCompilerId.c:# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
CMakeFiles/3.16.3/CompilerIdC/CMakeCCompilerId.c:#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
CMakeFiles/3.16.3/CompilerIdC/CMakeCCompilerId.c:# define PLATFORM_ID "HP-UX"
CMakeFiles/3.16.3/CompilerIdC/CMakeCCompilerId.c:# define PLATFORM_ID "MP-RAS"
CMakeFiles/3.16.3/CompilerIdC/CMakeCCompilerId.c:/*--------------------------------------------------------------------------*/
CMakeFiles/3.16.3/CMakeCCompiler.cmake:set(CMAKE_C_COMPILER_AR "/usr/bin/gcc-ar-8")
CMakeFiles/3.16.3/CMakeCCompiler.cmake:set(CMAKE_C_COMPILER_RANLIB "/usr/bin/gcc-ranlib-8")
CMakeFiles/3.16.3/CMakeCCompiler.cmake:set(CMAKE_C_LIBRARY_ARCHITECTURE "arm-linux-gnueabihf")
CMakeFiles/3.16.3/CMakeCCompiler.cmake:  set(CMAKE_LIBRARY_ARCHITECTURE "arm-linux-gnueabihf")
CMakeFiles/3.16.3/CMakeCCompiler.cmake:set(CMAKE_C_IMPLICIT_INCLUDE_DIRECTORIES "/usr/lib/gcc/arm-linux-gnueabihf/8/include;/usr/local/include;/usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed;/usr/include/arm-linux-gnueabihf;/usr/include")
CMakeFiles/3.16.3/CMakeCCompiler.cmake:set(CMAKE_C_IMPLICIT_LINK_DIRECTORIES "/usr/lib/gcc/arm-linux-gnueabihf/8;/usr/lib/arm-linux-gnueabihf;/usr/lib;/lib/arm-linux-gnueabihf")
Binary file CMakeFiles/3.16.3/CMakeDetermineCompilerABI_CXX.bin matches
CMakeFiles/3.16.3/CMakeSystem.cmake:set(CMAKE_HOST_SYSTEM "Linux-5.10.103-v7+")
CMakeFiles/3.16.3/CMakeSystem.cmake:set(CMAKE_HOST_SYSTEM_VERSION "5.10.103-v7+")
CMakeFiles/3.16.3/CMakeSystem.cmake:set(CMAKE_SYSTEM "Linux-5.10.103-v7+")
CMakeFiles/3.16.3/CMakeSystem.cmake:set(CMAKE_SYSTEM_VERSION "5.10.103-v7+")
Binary file CMakeFiles/3.16.3/CompilerIdCXX/a.out matches
CMakeFiles/3.16.3/CompilerIdCXX/CMakeCXXCompilerId.cpp:# define COMPILER_VERSION_MAJOR DEC((__WATCOMC__ - 1100) / 100)
CMakeFiles/3.16.3/CompilerIdCXX/CMakeCXXCompilerId.cpp:#  define COMPILER_VERSION_MINOR DEC((__VER__) - (((__VER__) / 100)*100))
CMakeFiles/3.16.3/CompilerIdCXX/CMakeCXXCompilerId.cpp:# define PLATFORM_ID "HP-UX"
CMakeFiles/3.16.3/CompilerIdCXX/CMakeCXXCompilerId.cpp:# define PLATFORM_ID "MP-RAS"
CMakeFiles/3.16.3/CompilerIdCXX/CMakeCXXCompilerId.cpp:/*--------------------------------------------------------------------------*/
CMakeFiles/CMakeOutput.log:The system is: Linux - 5.10.103-v7+ - armv7l
CMakeFiles/CMakeOutput.log:Run Build Command(s):/usr/bin/make cmTC_7f500/fast && /usr/bin/make -f CMakeFiles/cmTC_7f500.dir/build.make CMakeFiles/cmTC_7f500.dir/build
CMakeFiles/CMakeOutput.log:/usr/bin/cc    -o CMakeFiles/cmTC_7f500.dir/testCCompiler.c.o   -c /home/marius/lili/CMakeFiles/CMakeTmp/testCCompiler.c
CMakeFiles/CMakeOutput.log:/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_7f500.dir/link.txt --verbose=1
CMakeFiles/CMakeOutput.log:/usr/bin/cc      -rdynamic CMakeFiles/cmTC_7f500.dir/testCCompiler.c.o  -o cmTC_7f500 
CMakeFiles/CMakeOutput.log:Run Build Command(s):/usr/bin/make cmTC_a3d6f/fast && /usr/bin/make -f CMakeFiles/cmTC_a3d6f.dir/build.make CMakeFiles/cmTC_a3d6f.dir/build
CMakeFiles/CMakeOutput.log:/usr/bin/cc   -v -o CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o   -c /usr/share/cmake-3.16/Modules/CMakeCCompilerABI.c
CMakeFiles/CMakeOutput.log:Using built-in specs.
CMakeFiles/CMakeOutput.log:Target: arm-linux-gnueabihf
CMakeFiles/CMakeOutput.log:Configured with: ../src/configure -v --with-pkgversion='Raspbian 8.3.0-6+rpi1' --with-bugurl=file:///usr/share/doc/gcc-8/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-8 --program-prefix=arm-linux-gnueabihf- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-sjlj-exceptions --with-arch=armv6 --with-fpu=vfp --with-float=hard --disable-werror --enable-checking=release --build=arm-linux-gnueabihf --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf
CMakeFiles/CMakeOutput.log:gcc version 8.3.0 (Raspbian 8.3.0-6+rpi1) 
CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o' '-c'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp'
CMakeFiles/CMakeOutput.log: /usr/lib/gcc/arm-linux-gnueabihf/8/cc1 -quiet -v -imultilib . -imultiarch arm-linux-gnueabihf /usr/share/cmake-3.16/Modules/CMakeCCompilerABI.c -quiet -dumpbase CMakeCCompilerABI.c -mfloat-abi=hard -mfpu=vfp -mtls-dialect=gnu -marm -march=armv6+fp -auxbase-strip CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o -version -o /tmp/ccLBqxSw.s
CMakeFiles/CMakeOutput.log:GNU C17 (Raspbian 8.3.0-6+rpi1) version 8.3.0 (arm-linux-gnueabihf)
CMakeFiles/CMakeOutput.log:	compiled by GNU C version 8.3.0, GMP version 6.1.2, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.20-GMP
CMakeFiles/CMakeOutput.log:GGC heuristics: --param ggc-min-expand=89 --param ggc-min-heapsize=111573
CMakeFiles/CMakeOutput.log:ignoring nonexistent directory "/usr/local/include/arm-linux-gnueabihf"
CMakeFiles/CMakeOutput.log:ignoring nonexistent directory "/usr/lib/gcc/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/include"
CMakeFiles/CMakeOutput.log: /usr/lib/gcc/arm-linux-gnueabihf/8/include
CMakeFiles/CMakeOutput.log: /usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed
CMakeFiles/CMakeOutput.log: /usr/include/arm-linux-gnueabihf
CMakeFiles/CMakeOutput.log:GNU C17 (Raspbian 8.3.0-6+rpi1) version 8.3.0 (arm-linux-gnueabihf)
CMakeFiles/CMakeOutput.log:	compiled by GNU C version 8.3.0, GMP version 6.1.2, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.20-GMP
CMakeFiles/CMakeOutput.log:GGC heuristics: --param ggc-min-expand=89 --param ggc-min-heapsize=111573
CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o' '-c'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp'
CMakeFiles/CMakeOutput.log: as -v -march=armv6 -mfloat-abi=hard -mfpu=vfp -meabi=5 -o CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o /tmp/ccLBqxSw.s
CMakeFiles/CMakeOutput.log:GNU assembler version 2.31.1 (arm-linux-gnueabihf) using BFD version (GNU Binutils for Raspbian) 2.31.1
CMakeFiles/CMakeOutput.log:COMPILER_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/
CMakeFiles/CMakeOutput.log:LIBRARY_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../:/lib/arm-linux-gnueabihf/:/lib/:/usr/lib/arm-linux-gnueabihf/:/usr/lib/
CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o' '-c'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp'
CMakeFiles/CMakeOutput.log:/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_a3d6f.dir/link.txt --verbose=1
CMakeFiles/CMakeOutput.log:/usr/bin/cc     -v -rdynamic CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o  -o cmTC_a3d6f 
CMakeFiles/CMakeOutput.log:Using built-in specs.
CMakeFiles/CMakeOutput.log:COLLECT_LTO_WRAPPER=/usr/lib/gcc/arm-linux-gnueabihf/8/lto-wrapper
CMakeFiles/CMakeOutput.log:Target: arm-linux-gnueabihf
CMakeFiles/CMakeOutput.log:Configured with: ../src/configure -v --with-pkgversion='Raspbian 8.3.0-6+rpi1' --with-bugurl=file:///usr/share/doc/gcc-8/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-8 --program-prefix=arm-linux-gnueabihf- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-sjlj-exceptions --with-arch=armv6 --with-fpu=vfp --with-float=hard --disable-werror --enable-checking=release --build=arm-linux-gnueabihf --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf
CMakeFiles/CMakeOutput.log:gcc version 8.3.0 (Raspbian 8.3.0-6+rpi1) 
CMakeFiles/CMakeOutput.log:COMPILER_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/
CMakeFiles/CMakeOutput.log:LIBRARY_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../:/lib/arm-linux-gnueabihf/:/lib/:/usr/lib/arm-linux-gnueabihf/:/usr/lib/
CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_a3d6f'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp'
CMakeFiles/CMakeOutput.log: /usr/lib/gcc/arm-linux-gnueabihf/8/collect2 -plugin /usr/lib/gcc/arm-linux-gnueabihf/8/liblto_plugin.so -plugin-opt=/usr/lib/gcc/arm-linux-gnueabihf/8/lto-wrapper -plugin-opt=-fresolution=/tmp/ccdVOnyN.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -export-dynamic -dynamic-linker /lib/ld-linux-armhf.so.3 -X --hash-style=gnu -m armelf_linux_eabi -o cmTC_a3d6f /usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crt1.o /usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crti.o /usr/lib/gcc/arm-linux-gnueabihf/8/crtbegin.o -L/usr/lib/gcc/arm-linux-gnueabihf/8 -L/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf -L/usr/lib/gcc/arm-linux-gnueabihf/8/../../.. -L/lib/arm-linux-gnueabihf -L/usr/lib/arm-linux-gnueabihf CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/arm-linux-gnueabihf/8/crtend.o /usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crtn.o
CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_a3d6f'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp'
CMakeFiles/CMakeOutput.log:    add: [/usr/lib/gcc/arm-linux-gnueabihf/8/include]
CMakeFiles/CMakeOutput.log:    add: [/usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed]
CMakeFiles/CMakeOutput.log:    add: [/usr/include/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/lib/gcc/arm-linux-gnueabihf/8/include] ==> [/usr/lib/gcc/arm-linux-gnueabihf/8/include]
CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed] ==> [/usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed]
CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/include/arm-linux-gnueabihf] ==> [/usr/include/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  implicit include dirs: [/usr/lib/gcc/arm-linux-gnueabihf/8/include;/usr/local/include;/usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed;/usr/include/arm-linux-gnueabihf;/usr/include]
CMakeFiles/CMakeOutput.log:  link line regex: [^( *|.*[/\])(ld|CMAKE_LINK_STARTFILE-NOTFOUND|([^/\]+-)?ld|collect2)[^/\]*( |$)]
CMakeFiles/CMakeOutput.log:  ignore line: [Run Build Command(s):/usr/bin/make cmTC_a3d6f/fast && /usr/bin/make -f CMakeFiles/cmTC_a3d6f.dir/build.make CMakeFiles/cmTC_a3d6f.dir/build]
CMakeFiles/CMakeOutput.log:  ignore line: [/usr/bin/cc   -v -o CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o   -c /usr/share/cmake-3.16/Modules/CMakeCCompilerABI.c]
CMakeFiles/CMakeOutput.log:  ignore line: [Using built-in specs.]
CMakeFiles/CMakeOutput.log:  ignore line: [Target: arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Raspbian 8.3.0-6+rpi1' --with-bugurl=file:///usr/share/doc/gcc-8/README.Bugs --enable-languages=c ada c++ go d fortran objc obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-8 --program-prefix=arm-linux-gnueabihf- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-sjlj-exceptions --with-arch=armv6 --with-fpu=vfp --with-float=hard --disable-werror --enable-checking=release --build=arm-linux-gnueabihf --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  ignore line: [gcc version 8.3.0 (Raspbian 8.3.0-6+rpi1) ]
CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o' '-c'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp']
CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/arm-linux-gnueabihf/8/cc1 -quiet -v -imultilib . -imultiarch arm-linux-gnueabihf /usr/share/cmake-3.16/Modules/CMakeCCompilerABI.c -quiet -dumpbase CMakeCCompilerABI.c -mfloat-abi=hard -mfpu=vfp -mtls-dialect=gnu -marm -march=armv6+fp -auxbase-strip CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o -version -o /tmp/ccLBqxSw.s]
CMakeFiles/CMakeOutput.log:  ignore line: [GNU C17 (Raspbian 8.3.0-6+rpi1) version 8.3.0 (arm-linux-gnueabihf)]
CMakeFiles/CMakeOutput.log:  ignore line: [	compiled by GNU C version 8.3.0  GMP version 6.1.2  MPFR version 4.0.2  MPC version 1.1.0  isl version isl-0.20-GMP]
CMakeFiles/CMakeOutput.log:  ignore line: [GGC heuristics: --param ggc-min-expand=89 --param ggc-min-heapsize=111573]
CMakeFiles/CMakeOutput.log:  ignore line: [ignoring nonexistent directory "/usr/local/include/arm-linux-gnueabihf"]
CMakeFiles/CMakeOutput.log:  ignore line: [ignoring nonexistent directory "/usr/lib/gcc/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/include"]
CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/arm-linux-gnueabihf/8/include]
CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed]
CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/include/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  ignore line: [GNU C17 (Raspbian 8.3.0-6+rpi1) version 8.3.0 (arm-linux-gnueabihf)]
CMakeFiles/CMakeOutput.log:  ignore line: [	compiled by GNU C version 8.3.0  GMP version 6.1.2  MPFR version 4.0.2  MPC version 1.1.0  isl version isl-0.20-GMP]
CMakeFiles/CMakeOutput.log:  ignore line: [GGC heuristics: --param ggc-min-expand=89 --param ggc-min-heapsize=111573]
CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o' '-c'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp']
CMakeFiles/CMakeOutput.log:  ignore line: [ as -v -march=armv6 -mfloat-abi=hard -mfpu=vfp -meabi=5 -o CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o /tmp/ccLBqxSw.s]
CMakeFiles/CMakeOutput.log:  ignore line: [GNU assembler version 2.31.1 (arm-linux-gnueabihf) using BFD version (GNU Binutils for Raspbian) 2.31.1]
CMakeFiles/CMakeOutput.log:  ignore line: [COMPILER_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/]
CMakeFiles/CMakeOutput.log:  ignore line: [LIBRARY_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../:/lib/arm-linux-gnueabihf/:/lib/:/usr/lib/arm-linux-gnueabihf/:/usr/lib/]
CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o' '-c'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp']
CMakeFiles/CMakeOutput.log:  ignore line: [/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_a3d6f.dir/link.txt --verbose=1]
CMakeFiles/CMakeOutput.log:  ignore line: [/usr/bin/cc     -v -rdynamic CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o  -o cmTC_a3d6f ]
CMakeFiles/CMakeOutput.log:  ignore line: [Using built-in specs.]
CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_LTO_WRAPPER=/usr/lib/gcc/arm-linux-gnueabihf/8/lto-wrapper]
CMakeFiles/CMakeOutput.log:  ignore line: [Target: arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Raspbian 8.3.0-6+rpi1' --with-bugurl=file:///usr/share/doc/gcc-8/README.Bugs --enable-languages=c ada c++ go d fortran objc obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-8 --program-prefix=arm-linux-gnueabihf- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-sjlj-exceptions --with-arch=armv6 --with-fpu=vfp --with-float=hard --disable-werror --enable-checking=release --build=arm-linux-gnueabihf --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  ignore line: [gcc version 8.3.0 (Raspbian 8.3.0-6+rpi1) ]
CMakeFiles/CMakeOutput.log:  ignore line: [COMPILER_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/]
CMakeFiles/CMakeOutput.log:  ignore line: [LIBRARY_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../:/lib/arm-linux-gnueabihf/:/lib/:/usr/lib/arm-linux-gnueabihf/:/usr/lib/]
CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_a3d6f'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp']
CMakeFiles/CMakeOutput.log:  link line: [ /usr/lib/gcc/arm-linux-gnueabihf/8/collect2 -plugin /usr/lib/gcc/arm-linux-gnueabihf/8/liblto_plugin.so -plugin-opt=/usr/lib/gcc/arm-linux-gnueabihf/8/lto-wrapper -plugin-opt=-fresolution=/tmp/ccdVOnyN.res -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --build-id --eh-frame-hdr -export-dynamic -dynamic-linker /lib/ld-linux-armhf.so.3 -X --hash-style=gnu -m armelf_linux_eabi -o cmTC_a3d6f /usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crt1.o /usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crti.o /usr/lib/gcc/arm-linux-gnueabihf/8/crtbegin.o -L/usr/lib/gcc/arm-linux-gnueabihf/8 -L/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf -L/usr/lib/gcc/arm-linux-gnueabihf/8/../../.. -L/lib/arm-linux-gnueabihf -L/usr/lib/arm-linux-gnueabihf CMakeFiles/cmTC_a3d6f.dir/CMakeCCompilerABI.c.o -lgcc --push-state --as-needed -lgcc_s --pop-state -lc -lgcc --push-state --as-needed -lgcc_s --pop-state /usr/lib/gcc/arm-linux-gnueabihf/8/crtend.o /usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crtn.o]
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/collect2] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/liblto_plugin.so] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=/usr/lib/gcc/arm-linux-gnueabihf/8/lto-wrapper] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-fresolution=/tmp/ccdVOnyN.res] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lc] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [--build-id] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [--eh-frame-hdr] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-export-dynamic] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-dynamic-linker] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/lib/ld-linux-armhf.so.3] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-X] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [--hash-style=gnu] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-m] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-o] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crt1.o] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crti.o] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/crtbegin.o] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/gcc/arm-linux-gnueabihf/8] ==> dir [/usr/lib/gcc/arm-linux-gnueabihf/8]
CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf] ==> dir [/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/gcc/arm-linux-gnueabihf/8/../../..] ==> dir [/usr/lib/gcc/arm-linux-gnueabihf/8/../../..]
CMakeFiles/CMakeOutput.log:    arg [-L/lib/arm-linux-gnueabihf] ==> dir [/lib/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/arm-linux-gnueabihf] ==> dir [/usr/lib/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:    arg [-lgcc] ==> lib [gcc]
CMakeFiles/CMakeOutput.log:    arg [--push-state] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [--as-needed] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-lgcc_s] ==> lib [gcc_s]
CMakeFiles/CMakeOutput.log:    arg [--pop-state] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-lc] ==> lib [c]
CMakeFiles/CMakeOutput.log:    arg [-lgcc] ==> lib [gcc]
CMakeFiles/CMakeOutput.log:    arg [--push-state] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [--as-needed] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-lgcc_s] ==> lib [gcc_s]
CMakeFiles/CMakeOutput.log:    arg [--pop-state] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/crtend.o] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crtn.o] ==> ignore
CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/gcc/arm-linux-gnueabihf/8] ==> [/usr/lib/gcc/arm-linux-gnueabihf/8]
CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf] ==> [/usr/lib/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/gcc/arm-linux-gnueabihf/8/../../..] ==> [/usr/lib]
CMakeFiles/CMakeOutput.log:  collapse library dir [/lib/arm-linux-gnueabihf] ==> [/lib/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/arm-linux-gnueabihf] ==> [/usr/lib/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  implicit dirs: [/usr/lib/gcc/arm-linux-gnueabihf/8;/usr/lib/arm-linux-gnueabihf;/usr/lib;/lib/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:Run Build Command(s):/usr/bin/make cmTC_2d6a1/fast && /usr/bin/make -f CMakeFiles/cmTC_2d6a1.dir/build.make CMakeFiles/cmTC_2d6a1.dir/build
CMakeFiles/CMakeOutput.log:/usr/bin/c++     -o CMakeFiles/cmTC_2d6a1.dir/testCXXCompiler.cxx.o -c /home/marius/lili/CMakeFiles/CMakeTmp/testCXXCompiler.cxx
CMakeFiles/CMakeOutput.log:/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_2d6a1.dir/link.txt --verbose=1
CMakeFiles/CMakeOutput.log:/usr/bin/c++       -rdynamic CMakeFiles/cmTC_2d6a1.dir/testCXXCompiler.cxx.o  -o cmTC_2d6a1 
CMakeFiles/CMakeOutput.log:Run Build Command(s):/usr/bin/make cmTC_78cce/fast && /usr/bin/make -f CMakeFiles/cmTC_78cce.dir/build.make CMakeFiles/cmTC_78cce.dir/build
CMakeFiles/CMakeOutput.log:/usr/bin/c++    -v -o CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o -c /usr/share/cmake-3.16/Modules/CMakeCXXCompilerABI.cpp
CMakeFiles/CMakeOutput.log:Using built-in specs.
CMakeFiles/CMakeOutput.log:Target: arm-linux-gnueabihf
CMakeFiles/CMakeOutput.log:Configured with: ../src/configure -v --with-pkgversion='Raspbian 8.3.0-6+rpi1' --with-bugurl=file:///usr/share/doc/gcc-8/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-8 --program-prefix=arm-linux-gnueabihf- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-sjlj-exceptions --with-arch=armv6 --with-fpu=vfp --with-float=hard --disable-werror --enable-checking=release --build=arm-linux-gnueabihf --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf
CMakeFiles/CMakeOutput.log:gcc version 8.3.0 (Raspbian 8.3.0-6+rpi1) 
CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp'
CMakeFiles/CMakeOutput.log: /usr/lib/gcc/arm-linux-gnueabihf/8/cc1plus -quiet -v -imultilib . -imultiarch arm-linux-gnueabihf -D_GNU_SOURCE /usr/share/cmake-3.16/Modules/CMakeCXXCompilerABI.cpp -quiet -dumpbase CMakeCXXCompilerABI.cpp -mfloat-abi=hard -mfpu=vfp -mtls-dialect=gnu -marm -march=armv6+fp -auxbase-strip CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o -version -o /tmp/ccCBFCxT.s
CMakeFiles/CMakeOutput.log:GNU C++14 (Raspbian 8.3.0-6+rpi1) version 8.3.0 (arm-linux-gnueabihf)
CMakeFiles/CMakeOutput.log:	compiled by GNU C version 8.3.0, GMP version 6.1.2, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.20-GMP
CMakeFiles/CMakeOutput.log:GGC heuristics: --param ggc-min-expand=89 --param ggc-min-heapsize=111573
CMakeFiles/CMakeOutput.log:ignoring duplicate directory "/usr/include/arm-linux-gnueabihf/c++/8"
CMakeFiles/CMakeOutput.log:ignoring nonexistent directory "/usr/local/include/arm-linux-gnueabihf"
CMakeFiles/CMakeOutput.log:ignoring nonexistent directory "/usr/lib/gcc/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/include"
CMakeFiles/CMakeOutput.log: /usr/include/arm-linux-gnueabihf/c++/8
CMakeFiles/CMakeOutput.log: /usr/lib/gcc/arm-linux-gnueabihf/8/include
CMakeFiles/CMakeOutput.log: /usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed
CMakeFiles/CMakeOutput.log: /usr/include/arm-linux-gnueabihf
CMakeFiles/CMakeOutput.log:GNU C++14 (Raspbian 8.3.0-6+rpi1) version 8.3.0 (arm-linux-gnueabihf)
CMakeFiles/CMakeOutput.log:	compiled by GNU C version 8.3.0, GMP version 6.1.2, MPFR version 4.0.2, MPC version 1.1.0, isl version isl-0.20-GMP
CMakeFiles/CMakeOutput.log:GGC heuristics: --param ggc-min-expand=89 --param ggc-min-heapsize=111573
CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp'
CMakeFiles/CMakeOutput.log: as -v -march=armv6 -mfloat-abi=hard -mfpu=vfp -meabi=5 -o CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o /tmp/ccCBFCxT.s
CMakeFiles/CMakeOutput.log:GNU assembler version 2.31.1 (arm-linux-gnueabihf) using BFD version (GNU Binutils for Raspbian) 2.31.1
CMakeFiles/CMakeOutput.log:COMPILER_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/
CMakeFiles/CMakeOutput.log:LIBRARY_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../:/lib/arm-linux-gnueabihf/:/lib/:/usr/lib/arm-linux-gnueabihf/:/usr/lib/
CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp'
CMakeFiles/CMakeOutput.log:/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_78cce.dir/link.txt --verbose=1
CMakeFiles/CMakeOutput.log:/usr/bin/c++      -v -rdynamic CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o  -o cmTC_78cce 
CMakeFiles/CMakeOutput.log:Using built-in specs.
CMakeFiles/CMakeOutput.log:COLLECT_LTO_WRAPPER=/usr/lib/gcc/arm-linux-gnueabihf/8/lto-wrapper
CMakeFiles/CMakeOutput.log:Target: arm-linux-gnueabihf
CMakeFiles/CMakeOutput.log:Configured with: ../src/configure -v --with-pkgversion='Raspbian 8.3.0-6+rpi1' --with-bugurl=file:///usr/share/doc/gcc-8/README.Bugs --enable-languages=c,ada,c++,go,d,fortran,objc,obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-8 --program-prefix=arm-linux-gnueabihf- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-sjlj-exceptions --with-arch=armv6 --with-fpu=vfp --with-float=hard --disable-werror --enable-checking=release --build=arm-linux-gnueabihf --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf
CMakeFiles/CMakeOutput.log:gcc version 8.3.0 (Raspbian 8.3.0-6+rpi1) 
CMakeFiles/CMakeOutput.log:COMPILER_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/
CMakeFiles/CMakeOutput.log:LIBRARY_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../:/lib/arm-linux-gnueabihf/:/lib/:/usr/lib/arm-linux-gnueabihf/:/usr/lib/
CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_78cce' '-shared-libgcc'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp'
CMakeFiles/CMakeOutput.log: /usr/lib/gcc/arm-linux-gnueabihf/8/collect2 -plugin /usr/lib/gcc/arm-linux-gnueabihf/8/liblto_plugin.so -plugin-opt=/usr/lib/gcc/arm-linux-gnueabihf/8/lto-wrapper -plugin-opt=-fresolution=/tmp/ccnE3bXb.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr -export-dynamic -dynamic-linker /lib/ld-linux-armhf.so.3 -X --hash-style=gnu -m armelf_linux_eabi -o cmTC_78cce /usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crt1.o /usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crti.o /usr/lib/gcc/arm-linux-gnueabihf/8/crtbegin.o -L/usr/lib/gcc/arm-linux-gnueabihf/8 -L/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf -L/usr/lib/gcc/arm-linux-gnueabihf/8/../../.. -L/lib/arm-linux-gnueabihf -L/usr/lib/arm-linux-gnueabihf CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/arm-linux-gnueabihf/8/crtend.o /usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crtn.o
CMakeFiles/CMakeOutput.log:COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_78cce' '-shared-libgcc'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp'
CMakeFiles/CMakeOutput.log:    add: [/usr/include/arm-linux-gnueabihf/c++/8]
CMakeFiles/CMakeOutput.log:    add: [/usr/lib/gcc/arm-linux-gnueabihf/8/include]
CMakeFiles/CMakeOutput.log:    add: [/usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed]
CMakeFiles/CMakeOutput.log:    add: [/usr/include/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/include/arm-linux-gnueabihf/c++/8] ==> [/usr/include/arm-linux-gnueabihf/c++/8]
CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/lib/gcc/arm-linux-gnueabihf/8/include] ==> [/usr/lib/gcc/arm-linux-gnueabihf/8/include]
CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed] ==> [/usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed]
CMakeFiles/CMakeOutput.log:  collapse include dir [/usr/include/arm-linux-gnueabihf] ==> [/usr/include/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  implicit include dirs: [/usr/include/c++/8;/usr/include/arm-linux-gnueabihf/c++/8;/usr/include/c++/8/backward;/usr/lib/gcc/arm-linux-gnueabihf/8/include;/usr/local/include;/usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed;/usr/include/arm-linux-gnueabihf;/usr/include]
CMakeFiles/CMakeOutput.log:  link line regex: [^( *|.*[/\])(ld|CMAKE_LINK_STARTFILE-NOTFOUND|([^/\]+-)?ld|collect2)[^/\]*( |$)]
CMakeFiles/CMakeOutput.log:  ignore line: [Run Build Command(s):/usr/bin/make cmTC_78cce/fast && /usr/bin/make -f CMakeFiles/cmTC_78cce.dir/build.make CMakeFiles/cmTC_78cce.dir/build]
CMakeFiles/CMakeOutput.log:  ignore line: [/usr/bin/c++    -v -o CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o -c /usr/share/cmake-3.16/Modules/CMakeCXXCompilerABI.cpp]
CMakeFiles/CMakeOutput.log:  ignore line: [Using built-in specs.]
CMakeFiles/CMakeOutput.log:  ignore line: [Target: arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Raspbian 8.3.0-6+rpi1' --with-bugurl=file:///usr/share/doc/gcc-8/README.Bugs --enable-languages=c ada c++ go d fortran objc obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-8 --program-prefix=arm-linux-gnueabihf- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-sjlj-exceptions --with-arch=armv6 --with-fpu=vfp --with-float=hard --disable-werror --enable-checking=release --build=arm-linux-gnueabihf --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  ignore line: [gcc version 8.3.0 (Raspbian 8.3.0-6+rpi1) ]
CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp']
CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/arm-linux-gnueabihf/8/cc1plus -quiet -v -imultilib . -imultiarch arm-linux-gnueabihf -D_GNU_SOURCE /usr/share/cmake-3.16/Modules/CMakeCXXCompilerABI.cpp -quiet -dumpbase CMakeCXXCompilerABI.cpp -mfloat-abi=hard -mfpu=vfp -mtls-dialect=gnu -marm -march=armv6+fp -auxbase-strip CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o -version -o /tmp/ccCBFCxT.s]
CMakeFiles/CMakeOutput.log:  ignore line: [GNU C++14 (Raspbian 8.3.0-6+rpi1) version 8.3.0 (arm-linux-gnueabihf)]
CMakeFiles/CMakeOutput.log:  ignore line: [	compiled by GNU C version 8.3.0  GMP version 6.1.2  MPFR version 4.0.2  MPC version 1.1.0  isl version isl-0.20-GMP]
CMakeFiles/CMakeOutput.log:  ignore line: [GGC heuristics: --param ggc-min-expand=89 --param ggc-min-heapsize=111573]
CMakeFiles/CMakeOutput.log:  ignore line: [ignoring duplicate directory "/usr/include/arm-linux-gnueabihf/c++/8"]
CMakeFiles/CMakeOutput.log:  ignore line: [ignoring nonexistent directory "/usr/local/include/arm-linux-gnueabihf"]
CMakeFiles/CMakeOutput.log:  ignore line: [ignoring nonexistent directory "/usr/lib/gcc/arm-linux-gnueabihf/8/../../../../arm-linux-gnueabihf/include"]
CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/include/arm-linux-gnueabihf/c++/8]
CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/arm-linux-gnueabihf/8/include]
CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/lib/gcc/arm-linux-gnueabihf/8/include-fixed]
CMakeFiles/CMakeOutput.log:  ignore line: [ /usr/include/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  ignore line: [GNU C++14 (Raspbian 8.3.0-6+rpi1) version 8.3.0 (arm-linux-gnueabihf)]
CMakeFiles/CMakeOutput.log:  ignore line: [	compiled by GNU C version 8.3.0  GMP version 6.1.2  MPFR version 4.0.2  MPC version 1.1.0  isl version isl-0.20-GMP]
CMakeFiles/CMakeOutput.log:  ignore line: [GGC heuristics: --param ggc-min-expand=89 --param ggc-min-heapsize=111573]
CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp']
CMakeFiles/CMakeOutput.log:  ignore line: [ as -v -march=armv6 -mfloat-abi=hard -mfpu=vfp -meabi=5 -o CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o /tmp/ccCBFCxT.s]
CMakeFiles/CMakeOutput.log:  ignore line: [GNU assembler version 2.31.1 (arm-linux-gnueabihf) using BFD version (GNU Binutils for Raspbian) 2.31.1]
CMakeFiles/CMakeOutput.log:  ignore line: [COMPILER_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/]
CMakeFiles/CMakeOutput.log:  ignore line: [LIBRARY_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../:/lib/arm-linux-gnueabihf/:/lib/:/usr/lib/arm-linux-gnueabihf/:/usr/lib/]
CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-o' 'CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o' '-c' '-shared-libgcc'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp']
CMakeFiles/CMakeOutput.log:  ignore line: [/usr/bin/cmake -E cmake_link_script CMakeFiles/cmTC_78cce.dir/link.txt --verbose=1]
CMakeFiles/CMakeOutput.log:  ignore line: [/usr/bin/c++      -v -rdynamic CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o  -o cmTC_78cce ]
CMakeFiles/CMakeOutput.log:  ignore line: [Using built-in specs.]
CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_LTO_WRAPPER=/usr/lib/gcc/arm-linux-gnueabihf/8/lto-wrapper]
CMakeFiles/CMakeOutput.log:  ignore line: [Target: arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  ignore line: [Configured with: ../src/configure -v --with-pkgversion='Raspbian 8.3.0-6+rpi1' --with-bugurl=file:///usr/share/doc/gcc-8/README.Bugs --enable-languages=c ada c++ go d fortran objc obj-c++ --prefix=/usr --with-gcc-major-version-only --program-suffix=-8 --program-prefix=arm-linux-gnueabihf- --enable-shared --enable-linker-build-id --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --libdir=/usr/lib --enable-nls --enable-bootstrap --enable-clocale=gnu --enable-libstdcxx-debug --enable-libstdcxx-time=yes --with-default-libstdcxx-abi=new --enable-gnu-unique-object --disable-libitm --disable-libquadmath --disable-libquadmath-support --enable-plugin --with-system-zlib --with-target-system-zlib --enable-objc-gc=auto --enable-multiarch --disable-sjlj-exceptions --with-arch=armv6 --with-fpu=vfp --with-float=hard --disable-werror --enable-checking=release --build=arm-linux-gnueabihf --host=arm-linux-gnueabihf --target=arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  ignore line: [gcc version 8.3.0 (Raspbian 8.3.0-6+rpi1) ]
CMakeFiles/CMakeOutput.log:  ignore line: [COMPILER_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/]
CMakeFiles/CMakeOutput.log:  ignore line: [LIBRARY_PATH=/usr/lib/gcc/arm-linux-gnueabihf/8/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/:/usr/lib/gcc/arm-linux-gnueabihf/8/../../../:/lib/arm-linux-gnueabihf/:/lib/:/usr/lib/arm-linux-gnueabihf/:/usr/lib/]
CMakeFiles/CMakeOutput.log:  ignore line: [COLLECT_GCC_OPTIONS='-v' '-rdynamic' '-o' 'cmTC_78cce' '-shared-libgcc'  '-mfloat-abi=hard' '-mfpu=vfp' '-mtls-dialect=gnu' '-marm' '-march=armv6+fp']
CMakeFiles/CMakeOutput.log:  link line: [ /usr/lib/gcc/arm-linux-gnueabihf/8/collect2 -plugin /usr/lib/gcc/arm-linux-gnueabihf/8/liblto_plugin.so -plugin-opt=/usr/lib/gcc/arm-linux-gnueabihf/8/lto-wrapper -plugin-opt=-fresolution=/tmp/ccnE3bXb.res -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lgcc --build-id --eh-frame-hdr -export-dynamic -dynamic-linker /lib/ld-linux-armhf.so.3 -X --hash-style=gnu -m armelf_linux_eabi -o cmTC_78cce /usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crt1.o /usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crti.o /usr/lib/gcc/arm-linux-gnueabihf/8/crtbegin.o -L/usr/lib/gcc/arm-linux-gnueabihf/8 -L/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf -L/usr/lib/gcc/arm-linux-gnueabihf/8/../../.. -L/lib/arm-linux-gnueabihf -L/usr/lib/arm-linux-gnueabihf CMakeFiles/cmTC_78cce.dir/CMakeCXXCompilerABI.cpp.o -lstdc++ -lm -lgcc_s -lgcc -lc -lgcc_s -lgcc /usr/lib/gcc/arm-linux-gnueabihf/8/crtend.o /usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crtn.o]
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/collect2] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/liblto_plugin.so] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=/usr/lib/gcc/arm-linux-gnueabihf/8/lto-wrapper] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-fresolution=/tmp/ccnE3bXb.res] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lc] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc_s] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-plugin-opt=-pass-through=-lgcc] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [--build-id] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [--eh-frame-hdr] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-export-dynamic] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-dynamic-linker] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/lib/ld-linux-armhf.so.3] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-X] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [--hash-style=gnu] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-m] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-o] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crt1.o] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crti.o] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/crtbegin.o] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/gcc/arm-linux-gnueabihf/8] ==> dir [/usr/lib/gcc/arm-linux-gnueabihf/8]
CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf] ==> dir [/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/gcc/arm-linux-gnueabihf/8/../../..] ==> dir [/usr/lib/gcc/arm-linux-gnueabihf/8/../../..]
CMakeFiles/CMakeOutput.log:    arg [-L/lib/arm-linux-gnueabihf] ==> dir [/lib/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:    arg [-L/usr/lib/arm-linux-gnueabihf] ==> dir [/usr/lib/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:    arg [-lstdc++] ==> lib [stdc++]
CMakeFiles/CMakeOutput.log:    arg [-lm] ==> lib [m]
CMakeFiles/CMakeOutput.log:    arg [-lgcc_s] ==> lib [gcc_s]
CMakeFiles/CMakeOutput.log:    arg [-lgcc] ==> lib [gcc]
CMakeFiles/CMakeOutput.log:    arg [-lc] ==> lib [c]
CMakeFiles/CMakeOutput.log:    arg [-lgcc_s] ==> lib [gcc_s]
CMakeFiles/CMakeOutput.log:    arg [-lgcc] ==> lib [gcc]
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/crtend.o] ==> ignore
CMakeFiles/CMakeOutput.log:    arg [/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf/crtn.o] ==> ignore
CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/gcc/arm-linux-gnueabihf/8] ==> [/usr/lib/gcc/arm-linux-gnueabihf/8]
CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/gcc/arm-linux-gnueabihf/8/../../../arm-linux-gnueabihf] ==> [/usr/lib/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/gcc/arm-linux-gnueabihf/8/../../..] ==> [/usr/lib]
CMakeFiles/CMakeOutput.log:  collapse library dir [/lib/arm-linux-gnueabihf] ==> [/lib/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  collapse library dir [/usr/lib/arm-linux-gnueabihf] ==> [/usr/lib/arm-linux-gnueabihf]
CMakeFiles/CMakeOutput.log:  implicit dirs: [/usr/lib/gcc/arm-linux-gnueabihf/8;/usr/lib/arm-linux-gnueabihf;/usr/lib;/lib/arm-linux-gnueabihf]
Binary file CMakeFiles/liveimage.dir/avlibrtsp.cpp.o matches
Binary file CMakeFiles/liveimage.dir/motion.cpp.o matches
Binary file CMakeFiles/liveimage.dir/camevents.cpp.o matches
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
CMakeFiles/liveimage.dir/CXX.includecache:-
Binary file CMakeFiles/liveimage.dir/jpeghttpcam.cpp.o matches
Binary file CMakeFiles/liveimage.dir/sock.cpp.o matches
Binary file CMakeFiles/liveimage.dir/webcast.cpp.o matches
CMakeFiles/liveimage.dir/link.txt:g++   -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0  -rdynamic CMakeFiles/liveimage.dir/acamera.cpp.o CMakeFiles/liveimage.dir/pipefile.cpp.o CMakeFiles/liveimage.dir/cbconf.cpp.o CMakeFiles/liveimage.dir/avlibrtsp.cpp.o CMakeFiles/liveimage.dir/jpeghttpcam.cpp.o CMakeFiles/liveimage.dir/jencoder.cpp.o CMakeFiles/liveimage.dir/imgsink.cpp.o CMakeFiles/liveimage.dir/fxxtojpg.cpp.o CMakeFiles/liveimage.dir/localcam.cpp.o CMakeFiles/liveimage.dir/mainn.cpp.o CMakeFiles/liveimage.dir/motion.cpp.o CMakeFiles/liveimage.dir/camevents.cpp.o CMakeFiles/liveimage.dir/rtpudpcs.cpp.o CMakeFiles/liveimage.dir/rtspcam.cpp.o CMakeFiles/liveimage.dir/sock.cpp.o CMakeFiles/liveimage.dir/sockserver.cpp.o CMakeFiles/liveimage.dir/v4ldevice.cpp.o CMakeFiles/liveimage.dir/webcast.cpp.o  -o liveimage  -lpthread -ljpeg -lv4l2 -ldl 
Binary file CMakeFiles/liveimage.dir/sockserver.cpp.o matches
Binary file CMakeFiles/liveimage.dir/fxxtojpg.cpp.o matches
Binary file CMakeFiles/liveimage.dir/localcam.cpp.o matches
CMakeFiles/liveimage.dir/flags.make:CXX_FLAGS =  -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0  
CMakeFiles/liveimage.dir/flags.make:CXX_DEFINES = -DWITH_AVLIB_RTSP -Dcimg_display=0 -Dcimg_use_jpeg
CMakeFiles/liveimage.dir/build.make:RM = /usr/bin/cmake -E remove -f
CMakeFiles/liveimage.dir/build.make:# The top-level source directory on which CMake was run.
CMakeFiles/liveimage.dir/build.make:# The top-level build directory on which CMake was run.
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_1) "Building CXX object CMakeFiles/liveimage.dir/acamera.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/acamera.cpp.o -c /home/marius/lili/acamera.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/acamera.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/acamera.cpp > CMakeFiles/liveimage.dir/acamera.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/acamera.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/acamera.cpp -o CMakeFiles/liveimage.dir/acamera.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_2) "Building CXX object CMakeFiles/liveimage.dir/pipefile.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/pipefile.cpp.o -c /home/marius/lili/pipefile.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/pipefile.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/pipefile.cpp > CMakeFiles/liveimage.dir/pipefile.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/pipefile.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/pipefile.cpp -o CMakeFiles/liveimage.dir/pipefile.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_3) "Building CXX object CMakeFiles/liveimage.dir/cbconf.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/cbconf.cpp.o -c /home/marius/lili/cbconf.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/cbconf.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/cbconf.cpp > CMakeFiles/liveimage.dir/cbconf.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/cbconf.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/cbconf.cpp -o CMakeFiles/liveimage.dir/cbconf.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_4) "Building CXX object CMakeFiles/liveimage.dir/avlibrtsp.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/avlibrtsp.cpp.o -c /home/marius/lili/avlibrtsp.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/avlibrtsp.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/avlibrtsp.cpp > CMakeFiles/liveimage.dir/avlibrtsp.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/avlibrtsp.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/avlibrtsp.cpp -o CMakeFiles/liveimage.dir/avlibrtsp.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_5) "Building CXX object CMakeFiles/liveimage.dir/jpeghttpcam.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/jpeghttpcam.cpp.o -c /home/marius/lili/jpeghttpcam.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/jpeghttpcam.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/jpeghttpcam.cpp > CMakeFiles/liveimage.dir/jpeghttpcam.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/jpeghttpcam.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/jpeghttpcam.cpp -o CMakeFiles/liveimage.dir/jpeghttpcam.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_6) "Building CXX object CMakeFiles/liveimage.dir/jencoder.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/jencoder.cpp.o -c /home/marius/lili/jencoder.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/jencoder.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/jencoder.cpp > CMakeFiles/liveimage.dir/jencoder.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/jencoder.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/jencoder.cpp -o CMakeFiles/liveimage.dir/jencoder.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_7) "Building CXX object CMakeFiles/liveimage.dir/imgsink.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/imgsink.cpp.o -c /home/marius/lili/imgsink.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/imgsink.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/imgsink.cpp > CMakeFiles/liveimage.dir/imgsink.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/imgsink.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/imgsink.cpp -o CMakeFiles/liveimage.dir/imgsink.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_8) "Building CXX object CMakeFiles/liveimage.dir/fxxtojpg.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/fxxtojpg.cpp.o -c /home/marius/lili/fxxtojpg.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/fxxtojpg.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/fxxtojpg.cpp > CMakeFiles/liveimage.dir/fxxtojpg.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/fxxtojpg.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/fxxtojpg.cpp -o CMakeFiles/liveimage.dir/fxxtojpg.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_9) "Building CXX object CMakeFiles/liveimage.dir/localcam.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/localcam.cpp.o -c /home/marius/lili/localcam.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/localcam.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/localcam.cpp > CMakeFiles/liveimage.dir/localcam.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/localcam.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/localcam.cpp -o CMakeFiles/liveimage.dir/localcam.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_10) "Building CXX object CMakeFiles/liveimage.dir/mainn.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/mainn.cpp.o -c /home/marius/lili/mainn.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/mainn.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/mainn.cpp > CMakeFiles/liveimage.dir/mainn.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/mainn.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/mainn.cpp -o CMakeFiles/liveimage.dir/mainn.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_11) "Building CXX object CMakeFiles/liveimage.dir/motion.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/motion.cpp.o -c /home/marius/lili/motion.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/motion.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/motion.cpp > CMakeFiles/liveimage.dir/motion.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/motion.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/motion.cpp -o CMakeFiles/liveimage.dir/motion.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_12) "Building CXX object CMakeFiles/liveimage.dir/camevents.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/camevents.cpp.o -c /home/marius/lili/camevents.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/camevents.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/camevents.cpp > CMakeFiles/liveimage.dir/camevents.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/camevents.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/camevents.cpp -o CMakeFiles/liveimage.dir/camevents.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_13) "Building CXX object CMakeFiles/liveimage.dir/rtpudpcs.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/rtpudpcs.cpp.o -c /home/marius/lili/rtpudpcs.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/rtpudpcs.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/rtpudpcs.cpp > CMakeFiles/liveimage.dir/rtpudpcs.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/rtpudpcs.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/rtpudpcs.cpp -o CMakeFiles/liveimage.dir/rtpudpcs.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_14) "Building CXX object CMakeFiles/liveimage.dir/rtspcam.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/rtspcam.cpp.o -c /home/marius/lili/rtspcam.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/rtspcam.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/rtspcam.cpp > CMakeFiles/liveimage.dir/rtspcam.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/rtspcam.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/rtspcam.cpp -o CMakeFiles/liveimage.dir/rtspcam.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_15) "Building CXX object CMakeFiles/liveimage.dir/sock.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/sock.cpp.o -c /home/marius/lili/sock.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/sock.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/sock.cpp > CMakeFiles/liveimage.dir/sock.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/sock.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/sock.cpp -o CMakeFiles/liveimage.dir/sock.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_16) "Building CXX object CMakeFiles/liveimage.dir/sockserver.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/sockserver.cpp.o -c /home/marius/lili/sockserver.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/sockserver.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/sockserver.cpp > CMakeFiles/liveimage.dir/sockserver.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/sockserver.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/sockserver.cpp -o CMakeFiles/liveimage.dir/sockserver.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_17) "Building CXX object CMakeFiles/liveimage.dir/v4ldevice.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/v4ldevice.cpp.o -c /home/marius/lili/v4ldevice.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/v4ldevice.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/v4ldevice.cpp > CMakeFiles/liveimage.dir/v4ldevice.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/v4ldevice.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/v4ldevice.cpp -o CMakeFiles/liveimage.dir/v4ldevice.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_18) "Building CXX object CMakeFiles/liveimage.dir/webcast.cpp.o"
CMakeFiles/liveimage.dir/build.make:	g++  $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -o CMakeFiles/liveimage.dir/webcast.cpp.o -c /home/marius/lili/webcast.cpp
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Preprocessing CXX source to CMakeFiles/liveimage.dir/webcast.cpp.i"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -E /home/marius/lili/webcast.cpp > CMakeFiles/liveimage.dir/webcast.cpp.i
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green "Compiling CXX source to assembly CMakeFiles/liveimage.dir/webcast.cpp.s"
CMakeFiles/liveimage.dir/build.make:	g++ $(CXX_DEFINES) $(CXX_INCLUDES) $(CXX_FLAGS) -S /home/marius/lili/webcast.cpp -o CMakeFiles/liveimage.dir/webcast.cpp.s
CMakeFiles/liveimage.dir/build.make:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --green --bold --progress-dir=/home/marius/lili/CMakeFiles --progress-num=$(CMAKE_PROGRESS_19) "Linking CXX executable liveimage"
CMakeFiles/liveimage.dir/build.make:	$(CMAKE_COMMAND) -E cmake_link_script CMakeFiles/liveimage.dir/link.txt --verbose=$(VERBOSE)
CMakeFiles/liveimage.dir/build.make:	$(CMAKE_COMMAND) -P CMakeFiles/liveimage.dir/cmake_clean.cmake
CMakeFiles/liveimage.dir/build.make:	cd /home/marius/lili && $(CMAKE_COMMAND) -E cmake_depends "Unix Makefiles" /home/marius/lili /home/marius/lili /home/marius/lili /home/marius/lili /home/marius/lili/CMakeFiles/liveimage.dir/DependInfo.cmake --color=$(COLOR)
Binary file CMakeFiles/liveimage.dir/rtpudpcs.cpp.o matches
CMakeFiles/liveimage.dir/cmake_clean.cmake:# Per-language clean rules from dependency scanning.
Binary file CMakeFiles/liveimage.dir/imgsink.cpp.o matches
Binary file CMakeFiles/liveimage.dir/rtspcam.cpp.o matches
Binary file CMakeFiles/liveimage.dir/cbconf.cpp.o matches
Binary file CMakeFiles/liveimage.dir/pipefile.cpp.o matches
Binary file CMakeFiles/liveimage.dir/v4ldevice.cpp.o matches
Binary file CMakeFiles/liveimage.dir/mainn.cpp.o matches
Binary file CMakeFiles/liveimage.dir/acamera.cpp.o matches
Binary file CMakeFiles/liveimage.dir/jencoder.cpp.o matches
v4ldevice.cpp:    First Release: September 16 - 29 2016
v4ldevice.cpp:            if (-1 == _device)
v4ldevice.cpp:    if (-1 == _device)
v4ldevice.cpp:    if (-1 == _ioctl(VIDIOC_QUERYCAP, &caps))
v4ldevice.cpp:    if (-1 == _ioctl(VIDIOC_S_FMT, &frmt))
v4ldevice.cpp:        if (-1 == _ioctl(VIDIOC_S_PARM, &fint))
v4ldevice.cpp:    uint32_t buffer_size = (frmt.fmt.pix.sizeimage + page_size - 1) & ~(page_size - 1);
v4ldevice.cpp:    if (-1 == _ioctl(VIDIOC_REQBUFS, &req))
v4ldevice.cpp:        if (-1 == _ioctl(VIDIOC_REQBUFS, &req))
v4ldevice.cpp:            if (-1 == _ioctl(VIDIOC_QBUF, &buf))
v4ldevice.cpp:        if (-1 == _ioctl(VIDIOC_STREAMON, &type))
v4ldevice.cpp:        if (-1 == _ioctl(VIDIOC_QUERYBUF, &buf))
v4ldevice.cpp:        if (-1 == _ioctl(VIDIOC_QBUF, &buf))
v4ldevice.cpp:    if (-1 == _ioctl(VIDIOC_STREAMON, &type))
v4ldevice.cpp:    while (-1 == r && EINTR == errno)
v4ldevice.cpp:    if(r==-1)
v4ldevice.cpp:    if(-1==_ioctl(VIDIOC_DQBUF, &buf))
v4ldevice.cpp: //   if (-1 == _ioctl(VIDIOC_QBUF, &buf))
CMakeCache.txt://A wrapper around 'ar' adding the appropriate '--plugin' option
CMakeCache.txt:CMAKE_CXX_COMPILER_AR:FILEPATH=/usr/bin/gcc-ar-8
CMakeCache.txt://A wrapper around 'ranlib' adding the appropriate '--plugin' option
CMakeCache.txt:CMAKE_CXX_COMPILER_RANLIB:FILEPATH=/usr/bin/gcc-ranlib-8
CMakeCache.txt:CMAKE_CXX_FLAGS_DEBUG:STRING=-g
CMakeCache.txt:CMAKE_CXX_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG
CMakeCache.txt:CMAKE_CXX_FLAGS_RELEASE:STRING=-O3 -DNDEBUG
CMakeCache.txt:CMAKE_CXX_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG
CMakeCache.txt://A wrapper around 'ar' adding the appropriate '--plugin' option
CMakeCache.txt:CMAKE_C_COMPILER_AR:FILEPATH=/usr/bin/gcc-ar-8
CMakeCache.txt://A wrapper around 'ranlib' adding the appropriate '--plugin' option
CMakeCache.txt:CMAKE_C_COMPILER_RANLIB:FILEPATH=/usr/bin/gcc-ranlib-8
CMakeCache.txt:CMAKE_C_FLAGS_DEBUG:STRING=-g
CMakeCache.txt:CMAKE_C_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG
CMakeCache.txt:CMAKE_C_FLAGS_RELEASE:STRING=-O3 -DNDEBUG
CMakeCache.txt:CMAKE_C_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG
CMakeCache.txt:CMAKE_DLLTOOL:FILEPATH=CMAKE_DLLTOOL-NOTFOUND
CMakeCache.txt:CMAKE_ADDR2LINE-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_AR-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_COLOR_MAKEFILE-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_CXX_COMPILER-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_CXX_COMPILER_AR-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_CXX_COMPILER_RANLIB-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_CXX_FLAGS-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_CXX_FLAGS_DEBUG-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_CXX_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_CXX_FLAGS_RELEASE-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_CXX_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_C_COMPILER-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_C_COMPILER_AR-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_C_COMPILER_RANLIB-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_C_FLAGS-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_C_FLAGS_DEBUG-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_C_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_C_FLAGS_RELEASE-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_C_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_DLLTOOL-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_EXE_LINKER_FLAGS-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_EXE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_EXE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_EXE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_EXPORT_COMPILE_COMMANDS-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_LINKER-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_MAKE_PROGRAM-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_MODULE_LINKER_FLAGS-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_MODULE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_MODULE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_NM-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_OBJCOPY-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_OBJDUMP-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_RANLIB-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_READELF-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_ROOT:INTERNAL=/usr/share/cmake-3.16
CMakeCache.txt:CMAKE_SHARED_LINKER_FLAGS-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_SHARED_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_SHARED_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_SKIP_INSTALL_RPATH-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_SKIP_RPATH-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_STATIC_LINKER_FLAGS-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_STATIC_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_STATIC_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_STRIP-ADVANCED:INTERNAL=1
CMakeCache.txt:CMAKE_VERBOSE_MAKEFILE-ADVANCED:INTERNAL=1
Makefile:# Allow only one "make -f Makefile2" at a time, but pass parallelism.
Makefile:RM = /usr/bin/cmake -E remove -f
Makefile:# The top-level source directory on which CMake was run.
Makefile:# The top-level build directory on which CMake was run.
Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "Running CMake to regenerate build system..."
Makefile:	/usr/bin/cmake -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR)
Makefile:	@$(CMAKE_COMMAND) -E cmake_echo_color --switch=$(COLOR) --cyan "No interactive CMake dialog available..."
Makefile:	/usr/bin/cmake -E echo No\ interactive\ CMake\ dialog\ available.
Makefile:	$(CMAKE_COMMAND) -E cmake_progress_start /home/marius/lili/CMakeFiles /home/marius/lili/CMakeFiles/progress.marks
Makefile:	$(MAKE) -f CMakeFiles/Makefile2 all
Makefile:	$(CMAKE_COMMAND) -E cmake_progress_start /home/marius/lili/CMakeFiles 0
Makefile:	$(MAKE) -f CMakeFiles/Makefile2 clean
Makefile:	$(MAKE) -f CMakeFiles/Makefile2 preinstall
Makefile:	$(MAKE) -f CMakeFiles/Makefile2 preinstall
Makefile:	$(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 1
Makefile:	$(MAKE) -f CMakeFiles/Makefile2 liveimage
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/build
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/acamera.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/acamera.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/acamera.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/avlibrtsp.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/avlibrtsp.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/avlibrtsp.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/camevents.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/camevents.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/camevents.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/cbconf.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/cbconf.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/cbconf.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/fxxtojpg.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/fxxtojpg.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/fxxtojpg.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/imgsink.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/imgsink.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/imgsink.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/jencoder.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/jencoder.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/jencoder.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/jpeghttpcam.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/jpeghttpcam.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/jpeghttpcam.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/localcam.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/localcam.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/localcam.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/mainn.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/mainn.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/mainn.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/motion.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/motion.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/motion.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/pipefile.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/pipefile.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/pipefile.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/rtpudpcs.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/rtpudpcs.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/rtpudpcs.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/rtspcam.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/rtspcam.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/rtspcam.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/sock.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/sock.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/sock.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/sockserver.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/sockserver.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/sockserver.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/v4ldevice.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/v4ldevice.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/v4ldevice.cpp.s
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/webcast.cpp.o
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/webcast.cpp.i
Makefile:	$(MAKE) -f CMakeFiles/liveimage.dir/build.make CMakeFiles/liveimage.dir/webcast.cpp.s
Makefile:	$(CMAKE_COMMAND) -S$(CMAKE_SOURCE_DIR) -B$(CMAKE_BINARY_DIR) --check-build-system CMakeFiles/Makefile.cmake 0
qt_prj/qt_liveimage.pro.user.22:<?xml version="1.0" encoding="UTF-8"?>
qt_prj/qt_liveimage.pro.user.22:<!-- Written by QtCreator 5.0.1, 2022-05-01T19:05:21. -->
qt_prj/qt_liveimage.pro.user.22:  <value type="QByteArray">{69a5c52f-fe65-469b-b7f3-2f417de34efc}</value>
qt_prj/qt_liveimage.pro.user.22:   <value type="QByteArray" key="EditorConfiguration.Codec">UTF-8</value>
qt_prj/qt_liveimage.pro.user.22:   <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">{b2397820-a64e-4365-be4d-2b04d16c53f2}</value>
qt_prj/qt_liveimage.pro.user.22:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Debug</value>
qt_prj/qt_liveimage.pro.user.22:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory.shadowDir">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Debug</value>
qt_prj/qt_liveimage.pro.user.22:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Release</value>
qt_prj/qt_liveimage.pro.user.22:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory.shadowDir">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Release</value>
qt_prj/qt_liveimage.pro.user.22:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Profile</value>
qt_prj/qt_liveimage.pro.user.22:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory.shadowDir">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Profile</value>
qt_prj/qt_liveimage.pro.user.22:    <value type="QString" key="RunConfiguration.WorkingDirectory.default">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Debug</value>
Binary file qt_prj/qt_liveimage matches
qt_prj/qt_liveimage.pro.user:<?xml version="1.0" encoding="UTF-8"?>
qt_prj/qt_liveimage.pro.user:<!-- Written by QtCreator 10.0.2, 2023-09-15T14:10:25. -->
qt_prj/qt_liveimage.pro.user:  <value type="QByteArray">{69a5c52f-fe65-469b-b7f3-2f417de34efc}</value>
qt_prj/qt_liveimage.pro.user:   <value type="QByteArray" key="EditorConfiguration.Codec">UTF-8</value>
qt_prj/qt_liveimage.pro.user:   <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">{b2397820-a64e-4365-be4d-2b04d16c53f2}</value>
qt_prj/qt_liveimage.pro.user:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Debug</value>
qt_prj/qt_liveimage.pro.user:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory.shadowDir">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Debug</value>
qt_prj/qt_liveimage.pro.user:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Release</value>
qt_prj/qt_liveimage.pro.user:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory.shadowDir">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Release</value>
qt_prj/qt_liveimage.pro.user:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Profile</value>
qt_prj/qt_liveimage.pro.user:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory.shadowDir">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Profile</value>
qt_prj/qt_liveimage.pro.user:    <value type="QString" key="RunConfiguration.WorkingDirectory.default">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Debug</value>
qt_prj/qt_liveimage.pro.user.4.10-pre1:<?xml version="1.0" encoding="UTF-8"?>
qt_prj/qt_liveimage.pro.user.4.10-pre1:<!-- Written by QtCreator 4.9.1, 2022-05-13T14:54:26. -->
qt_prj/qt_liveimage.pro.user.4.10-pre1:  <value type="QByteArray">{69a5c52f-fe65-469b-b7f3-2f417de34efc}</value>
qt_prj/qt_liveimage.pro.user.4.10-pre1:   <value type="QByteArray" key="EditorConfiguration.Codec">UTF-8</value>
qt_prj/qt_liveimage.pro.user.4.10-pre1:   <value type="QString" key="ProjectExplorer.ProjectConfiguration.Id">{b2397820-a64e-4365-be4d-2b04d16c53f2}</value>
qt_prj/qt_liveimage.pro.user.4.10-pre1:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Debug</value>
qt_prj/qt_liveimage.pro.user.4.10-pre1:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Release</value>
qt_prj/qt_liveimage.pro.user.4.10-pre1:    <value type="QString" key="ProjectExplorer.BuildConfiguration.BuildDirectory">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Profile</value>
qt_prj/qt_liveimage.pro.user.4.10-pre1:     <value type="QString">cpu-cycles</value>
qt_prj/qt_liveimage.pro.user.4.10-pre1:    <value type="QString" key="Analyzer.Perf.SampleMode">-F</value>
qt_prj/qt_liveimage.pro.user.4.10-pre1:    <value type="QString" key="RunConfiguration.WorkingDirectory.default">/sdaone/GIT_HUB/lili/build-qt_liveimage-LINUX_DEFAULT-Debug</value>
qt_prj/qt_liveimage.pro:QT -= gui
qt_prj/qt_liveimage.pro:QT -= core
qt_prj/qt_liveimage.pro:#QMAKE_LFLAGS += -no-pie
qt_prj/qt_liveimage.pro:CONFIG -= app_bundle
qt_prj/qt_liveimage.pro:# QMAKE_CFLAGS += -Wextra -Wfatal-errors -Werror=unknown-pragmas -Werror=unused-label -Wshadow -std=c++11 -pedantic -Dcimg_display=0 -Ofast -mtune=generic -lm
qt_prj/qt_liveimage.pro:LIBS +=  -lpthread  -lv4l2 -ljpeg -ldl
qt_prj/qt_liveimage.pro:# -lavdevice - -lavformat -lavcodec -lavutil
qt_prj/qt_liveimage.pro:LIBS += -L$$usr/lib/x86_64-linux-gnu
qt_prj/qt_liveimage.pro:LIBS +=  -lpthread  -lv4l2 -ljpeg -ldl
qt_prj/qt_liveimage.pro:# -lavdevice - -lavformat -lavcodec -lavutil
qt_prj/qt_liveimage.pro:LIBS += -L$$usr/lib/x86_64-linux-gnu
mpeger-old.cpp:    delete[] _frame->data[0];
mpeger-old.cpp:    _pcodekCtx->time_base.den = 1;
mpeger-old.cpp:    _pcodekCtx->time_base.num = 1;
mpeger-old.cpp:    _pcodekCtx->width         = imgsz.x;
mpeger-old.cpp:    _pcodekCtx->height        = imgsz.y;
mpeger-old.cpp:    _pcodekCtx->pix_fmt       = AV_PIX_FMT_YUVJ420P; //AV_PIX_FMT_YUV420P;
mpeger-old.cpp:    _packet->data = NULL;
mpeger-old.cpp:    _packet->size = 0;
mpeger-old.cpp:        _pcodekCtx->pix_fmt = (AVPixelFormat)fmt;
mpeger-old.cpp:        _frame->format = _pcodekCtx->pix_fmt;
mpeger-old.cpp:        _frame->width  = _pcodekCtx->width;
mpeger-old.cpp:        _frame->height = _pcodekCtx->height;
mpeger-old.cpp:                         unkfmt, _pcodekCtx->pix_fmt,
mpeger-old.cpp:                         _pcodekCtx->width,
mpeger-old.cpp:                         _pcodekCtx->height);
mpeger-old.cpp:        packet->data = (uint8_t*)unkfmt;
mpeger-old.cpp:        packet->size = len;
rtpudpcs.cpp:        bytes2 = _udpc.receive(_frame+bytes1,MAX_BUFF-bytes1);
mainn.cpp-old.cpp:    First Release: September 16 - 29 2016
mainn.cpp-old.cpp:sudo apt-get install libpng-dev libv4l-dev libjpeg-dev
mainn.cpp-old.cpp:        pCFG->parse("./liveimage.konf");
mainn.cpp-old.cpp:            if(ps && ps->listen()==false)
mainn.cpp-old.cpp:            if(ffmt->init(wh.x, wh.y)==false)
mainn.cpp-old.cpp:        Transport: RTP/AVP;unicast;client_port=8000-8001
mainn.cpp-old.cpp:            a->start_thread();
mainn.cpp-old.cpp:        cast->start_thread();
mainn.cpp-old.cpp:            ps->spin();
mainn.cpp-old.cpp:        jpgsz = ffmt->convert420(pb422, sz, iw, ih, quality, &pjpg);
mainn.cpp-old.cpp:        if(ps && ps->has_clients() && jpgsz)
mainn.cpp-old.cpp:            int wants = ps->anyone_needs();
mainn.cpp-old.cpp:                ps->stream_on(0, 0, ifmt, WANTS_HTML);
mainn.cpp-old.cpp:                ps->stream_on(pjpg, jpgsz,ifmt, WANTS_LIVE_IMAGE);
mainn.cpp-old.cpp:                size_t          jpgsz1 = ffmt->convertBW(mot,
mainn.cpp-old.cpp:                    ps->stream_on(pjpg1, jpgsz1, ifmt, WANTS_MOTION);
mainn.cpp-old.cpp:                        jpgsz = a->getframe(&pjpg);
mainn.cpp-old.cpp:                        ps->stream_on(pjpg,jpgsz,ifmt, WANTS_REMOTE);
mainn.cpp-old.cpp:            if(now - tickmove > innertia_interval)
mainn.cpp-old.cpp:                    --movementintertia;
mainn.cpp-old.cpp:            if((now - lapsetick) > (uint32_t)time_lapse)
mainn.cpp-old.cpp:        if(cast && !cast->is_stopped())
mainn.cpp-old.cpp:            cast->stream_frame(pjpg, jpgsz, event, iw, ih);
mainn.cpp-old.cpp:                    if(time(0) - _mpgnewfile > 3600)
mainn.cpp-old.cpp:                    ::sprintf(fname, "%si%04d-%06d.jpg", save_loc.c_str(),
mainn.cpp-old.cpp:    if(cast && !cast->is_stopped())
mainn.cpp-old.cpp:        cast->kill();
mainn.cpp-old.cpp:        cast->stop_thread();
mainn.cpp-old.cpp:        a->stop_thread();
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:# For build in directory: /sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_ADDR2LINE:FILEPATH=/usr/bin/x86_64-linux-gnu-addr2line
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_AR:FILEPATH=/usr/bin/x86_64-linux-gnu-ar
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_COMPILER:STRING=/usr/bin/x86_64-linux-gnu-g++-9
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev://A wrapper around 'ar' adding the appropriate '--plugin' option
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_COMPILER_AR:FILEPATH=/usr/bin/x86_64-linux-gnu-gcc-ar-9
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev://A wrapper around 'ranlib' adding the appropriate '--plugin' option
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_COMPILER_RANLIB:FILEPATH=/usr/bin/x86_64-linux-gnu-gcc-ranlib-9
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_FLAGS:STRING=-DQT_QML_DEBUG
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_FLAGS_DEBUG:STRING=-g
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_FLAGS_INIT:STRING=-DQT_QML_DEBUG
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_FLAGS_RELEASE:STRING=-O3 -DNDEBUG
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_COMPILER:STRING=/usr/bin/x86_64-linux-gnu-gcc-9
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev://A wrapper around 'ar' adding the appropriate '--plugin' option
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_COMPILER_AR:FILEPATH=/usr/bin/x86_64-linux-gnu-gcc-ar-9
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev://A wrapper around 'ranlib' adding the appropriate '--plugin' option
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_COMPILER_RANLIB:FILEPATH=/usr/bin/x86_64-linux-gnu-gcc-ranlib-9
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_FLAGS_DEBUG:STRING=-g
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_FLAGS_MINSIZEREL:STRING=-Os -DNDEBUG
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_FLAGS_RELEASE:STRING=-O3 -DNDEBUG
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_FLAGS_RELWITHDEBINFO:STRING=-O2 -g -DNDEBUG
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_DLLTOOL:FILEPATH=CMAKE_DLLTOOL-NOTFOUND
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_FIND_PACKAGE_REDIRECTS_DIR:STATIC=/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeFiles/pkgRedirects
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_LINKER:FILEPATH=/usr/bin/x86_64-linux-gnu-ld
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_NM:FILEPATH=/usr/bin/x86_64-linux-gnu-nm
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_OBJCOPY:FILEPATH=/usr/bin/x86_64-linux-gnu-objcopy
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_OBJDUMP:FILEPATH=/usr/bin/x86_64-linux-gnu-objdump
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_PROJECT_INCLUDE_BEFORE:FILEPATH=/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_RANLIB:FILEPATH=/usr/bin/x86_64-linux-gnu-ranlib
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_READELF:FILEPATH=/usr/bin/x86_64-linux-gnu-readelf
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_STRIP:FILEPATH=/usr/bin/x86_64-linux-gnu-strip
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev://Skip Qt Creator's package manager auto-setup
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:liveimage_srv_BINARY_DIR:STATIC=/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_ADDR2LINE-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_AR-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CACHEFILE_DIR:INTERNAL=/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_COMPILER-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_COMPILER_AR-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_COMPILER_RANLIB-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_FLAGS-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_FLAGS_DEBUG-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_FLAGS_RELEASE-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_CXX_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_COMPILER-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_COMPILER_AR-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_COMPILER_RANLIB-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_FLAGS-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_FLAGS_DEBUG-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_FLAGS_RELEASE-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_C_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_DLLTOOL-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_EXE_LINKER_FLAGS-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_EXE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_EXE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_EXE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_EXE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_EXPORT_COMPILE_COMMANDS-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_LINKER-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_MAKE_PROGRAM-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_MODULE_LINKER_FLAGS-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_MODULE_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_MODULE_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_MODULE_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_MODULE_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_NM-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_OBJCOPY-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_OBJDUMP-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_RANLIB-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_READELF-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_ROOT:INTERNAL=/home/marius/Qt2/Tools/CMake/share/cmake-3.24
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_SHARED_LINKER_FLAGS-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_SHARED_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_SHARED_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_SHARED_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_SHARED_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_SKIP_INSTALL_RPATH-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_SKIP_RPATH-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_STATIC_LINKER_FLAGS-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_STATIC_LINKER_FLAGS_DEBUG-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_STATIC_LINKER_FLAGS_MINSIZEREL-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_STATIC_LINKER_FLAGS_RELEASE-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_STATIC_LINKER_FLAGS_RELWITHDEBINFO-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_STRIP-ADVANCED:INTERNAL=1
build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeCache.txt.prev:CMAKE_VERBOSE_MAKEFILE-ADVANCED:INTERNAL=1
Binary file build-liveimage_srv-LINUX_DEFAULT-Debug/.ninja_deps matches
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:# https://github.com/conan-io/cmake-conan/blob/develop2/conan_support.cmake
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:    message(STATUS "Conan-cmake: cmake_system_name=${CMAKE_SYSTEM_NAME}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:    message(STATUS "Conan-cmake: CMake compiler=${_COMPILER}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:    message(STATUS "Conan-cmake: CMake cmpiler version=${_COMPILER_VERSION}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:        set(_COMPILER "apple-clang")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:    message(STATUS "Conan-cmake: [settings] compiler=${_COMPILER}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:    message(STATUS "Conan-cmake: [settings] compiler.version=${_COMPILER_VERSION}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:        # Only set when we know we are in a single-configuration generator
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:    message(STATUS "Conan-cmake: Creating profile ${_FN}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:    message(STATUS "Conan-cmake: Profile: \n${PROFILE}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:    message(STATUS "Conan-cmake: Checking if a default profile exists")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:        message(STATUS "Conan-cmake: The default profile doesn't exist, detecting it.")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:    set(CONAN_ARGS ${CONAN_ARGS} -of=${CONAN_OUTPUT_FOLDER})
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:    message(STATUS "CMake-conan: conan install ${CMAKE_SOURCE_DIR} ${CONAN_ARGS} ${ARGN}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:    execute_process(COMMAND conan install ${CMAKE_SOURCE_DIR} ${CONAN_ARGS} ${ARGN} --format=json
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:        message(STATUS "CMake-conan: CONAN_GENERATORS_FOLDER=${CONAN_GENERATORS_FOLDER}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:        message(STATUS "CMake-conan: first find_package() found. Installing dependencies with Conan")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:            message(STATUS "CMake-conan: Installing single configuration ${CMAKE_BUILD_TYPE}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:            conan_install(-pr ${CMAKE_BINARY_DIR}/conan_host_profile --build=missing -g CMakeDeps)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:            message(STATUS "CMake-conan: Installing both Debug and Release")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:            conan_install(-pr ${CMAKE_BINARY_DIR}/conan_host_profile -s build_type=Release --build=missing -g CMakeDeps)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:            conan_install(-pr ${CMAKE_BINARY_DIR}/conan_host_profile -s build_type=Debug --build=missing -g CMakeDeps)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan_support.cmake:        message(STATUS "CMake-conan: find_package(${package_name}) found, 'conan install' aready ran")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:option(QT_CREATOR_SKIP_PACKAGE_MANAGER_SETUP "Skip Qt Creator's package manager auto-setup" OFF)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:    option(QT_CREATOR_SKIP_CONAN_SETUP "Skip Qt Creator's conan package manager auto-setup" OFF)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:    set(QT_CREATOR_CONAN_BUILD_POLICY "missing" CACHE STRING "Qt Creator's conan package manager auto-setup build policy. This is used for the BUILD property of cmake_conan_run")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:                      "Package manager auto-setup will be skipped. "
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:    execute_process(COMMAND ${conan_program} --version
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:      message(FATAL_ERROR "conan --version failed='${result_code}: ${conan_version_output}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:    string(REGEX REPLACE ".*Conan version ([0-9].[0-9]).*" "\\1" conan_version "${conan_version_output}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:    set(conanfile_timestamp_file "${CMAKE_BINARY_DIR}/conan-dependencies/conanfile.timestamp")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:    set(conanfile_build_policy_file "${CMAKE_BINARY_DIR}/conan-dependencies/conanfile.buildpolicy")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:      message(STATUS "Qt Creator: conan package manager auto-setup. "
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:      file(COPY "${conanfile_txt}" DESTINATION "${CMAKE_BINARY_DIR}/conan-dependencies/")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:      file(WRITE "${CMAKE_BINARY_DIR}/conan-dependencies/toolchain.cmake" "
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:        file(APPEND "${CMAKE_BINARY_DIR}/conan-dependencies/toolchain.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:       file(WRITE "${CMAKE_BINARY_DIR}/conan-dependencies/CMakeLists.txt" "
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:          project(conan-setup)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:            detect_host_profile(\"${CMAKE_BINARY_DIR}/conan-dependencies/conan_host_profile\")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:              -pr \"${CMAKE_BINARY_DIR}/conan-dependencies/conan_host_profile\"
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:              --build=${QT_CREATOR_CONAN_BUILD_POLICY}
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:              -s build_type=${CMAKE_BUILD_TYPE}
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:              -g CMakeDeps)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:              file(WRITE \"${CMAKE_BINARY_DIR}/conan-dependencies/conan_paths.cmake\" \"
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:              INSTALL_FOLDER \"${CMAKE_BINARY_DIR}/conan-dependencies\"
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:              ENV CONAN_CMAKE_TOOLCHAIN_FILE=\"${CMAKE_BINARY_DIR}/conan-dependencies/toolchain.cmake\"
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:        -S "${CMAKE_BINARY_DIR}/conan-dependencies/"
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:        -B "${CMAKE_BINARY_DIR}/conan-dependencies/build"
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:        -C "${CMAKE_BINARY_DIR}/qtcsettings.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:        -D "CMAKE_TOOLCHAIN_FILE=${CMAKE_BINARY_DIR}/conan-dependencies/toolchain.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:        -G ${CMAKE_GENERATOR}
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:        -D CMAKE_BUILD_TYPE=${CMAKE_BUILD_TYPE}
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:        message(WARNING "Qt Creator's conan package manager auto-setup failed. Consider setting "
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:    include("${CMAKE_BINARY_DIR}/conan-dependencies/conan_paths.cmake")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:    option(QT_CREATOR_SKIP_VCPKG_SETUP "Skip Qt Creator's vcpkg package manager auto-setup" OFF)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:                      "Package manager auto-setup will be skipped. "
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:    if (NOT EXISTS "${CMAKE_BINARY_DIR}/vcpkg-dependencies/toolchain.cmake")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:      message(STATUS "Qt Creator: vcpkg package manager auto-setup. "
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:      file(WRITE "${CMAKE_BINARY_DIR}/vcpkg-dependencies/toolchain.cmake" "
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:          CMAKE_TOOLCHAIN_FILE STREQUAL "${CMAKE_BINARY_DIR}/vcpkg-dependencies/toolchain.cmake")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:        file(APPEND "${CMAKE_BINARY_DIR}/vcpkg-dependencies/toolchain.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:          set(vcpkg_triplet x64-mingw-static)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:            set(vcpkg_triplet ${CMAKE_MATCH_1}-windows)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:          set(vcpkg_triplet x64-osx)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:          set(vcpkg_triplet x64-linux)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:      file(APPEND "${CMAKE_BINARY_DIR}/vcpkg-dependencies/toolchain.cmake" "
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake:    set(CMAKE_TOOLCHAIN_FILE "${CMAKE_BINARY_DIR}/vcpkg-dependencies/toolchain.cmake" CACHE PATH "" FORCE)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:# This file comes from: https://github.com/conan-io/cmake-conan. Please refer
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:# but it is only necessary on the end-user side. It is not necessary to create conan
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        message(FATAL_ERROR "Please specify in command line CMAKE_BUILD_TYPE (-DCMAKE_BUILD_TYPE=Release)")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:    #handle -s os setting
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        if (${_index} GREATER -1)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        set(_CONAN_SETTING_COMPILER apple-clang)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                message(STATUS "Conan: APPLE and Clang detected. Assuming apple-clang compiler. Set CMP0025 to avoid it")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(_CONAN_SETTING_COMPILER apple-clang)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        set(_SETTINGS ${_SETTINGS} -pr=${ARG})
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        set(_SETTINGS ${_SETTINGS} -pr:b=${ARG})
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:            set(_SETTINGS ${_SETTINGS} -s ${ARG}=${_CONAN_SETTING_${_arg_name}})
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        set(_SETTINGS ${_SETTINGS} -s ${ARG})
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:    # Take into account any -stdlib in compile options
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:            if(define MATCHES "^-D")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(compile_options ${compile_options} "-D${define}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        # without --target= we may be calling the wrong underlying GCC
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        # without --sysroot= we may find the wrong #include <string>
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        set(xcode_sysroot_option "--sysroot=${CMAKE_OSX_SYSROOT}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        COMMAND ${CMAKE_COMMAND} -E echo "#include <string>"
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        COMMAND ${EXPAND_CXX_COMPILER} ${SPLIT_CXX_FLAGS} -x c++ ${xcode_sysroot_option} ${compile_options} -E -dM -
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        # Allow -D_GLIBCXX_USE_CXX11_ABI=ON/OFF as argument to cmake
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        message(FATAL_ERROR "Please specify in command line CMAKE_BUILD_TYPE (-DCMAKE_BUILD_TYPE=Release)")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                    string(SUBSTRING "${flag}" 1 -1 runtime)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:    # Argument BUILD is equivalant to --build={missing, PkgName,...} or
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:    # --build when argument is 'BUILD all' (which builds all packages from source)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:            set(CONAN_BUILD_POLICY ${CONAN_BUILD_POLICY} --build)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:            set(CONAN_BUILD_POLICY ${CONAN_BUILD_POLICY} --build=${ARG})
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:      set(CONAN_OPTIONS ${CONAN_OPTIONS} -o=${ARG})
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:      set(CONAN_INSTALL_UPDATE --update)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:      set(CONAN_INSTALL_NO_IMPORTS --no-imports)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:      set(CONAN_INSTALL_FOLDER -if=${ARGUMENTS_INSTALL_FOLDER})
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:      set(CONAN_OUTPUT_FOLDER -of=${ARGUMENTS_OUTPUT_FOLDER})
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        set(CONAN_GENERATORS ${CONAN_GENERATORS} -g=${ARG})
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        set(CONAN_ENV_VARS ${CONAN_ENV_VARS} -e=${ARG})
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--remote")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--lockfile")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--lockfile-out")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--lockfile-node-id")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--install-folder")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--output-folder")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--generator")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--build")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--env")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--env:host")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--env:build")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--options")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--options:host")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--options:build")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--profile")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--profile:host")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--profile:build")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--settings")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--settings:host")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--settings:build")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                    set(${arg} "--build")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        set(UPDATE --update)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        set(NO_IMPORTS --no-imports)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--remote")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--lockfile")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--lockfile-out")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--build")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--env")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--env:host")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--env:build")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--options")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--options:host")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--options:build")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--profile")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--profile:host")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--profile:build")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--settings")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--settings:host")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                set(flag "--settings:build")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:                    set(${arg} "--build")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        set(UPDATE --update)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        set(BASE --base)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:    # configure_file will make sure cmake re-runs when conanfile is updated
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        message(WARNING "CONFIGURATION_TYPES should only be specified for multi-configuration generators")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        message(STATUS "Conan: Using cmake-multi generator")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:    execute_process(COMMAND ${CONAN_CMD} --version
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:      message(FATAL_ERROR "Conan --version failed='${return_code}'")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        string(REGEX MATCH ".*Conan version ([0-9]+\\.[0-9]+\\.[0-9]+)" FOO
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:    #       URL https://api.bintray.com/conan/bincrafters/public-conan
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:        set(CONAN_INDEX_ARG "-i ${CONAN_INDEX}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:    execute_process(COMMAND ${CONAN_CMD} remote add ${CONAN_NAME} ${CONAN_INDEX_ARG} -f ${CONAN_URL} ${CONAN_VERIFY_SSL_ARG}
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:    #    conan_config_install(ITEM https://github.com/conan-io/cmake-conan.git
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:    #       TYPE git SOURCE source-folder TARGET target-folder VERIFY_SSL false)
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:	set(CONAN_VERIFY_SSL_ARG "--verify-ssl=${CONAN_VERIFY_SSL}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:	set(CONAN_TYPE_ARG "--type=${CONAN_TYPE}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:	set(CONAN_ARGS_ARGS "--args=\"${CONAN_ARGS}\"")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:	set(CONAN_SOURCE_ARGS "--source-folder=${CONAN_SOURCE}")
build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/conan.cmake:	set(CONAN_TARGET_ARGS "--target-folder=${CONAN_TARGET}")
build-liveimage_srv-LINUX_DEFAULT-Debug/Testing/Temporary/LastTest.log:----------------------------------------------------------
Binary file build-liveimage_srv-LINUX_DEFAULT-Debug/liveimage_srv matches
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:cmake_ninja_workdir = /sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:# Order-only phony target for liveimage_srv
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  DEFINES = -Dcimg_display=0 -Dcimg_use_jpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  FLAGS = -DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  LINK_FLAGS = -rdynamic
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  LINK_LIBRARIES = -lpthread  -ljpeg
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  COMMAND = cd /sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug && /home/marius/Qt2/Tools/CMake/bin/ccmake -S/sdaone/GIT_HUB/lili_git/liveimage_srv -B/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:  COMMAND = cd /sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug && /home/marius/Qt2/Tools/CMake/bin/cmake --regenerate-during-build -S/sdaone/GIT_HUB/lili_git/liveimage_srv -B/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:# Folder: /sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:# otherwise ordered by order-only dependencies.
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:# Built-in targets
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:# Re-run CMake if any of its inputs changed.
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:build build.ninja: RERUN_CMAKE | .qtc/package-manager/auto-setup.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCInformation.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCXXInformation.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCommonLanguageInclude.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeGenericSystem.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeInitializeConfigs.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeLanguageInformation.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeSystemSpecificInformation.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeSystemSpecificInitialize.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/CMakeCommonCompilerMacros.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU-C.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU-CXX.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU-C.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU-CXX.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/UnixPaths.cmake /sdaone/GIT_HUB/lili_git/liveimage_srv/CMakeLists.txt CMakeCache.txt CMakeFiles/3.24.2/CMakeCCompiler.cmake CMakeFiles/3.24.2/CMakeCXXCompiler.cmake CMakeFiles/3.24.2/CMakeSystem.cmake
build-liveimage_srv-LINUX_DEFAULT-Debug/build.ninja:build .qtc/package-manager/auto-setup.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCInformation.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCXXInformation.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCommonLanguageInclude.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeGenericSystem.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeInitializeConfigs.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeLanguageInformation.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeSystemSpecificInformation.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeSystemSpecificInitialize.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/CMakeCommonCompilerMacros.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU-C.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU-CXX.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU-C.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU-CXX.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux.cmake /home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/UnixPaths.cmake /sdaone/GIT_HUB/lili_git/liveimage_srv/CMakeLists.txt CMakeCache.txt CMakeFiles/3.24.2/CMakeCCompiler.cmake CMakeFiles/3.24.2/CMakeCXXCompiler.cmake CMakeFiles/3.24.2/CMakeSystem.cmake: phony
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/target-liveimage_srv-Debug-3b9fc2c3e5337df654eb.json:					"fragment" : "-DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/target-liveimage_srv-Debug-3b9fc2c3e5337df654eb.json:				"fragment" : "-DQT_QML_DEBUG -std=c++11 -fexceptions -Wall -fpermissive -fstack-protector-all -g -O0 -g",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/target-liveimage_srv-Debug-3b9fc2c3e5337df654eb.json:				"fragment" : "-rdynamic",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/target-liveimage_srv-Debug-3b9fc2c3e5337df654eb.json:				"fragment" : "-lpthread",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/target-liveimage_srv-Debug-3b9fc2c3e5337df654eb.json:				"fragment" : "-ljpeg",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeDetermineSystem.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeSystem.cmake.in"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeFiles/3.24.2/CMakeSystem.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeNinjaFindMake.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeSystemSpecificInitialize.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeDetermineCCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeDetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeDetermineCompilerId.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCompilerIdDetection.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/ADSP-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/ARMCC-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/ARMClang-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/AppleClang-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Clang-DetermineCompilerInternal.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Borland-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Bruce-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Clang-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Clang-DetermineCompilerInternal.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Compaq-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Cray-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Embarcadero-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Fujitsu-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/FujitsuClang-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GHS-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/HP-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/IAR-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/IBMClang-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Intel-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/IntelLLVM-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/LCC-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/MSVC-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/NVHPC-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/NVIDIA-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/OpenWatcom-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/PGI-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/PathScale-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/SCO-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/SDCC-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/SunPro-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/TI-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/TinyCC-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/VisualAge-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/IBMCPP-C-DetermineVersionInternal.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Watcom-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/XL-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/IBMCPP-C-DetermineVersionInternal.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/XLClang-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/zOS-C-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/IBMCPP-C-DetermineVersionInternal.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeFindBinUtils.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU-FindBinUtils.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCCompiler.cmake.in"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeFiles/3.24.2/CMakeCCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeDetermineCXXCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeDetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-Determine-CXX.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeDetermineCompilerId.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCompilerIdDetection.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/ADSP-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/ARMCC-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/ARMClang-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/AppleClang-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Clang-DetermineCompilerInternal.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Borland-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Clang-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Clang-DetermineCompilerInternal.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Comeau-CXX-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Compaq-CXX-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Cray-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Embarcadero-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Fujitsu-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/FujitsuClang-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GHS-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU-CXX-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/HP-CXX-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/IAR-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/IBMClang-CXX-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Intel-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/IntelLLVM-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/LCC-CXX-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/MSVC-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/NVHPC-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/NVIDIA-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/OpenWatcom-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/PGI-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/PathScale-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/SCO-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/SunPro-CXX-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/TI-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/VisualAge-CXX-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/IBMCPP-CXX-DetermineVersionInternal.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/Watcom-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/XL-CXX-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/IBMCPP-CXX-DetermineVersionInternal.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/XLClang-CXX-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/zOS-CXX-DetermineCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/IBMCPP-CXX-DetermineVersionInternal.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeFindBinUtils.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU-FindBinUtils.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCXXCompiler.cmake.in"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeFiles/3.24.2/CMakeCXXCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeSystemSpecificInformation.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeGenericSystem.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeInitializeConfigs.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/UnixPaths.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCInformation.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeLanguageInformation.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU-C.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/CMakeCommonCompilerMacros.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU-C.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCommonLanguageInclude.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeTestCCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeTestCompilerCommon.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeDetermineCompilerABI.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeParseImplicitIncludeInfo.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeParseImplicitLinkInfo.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeParseLibraryArchitecture.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeTestCompilerCommon.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCCompilerABI.c"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeDetermineCompileFeatures.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Internal/FeatureTesting.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCCompiler.cmake.in"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeFiles/3.24.2/CMakeCCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCXXInformation.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeLanguageInformation.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU-CXX.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU-CXX.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCommonLanguageInclude.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeTestCXXCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeTestCompilerCommon.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeDetermineCompilerABI.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeParseImplicitIncludeInfo.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeParseImplicitLinkInfo.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeParseLibraryArchitecture.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeTestCompilerCommon.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCXXCompilerABI.cpp"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeDetermineCompileFeatures.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Internal/FeatureTesting.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCXXCompiler.cmake.in"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:			"path" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeFiles/3.24.2/CMakeCXXCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-ac283f39136d801fb695.json:		"build" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-11T21-25-03-0912.json:			"root" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-11T21-25-03-0912.json:			"jsonFile" : "codemodel-v2-04725fff8cccff005948.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-11T21-25-03-0912.json:			"jsonFile" : "cache-v2-4be7ddfb0b2bf0fd07b2.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-11T21-25-03-0912.json:			"jsonFile" : "cmakeFiles-v1-ac283f39136d801fb695.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-11T21-25-03-0912.json:		"cache-v2" : 
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-11T21-25-03-0912.json:			"jsonFile" : "cache-v2-4be7ddfb0b2bf0fd07b2.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-11T21-25-03-0912.json:		"cmakeFiles-v1" : 
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-11T21-25-03-0912.json:			"jsonFile" : "cmakeFiles-v1-ac283f39136d801fb695.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-11T21-25-03-0912.json:		"codemodel-v2" : 
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-11T21-25-03-0912.json:			"jsonFile" : "codemodel-v2-04725fff8cccff005948.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-14T01-25-12-0520.json:			"root" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-14T01-25-12-0520.json:			"jsonFile" : "codemodel-v2-04725fff8cccff005948.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-14T01-25-12-0520.json:			"jsonFile" : "cache-v2-4be7ddfb0b2bf0fd07b2.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-14T01-25-12-0520.json:			"jsonFile" : "cmakeFiles-v1-d910f44e5ccaef49b16f.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-14T01-25-12-0520.json:		"cache-v2" : 
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-14T01-25-12-0520.json:			"jsonFile" : "cache-v2-4be7ddfb0b2bf0fd07b2.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-14T01-25-12-0520.json:		"cmakeFiles-v1" : 
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-14T01-25-12-0520.json:			"jsonFile" : "cmakeFiles-v1-d910f44e5ccaef49b16f.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-14T01-25-12-0520.json:		"codemodel-v2" : 
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/index-2023-07-14T01-25-12-0520.json:			"jsonFile" : "codemodel-v2-04725fff8cccff005948.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeFiles/3.24.2/CMakeSystem.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeSystemSpecificInitialize.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeFiles/3.24.2/CMakeCCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeFiles/3.24.2/CMakeCXXCompiler.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeSystemSpecificInformation.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeGenericSystem.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeInitializeConfigs.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/UnixPaths.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCInformation.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeLanguageInformation.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU-C.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/CMakeCommonCompilerMacros.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU-C.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCommonLanguageInclude.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCXXInformation.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeLanguageInformation.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU-CXX.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Compiler/GNU.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU-CXX.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/Platform/Linux-GNU.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:			"path" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24/Modules/CMakeCommonLanguageInclude.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cmakeFiles-v1-d910f44e5ccaef49b16f.json:		"build" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/codemodel-v2-04725fff8cccff005948.json:					"jsonFile" : "directory-.-Debug-f5ebdc15457944623624.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/codemodel-v2-04725fff8cccff005948.json:					"jsonFile" : "target-liveimage_srv-Debug-3b9fc2c3e5337df654eb.json",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/codemodel-v2-04725fff8cccff005948.json:		"build" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug",
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-addr2line"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-ar"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-g++-9"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:					"value" : "A wrapper around 'ar' adding the appropriate '--plugin' option for the GCC compiler"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-gcc-ar-9"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:					"value" : "A wrapper around 'ranlib' adding the appropriate '--plugin' option for the GCC compiler"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-gcc-ranlib-9"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "-DQT_QML_DEBUG"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "-g"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "-DQT_QML_DEBUG"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "-Os -DNDEBUG"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "-O3 -DNDEBUG"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "-O2 -g -DNDEBUG"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-gcc-9"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:					"value" : "A wrapper around 'ar' adding the appropriate '--plugin' option for the GCC compiler"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-gcc-ar-9"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:					"value" : "A wrapper around 'ranlib' adding the appropriate '--plugin' option for the GCC compiler"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-gcc-ranlib-9"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "-g"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "-Os -DNDEBUG"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "-O3 -DNDEBUG"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "-O2 -g -DNDEBUG"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "CMAKE_DLLTOOL-NOTFOUND"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/CMakeFiles/pkgRedirects"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-ld"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-nm"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-objcopy"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-objdump"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug/.qtc/package-manager/auto-setup.cmake"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-ranlib"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-readelf"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/home/marius/Qt2/Tools/CMake/share/cmake-3.24"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/usr/bin/x86_64-linux-gnu-strip"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:					"value" : "Skip Qt Creator's package manager auto-setup"
build-liveimage_srv-LINUX_DEFAULT-Debug/.cmake/api/v1/reply/cache-v2-4be7ddfb0b2bf0fd07b2.json:			"value" : "/sdaone/GIT_HUB/lili_git/build-liveimage_srv-LINUX_DEFAULT-Debug"
cmake_install.cmake:    string(REGEX REPLACE "^[^A-Za-z0-9_]+" ""
README.md:## SUITABLE FOR R-PI, NANO-Pi-NEO
README.md:--
README.md:--
README.md:sudo apt-get install git
README.md:sudo apt install cmake build-essential
README.md:sudo apt-get install libv4l-dev
README.md:sudo apt install libjpeg-dev
README.md:sudo apt-get install libavcodec-dev libavformat-dev # (optional with code changes)
README.md:sudo apt-get install v4l-utils # (optional to adjust luminosity)
README.md:#### Create the I{'save_loc'} location and give RW access for the user that runs liveimage (aka: www-data:you & 775)
README.md:  - HP x86_64 Linux with incorporated webcam
README.md:  - R-PI 3 with USB Camera
README.md:  - Nano Pi with USB camera and wifi USB dongle supporting AP
README.md:  - C.H.I.P with USB camera. The USB cable was changed to allow external power to USB camera due camera higher amperage
README.md:http://CAM_IP:9000    <-  shows the streams
README.md:----
sock.cpp.save:# Copyright (C) 2007-2014 Chincisan Octavian-Marius(mariuschincisan@gmail.com) - coinscode.com - N/A
sock.cpp.save:# http://www.apache.org/licenses/LICENSE-2.0
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:bio_unblock::bio_unblock(sock* sock, int bl):_sk(sock),_bl(_sk->_blocking){
sock.cpp.save:    sock->set_blocking(bl);
sock.cpp.save:    _sk->set_blocking(_bl);
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:        ::memcpy((char*)&(sin.sin_addr), hostent->h_addr, hostent->h_length);
sock.cpp.save:        strcpy(out, h->h_name);
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    _thesock     = -1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:   if (flags == -1) return false;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    return (SOCKET)-1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    return (SOCKET)-1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    if(-1 == gethostname((char*)szBuf, (int)dwSize))
sock.cpp.save:    ::memcpy((char*)&(locSin.sin_addr), pHe->h_addr,pHe->h_length);
sock.cpp.save:        if (ifAddrStruct->ifa_addr->sa_family==AF_INET && strcmp(ifAddrStruct->ifa_name, "lo0")!=0)
sock.cpp.save:            tmpAddrPtr = (void*)&((SADDR_46 *)ifAddrStruct->ifa_addr)->sin_addr;
sock.cpp.save:            inet_ntop(AF_INET, tmpAddrPtr, tmp, (sizeof(tmp)-1));
sock.cpp.save:            if(strlen(localip) + strlen(tmp) < (sizeof(localip)-1) )
sock.cpp.save:        ifAddrStruct = ifAddrStruct->ifa_next;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    return -1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    return -1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    int      bytes = -1;
sock.cpp.save:    return -1; // no data this time
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:        toreceive -= shot;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    while(length > 0 &&  tout-->0)
sock.cpp.save:            length -= shot;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:            return -1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:            return -1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:        while(-1==::close(_thesock) && --k>0)
sock.cpp.save:    _thesock = -1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    if((int)-1 == rv)
sock.cpp.save:        return -1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:        return (SOCKET)-1;
sock.cpp.save:        return (SOCKET)-1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:        return (SOCKET)-1;
sock.cpp.save:        return (SOCKET)-1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:        return -1;
sock.cpp.save://as send -1 continue, 0 closed -cannot 1 ok
sock.cpp.save:    ::memcpy((char*)&(_remote_sin.sin_addr), _hostent->h_addr, _hostent->h_length);
sock.cpp.save:    this->set_blocking(1);
sock.cpp.save:    if(-1 == ::connect(_thesock, (const struct sockaddr*)&_remote_sin, _remote_sin.rsz()))
sock.cpp.save:    ::memcpy((char*)&(locSin.sin_addr), _hostent->h_addr, _hostent->h_length);
sock.cpp.save:// 0 no connection, >0 OK, -1 in progress
sock.cpp.save:    if(-1 == rv)
sock.cpp.save:                while(time(0) - t < tout)
sock.cpp.save:            return -1;
sock.cpp.save:    if(-1 == rv)
sock.cpp.save:            return -1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    if((int)_thesock != (int)-1)
sock.cpp.save:    if(err==-1 )
sock.cpp.save:        while(cbCall(pUser, time(0)-ti))
sock.cpp.save:    if(err==-1)
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    if((int)_thesock != (int)-1)
sock.cpp.save:    if(err==-1)
sock.cpp.save:        if(pUser==(void*)-1)
sock.cpp.save:            return -1;
sock.cpp.save:        int tdiff = time(0)-ti;
sock.cpp.save:            tdiff = time(0)-ti;
sock.cpp.save:    if(err==-1)
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:        ::memcpy((char*)&(locSin.sin_addr), _hostent->h_addr, _hostent->h_length);
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    if((int)-1 == (int)_thesock)
sock.cpp.save:        return -1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    if((int)-1 == (int)_thesock)
sock.cpp.save:        return -1;
sock.cpp.save:        printf("udp-sock-bind-error\n");
sock.cpp.save:        return -1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    int snd = -1;
sock.cpp.save:        ////printf("<-to %s : %d\n", IP2STR(_remote_sin.sin_addr.s_addr), htons(_remote_sin.sin_port));
sock.cpp.save:        ////printf("<-to %s : %d\n", IP2STR(_remote_sin.sin_addr.s_addr), htons(_remote_sin.sin_port));
sock.cpp.save:    if(-1 == snd)
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:        ////printf("<-to %s : %d\n", IP2STR(rsin.sin_addr.s_addr), htons(rsin.sin_port));
sock.cpp.save:    if(-1 == snd)
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    if(rcv==-1)
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    if(rcv==-1)
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    while(cbCall(pUser, time(0)-ti))
sock.cpp.save:    return -1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:              sizeof (_local_sin)) == -1)
sock.cpp.save:        return -1;
sock.cpp.save:                    (char  *)&iOptVal, sizeof (int)) == -1)
sock.cpp.save:        return -1;
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    if(i==-1)
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save://-----------------------------------------------------------------------------
sock.cpp.save:    if(_thesock != -1)
sock.cpp.save:        return -1;
sock.cpp.save:    if (bnd == -1)
sock.cpp.save:    if (bnd == -1)
motion.h:    First Release: September 16 - 29 2016
